//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (3384)
//--------------------------------------------------------------------------------
pub const SI_TEMPORARY = @as(u32, 2147483648);
pub const SUBSINFO_ALLFLAGS = @as(u32, 61311);
pub const RS_READY = @as(u32, 1);
pub const RS_SUSPENDED = @as(u32, 2);
pub const RS_UPDATING = @as(u32, 4);
pub const RS_SUSPENDONIDLE = @as(u32, 65536);
pub const RS_MAYBOTHERUSER = @as(u32, 131072);
pub const RS_COMPLETED = @as(u32, 2147483648);
pub const SUBSMGRUPDATE_MINIMIZE = @as(u32, 1);
pub const SUBSMGRUPDATE_MASK = @as(u32, 1);
pub const SUBSMGRENUM_TEMP = @as(u32, 1);
pub const SUBSMGRENUM_MASK = @as(u32, 1);
pub const INET_E_AGENT_MAX_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693248));
pub const INET_S_AGENT_PART_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 790401));
pub const INET_E_AGENT_CACHE_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693246));
pub const INET_E_AGENT_CONNECTION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693245));
pub const INET_E_SCHEDULED_UPDATES_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693244));
pub const INET_E_SCHEDULED_UPDATES_RESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693243));
pub const INET_E_SCHEDULED_UPDATE_INTERVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693242));
pub const INET_E_SCHEDULED_EXCLUDE_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693241));
pub const INET_E_AGENT_EXCEEDING_CACHE_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693232));
pub const INET_S_AGENT_INCREASED_CACHE_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 790416));
pub const OLEDBVER = @as(u32, 624);
pub const DB_NULL_HACCESSOR = @as(u32, 0);
pub const DB_INVALID_HACCESSOR = @as(u32, 0);
pub const DB_NULL_HROW = @as(u32, 0);
pub const DB_NULL_HCHAPTER = @as(u32, 0);
pub const DB_INVALID_HCHAPTER = @as(u32, 0);
pub const STD_BOOKMARKLENGTH = @as(u32, 1);
pub const DBPROPVAL_BMK_NUMERIC = @as(i32, 1);
pub const DBPROPVAL_BMK_KEY = @as(i32, 2);
pub const DBPROPVAL_CL_START = @as(i32, 1);
pub const DBPROPVAL_CL_END = @as(i32, 2);
pub const DBPROPVAL_CU_DML_STATEMENTS = @as(i32, 1);
pub const DBPROPVAL_CU_TABLE_DEFINITION = @as(i32, 2);
pub const DBPROPVAL_CU_INDEX_DEFINITION = @as(i32, 4);
pub const DBPROPVAL_CU_PRIVILEGE_DEFINITION = @as(i32, 8);
pub const DBPROPVAL_CD_NOTNULL = @as(i32, 1);
pub const DBPROPVAL_CB_NULL = @as(i32, 1);
pub const DBPROPVAL_CB_NON_NULL = @as(i32, 2);
pub const DBPROPVAL_FU_NOT_SUPPORTED = @as(i32, 1);
pub const DBPROPVAL_FU_COLUMN = @as(i32, 2);
pub const DBPROPVAL_FU_TABLE = @as(i32, 4);
pub const DBPROPVAL_FU_CATALOG = @as(i32, 8);
pub const DBPROPVAL_GB_NOT_SUPPORTED = @as(i32, 1);
pub const DBPROPVAL_GB_EQUALS_SELECT = @as(i32, 2);
pub const DBPROPVAL_GB_CONTAINS_SELECT = @as(i32, 4);
pub const DBPROPVAL_GB_NO_RELATION = @as(i32, 8);
pub const DBPROPVAL_HT_DIFFERENT_CATALOGS = @as(i32, 1);
pub const DBPROPVAL_HT_DIFFERENT_PROVIDERS = @as(i32, 2);
pub const DBPROPVAL_IC_UPPER = @as(i32, 1);
pub const DBPROPVAL_IC_LOWER = @as(i32, 2);
pub const DBPROPVAL_IC_SENSITIVE = @as(i32, 4);
pub const DBPROPVAL_IC_MIXED = @as(i32, 8);
pub const DBPROPVAL_LM_NONE = @as(i32, 1);
pub const DBPROPVAL_LM_READ = @as(i32, 2);
pub const DBPROPVAL_LM_INTENT = @as(i32, 4);
pub const DBPROPVAL_LM_RITE = @as(i32, 8);
pub const DBPROPVAL_NP_OKTODO = @as(i32, 1);
pub const DBPROPVAL_NP_ABOUTTODO = @as(i32, 2);
pub const DBPROPVAL_NP_SYNCHAFTER = @as(i32, 4);
pub const DBPROPVAL_NP_FAILEDTODO = @as(i32, 8);
pub const DBPROPVAL_NP_DIDEVENT = @as(i32, 16);
pub const DBPROPVAL_NC_END = @as(i32, 1);
pub const DBPROPVAL_NC_HIGH = @as(i32, 2);
pub const DBPROPVAL_NC_LOW = @as(i32, 4);
pub const DBPROPVAL_NC_START = @as(i32, 8);
pub const DBPROPVAL_OO_BLOB = @as(i32, 1);
pub const DBPROPVAL_OO_IPERSIST = @as(i32, 2);
pub const DBPROPVAL_CB_DELETE = @as(i32, 1);
pub const DBPROPVAL_CB_PRESERVE = @as(i32, 2);
pub const DBPROPVAL_SU_DML_STATEMENTS = @as(i32, 1);
pub const DBPROPVAL_SU_TABLE_DEFINITION = @as(i32, 2);
pub const DBPROPVAL_SU_INDEX_DEFINITION = @as(i32, 4);
pub const DBPROPVAL_SU_PRIVILEGE_DEFINITION = @as(i32, 8);
pub const DBPROPVAL_SQ_CORRELATEDSUBQUERIES = @as(i32, 1);
pub const DBPROPVAL_SQ_COMPARISON = @as(i32, 2);
pub const DBPROPVAL_SQ_EXISTS = @as(i32, 4);
pub const DBPROPVAL_SQ_IN = @as(i32, 8);
pub const DBPROPVAL_SQ_QUANTIFIED = @as(i32, 16);
pub const DBPROPVAL_SQ_TABLE = @as(i32, 32);
pub const DBPROPVAL_SS_ISEQUENTIALSTREAM = @as(i32, 1);
pub const DBPROPVAL_SS_ISTREAM = @as(i32, 2);
pub const DBPROPVAL_SS_ISTORAGE = @as(i32, 4);
pub const DBPROPVAL_SS_ILOCKBYTES = @as(i32, 8);
pub const DBPROPVAL_TI_CHAOS = @as(i32, 16);
pub const DBPROPVAL_TI_READUNCOMMITTED = @as(i32, 256);
pub const DBPROPVAL_TI_BROWSE = @as(i32, 256);
pub const DBPROPVAL_TI_CURSORSTABILITY = @as(i32, 4096);
pub const DBPROPVAL_TI_READCOMMITTED = @as(i32, 4096);
pub const DBPROPVAL_TI_REPEATABLEREAD = @as(i32, 65536);
pub const DBPROPVAL_TI_SERIALIZABLE = @as(i32, 1048576);
pub const DBPROPVAL_TI_ISOLATED = @as(i32, 1048576);
pub const DBPROPVAL_TR_COMMIT_DC = @as(i32, 1);
pub const DBPROPVAL_TR_COMMIT = @as(i32, 2);
pub const DBPROPVAL_TR_COMMIT_NO = @as(i32, 4);
pub const DBPROPVAL_TR_ABORT_DC = @as(i32, 8);
pub const DBPROPVAL_TR_ABORT = @as(i32, 16);
pub const DBPROPVAL_TR_ABORT_NO = @as(i32, 32);
pub const DBPROPVAL_TR_DONTCARE = @as(i32, 64);
pub const DBPROPVAL_TR_BOTH = @as(i32, 128);
pub const DBPROPVAL_TR_NONE = @as(i32, 256);
pub const DBPROPVAL_TR_OPTIMISTIC = @as(i32, 512);
pub const DBPROPVAL_RT_FREETHREAD = @as(i32, 1);
pub const DBPROPVAL_RT_APTMTTHREAD = @as(i32, 2);
pub const DBPROPVAL_RT_SINGLETHREAD = @as(i32, 4);
pub const DBPROPVAL_UP_CHANGE = @as(i32, 1);
pub const DBPROPVAL_UP_DELETE = @as(i32, 2);
pub const DBPROPVAL_UP_INSERT = @as(i32, 4);
pub const DBPROPVAL_SQL_NONE = @as(i32, 0);
pub const DBPROPVAL_SQL_ODBC_MINIMUM = @as(i32, 1);
pub const DBPROPVAL_SQL_ODBC_CORE = @as(i32, 2);
pub const DBPROPVAL_SQL_ODBC_EXTENDED = @as(i32, 4);
pub const DBPROPVAL_SQL_ANSI89_IEF = @as(i32, 8);
pub const DBPROPVAL_SQL_ANSI92_ENTRY = @as(i32, 16);
pub const DBPROPVAL_SQL_FIPS_TRANSITIONAL = @as(i32, 32);
pub const DBPROPVAL_SQL_ANSI92_INTERMEDIATE = @as(i32, 64);
pub const DBPROPVAL_SQL_ANSI92_FULL = @as(i32, 128);
pub const DBPROPVAL_SQL_ESCAPECLAUSES = @as(i32, 256);
pub const DBPROPVAL_IT_BTREE = @as(i32, 1);
pub const DBPROPVAL_IT_HASH = @as(i32, 2);
pub const DBPROPVAL_IT_CONTENT = @as(i32, 3);
pub const DBPROPVAL_IT_OTHER = @as(i32, 4);
pub const DBPROPVAL_IN_DISALLOWNULL = @as(i32, 1);
pub const DBPROPVAL_IN_IGNORENULL = @as(i32, 2);
pub const DBPROPVAL_IN_IGNOREANYNULL = @as(i32, 4);
pub const DBPROPVAL_TC_NONE = @as(i32, 0);
pub const DBPROPVAL_TC_DML = @as(i32, 1);
pub const DBPROPVAL_TC_DDL_COMMIT = @as(i32, 2);
pub const DBPROPVAL_TC_DDL_IGNORE = @as(i32, 4);
pub const DBPROPVAL_TC_ALL = @as(i32, 8);
pub const DBPROPVAL_OA_NOTSUPPORTED = @as(i32, 1);
pub const DBPROPVAL_OA_ATEXECUTE = @as(i32, 2);
pub const DBPROPVAL_OA_ATROWRELEASE = @as(i32, 4);
pub const DBPROPVAL_MR_NOTSUPPORTED = @as(i32, 0);
pub const DBPROPVAL_MR_SUPPORTED = @as(i32, 1);
pub const DBPROPVAL_MR_CONCURRENT = @as(i32, 2);
pub const DBPROPVAL_PT_GUID_NAME = @as(i32, 1);
pub const DBPROPVAL_PT_GUID_PROPID = @as(i32, 2);
pub const DBPROPVAL_PT_NAME = @as(i32, 4);
pub const DBPROPVAL_PT_GUID = @as(i32, 8);
pub const DBPROPVAL_PT_PROPID = @as(i32, 16);
pub const DBPROPVAL_PT_PGUID_NAME = @as(i32, 32);
pub const DBPROPVAL_PT_PGUID_PROPID = @as(i32, 64);
pub const DBPROPVAL_NT_SINGLEROW = @as(i32, 1);
pub const DBPROPVAL_NT_MULTIPLEROWS = @as(i32, 2);
pub const DBPROPVAL_ASYNCH_INITIALIZE = @as(i32, 1);
pub const DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION = @as(i32, 2);
pub const DBPROPVAL_ASYNCH_RANDOMPOPULATION = @as(i32, 4);
pub const DBPROPVAL_OP_EQUAL = @as(i32, 1);
pub const DBPROPVAL_OP_RELATIVE = @as(i32, 2);
pub const DBPROPVAL_OP_STRING = @as(i32, 4);
pub const DBPROPVAL_CO_EQUALITY = @as(i32, 1);
pub const DBPROPVAL_CO_STRING = @as(i32, 2);
pub const DBPROPVAL_CO_CASESENSITIVE = @as(i32, 4);
pub const DBPROPVAL_CO_CASEINSENSITIVE = @as(i32, 8);
pub const DBPROPVAL_CO_CONTAINS = @as(i32, 16);
pub const DBPROPVAL_CO_BEGINSWITH = @as(i32, 32);
pub const DBPROPVAL_ASYNCH_BACKGROUNDPOPULATION = @as(i32, 8);
pub const DBPROPVAL_ASYNCH_PREPOPULATE = @as(i32, 16);
pub const DBPROPVAL_ASYNCH_POPULATEONDEMAND = @as(i32, 32);
pub const DBPROPVAL_LM_SINGLEROW = @as(i32, 2);
pub const DBPROPVAL_SQL_SUBMINIMUM = @as(i32, 512);
pub const DBPROPVAL_DST_TDP = @as(i32, 1);
pub const DBPROPVAL_DST_MDP = @as(i32, 2);
pub const DBPROPVAL_DST_TDPANDMDP = @as(i32, 3);
pub const MDPROPVAL_AU_UNSUPPORTED = @as(i32, 0);
pub const MDPROPVAL_AU_UNCHANGED = @as(i32, 1);
pub const MDPROPVAL_AU_UNKNOWN = @as(i32, 2);
pub const MDPROPVAL_MF_WITH_CALCMEMBERS = @as(i32, 1);
pub const MDPROPVAL_MF_WITH_NAMEDSETS = @as(i32, 2);
pub const MDPROPVAL_MF_CREATE_CALCMEMBERS = @as(i32, 4);
pub const MDPROPVAL_MF_CREATE_NAMEDSETS = @as(i32, 8);
pub const MDPROPVAL_MF_SCOPE_SESSION = @as(i32, 16);
pub const MDPROPVAL_MF_SCOPE_GLOBAL = @as(i32, 32);
pub const MDPROPVAL_MMF_COUSIN = @as(i32, 1);
pub const MDPROPVAL_MMF_PARALLELPERIOD = @as(i32, 2);
pub const MDPROPVAL_MMF_OPENINGPERIOD = @as(i32, 4);
pub const MDPROPVAL_MMF_CLOSINGPERIOD = @as(i32, 8);
pub const MDPROPVAL_MNF_MEDIAN = @as(i32, 1);
pub const MDPROPVAL_MNF_VAR = @as(i32, 2);
pub const MDPROPVAL_MNF_STDDEV = @as(i32, 4);
pub const MDPROPVAL_MNF_RANK = @as(i32, 8);
pub const MDPROPVAL_MNF_AGGREGATE = @as(i32, 16);
pub const MDPROPVAL_MNF_COVARIANCE = @as(i32, 32);
pub const MDPROPVAL_MNF_CORRELATION = @as(i32, 64);
pub const MDPROPVAL_MNF_LINREGSLOPE = @as(i32, 128);
pub const MDPROPVAL_MNF_LINREGVARIANCE = @as(i32, 256);
pub const MDPROPVAL_MNF_LINREG2 = @as(i32, 512);
pub const MDPROPVAL_MNF_LINREGPOINT = @as(i32, 1024);
pub const MDPROPVAL_MNF_DRILLDOWNLEVEL = @as(i32, 2048);
pub const MDPROPVAL_MNF_DRILLDOWNMEMBERTOP = @as(i32, 4096);
pub const MDPROPVAL_MNF_DRILLDOWNMEMBERBOTTOM = @as(i32, 8192);
pub const MDPROPVAL_MNF_DRILLDOWNLEVELTOP = @as(i32, 16384);
pub const MDPROPVAL_MNF_DRILLDOWNLEVELBOTTOM = @as(i32, 32768);
pub const MDPROPVAL_MNF_DRILLUPMEMBER = @as(i32, 65536);
pub const MDPROPVAL_MNF_DRILLUPLEVEL = @as(i32, 131072);
pub const MDPROPVAL_MSF_TOPPERCENT = @as(i32, 1);
pub const MDPROPVAL_MSF_BOTTOMPERCENT = @as(i32, 2);
pub const MDPROPVAL_MSF_TOPSUM = @as(i32, 4);
pub const MDPROPVAL_MSF_BOTTOMSUM = @as(i32, 8);
pub const MDPROPVAL_MSF_PERIODSTODATE = @as(i32, 16);
pub const MDPROPVAL_MSF_LASTPERIODS = @as(i32, 32);
pub const MDPROPVAL_MSF_YTD = @as(i32, 64);
pub const MDPROPVAL_MSF_QTD = @as(i32, 128);
pub const MDPROPVAL_MSF_MTD = @as(i32, 256);
pub const MDPROPVAL_MSF_WTD = @as(i32, 512);
pub const MDPROPVAL_MSF_DRILLDOWNMEMBBER = @as(i32, 1024);
pub const MDPROPVAL_MSF_DRILLDOWNLEVEL = @as(i32, 2048);
pub const MDPROPVAL_MSF_DRILLDOWNMEMBERTOP = @as(i32, 4096);
pub const MDPROPVAL_MSF_DRILLDOWNMEMBERBOTTOM = @as(i32, 8192);
pub const MDPROPVAL_MSF_DRILLDOWNLEVELTOP = @as(i32, 16384);
pub const MDPROPVAL_MSF_DRILLDOWNLEVELBOTTOM = @as(i32, 32768);
pub const MDPROPVAL_MSF_DRILLUPMEMBER = @as(i32, 65536);
pub const MDPROPVAL_MSF_DRILLUPLEVEL = @as(i32, 131072);
pub const MDPROPVAL_MSF_TOGGLEDRILLSTATE = @as(i32, 262144);
pub const MDPROPVAL_MD_SELF = @as(i32, 1);
pub const MDPROPVAL_MD_BEFORE = @as(i32, 2);
pub const MDPROPVAL_MD_AFTER = @as(i32, 4);
pub const MDPROPVAL_MSC_LESSTHAN = @as(i32, 1);
pub const MDPROPVAL_MSC_GREATERTHAN = @as(i32, 2);
pub const MDPROPVAL_MSC_LESSTHANEQUAL = @as(i32, 4);
pub const MDPROPVAL_MSC_GREATERTHANEQUAL = @as(i32, 8);
pub const MDPROPVAL_MC_SINGLECASE = @as(i32, 1);
pub const MDPROPVAL_MC_SEARCHEDCASE = @as(i32, 2);
pub const MDPROPVAL_MOQ_OUTERREFERENCE = @as(i32, 1);
pub const MDPROPVAL_MOQ_DATASOURCE_CUBE = @as(i32, 1);
pub const MDPROPVAL_MOQ_CATALOG_CUBE = @as(i32, 2);
pub const MDPROPVAL_MOQ_SCHEMA_CUBE = @as(i32, 4);
pub const MDPROPVAL_MOQ_CUBE_DIM = @as(i32, 8);
pub const MDPROPVAL_MOQ_DIM_HIER = @as(i32, 16);
pub const MDPROPVAL_MOQ_DIMHIER_LEVEL = @as(i32, 32);
pub const MDPROPVAL_MOQ_LEVEL_MEMBER = @as(i32, 64);
pub const MDPROPVAL_MOQ_MEMBER_MEMBER = @as(i32, 128);
pub const MDPROPVAL_MOQ_DIMHIER_MEMBER = @as(i32, 256);
pub const MDPROPVAL_FS_FULL_SUPPORT = @as(i32, 1);
pub const MDPROPVAL_FS_GENERATED_COLUMN = @as(i32, 2);
pub const MDPROPVAL_FS_GENERATED_DIMENSION = @as(i32, 3);
pub const MDPROPVAL_FS_NO_SUPPORT = @as(i32, 4);
pub const MDPROPVAL_NL_NAMEDLEVELS = @as(i32, 1);
pub const MDPROPVAL_NL_NUMBEREDLEVELS = @as(i32, 2);
pub const MDPROPVAL_MJC_SINGLECUBE = @as(i32, 1);
pub const MDPROPVAL_MJC_MULTICUBES = @as(i32, 2);
pub const MDPROPVAL_MJC_IMPLICITCUBE = @as(i32, 4);
pub const MDPROPVAL_RR_NORANGEROWSET = @as(i32, 1);
pub const MDPROPVAL_RR_READONLY = @as(i32, 2);
pub const MDPROPVAL_RR_UPDATE = @as(i32, 4);
pub const MDPROPVAL_MS_MULTIPLETUPLES = @as(i32, 1);
pub const MDPROPVAL_MS_SINGLETUPLE = @as(i32, 2);
pub const MDPROPVAL_NME_ALLDIMENSIONS = @as(i32, 0);
pub const MDPROPVAL_NME_MEASURESONLY = @as(i32, 1);
pub const DBPROPVAL_AO_SEQUENTIAL = @as(i32, 0);
pub const DBPROPVAL_AO_SEQUENTIALSTORAGEOBJECTS = @as(i32, 1);
pub const DBPROPVAL_AO_RANDOM = @as(i32, 2);
pub const DBPROPVAL_BD_ROWSET = @as(i32, 0);
pub const DBPROPVAL_BD_INTRANSACTION = @as(i32, 1);
pub const DBPROPVAL_BD_XTRANSACTION = @as(i32, 2);
pub const DBPROPVAL_BD_REORGANIZATION = @as(i32, 3);
pub const BMK_DURABILITY_ROWSET = @as(i32, 0);
pub const BMK_DURABILITY_INTRANSACTION = @as(i32, 1);
pub const BMK_DURABILITY_XTRANSACTION = @as(i32, 2);
pub const BMK_DURABILITY_REORGANIZATION = @as(i32, 3);
pub const DBPROPVAL_BO_NOLOG = @as(i32, 0);
pub const DBPROPVAL_BO_NOINDEXUPDATE = @as(i32, 1);
pub const DBPROPVAL_BO_REFINTEGRITY = @as(i32, 2);
pub const DBPROPVAL_STGM_DIRECT = @as(u32, 65536);
pub const DBPROPVAL_STGM_TRANSACTED = @as(u32, 131072);
pub const DBPROPVAL_STGM_CONVERT = @as(u32, 262144);
pub const DBPROPVAL_STGM_FAILIFTHERE = @as(u32, 524288);
pub const DBPROPVAL_STGM_PRIORITY = @as(u32, 1048576);
pub const DBPROPVAL_STGM_DELETEONRELEASE = @as(u32, 2097152);
pub const DBPROPVAL_GB_COLLATE = @as(i32, 16);
pub const DBPROPVAL_CS_UNINITIALIZED = @as(i32, 0);
pub const DBPROPVAL_CS_INITIALIZED = @as(i32, 1);
pub const DBPROPVAL_CS_COMMUNICATIONFAILURE = @as(i32, 2);
pub const DBPROPVAL_RD_RESETALL = @as(i32, -1);
pub const DBPROPVAL_OS_RESOURCEPOOLING = @as(i32, 1);
pub const DBPROPVAL_OS_TXNENLISTMENT = @as(i32, 2);
pub const DBPROPVAL_OS_CLIENTCURSOR = @as(i32, 4);
pub const DBPROPVAL_OS_ENABLEALL = @as(i32, -1);
pub const DBPROPVAL_BI_CROSSROWSET = @as(i32, 1);
pub const MDPROPVAL_NL_SCHEMAONLY = @as(i32, 4);
pub const DBPROPVAL_OS_DISABLEALL = @as(i32, 0);
pub const DBPROPVAL_OO_ROWOBJECT = @as(i32, 4);
pub const DBPROPVAL_OO_SCOPED = @as(i32, 8);
pub const DBPROPVAL_OO_DIRECTBIND = @as(i32, 16);
pub const DBPROPVAL_DST_DOCSOURCE = @as(i32, 4);
pub const DBPROPVAL_GU_NOTSUPPORTED = @as(i32, 1);
pub const DBPROPVAL_GU_SUFFIX = @as(i32, 2);
pub const DB_BINDFLAGS_DELAYFETCHCOLUMNS = @as(i32, 1);
pub const DB_BINDFLAGS_DELAYFETCHSTREAM = @as(i32, 2);
pub const DB_BINDFLAGS_RECURSIVE = @as(i32, 4);
pub const DB_BINDFLAGS_OUTPUT = @as(i32, 8);
pub const DB_BINDFLAGS_COLLECTION = @as(i32, 16);
pub const DB_BINDFLAGS_OPENIFEXISTS = @as(i32, 32);
pub const DB_BINDFLAGS_OVERWRITE = @as(i32, 64);
pub const DB_BINDFLAGS_ISSTRUCTUREDDOCUMENT = @as(i32, 128);
pub const DBPROPVAL_ORS_TABLE = @as(i32, 0);
pub const DBPROPVAL_ORS_INDEX = @as(i32, 1);
pub const DBPROPVAL_ORS_INTEGRATEDINDEX = @as(i32, 2);
pub const DBPROPVAL_TC_DDL_LOCK = @as(i32, 16);
pub const DBPROPVAL_ORS_STOREDPROC = @as(i32, 4);
pub const DBPROPVAL_IN_ALLOWNULL = @as(i32, 0);
pub const DBPROPVAL_OO_SINGLETON = @as(i32, 32);
pub const DBPROPVAL_OS_AGR_AFTERSESSION = @as(i32, 8);
pub const DBPROPVAL_CM_TRANSACTIONS = @as(i32, 1);
pub const DBPROPVAL_TS_CARDINALITY = @as(i32, 1);
pub const DBPROPVAL_TS_HISTOGRAM = @as(i32, 2);
pub const DBPROPVAL_ORS_HISTOGRAM = @as(i32, 8);
pub const MDPROPVAL_VISUAL_MODE_DEFAULT = @as(i32, 0);
pub const MDPROPVAL_VISUAL_MODE_VISUAL = @as(i32, 1);
pub const MDPROPVAL_VISUAL_MODE_VISUAL_OFF = @as(i32, 2);
pub const DB_IMP_LEVEL_ANONYMOUS = @as(u32, 0);
pub const DB_IMP_LEVEL_IDENTIFY = @as(u32, 1);
pub const DB_IMP_LEVEL_IMPERSONATE = @as(u32, 2);
pub const DB_IMP_LEVEL_DELEGATE = @as(u32, 3);
pub const DBPROMPT_PROMPT = @as(u32, 1);
pub const DBPROMPT_COMPLETE = @as(u32, 2);
pub const DBPROMPT_COMPLETEREQUIRED = @as(u32, 3);
pub const DBPROMPT_NOPROMPT = @as(u32, 4);
pub const DB_PROT_LEVEL_NONE = @as(u32, 0);
pub const DB_PROT_LEVEL_CONNECT = @as(u32, 1);
pub const DB_PROT_LEVEL_CALL = @as(u32, 2);
pub const DB_PROT_LEVEL_PKT = @as(u32, 3);
pub const DB_PROT_LEVEL_PKT_INTEGRITY = @as(u32, 4);
pub const DB_PROT_LEVEL_PKT_PRIVACY = @as(u32, 5);
pub const DB_MODE_READ = @as(u32, 1);
pub const DB_MODE_WRITE = @as(u32, 2);
pub const DB_MODE_READWRITE = @as(u32, 3);
pub const DB_MODE_SHARE_DENY_READ = @as(u32, 4);
pub const DB_MODE_SHARE_DENY_WRITE = @as(u32, 8);
pub const DB_MODE_SHARE_EXCLUSIVE = @as(u32, 12);
pub const DB_MODE_SHARE_DENY_NONE = @as(u32, 16);
pub const DBCOMPUTEMODE_COMPUTED = @as(u32, 1);
pub const DBCOMPUTEMODE_DYNAMIC = @as(u32, 2);
pub const DBCOMPUTEMODE_NOTCOMPUTED = @as(u32, 3);
pub const DBPROPVAL_DF_INITIALLY_DEFERRED = @as(u32, 1);
pub const DBPROPVAL_DF_INITIALLY_IMMEDIATE = @as(u32, 2);
pub const DBPROPVAL_DF_NOT_DEFERRABLE = @as(u32, 3);
pub const DBPARAMTYPE_INPUT = @as(u32, 1);
pub const DBPARAMTYPE_INPUTOUTPUT = @as(u32, 2);
pub const DBPARAMTYPE_OUTPUT = @as(u32, 3);
pub const DBPARAMTYPE_RETURNVALUE = @as(u32, 4);
pub const DB_PT_UNKNOWN = @as(u32, 1);
pub const DB_PT_PROCEDURE = @as(u32, 2);
pub const DB_PT_FUNCTION = @as(u32, 3);
pub const DB_REMOTE = @as(u32, 1);
pub const DB_LOCAL_SHARED = @as(u32, 2);
pub const DB_LOCAL_EXCLUSIVE = @as(u32, 3);
pub const DB_COLLATION_ASC = @as(u32, 1);
pub const DB_COLLATION_DESC = @as(u32, 2);
pub const DB_UNSEARCHABLE = @as(u32, 1);
pub const DB_LIKE_ONLY = @as(u32, 2);
pub const DB_ALL_EXCEPT_LIKE = @as(u32, 3);
pub const DB_SEARCHABLE = @as(u32, 4);
pub const MDTREEOP_CHILDREN = @as(u32, 1);
pub const MDTREEOP_SIBLINGS = @as(u32, 2);
pub const MDTREEOP_PARENT = @as(u32, 4);
pub const MDTREEOP_SELF = @as(u32, 8);
pub const MDTREEOP_DESCENDANTS = @as(u32, 16);
pub const MDTREEOP_ANCESTORS = @as(u32, 32);
pub const MD_DIMTYPE_UNKNOWN = @as(u32, 0);
pub const MD_DIMTYPE_TIME = @as(u32, 1);
pub const MD_DIMTYPE_MEASURE = @as(u32, 2);
pub const MD_DIMTYPE_OTHER = @as(u32, 3);
pub const MDLEVEL_TYPE_UNKNOWN = @as(u32, 0);
pub const MDLEVEL_TYPE_REGULAR = @as(u32, 0);
pub const MDLEVEL_TYPE_ALL = @as(u32, 1);
pub const MDLEVEL_TYPE_CALCULATED = @as(u32, 2);
pub const MDLEVEL_TYPE_TIME = @as(u32, 4);
pub const MDLEVEL_TYPE_RESERVED1 = @as(u32, 8);
pub const MDLEVEL_TYPE_TIME_YEARS = @as(u32, 20);
pub const MDLEVEL_TYPE_TIME_HALF_YEAR = @as(u32, 36);
pub const MDLEVEL_TYPE_TIME_QUARTERS = @as(u32, 68);
pub const MDLEVEL_TYPE_TIME_MONTHS = @as(u32, 132);
pub const MDLEVEL_TYPE_TIME_WEEKS = @as(u32, 260);
pub const MDLEVEL_TYPE_TIME_DAYS = @as(u32, 516);
pub const MDLEVEL_TYPE_TIME_HOURS = @as(u32, 772);
pub const MDLEVEL_TYPE_TIME_MINUTES = @as(u32, 1028);
pub const MDLEVEL_TYPE_TIME_SECONDS = @as(u32, 2052);
pub const MDLEVEL_TYPE_TIME_UNDEFINED = @as(u32, 4100);
pub const MDMEASURE_AGGR_UNKNOWN = @as(u32, 0);
pub const MDMEASURE_AGGR_SUM = @as(u32, 1);
pub const MDMEASURE_AGGR_COUNT = @as(u32, 2);
pub const MDMEASURE_AGGR_MIN = @as(u32, 3);
pub const MDMEASURE_AGGR_MAX = @as(u32, 4);
pub const MDMEASURE_AGGR_AVG = @as(u32, 5);
pub const MDMEASURE_AGGR_VAR = @as(u32, 6);
pub const MDMEASURE_AGGR_STD = @as(u32, 7);
pub const MDMEASURE_AGGR_CALCULATED = @as(u32, 127);
pub const MDPROP_MEMBER = @as(u32, 1);
pub const MDPROP_CELL = @as(u32, 2);
pub const MDMEMBER_TYPE_UNKNOWN = @as(u32, 0);
pub const MDMEMBER_TYPE_REGULAR = @as(u32, 1);
pub const MDMEMBER_TYPE_ALL = @as(u32, 2);
pub const MDMEMBER_TYPE_MEASURE = @as(u32, 3);
pub const MDMEMBER_TYPE_FORMULA = @as(u32, 4);
pub const MDMEMBER_TYPE_RESERVE1 = @as(u32, 5);
pub const MDMEMBER_TYPE_RESERVE2 = @as(u32, 6);
pub const MDMEMBER_TYPE_RESERVE3 = @as(u32, 7);
pub const MDMEMBER_TYPE_RESERVE4 = @as(u32, 8);
pub const MDDISPINFO_DRILLED_DOWN = @as(u32, 65536);
pub const MDDISPINFO_PARENT_SAME_AS_PREV = @as(u32, 131072);
pub const DB_COUNTUNAVAILABLE = @as(i32, -1);
pub const MDFF_BOLD = @as(u32, 1);
pub const MDFF_ITALIC = @as(u32, 2);
pub const MDFF_UNDERLINE = @as(u32, 4);
pub const MDFF_STRIKEOUT = @as(u32, 8);
pub const MDAXIS_COLUMNS = @as(u32, 0);
pub const MDAXIS_ROWS = @as(u32, 1);
pub const MDAXIS_PAGES = @as(u32, 2);
pub const MDAXIS_SECTIONS = @as(u32, 3);
pub const MDAXIS_CHAPTERS = @as(u32, 4);
pub const MDAXIS_SLICERS = @as(u32, 4294967295);
pub const CRESTRICTIONS_DBSCHEMA_ASSERTIONS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_CATALOGS = @as(u32, 1);
pub const CRESTRICTIONS_DBSCHEMA_CHARACTER_SETS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_COLLATIONS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_COLUMNS = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_CHECK_CONSTRAINTS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_CONSTRAINT_COLUMN_USAGE = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_CONSTRAINT_TABLE_USAGE = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_KEY_COLUMN_USAGE = @as(u32, 7);
pub const CRESTRICTIONS_DBSCHEMA_REFERENTIAL_CONSTRAINTS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_TABLE_CONSTRAINTS = @as(u32, 7);
pub const CRESTRICTIONS_DBSCHEMA_COLUMN_DOMAIN_USAGE = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_INDEXES = @as(u32, 5);
pub const CRESTRICTIONS_DBSCHEMA_OBJECT_ACTIONS = @as(u32, 1);
pub const CRESTRICTIONS_DBSCHEMA_OBJECTS = @as(u32, 1);
pub const CRESTRICTIONS_DBSCHEMA_COLUMN_PRIVILEGES = @as(u32, 6);
pub const CRESTRICTIONS_DBSCHEMA_TABLE_PRIVILEGES = @as(u32, 5);
pub const CRESTRICTIONS_DBSCHEMA_USAGE_PRIVILEGES = @as(u32, 6);
pub const CRESTRICTIONS_DBSCHEMA_PROCEDURES = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_SCHEMATA = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_SQL_LANGUAGES = @as(u32, 0);
pub const CRESTRICTIONS_DBSCHEMA_STATISTICS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_TABLES = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_TRANSLATIONS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_PROVIDER_TYPES = @as(u32, 2);
pub const CRESTRICTIONS_DBSCHEMA_VIEWS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_VIEW_COLUMN_USAGE = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_VIEW_TABLE_USAGE = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_PROCEDURE_PARAMETERS = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_FOREIGN_KEYS = @as(u32, 6);
pub const CRESTRICTIONS_DBSCHEMA_PRIMARY_KEYS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_PROCEDURE_COLUMNS = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_TABLES_INFO = @as(u32, 4);
pub const CRESTRICTIONS_MDSCHEMA_CUBES = @as(u32, 3);
pub const CRESTRICTIONS_MDSCHEMA_DIMENSIONS = @as(u32, 5);
pub const CRESTRICTIONS_MDSCHEMA_HIERARCHIES = @as(u32, 6);
pub const CRESTRICTIONS_MDSCHEMA_LEVELS = @as(u32, 7);
pub const CRESTRICTIONS_MDSCHEMA_MEASURES = @as(u32, 5);
pub const CRESTRICTIONS_MDSCHEMA_PROPERTIES = @as(u32, 9);
pub const CRESTRICTIONS_MDSCHEMA_MEMBERS = @as(u32, 12);
pub const CRESTRICTIONS_DBSCHEMA_TRUSTEE = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_TABLE_STATISTICS = @as(u32, 7);
pub const CRESTRICTIONS_DBSCHEMA_CHECK_CONSTRAINTS_BY_TABLE = @as(u32, 6);
pub const CRESTRICTIONS_MDSCHEMA_FUNCTIONS = @as(u32, 4);
pub const CRESTRICTIONS_MDSCHEMA_ACTIONS = @as(u32, 8);
pub const CRESTRICTIONS_MDSCHEMA_COMMANDS = @as(u32, 5);
pub const CRESTRICTIONS_MDSCHEMA_SETS = @as(u32, 5);
pub const IDENTIFIER_SDK_MASK = @as(u32, 4026531840);
pub const IDENTIFIER_SDK_ERROR = @as(u32, 268435456);
pub const DBPROP_MSDAORA_DETERMINEKEYCOLUMNS = @as(u32, 1);
pub const DBPROP_MSDAORA8_DETERMINEKEYCOLUMNS = @as(u32, 2);
pub const PWPROP_OSPVALUE = @as(u32, 2);
pub const STGM_COLLECTION = @as(i32, 8192);
pub const STGM_OUTPUT = @as(i32, 32768);
pub const STGM_OPEN = @as(i32, -2147483648);
pub const STGM_RECURSIVE = @as(i32, 16777216);
pub const STGM_STRICTOPEN = @as(i32, 1073741824);
pub const KAGPROP_QUERYBASEDUPDATES = @as(u32, 2);
pub const KAGPROP_MARSHALLABLE = @as(u32, 3);
pub const KAGPROP_POSITIONONNEWROW = @as(u32, 4);
pub const KAGPROP_IRowsetChangeExtInfo = @as(u32, 5);
pub const KAGPROP_CURSOR = @as(u32, 6);
pub const KAGPROP_CONCURRENCY = @as(u32, 7);
pub const KAGPROP_BLOBSONFOCURSOR = @as(u32, 8);
pub const KAGPROP_INCLUDENONEXACT = @as(u32, 9);
pub const KAGPROP_FORCESSFIREHOSEMODE = @as(u32, 10);
pub const KAGPROP_FORCENOPARAMETERREBIND = @as(u32, 11);
pub const KAGPROP_FORCENOPREPARE = @as(u32, 12);
pub const KAGPROP_FORCENOREEXECUTE = @as(u32, 13);
pub const KAGPROP_ACCESSIBLEPROCEDURES = @as(u32, 2);
pub const KAGPROP_ACCESSIBLETABLES = @as(u32, 3);
pub const KAGPROP_ODBCSQLOPTIEF = @as(u32, 4);
pub const KAGPROP_OJCAPABILITY = @as(u32, 5);
pub const KAGPROP_PROCEDURES = @as(u32, 6);
pub const KAGPROP_DRIVERNAME = @as(u32, 7);
pub const KAGPROP_DRIVERVER = @as(u32, 8);
pub const KAGPROP_DRIVERODBCVER = @as(u32, 9);
pub const KAGPROP_LIKEESCAPECLAUSE = @as(u32, 10);
pub const KAGPROP_SPECIALCHARACTERS = @as(u32, 11);
pub const KAGPROP_MAXCOLUMNSINGROUPBY = @as(u32, 12);
pub const KAGPROP_MAXCOLUMNSININDEX = @as(u32, 13);
pub const KAGPROP_MAXCOLUMNSINORDERBY = @as(u32, 14);
pub const KAGPROP_MAXCOLUMNSINSELECT = @as(u32, 15);
pub const KAGPROP_MAXCOLUMNSINTABLE = @as(u32, 16);
pub const KAGPROP_NUMERICFUNCTIONS = @as(u32, 17);
pub const KAGPROP_ODBCSQLCONFORMANCE = @as(u32, 18);
pub const KAGPROP_OUTERJOINS = @as(u32, 19);
pub const KAGPROP_STRINGFUNCTIONS = @as(u32, 20);
pub const KAGPROP_SYSTEMFUNCTIONS = @as(u32, 21);
pub const KAGPROP_TIMEDATEFUNCTIONS = @as(u32, 22);
pub const KAGPROP_FILEUSAGE = @as(u32, 23);
pub const KAGPROP_ACTIVESTATEMENTS = @as(u32, 24);
pub const KAGPROP_AUTH_TRUSTEDCONNECTION = @as(u32, 2);
pub const KAGPROP_AUTH_SERVERINTEGRATED = @as(u32, 3);
pub const KAGPROPVAL_CONCUR_ROWVER = @as(u32, 1);
pub const KAGPROPVAL_CONCUR_VALUES = @as(u32, 2);
pub const KAGPROPVAL_CONCUR_LOCK = @as(u32, 4);
pub const KAGPROPVAL_CONCUR_READ_ONLY = @as(u32, 8);
pub const ODBCVER = @as(u32, 896);
pub const ODBC_ADD_DSN = @as(u32, 1);
pub const ODBC_CONFIG_DSN = @as(u32, 2);
pub const ODBC_REMOVE_DSN = @as(u32, 3);
pub const ODBC_ADD_SYS_DSN = @as(u32, 4);
pub const ODBC_CONFIG_SYS_DSN = @as(u32, 5);
pub const ODBC_REMOVE_SYS_DSN = @as(u32, 6);
pub const ODBC_REMOVE_DEFAULT_DSN = @as(u32, 7);
pub const ODBC_INSTALL_INQUIRY = @as(u32, 1);
pub const ODBC_INSTALL_COMPLETE = @as(u32, 2);
pub const ODBC_INSTALL_DRIVER = @as(u32, 1);
pub const ODBC_REMOVE_DRIVER = @as(u32, 2);
pub const ODBC_CONFIG_DRIVER = @as(u32, 3);
pub const ODBC_CONFIG_DRIVER_MAX = @as(u32, 100);
pub const ODBC_BOTH_DSN = @as(u32, 0);
pub const ODBC_USER_DSN = @as(u32, 1);
pub const ODBC_SYSTEM_DSN = @as(u32, 2);
pub const ODBC_ERROR_GENERAL_ERR = @as(u32, 1);
pub const ODBC_ERROR_INVALID_BUFF_LEN = @as(u32, 2);
pub const ODBC_ERROR_INVALID_HWND = @as(u32, 3);
pub const ODBC_ERROR_INVALID_STR = @as(u32, 4);
pub const ODBC_ERROR_INVALID_REQUEST_TYPE = @as(u32, 5);
pub const ODBC_ERROR_COMPONENT_NOT_FOUND = @as(u32, 6);
pub const ODBC_ERROR_INVALID_NAME = @as(u32, 7);
pub const ODBC_ERROR_INVALID_KEYWORD_VALUE = @as(u32, 8);
pub const ODBC_ERROR_INVALID_DSN = @as(u32, 9);
pub const ODBC_ERROR_INVALID_INF = @as(u32, 10);
pub const ODBC_ERROR_REQUEST_FAILED = @as(u32, 11);
pub const ODBC_ERROR_INVALID_PATH = @as(u32, 12);
pub const ODBC_ERROR_LOAD_LIB_FAILED = @as(u32, 13);
pub const ODBC_ERROR_INVALID_PARAM_SEQUENCE = @as(u32, 14);
pub const ODBC_ERROR_INVALID_LOG_FILE = @as(u32, 15);
pub const ODBC_ERROR_USER_CANCELED = @as(u32, 16);
pub const ODBC_ERROR_USAGE_UPDATE_FAILED = @as(u32, 17);
pub const ODBC_ERROR_CREATE_DSN_FAILED = @as(u32, 18);
pub const ODBC_ERROR_WRITING_SYSINFO_FAILED = @as(u32, 19);
pub const ODBC_ERROR_REMOVE_DSN_FAILED = @as(u32, 20);
pub const ODBC_ERROR_OUT_OF_MEM = @as(u32, 21);
pub const ODBC_ERROR_OUTPUT_STRING_TRUNCATED = @as(u32, 22);
pub const ODBC_ERROR_NOTRANINFO = @as(u32, 23);
pub const ODBC_ERROR_MAX = @as(u32, 23);
pub const SQL_MAX_SQLSERVERNAME = @as(u32, 128);
pub const SQL_COPT_SS_BASE = @as(u32, 1200);
pub const SQL_COPT_SS_REMOTE_PWD = @as(u32, 1201);
pub const SQL_COPT_SS_USE_PROC_FOR_PREP = @as(u32, 1202);
pub const SQL_COPT_SS_INTEGRATED_SECURITY = @as(u32, 1203);
pub const SQL_COPT_SS_PRESERVE_CURSORS = @as(u32, 1204);
pub const SQL_COPT_SS_USER_DATA = @as(u32, 1205);
pub const SQL_COPT_SS_FALLBACK_CONNECT = @as(u32, 1210);
pub const SQL_COPT_SS_PERF_DATA = @as(u32, 1211);
pub const SQL_COPT_SS_PERF_DATA_LOG = @as(u32, 1212);
pub const SQL_COPT_SS_PERF_QUERY_INTERVAL = @as(u32, 1213);
pub const SQL_COPT_SS_PERF_QUERY_LOG = @as(u32, 1214);
pub const SQL_COPT_SS_PERF_QUERY = @as(u32, 1215);
pub const SQL_COPT_SS_PERF_DATA_LOG_NOW = @as(u32, 1216);
pub const SQL_COPT_SS_QUOTED_IDENT = @as(u32, 1217);
pub const SQL_COPT_SS_ANSI_NPW = @as(u32, 1218);
pub const SQL_COPT_SS_BCP = @as(u32, 1219);
pub const SQL_COPT_SS_TRANSLATE = @as(u32, 1220);
pub const SQL_COPT_SS_ATTACHDBFILENAME = @as(u32, 1221);
pub const SQL_COPT_SS_CONCAT_NULL = @as(u32, 1222);
pub const SQL_COPT_SS_ENCRYPT = @as(u32, 1223);
pub const SQL_COPT_SS_MAX_USED = @as(u32, 1223);
pub const SQL_SOPT_SS_BASE = @as(u32, 1225);
pub const SQL_SOPT_SS_TEXTPTR_LOGGING = @as(u32, 1225);
pub const SQL_SOPT_SS_CURRENT_COMMAND = @as(u32, 1226);
pub const SQL_SOPT_SS_HIDDEN_COLUMNS = @as(u32, 1227);
pub const SQL_SOPT_SS_NOBROWSETABLE = @as(u32, 1228);
pub const SQL_SOPT_SS_REGIONALIZE = @as(u32, 1229);
pub const SQL_SOPT_SS_CURSOR_OPTIONS = @as(u32, 1230);
pub const SQL_SOPT_SS_NOCOUNT_STATUS = @as(u32, 1231);
pub const SQL_SOPT_SS_DEFER_PREPARE = @as(u32, 1232);
pub const SQL_SOPT_SS_MAX_USED = @as(u32, 1232);
pub const SQL_COPT_SS_BASE_EX = @as(u32, 1240);
pub const SQL_COPT_SS_BROWSE_CONNECT = @as(u32, 1241);
pub const SQL_COPT_SS_BROWSE_SERVER = @as(u32, 1242);
pub const SQL_COPT_SS_WARN_ON_CP_ERROR = @as(u32, 1243);
pub const SQL_COPT_SS_CONNECTION_DEAD = @as(u32, 1244);
pub const SQL_COPT_SS_BROWSE_CACHE_DATA = @as(u32, 1245);
pub const SQL_COPT_SS_RESET_CONNECTION = @as(u32, 1246);
pub const SQL_COPT_SS_EX_MAX_USED = @as(u32, 1246);
pub const SQL_UP_OFF = @as(i32, 0);
pub const SQL_UP_ON = @as(i32, 1);
pub const SQL_UP_ON_DROP = @as(i32, 2);
pub const SQL_UP_DEFAULT = @as(i32, 1);
pub const SQL_IS_OFF = @as(i32, 0);
pub const SQL_IS_ON = @as(i32, 1);
pub const SQL_IS_DEFAULT = @as(i32, 0);
pub const SQL_PC_OFF = @as(i32, 0);
pub const SQL_PC_ON = @as(i32, 1);
pub const SQL_PC_DEFAULT = @as(i32, 0);
pub const SQL_XL_OFF = @as(i32, 0);
pub const SQL_XL_ON = @as(i32, 1);
pub const SQL_XL_DEFAULT = @as(i32, 1);
pub const SQL_FB_OFF = @as(i32, 0);
pub const SQL_FB_ON = @as(i32, 1);
pub const SQL_FB_DEFAULT = @as(i32, 0);
pub const SQL_BCP_OFF = @as(i32, 0);
pub const SQL_BCP_ON = @as(i32, 1);
pub const SQL_BCP_DEFAULT = @as(i32, 0);
pub const SQL_QI_OFF = @as(i32, 0);
pub const SQL_QI_ON = @as(i32, 1);
pub const SQL_QI_DEFAULT = @as(i32, 1);
pub const SQL_AD_OFF = @as(i32, 0);
pub const SQL_AD_ON = @as(i32, 1);
pub const SQL_AD_DEFAULT = @as(i32, 1);
pub const SQL_CN_OFF = @as(i32, 0);
pub const SQL_CN_ON = @as(i32, 1);
pub const SQL_CN_DEFAULT = @as(i32, 1);
pub const SQL_TL_OFF = @as(i32, 0);
pub const SQL_TL_ON = @as(i32, 1);
pub const SQL_TL_DEFAULT = @as(i32, 1);
pub const SQL_HC_OFF = @as(i32, 0);
pub const SQL_HC_ON = @as(i32, 1);
pub const SQL_HC_DEFAULT = @as(i32, 0);
pub const SQL_NB_OFF = @as(i32, 0);
pub const SQL_NB_ON = @as(i32, 1);
pub const SQL_NB_DEFAULT = @as(i32, 0);
pub const SQL_RE_OFF = @as(i32, 0);
pub const SQL_RE_ON = @as(i32, 1);
pub const SQL_RE_DEFAULT = @as(i32, 0);
pub const SQL_CO_OFF = @as(i32, 0);
pub const SQL_CO_FFO = @as(i32, 1);
pub const SQL_CO_AF = @as(i32, 2);
pub const SQL_CO_FIREHOSE_AF = @as(i32, 4);
pub const SQL_CO_DEFAULT = @as(i32, 0);
pub const SQL_NC_OFF = @as(i32, 0);
pub const SQL_NC_ON = @as(i32, 1);
pub const SQL_DP_OFF = @as(i32, 0);
pub const SQL_DP_ON = @as(i32, 1);
pub const SQL_EN_OFF = @as(i32, 0);
pub const SQL_EN_ON = @as(i32, 1);
pub const SQL_MORE_INFO_NO = @as(i32, 0);
pub const SQL_MORE_INFO_YES = @as(i32, 1);
pub const SQL_CACHE_DATA_NO = @as(i32, 0);
pub const SQL_CACHE_DATA_YES = @as(i32, 1);
pub const SQL_RESET_YES = @as(i32, 1);
pub const SQL_WARN_NO = @as(i32, 0);
pub const SQL_WARN_YES = @as(i32, 1);
pub const SQL_CURSOR_FAST_FORWARD_ONLY = @as(u32, 8);
pub const SQL_CA_SS_BASE = @as(u32, 1200);
pub const SQL_CA_SS_COLUMN_SSTYPE = @as(u32, 1200);
pub const SQL_CA_SS_COLUMN_UTYPE = @as(u32, 1201);
pub const SQL_CA_SS_NUM_ORDERS = @as(u32, 1202);
pub const SQL_CA_SS_COLUMN_ORDER = @as(u32, 1203);
pub const SQL_CA_SS_COLUMN_VARYLEN = @as(u32, 1204);
pub const SQL_CA_SS_NUM_COMPUTES = @as(u32, 1205);
pub const SQL_CA_SS_COMPUTE_ID = @as(u32, 1206);
pub const SQL_CA_SS_COMPUTE_BYLIST = @as(u32, 1207);
pub const SQL_CA_SS_COLUMN_ID = @as(u32, 1208);
pub const SQL_CA_SS_COLUMN_OP = @as(u32, 1209);
pub const SQL_CA_SS_COLUMN_SIZE = @as(u32, 1210);
pub const SQL_CA_SS_COLUMN_HIDDEN = @as(u32, 1211);
pub const SQL_CA_SS_COLUMN_KEY = @as(u32, 1212);
pub const SQL_CA_SS_COLUMN_COLLATION = @as(u32, 1214);
pub const SQL_CA_SS_VARIANT_TYPE = @as(u32, 1215);
pub const SQL_CA_SS_VARIANT_SQL_TYPE = @as(u32, 1216);
pub const SQL_CA_SS_VARIANT_SERVER_TYPE = @as(u32, 1217);
pub const SQL_CA_SS_MAX_USED = @as(u32, 1218);
pub const SQLTEXT = @as(u32, 35);
pub const SQLVARBINARY = @as(u32, 37);
pub const SQLINTN = @as(u32, 38);
pub const SQLVARCHAR = @as(u32, 39);
pub const SQLBINARY = @as(u32, 45);
pub const SQLIMAGE = @as(u32, 34);
pub const SQLCHARACTER = @as(u32, 47);
pub const SQLINT1 = @as(u32, 48);
pub const SQLBIT = @as(u32, 50);
pub const SQLINT2 = @as(u32, 52);
pub const SQLINT4 = @as(u32, 56);
pub const SQLMONEY = @as(u32, 60);
pub const SQLDATETIME = @as(u32, 61);
pub const SQLFLT8 = @as(u32, 62);
pub const SQLFLTN = @as(u32, 109);
pub const SQLMONEYN = @as(u32, 110);
pub const SQLDATETIMN = @as(u32, 111);
pub const SQLFLT4 = @as(u32, 59);
pub const SQLMONEY4 = @as(u32, 122);
pub const SQLDATETIM4 = @as(u32, 58);
pub const SQLDECIMAL = @as(u32, 106);
pub const SQLNUMERIC = @as(u32, 108);
pub const SQLUNIQUEID = @as(u32, 36);
pub const SQLBIGCHAR = @as(u32, 175);
pub const SQLBIGVARCHAR = @as(u32, 167);
pub const SQLBIGBINARY = @as(u32, 173);
pub const SQLBIGVARBINARY = @as(u32, 165);
pub const SQLBITN = @as(u32, 104);
pub const SQLNCHAR = @as(u32, 239);
pub const SQLNVARCHAR = @as(u32, 231);
pub const SQLNTEXT = @as(u32, 99);
pub const SQLINT8 = @as(u32, 127);
pub const SQLVARIANT = @as(u32, 98);
pub const SQLudtBINARY = @as(u32, 3);
pub const SQLudtBIT = @as(u32, 16);
pub const SQLudtBITN = @as(u32, 0);
pub const SQLudtCHAR = @as(u32, 1);
pub const SQLudtDATETIM4 = @as(u32, 22);
pub const SQLudtDATETIME = @as(u32, 12);
pub const SQLudtDATETIMN = @as(u32, 15);
pub const SQLudtDECML = @as(u32, 24);
pub const SQLudtDECMLN = @as(u32, 26);
pub const SQLudtFLT4 = @as(u32, 23);
pub const SQLudtFLT8 = @as(u32, 8);
pub const SQLudtFLTN = @as(u32, 14);
pub const SQLudtIMAGE = @as(u32, 20);
pub const SQLudtINT1 = @as(u32, 5);
pub const SQLudtINT2 = @as(u32, 6);
pub const SQLudtINT4 = @as(u32, 7);
pub const SQLudtINTN = @as(u32, 13);
pub const SQLudtMONEY = @as(u32, 11);
pub const SQLudtMONEY4 = @as(u32, 21);
pub const SQLudtMONEYN = @as(u32, 17);
pub const SQLudtNUM = @as(u32, 10);
pub const SQLudtNUMN = @as(u32, 25);
pub const SQLudtSYSNAME = @as(u32, 18);
pub const SQLudtTEXT = @as(u32, 19);
pub const SQLudtTIMESTAMP = @as(u32, 80);
pub const SQLudtUNIQUEIDENTIFIER = @as(u32, 0);
pub const SQLudtVARBINARY = @as(u32, 4);
pub const SQLudtVARCHAR = @as(u32, 2);
pub const MIN_USER_DATATYPE = @as(u32, 256);
pub const SQLAOPSTDEV = @as(u32, 48);
pub const SQLAOPSTDEVP = @as(u32, 49);
pub const SQLAOPVAR = @as(u32, 50);
pub const SQLAOPVARP = @as(u32, 51);
pub const SQLAOPCNT = @as(u32, 75);
pub const SQLAOPSUM = @as(u32, 77);
pub const SQLAOPAVG = @as(u32, 79);
pub const SQLAOPMIN = @as(u32, 81);
pub const SQLAOPMAX = @as(u32, 82);
pub const SQLAOPANY = @as(u32, 83);
pub const SQLAOPNOOP = @as(u32, 86);
pub const SQL_INFO_SS_FIRST = @as(u32, 1199);
pub const SQL_INFO_SS_NETLIB_NAMEW = @as(u32, 1199);
pub const SQL_INFO_SS_NETLIB_NAMEA = @as(u32, 1200);
pub const SQL_INFO_SS_MAX_USED = @as(u32, 1200);
pub const SQL_INFO_SS_NETLIB_NAME = @as(u32, 1199);
pub const SQL_SS_VARIANT = @as(i32, -150);
pub const SQL_DIAG_SS_BASE = @as(i32, -1150);
pub const SQL_DIAG_SS_MSGSTATE = @as(i32, -1150);
pub const SQL_DIAG_DFC_SS_BASE = @as(i32, -200);
pub const EX_ANY = @as(u32, 0);
pub const EX_INFO = @as(u32, 10);
pub const EX_MAXISEVERITY = @as(u32, 10);
pub const EX_MISSING = @as(u32, 11);
pub const EX_TYPE = @as(u32, 12);
pub const EX_DEADLOCK = @as(u32, 13);
pub const EX_PERMIT = @as(u32, 14);
pub const EX_SYNTAX = @as(u32, 15);
pub const EX_USER = @as(u32, 16);
pub const EX_RESOURCE = @as(u32, 17);
pub const EX_INTOK = @as(u32, 18);
pub const MAXUSEVERITY = @as(u32, 18);
pub const EX_LIMIT = @as(u32, 19);
pub const EX_CMDFATAL = @as(u32, 20);
pub const MINFATALERR = @as(u32, 20);
pub const EX_DBFATAL = @as(u32, 21);
pub const EX_TABCORRUPT = @as(u32, 22);
pub const EX_DBCORRUPT = @as(u32, 23);
pub const EX_HARDWARE = @as(u32, 24);
pub const EX_CONTROL = @as(u32, 25);
pub const DBMAXCHAR = @as(u32, 8001);
pub const MAXNAME = @as(u32, 129);
pub const MAXNUMERICLEN = @as(u32, 16);
pub const SQL_PERF_START = @as(u32, 1);
pub const SQL_PERF_STOP = @as(u32, 2);
pub const SQL_SS_QI_DEFAULT = @as(u32, 30000);
pub const SUCCEED = @as(u32, 1);
pub const FAIL = @as(u32, 0);
pub const SUCCEED_ABORT = @as(u32, 2);
pub const SUCCEED_ASYNC = @as(u32, 3);
pub const DB_IN = @as(u32, 1);
pub const DB_OUT = @as(u32, 2);
pub const BCPMAXERRS = @as(u32, 1);
pub const BCPFIRST = @as(u32, 2);
pub const BCPLAST = @as(u32, 3);
pub const BCPBATCH = @as(u32, 4);
pub const BCPKEEPNULLS = @as(u32, 5);
pub const BCPABORT = @as(u32, 6);
pub const BCPODBC = @as(u32, 7);
pub const BCPKEEPIDENTITY = @as(u32, 8);
pub const BCP6xFILEFMT = @as(u32, 9);
pub const BCPHINTSA = @as(u32, 10);
pub const BCPHINTSW = @as(u32, 11);
pub const BCPFILECP = @as(u32, 12);
pub const BCPUNICODEFILE = @as(u32, 13);
pub const BCPTEXTFILE = @as(u32, 14);
pub const BCPFILEFMT = @as(u32, 15);
pub const BCPFILECP_ACP = @as(u32, 0);
pub const BCPFILECP_OEMCP = @as(u32, 1);
pub const BCPFILECP_RAW = @as(i32, -1);
pub const SQL_VARLEN_DATA = @as(i32, -10);
pub const BCPHINTS = @as(u32, 11);
pub const BCP_FMT_TYPE = @as(u32, 1);
pub const BCP_FMT_INDICATOR_LEN = @as(u32, 2);
pub const BCP_FMT_DATA_LEN = @as(u32, 3);
pub const BCP_FMT_TERMINATOR = @as(u32, 4);
pub const BCP_FMT_SERVER_COL = @as(u32, 5);
pub const BCP_FMT_COLLATION = @as(u32, 6);
pub const BCP_FMT_COLLATION_ID = @as(u32, 7);
pub const SQL_FAST_CONNECT = @as(u32, 1200);
pub const SQL_FC_OFF = @as(i32, 0);
pub const SQL_FC_ON = @as(i32, 1);
pub const SQL_FC_DEFAULT = @as(i32, 0);
pub const SQL_COPT_SS_ANSI_OEM = @as(u32, 1206);
pub const SQL_AO_OFF = @as(i32, 0);
pub const SQL_AO_ON = @as(i32, 1);
pub const SQL_AO_DEFAULT = @as(i32, 0);
pub const SQL_REMOTE_PWD = @as(u32, 1201);
pub const SQL_USE_PROCEDURE_FOR_PREPARE = @as(u32, 1202);
pub const SQL_INTEGRATED_SECURITY = @as(u32, 1203);
pub const SQL_PRESERVE_CURSORS = @as(u32, 1204);
pub const SQL_TEXTPTR_LOGGING = @as(u32, 1225);
pub const SQLDECIMALN = @as(u32, 106);
pub const SQLNUMERICN = @as(u32, 108);
pub const DB_E_BOGUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217665));
pub const DB_E_BADACCESSORHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217920));
pub const DB_E_ROWLIMITEXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217919));
pub const DB_E_READONLYACCESSOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217918));
pub const DB_E_SCHEMAVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217917));
pub const DB_E_BADROWHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217916));
pub const DB_E_OBJECTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217915));
pub const DB_E_BADCHAPTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217914));
pub const DB_E_CANTCONVERTVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217913));
pub const DB_E_BADBINDINFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217912));
pub const DB_SEC_E_PERMISSIONDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217911));
pub const DB_E_NOTAREFERENCECOLUMN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217910));
pub const DB_E_LIMITREJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217909));
pub const DB_E_NOCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217908));
pub const DB_E_COSTLIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217907));
pub const DB_E_BADBOOKMARK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217906));
pub const DB_E_BADLOCKMODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217905));
pub const DB_E_PARAMNOTOPTIONAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217904));
pub const DB_E_BADCOLUMNID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217903));
pub const DB_E_BADRATIO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217902));
pub const DB_E_BADVALUES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217901));
pub const DB_E_ERRORSINCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217900));
pub const DB_E_CANTCANCEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217899));
pub const DB_E_DIALECTNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217898));
pub const DB_E_DUPLICATEDATASOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217897));
pub const DB_E_CANNOTRESTART = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217896));
pub const DB_E_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217895));
pub const DB_E_NEWLYINSERTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217893));
pub const DB_E_CANNOTFREE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217894));
pub const DB_E_GOALREJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217892));
pub const DB_E_UNSUPPORTEDCONVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217891));
pub const DB_E_BADSTARTPOSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217890));
pub const DB_E_NOQUERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217889));
pub const DB_E_NOTREENTRANT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217888));
pub const DB_E_ERRORSOCCURRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217887));
pub const DB_E_NOAGGREGATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217886));
pub const DB_E_DELETEDROW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217885));
pub const DB_E_CANTFETCHBACKWARDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217884));
pub const DB_E_ROWSNOTRELEASED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217883));
pub const DB_E_BADSTORAGEFLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217882));
pub const DB_E_BADCOMPAREOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217881));
pub const DB_E_BADSTATUSVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217880));
pub const DB_E_CANTSCROLLBACKWARDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217879));
pub const DB_E_BADREGIONHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217878));
pub const DB_E_NONCONTIGUOUSRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217877));
pub const DB_E_INVALIDTRANSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217876));
pub const DB_E_NOTASUBREGION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217875));
pub const DB_E_MULTIPLESTATEMENTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217874));
pub const DB_E_INTEGRITYVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217873));
pub const DB_E_BADTYPENAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217872));
pub const DB_E_ABORTLIMITREACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217871));
pub const DB_E_ROWSETINCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217870));
pub const DB_E_CANTTRANSLATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217869));
pub const DB_E_DUPLICATEINDEXID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217868));
pub const DB_E_NOINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217867));
pub const DB_E_INDEXINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217866));
pub const DB_E_NOTABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217865));
pub const DB_E_CONCURRENCYVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217864));
pub const DB_E_BADCOPY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217863));
pub const DB_E_BADPRECISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217862));
pub const DB_E_BADSCALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217861));
pub const DB_E_BADTABLEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217860));
pub const DB_E_BADID = @as(i32, -2147217860);
pub const DB_E_BADTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217859));
pub const DB_E_DUPLICATECOLUMNID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217858));
pub const DB_E_DUPLICATETABLEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217857));
pub const DB_E_TABLEINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217856));
pub const DB_E_NOLOCALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217855));
pub const DB_E_BADRECORDNUM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217854));
pub const DB_E_BOOKMARKSKIPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217853));
pub const DB_E_BADPROPERTYVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217852));
pub const DB_E_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217851));
pub const DB_E_BADACCESSORFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217850));
pub const DB_E_BADSTORAGEFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217849));
pub const DB_E_BYREFACCESSORNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217848));
pub const DB_E_NULLACCESSORNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217847));
pub const DB_E_NOTPREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217846));
pub const DB_E_BADACCESSORTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217845));
pub const DB_E_WRITEONLYACCESSOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217844));
pub const DB_SEC_E_AUTH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217843));
pub const DB_E_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217842));
pub const DB_E_CHAPTERNOTRELEASED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217841));
pub const DB_E_BADSOURCEHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217840));
pub const DB_E_PARAMUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217839));
pub const DB_E_ALREADYINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217838));
pub const DB_E_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217837));
pub const DB_E_MAXPENDCHANGESEXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217836));
pub const DB_E_BADORDINAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217835));
pub const DB_E_PENDINGCHANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217834));
pub const DB_E_DATAOVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217833));
pub const DB_E_BADHRESULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217832));
pub const DB_E_BADLOOKUPID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217831));
pub const DB_E_BADDYNAMICERRORID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217830));
pub const DB_E_PENDINGINSERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217829));
pub const DB_E_BADCONVERTFLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217828));
pub const DB_E_BADPARAMETERNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217827));
pub const DB_E_MULTIPLESTORAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217826));
pub const DB_E_CANTFILTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217825));
pub const DB_E_CANTORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217824));
pub const MD_E_BADTUPLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217823));
pub const MD_E_BADCOORDINATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217822));
pub const MD_E_INVALIDAXIS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217821));
pub const MD_E_INVALIDCELLRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217820));
pub const DB_E_NOCOLUMN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217819));
pub const DB_E_COMMANDNOTPERSISTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217817));
pub const DB_E_DUPLICATEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217816));
pub const DB_E_OBJECTCREATIONLIMITREACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217815));
pub const DB_E_BADINDEXID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217806));
pub const DB_E_BADINITSTRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217805));
pub const DB_E_NOPROVIDERSREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217804));
pub const DB_E_MISMATCHEDPROVIDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217803));
pub const DB_E_BADCOMMANDID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217802));
pub const SEC_E_PERMISSIONDENIED = @as(i32, -2147217911);
pub const SEC_E_BADTRUSTEEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217814));
pub const SEC_E_NOTRUSTEEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217813));
pub const SEC_E_NOMEMBERSHIPSUPPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217812));
pub const SEC_E_INVALIDOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217811));
pub const SEC_E_NOOWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217810));
pub const SEC_E_INVALIDACCESSENTRYLIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217809));
pub const SEC_E_INVALIDOWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217808));
pub const SEC_E_INVALIDACCESSENTRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217807));
pub const DB_E_BADCONSTRAINTTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217801));
pub const DB_E_BADCONSTRAINTFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217800));
pub const DB_E_BADDEFERRABILITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217799));
pub const DB_E_BADMATCHTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217792));
pub const DB_E_BADUPDATEDELETERULE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217782));
pub const DB_E_BADCONSTRAINTID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217781));
pub const DB_E_BADCOMMANDFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217780));
pub const DB_E_OBJECTMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217779));
pub const DB_E_NOSOURCEOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217775));
pub const DB_E_RESOURCELOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217774));
pub const DB_E_NOTCOLLECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217773));
pub const DB_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217772));
pub const DB_E_ASYNCNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217771));
pub const DB_E_CANNOTCONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217770));
pub const DB_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217769));
pub const DB_E_RESOURCEEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217768));
pub const DB_E_RESOURCEOUTOFSCOPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217778));
pub const DB_E_DROPRESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217776));
pub const DB_E_DUPLICATECONSTRAINTID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217767));
pub const DB_E_OUTOFSPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217766));
pub const DB_SEC_E_SAFEMODE_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217765));
pub const DB_E_NOSTATISTIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217764));
pub const DB_E_ALTERRESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217763));
pub const DB_E_RESOURCENOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217762));
pub const DB_E_NOCONSTRAINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217761));
pub const DB_E_COLUMNUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217760));
pub const DB_S_ROWLIMITEXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265920));
pub const DB_S_COLUMNTYPEMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265921));
pub const DB_S_TYPEINFOOVERRIDDEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265922));
pub const DB_S_BOOKMARKSKIPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265923));
pub const DB_S_NONEXTROWSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265925));
pub const DB_S_ENDOFROWSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265926));
pub const DB_S_COMMANDREEXECUTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265927));
pub const DB_S_BUFFERFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265928));
pub const DB_S_NORESULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265929));
pub const DB_S_CANTRELEASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265930));
pub const DB_S_GOALCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265931));
pub const DB_S_UNWANTEDOPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265932));
pub const DB_S_DIALECTIGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265933));
pub const DB_S_UNWANTEDPHASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265934));
pub const DB_S_UNWANTEDREASON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265935));
pub const DB_S_ASYNCHRONOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265936));
pub const DB_S_COLUMNSCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265937));
pub const DB_S_ERRORSRETURNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265938));
pub const DB_S_BADROWHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265939));
pub const DB_S_DELETEDROW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265940));
pub const DB_S_TOOMANYCHANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265941));
pub const DB_S_STOPLIMITREACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265942));
pub const DB_S_LOCKUPGRADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265944));
pub const DB_S_PROPERTIESCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265945));
pub const DB_S_ERRORSOCCURRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265946));
pub const DB_S_PARAMUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265947));
pub const DB_S_MULTIPLECHANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265948));
pub const DB_S_NOTSINGLETON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265943));
pub const DB_S_NOROWSPECIFICCOLUMNS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265949));
pub const DBPROPFLAGS_PERSIST = @as(u32, 8192);
pub const DBPROPVAL_PERSIST_ADTG = @as(u32, 0);
pub const DBPROPVAL_PERSIST_XML = @as(u32, 1);
pub const DBPROP_PersistFormat = @as(u32, 2);
pub const DBPROP_PersistSchema = @as(u32, 3);
pub const DBPROP_HCHAPTER = @as(u32, 4);
pub const DBPROP_MAINTAINPROPS = @as(u32, 5);
pub const DBPROP_Unicode = @as(u32, 6);
pub const DBPROP_INTERLEAVEDROWS = @as(u32, 8);
pub const DISPID_QUERY_RANKVECTOR = @as(u32, 2);
pub const DISPID_QUERY_RANK = @as(u32, 3);
pub const DISPID_QUERY_HITCOUNT = @as(u32, 4);
pub const DISPID_QUERY_WORKID = @as(u32, 5);
pub const DISPID_QUERY_ALL = @as(u32, 6);
pub const DISPID_QUERY_UNFILTERED = @as(u32, 7);
pub const DISPID_QUERY_REVNAME = @as(u32, 8);
pub const DISPID_QUERY_VIRTUALPATH = @as(u32, 9);
pub const DISPID_QUERY_LASTSEENTIME = @as(u32, 10);
pub const CQUERYDISPIDS = @as(u32, 11);
pub const DISPID_QUERY_METADATA_VROOTUSED = @as(u32, 2);
pub const DISPID_QUERY_METADATA_VROOTAUTOMATIC = @as(u32, 3);
pub const DISPID_QUERY_METADATA_VROOTMANUAL = @as(u32, 4);
pub const DISPID_QUERY_METADATA_PROPGUID = @as(u32, 5);
pub const DISPID_QUERY_METADATA_PROPDISPID = @as(u32, 6);
pub const DISPID_QUERY_METADATA_PROPNAME = @as(u32, 7);
pub const DISPID_QUERY_METADATA_STORELEVEL = @as(u32, 8);
pub const DISPID_QUERY_METADATA_PROPMODIFIABLE = @as(u32, 9);
pub const CQUERYMETADISPIDS = @as(u32, 10);
pub const PROPID_DBBMK_BOOKMARK = @as(u32, 2);
pub const PROPID_DBBMK_CHAPTER = @as(u32, 3);
pub const CDBBMKDISPIDS = @as(u32, 8);
pub const PROPID_DBSELF_SELF = @as(u32, 2);
pub const CDBSELFDISPIDS = @as(u32, 8);
pub const CDBCOLDISPIDS = @as(u32, 28);
pub const CQUERYPROPERTY = @as(u32, 64);
pub const QUERY_VALIDBITS = @as(u32, 3);
pub const RTNone = @as(u32, 0);
pub const RTAnd = @as(u32, 1);
pub const RTOr = @as(u32, 2);
pub const RTNot = @as(u32, 3);
pub const RTContent = @as(u32, 4);
pub const RTProperty = @as(u32, 5);
pub const RTProximity = @as(u32, 6);
pub const RTVector = @as(u32, 7);
pub const RTNatLanguage = @as(u32, 8);
pub const GENERATE_METHOD_PREFIXMATCH = @as(u32, 1);
pub const GENERATE_METHOD_STEMMED = @as(u32, 2);
pub const PRRE = @as(u32, 6);
pub const PRAllBits = @as(u32, 7);
pub const PRSomeBits = @as(u32, 8);
pub const PRAll = @as(u32, 256);
pub const PRAny = @as(u32, 512);
pub const QUERY_SORTXASCEND = @as(u32, 2);
pub const QUERY_SORTXDESCEND = @as(u32, 3);
pub const QUERY_SORTDEFAULT = @as(u32, 4);
pub const CATEGORIZE_UNIQUE = @as(u32, 0);
pub const CATEGORIZE_CLUSTER = @as(u32, 1);
pub const CATEGORIZE_BUCKETS = @as(u32, 2);
pub const BUCKET_LINEAR = @as(u32, 0);
pub const BUCKET_EXPONENTIAL = @as(u32, 1);
pub const CATEGORIZE_RANGE = @as(u32, 3);
pub const OCC_INVALID = @as(u32, 4294967295);
pub const MAX_QUERY_RANK = @as(u32, 1000);
pub const OSP_IndexLabel = @as(u32, 0);
pub const SQL_NULL_DATA = @as(i32, -1);
pub const SQL_DATA_AT_EXEC = @as(i32, -2);
pub const SQL_SUCCESS = @as(u32, 0);
pub const SQL_SUCCESS_WITH_INFO = @as(u32, 1);
pub const SQL_NO_DATA = @as(u32, 100);
pub const SQL_PARAM_DATA_AVAILABLE = @as(u32, 101);
pub const SQL_ERROR = @as(i32, -1);
pub const SQL_INVALID_HANDLE = @as(i32, -2);
pub const SQL_STILL_EXECUTING = @as(u32, 2);
pub const SQL_NEED_DATA = @as(u32, 99);
pub const SQL_NTS = @as(i32, -3);
pub const SQL_NTSL = @as(i32, -3);
pub const SQL_MAX_MESSAGE_LENGTH = @as(u32, 512);
pub const SQL_DATE_LEN = @as(u32, 10);
pub const SQL_TIME_LEN = @as(u32, 8);
pub const SQL_TIMESTAMP_LEN = @as(u32, 19);
pub const SQL_HANDLE_ENV = @as(u32, 1);
pub const SQL_HANDLE_DBC = @as(u32, 2);
pub const SQL_HANDLE_STMT = @as(u32, 3);
pub const SQL_HANDLE_DESC = @as(u32, 4);
pub const SQL_ATTR_OUTPUT_NTS = @as(u32, 10001);
pub const SQL_ATTR_AUTO_IPD = @as(u32, 10001);
pub const SQL_ATTR_METADATA_ID = @as(u32, 10014);
pub const SQL_ATTR_APP_ROW_DESC = @as(u32, 10010);
pub const SQL_ATTR_APP_PARAM_DESC = @as(u32, 10011);
pub const SQL_ATTR_IMP_ROW_DESC = @as(u32, 10012);
pub const SQL_ATTR_IMP_PARAM_DESC = @as(u32, 10013);
pub const SQL_ATTR_CURSOR_SCROLLABLE = @as(i32, -1);
pub const SQL_ATTR_CURSOR_SENSITIVITY = @as(i32, -2);
pub const SQL_NONSCROLLABLE = @as(u32, 0);
pub const SQL_SCROLLABLE = @as(u32, 1);
pub const SQL_DESC_COUNT = @as(u32, 1001);
pub const SQL_DESC_TYPE = @as(u32, 1002);
pub const SQL_DESC_LENGTH = @as(u32, 1003);
pub const SQL_DESC_OCTET_LENGTH_PTR = @as(u32, 1004);
pub const SQL_DESC_PRECISION = @as(u32, 1005);
pub const SQL_DESC_SCALE = @as(u32, 1006);
pub const SQL_DESC_DATETIME_INTERVAL_CODE = @as(u32, 1007);
pub const SQL_DESC_NULLABLE = @as(u32, 1008);
pub const SQL_DESC_INDICATOR_PTR = @as(u32, 1009);
pub const SQL_DESC_DATA_PTR = @as(u32, 1010);
pub const SQL_DESC_NAME = @as(u32, 1011);
pub const SQL_DESC_UNNAMED = @as(u32, 1012);
pub const SQL_DESC_OCTET_LENGTH = @as(u32, 1013);
pub const SQL_DESC_ALLOC_TYPE = @as(u32, 1099);
pub const SQL_DIAG_RETURNCODE = @as(u32, 1);
pub const SQL_DIAG_NUMBER = @as(u32, 2);
pub const SQL_DIAG_ROW_COUNT = @as(u32, 3);
pub const SQL_DIAG_SQLSTATE = @as(u32, 4);
pub const SQL_DIAG_NATIVE = @as(u32, 5);
pub const SQL_DIAG_MESSAGE_TEXT = @as(u32, 6);
pub const SQL_DIAG_DYNAMIC_FUNCTION = @as(u32, 7);
pub const SQL_DIAG_CLASS_ORIGIN = @as(u32, 8);
pub const SQL_DIAG_SUBCLASS_ORIGIN = @as(u32, 9);
pub const SQL_DIAG_CONNECTION_NAME = @as(u32, 10);
pub const SQL_DIAG_SERVER_NAME = @as(u32, 11);
pub const SQL_DIAG_DYNAMIC_FUNCTION_CODE = @as(u32, 12);
pub const SQL_DIAG_ALTER_DOMAIN = @as(u32, 3);
pub const SQL_DIAG_ALTER_TABLE = @as(u32, 4);
pub const SQL_DIAG_CALL = @as(u32, 7);
pub const SQL_DIAG_CREATE_ASSERTION = @as(u32, 6);
pub const SQL_DIAG_CREATE_CHARACTER_SET = @as(u32, 8);
pub const SQL_DIAG_CREATE_COLLATION = @as(u32, 10);
pub const SQL_DIAG_CREATE_DOMAIN = @as(u32, 23);
pub const SQL_DIAG_CREATE_INDEX = @as(i32, -1);
pub const SQL_DIAG_CREATE_SCHEMA = @as(u32, 64);
pub const SQL_DIAG_CREATE_TABLE = @as(u32, 77);
pub const SQL_DIAG_CREATE_TRANSLATION = @as(u32, 79);
pub const SQL_DIAG_CREATE_VIEW = @as(u32, 84);
pub const SQL_DIAG_DELETE_WHERE = @as(u32, 19);
pub const SQL_DIAG_DROP_ASSERTION = @as(u32, 24);
pub const SQL_DIAG_DROP_CHARACTER_SET = @as(u32, 25);
pub const SQL_DIAG_DROP_COLLATION = @as(u32, 26);
pub const SQL_DIAG_DROP_DOMAIN = @as(u32, 27);
pub const SQL_DIAG_DROP_INDEX = @as(i32, -2);
pub const SQL_DIAG_DROP_SCHEMA = @as(u32, 31);
pub const SQL_DIAG_DROP_TABLE = @as(u32, 32);
pub const SQL_DIAG_DROP_TRANSLATION = @as(u32, 33);
pub const SQL_DIAG_DROP_VIEW = @as(u32, 36);
pub const SQL_DIAG_DYNAMIC_DELETE_CURSOR = @as(u32, 38);
pub const SQL_DIAG_DYNAMIC_UPDATE_CURSOR = @as(u32, 81);
pub const SQL_DIAG_GRANT = @as(u32, 48);
pub const SQL_DIAG_INSERT = @as(u32, 50);
pub const SQL_DIAG_REVOKE = @as(u32, 59);
pub const SQL_DIAG_SELECT_CURSOR = @as(u32, 85);
pub const SQL_DIAG_UNKNOWN_STATEMENT = @as(u32, 0);
pub const SQL_DIAG_UPDATE_WHERE = @as(u32, 82);
pub const SQL_UNKNOWN_TYPE = @as(u32, 0);
pub const SQL_CHAR = @as(u32, 1);
pub const SQL_NUMERIC = @as(u32, 2);
pub const SQL_DECIMAL = @as(u32, 3);
pub const SQL_INTEGER = @as(u32, 4);
pub const SQL_SMALLINT = @as(u32, 5);
pub const SQL_FLOAT = @as(u32, 6);
pub const SQL_REAL = @as(u32, 7);
pub const SQL_DOUBLE = @as(u32, 8);
pub const SQL_DATETIME = @as(u32, 9);
pub const SQL_VARCHAR = @as(u32, 12);
pub const SQL_TYPE_DATE = @as(u32, 91);
pub const SQL_TYPE_TIME = @as(u32, 92);
pub const SQL_TYPE_TIMESTAMP = @as(u32, 93);
pub const SQL_UNSPECIFIED = @as(u32, 0);
pub const SQL_INSENSITIVE = @as(u32, 1);
pub const SQL_SENSITIVE = @as(u32, 2);
pub const SQL_ALL_TYPES = @as(u32, 0);
pub const SQL_DEFAULT = @as(u32, 99);
pub const SQL_ARD_TYPE = @as(i32, -99);
pub const SQL_APD_TYPE = @as(i32, -100);
pub const SQL_CODE_DATE = @as(u32, 1);
pub const SQL_CODE_TIME = @as(u32, 2);
pub const SQL_CODE_TIMESTAMP = @as(u32, 3);
pub const SQL_FALSE = @as(u32, 0);
pub const SQL_TRUE = @as(u32, 1);
pub const SQL_NO_NULLS = @as(u32, 0);
pub const SQL_NULLABLE = @as(u32, 1);
pub const SQL_NULLABLE_UNKNOWN = @as(u32, 2);
pub const SQL_PRED_NONE = @as(u32, 0);
pub const SQL_PRED_CHAR = @as(u32, 1);
pub const SQL_PRED_BASIC = @as(u32, 2);
pub const SQL_NAMED = @as(u32, 0);
pub const SQL_UNNAMED = @as(u32, 1);
pub const SQL_DESC_ALLOC_AUTO = @as(u32, 1);
pub const SQL_DESC_ALLOC_USER = @as(u32, 2);
pub const SQL_CLOSE = @as(u32, 0);
pub const SQL_DROP = @as(u32, 1);
pub const SQL_UNBIND = @as(u32, 2);
pub const SQL_RESET_PARAMS = @as(u32, 3);
pub const SQL_FETCH_NEXT = @as(u32, 1);
pub const SQL_FETCH_FIRST = @as(u32, 2);
pub const SQL_FETCH_LAST = @as(u32, 3);
pub const SQL_FETCH_PRIOR = @as(u32, 4);
pub const SQL_FETCH_ABSOLUTE = @as(u32, 5);
pub const SQL_FETCH_RELATIVE = @as(u32, 6);
pub const SQL_COMMIT = @as(u32, 0);
pub const SQL_ROLLBACK = @as(u32, 1);
pub const SQL_NULL_HENV = @as(u32, 0);
pub const SQL_NULL_HDBC = @as(u32, 0);
pub const SQL_NULL_HSTMT = @as(u32, 0);
pub const SQL_NULL_HDESC = @as(u32, 0);
pub const SQL_NULL_HANDLE = @as(i32, 0);
pub const SQL_SCOPE_CURROW = @as(u32, 0);
pub const SQL_SCOPE_TRANSACTION = @as(u32, 1);
pub const SQL_SCOPE_SESSION = @as(u32, 2);
pub const SQL_PC_UNKNOWN = @as(u32, 0);
pub const SQL_PC_NON_PSEUDO = @as(u32, 1);
pub const SQL_PC_PSEUDO = @as(u32, 2);
pub const SQL_ROW_IDENTIFIER = @as(u32, 1);
pub const SQL_INDEX_UNIQUE = @as(u32, 0);
pub const SQL_INDEX_ALL = @as(u32, 1);
pub const SQL_INDEX_CLUSTERED = @as(u32, 1);
pub const SQL_INDEX_HASHED = @as(u32, 2);
pub const SQL_INDEX_OTHER = @as(u32, 3);
pub const SQL_API_SQLALLOCCONNECT = @as(u32, 1);
pub const SQL_API_SQLALLOCENV = @as(u32, 2);
pub const SQL_API_SQLALLOCHANDLE = @as(u32, 1001);
pub const SQL_API_SQLALLOCSTMT = @as(u32, 3);
pub const SQL_API_SQLBINDCOL = @as(u32, 4);
pub const SQL_API_SQLBINDPARAM = @as(u32, 1002);
pub const SQL_API_SQLCANCEL = @as(u32, 5);
pub const SQL_API_SQLCLOSECURSOR = @as(u32, 1003);
pub const SQL_API_SQLCOLATTRIBUTE = @as(u32, 6);
pub const SQL_API_SQLCOLUMNS = @as(u32, 40);
pub const SQL_API_SQLCONNECT = @as(u32, 7);
pub const SQL_API_SQLCOPYDESC = @as(u32, 1004);
pub const SQL_API_SQLDATASOURCES = @as(u32, 57);
pub const SQL_API_SQLDESCRIBECOL = @as(u32, 8);
pub const SQL_API_SQLDISCONNECT = @as(u32, 9);
pub const SQL_API_SQLENDTRAN = @as(u32, 1005);
pub const SQL_API_SQLERROR = @as(u32, 10);
pub const SQL_API_SQLEXECDIRECT = @as(u32, 11);
pub const SQL_API_SQLEXECUTE = @as(u32, 12);
pub const SQL_API_SQLFETCH = @as(u32, 13);
pub const SQL_API_SQLFETCHSCROLL = @as(u32, 1021);
pub const SQL_API_SQLFREECONNECT = @as(u32, 14);
pub const SQL_API_SQLFREEENV = @as(u32, 15);
pub const SQL_API_SQLFREEHANDLE = @as(u32, 1006);
pub const SQL_API_SQLFREESTMT = @as(u32, 16);
pub const SQL_API_SQLGETCONNECTATTR = @as(u32, 1007);
pub const SQL_API_SQLGETCONNECTOPTION = @as(u32, 42);
pub const SQL_API_SQLGETCURSORNAME = @as(u32, 17);
pub const SQL_API_SQLGETDATA = @as(u32, 43);
pub const SQL_API_SQLGETDESCFIELD = @as(u32, 1008);
pub const SQL_API_SQLGETDESCREC = @as(u32, 1009);
pub const SQL_API_SQLGETDIAGFIELD = @as(u32, 1010);
pub const SQL_API_SQLGETDIAGREC = @as(u32, 1011);
pub const SQL_API_SQLGETENVATTR = @as(u32, 1012);
pub const SQL_API_SQLGETFUNCTIONS = @as(u32, 44);
pub const SQL_API_SQLGETINFO = @as(u32, 45);
pub const SQL_API_SQLGETSTMTATTR = @as(u32, 1014);
pub const SQL_API_SQLGETSTMTOPTION = @as(u32, 46);
pub const SQL_API_SQLGETTYPEINFO = @as(u32, 47);
pub const SQL_API_SQLNUMRESULTCOLS = @as(u32, 18);
pub const SQL_API_SQLPARAMDATA = @as(u32, 48);
pub const SQL_API_SQLPREPARE = @as(u32, 19);
pub const SQL_API_SQLPUTDATA = @as(u32, 49);
pub const SQL_API_SQLROWCOUNT = @as(u32, 20);
pub const SQL_API_SQLSETCONNECTATTR = @as(u32, 1016);
pub const SQL_API_SQLSETCONNECTOPTION = @as(u32, 50);
pub const SQL_API_SQLSETCURSORNAME = @as(u32, 21);
pub const SQL_API_SQLSETDESCFIELD = @as(u32, 1017);
pub const SQL_API_SQLSETDESCREC = @as(u32, 1018);
pub const SQL_API_SQLSETENVATTR = @as(u32, 1019);
pub const SQL_API_SQLSETPARAM = @as(u32, 22);
pub const SQL_API_SQLSETSTMTATTR = @as(u32, 1020);
pub const SQL_API_SQLSETSTMTOPTION = @as(u32, 51);
pub const SQL_API_SQLSPECIALCOLUMNS = @as(u32, 52);
pub const SQL_API_SQLSTATISTICS = @as(u32, 53);
pub const SQL_API_SQLTABLES = @as(u32, 54);
pub const SQL_API_SQLTRANSACT = @as(u32, 23);
pub const SQL_API_SQLCANCELHANDLE = @as(u32, 1550);
pub const SQL_API_SQLCOMPLETEASYNC = @as(u32, 1551);
pub const SQL_MAX_DRIVER_CONNECTIONS = @as(u32, 0);
pub const SQL_MAXIMUM_DRIVER_CONNECTIONS = @as(u32, 0);
pub const SQL_MAX_CONCURRENT_ACTIVITIES = @as(u32, 1);
pub const SQL_MAXIMUM_CONCURRENT_ACTIVITIES = @as(u32, 1);
pub const SQL_DATA_SOURCE_NAME = @as(u32, 2);
pub const SQL_FETCH_DIRECTION = @as(u32, 8);
pub const SQL_SERVER_NAME = @as(u32, 13);
pub const SQL_SEARCH_PATTERN_ESCAPE = @as(u32, 14);
pub const SQL_DBMS_NAME = @as(u32, 17);
pub const SQL_DBMS_VER = @as(u32, 18);
pub const SQL_ACCESSIBLE_TABLES = @as(u32, 19);
pub const SQL_ACCESSIBLE_PROCEDURES = @as(u32, 20);
pub const SQL_CURSOR_COMMIT_BEHAVIOR = @as(u32, 23);
pub const SQL_DATA_SOURCE_READ_ONLY = @as(u32, 25);
pub const SQL_DEFAULT_TXN_ISOLATION = @as(u32, 26);
pub const SQL_IDENTIFIER_CASE = @as(u32, 28);
pub const SQL_IDENTIFIER_QUOTE_CHAR = @as(u32, 29);
pub const SQL_MAX_COLUMN_NAME_LEN = @as(u32, 30);
pub const SQL_MAXIMUM_COLUMN_NAME_LENGTH = @as(u32, 30);
pub const SQL_MAX_CURSOR_NAME_LEN = @as(u32, 31);
pub const SQL_MAXIMUM_CURSOR_NAME_LENGTH = @as(u32, 31);
pub const SQL_MAX_SCHEMA_NAME_LEN = @as(u32, 32);
pub const SQL_MAXIMUM_SCHEMA_NAME_LENGTH = @as(u32, 32);
pub const SQL_MAX_CATALOG_NAME_LEN = @as(u32, 34);
pub const SQL_MAXIMUM_CATALOG_NAME_LENGTH = @as(u32, 34);
pub const SQL_MAX_TABLE_NAME_LEN = @as(u32, 35);
pub const SQL_SCROLL_CONCURRENCY = @as(u32, 43);
pub const SQL_TXN_CAPABLE = @as(u32, 46);
pub const SQL_TRANSACTION_CAPABLE = @as(u32, 46);
pub const SQL_USER_NAME = @as(u32, 47);
pub const SQL_TXN_ISOLATION_OPTION = @as(u32, 72);
pub const SQL_TRANSACTION_ISOLATION_OPTION = @as(u32, 72);
pub const SQL_INTEGRITY = @as(u32, 73);
pub const SQL_GETDATA_EXTENSIONS = @as(u32, 81);
pub const SQL_NULL_COLLATION = @as(u32, 85);
pub const SQL_ALTER_TABLE = @as(u32, 86);
pub const SQL_ORDER_BY_COLUMNS_IN_SELECT = @as(u32, 90);
pub const SQL_SPECIAL_CHARACTERS = @as(u32, 94);
pub const SQL_MAX_COLUMNS_IN_GROUP_BY = @as(u32, 97);
pub const SQL_MAXIMUM_COLUMNS_IN_GROUP_BY = @as(u32, 97);
pub const SQL_MAX_COLUMNS_IN_INDEX = @as(u32, 98);
pub const SQL_MAXIMUM_COLUMNS_IN_INDEX = @as(u32, 98);
pub const SQL_MAX_COLUMNS_IN_ORDER_BY = @as(u32, 99);
pub const SQL_MAXIMUM_COLUMNS_IN_ORDER_BY = @as(u32, 99);
pub const SQL_MAX_COLUMNS_IN_SELECT = @as(u32, 100);
pub const SQL_MAXIMUM_COLUMNS_IN_SELECT = @as(u32, 100);
pub const SQL_MAX_COLUMNS_IN_TABLE = @as(u32, 101);
pub const SQL_MAX_INDEX_SIZE = @as(u32, 102);
pub const SQL_MAXIMUM_INDEX_SIZE = @as(u32, 102);
pub const SQL_MAX_ROW_SIZE = @as(u32, 104);
pub const SQL_MAXIMUM_ROW_SIZE = @as(u32, 104);
pub const SQL_MAX_STATEMENT_LEN = @as(u32, 105);
pub const SQL_MAXIMUM_STATEMENT_LENGTH = @as(u32, 105);
pub const SQL_MAX_TABLES_IN_SELECT = @as(u32, 106);
pub const SQL_MAXIMUM_TABLES_IN_SELECT = @as(u32, 106);
pub const SQL_MAX_USER_NAME_LEN = @as(u32, 107);
pub const SQL_MAXIMUM_USER_NAME_LENGTH = @as(u32, 107);
pub const SQL_OJ_CAPABILITIES = @as(u32, 115);
pub const SQL_OUTER_JOIN_CAPABILITIES = @as(u32, 115);
pub const SQL_XOPEN_CLI_YEAR = @as(u32, 10000);
pub const SQL_CURSOR_SENSITIVITY = @as(u32, 10001);
pub const SQL_DESCRIBE_PARAMETER = @as(u32, 10002);
pub const SQL_CATALOG_NAME = @as(u32, 10003);
pub const SQL_COLLATION_SEQ = @as(u32, 10004);
pub const SQL_MAX_IDENTIFIER_LEN = @as(u32, 10005);
pub const SQL_MAXIMUM_IDENTIFIER_LENGTH = @as(u32, 10005);
pub const SQL_AT_ADD_COLUMN = @as(i32, 1);
pub const SQL_AT_DROP_COLUMN = @as(i32, 2);
pub const SQL_AT_ADD_CONSTRAINT = @as(i32, 8);
pub const SQL_AM_NONE = @as(u32, 0);
pub const SQL_AM_CONNECTION = @as(u32, 1);
pub const SQL_AM_STATEMENT = @as(u32, 2);
pub const SQL_CB_DELETE = @as(u32, 0);
pub const SQL_CB_CLOSE = @as(u32, 1);
pub const SQL_CB_PRESERVE = @as(u32, 2);
pub const SQL_FD_FETCH_NEXT = @as(i32, 1);
pub const SQL_FD_FETCH_FIRST = @as(i32, 2);
pub const SQL_FD_FETCH_LAST = @as(i32, 4);
pub const SQL_FD_FETCH_PRIOR = @as(i32, 8);
pub const SQL_FD_FETCH_ABSOLUTE = @as(i32, 16);
pub const SQL_FD_FETCH_RELATIVE = @as(i32, 32);
pub const SQL_GD_ANY_COLUMN = @as(i32, 1);
pub const SQL_GD_ANY_ORDER = @as(i32, 2);
pub const SQL_IC_UPPER = @as(u32, 1);
pub const SQL_IC_LOWER = @as(u32, 2);
pub const SQL_IC_SENSITIVE = @as(u32, 3);
pub const SQL_IC_MIXED = @as(u32, 4);
pub const SQL_OJ_LEFT = @as(i32, 1);
pub const SQL_OJ_RIGHT = @as(i32, 2);
pub const SQL_OJ_FULL = @as(i32, 4);
pub const SQL_OJ_NESTED = @as(i32, 8);
pub const SQL_OJ_NOT_ORDERED = @as(i32, 16);
pub const SQL_OJ_INNER = @as(i32, 32);
pub const SQL_OJ_ALL_COMPARISON_OPS = @as(i32, 64);
pub const SQL_SCCO_READ_ONLY = @as(i32, 1);
pub const SQL_SCCO_LOCK = @as(i32, 2);
pub const SQL_SCCO_OPT_ROWVER = @as(i32, 4);
pub const SQL_SCCO_OPT_VALUES = @as(i32, 8);
pub const SQL_TC_NONE = @as(u32, 0);
pub const SQL_TC_DML = @as(u32, 1);
pub const SQL_TC_ALL = @as(u32, 2);
pub const SQL_TC_DDL_COMMIT = @as(u32, 3);
pub const SQL_TC_DDL_IGNORE = @as(u32, 4);
pub const SQL_TXN_READ_UNCOMMITTED = @as(i32, 1);
pub const SQL_TRANSACTION_READ_UNCOMMITTED = @as(i32, 1);
pub const SQL_TXN_READ_COMMITTED = @as(i32, 2);
pub const SQL_TRANSACTION_READ_COMMITTED = @as(i32, 2);
pub const SQL_TXN_REPEATABLE_READ = @as(i32, 4);
pub const SQL_TRANSACTION_REPEATABLE_READ = @as(i32, 4);
pub const SQL_TXN_SERIALIZABLE = @as(i32, 8);
pub const SQL_TRANSACTION_SERIALIZABLE = @as(i32, 8);
pub const SQL_NC_HIGH = @as(u32, 0);
pub const SQL_NC_LOW = @as(u32, 1);
pub const SQL_SPEC_MAJOR = @as(u32, 3);
pub const SQL_SPEC_MINOR = @as(u32, 80);
pub const SQL_SQLSTATE_SIZE = @as(u32, 5);
pub const SQL_MAX_DSN_LENGTH = @as(u32, 32);
pub const SQL_MAX_OPTION_STRING_LENGTH = @as(u32, 256);
pub const SQL_NO_DATA_FOUND = @as(u32, 100);
pub const SQL_HANDLE_SENV = @as(u32, 5);
pub const SQL_ATTR_ODBC_VERSION = @as(u32, 200);
pub const SQL_ATTR_CONNECTION_POOLING = @as(u32, 201);
pub const SQL_ATTR_CP_MATCH = @as(u32, 202);
pub const SQL_ATTR_APPLICATION_KEY = @as(u32, 203);
pub const SQL_CP_OFF = @as(u32, 0);
pub const SQL_CP_ONE_PER_DRIVER = @as(u32, 1);
pub const SQL_CP_ONE_PER_HENV = @as(u32, 2);
pub const SQL_CP_DRIVER_AWARE = @as(u32, 3);
pub const SQL_CP_DEFAULT = @as(u32, 0);
pub const SQL_CP_STRICT_MATCH = @as(u32, 0);
pub const SQL_CP_RELAXED_MATCH = @as(u32, 1);
pub const SQL_CP_MATCH_DEFAULT = @as(u32, 0);
pub const SQL_OV_ODBC2 = @as(u32, 2);
pub const SQL_OV_ODBC3 = @as(u32, 3);
pub const SQL_OV_ODBC3_80 = @as(u32, 380);
pub const SQL_ACCESS_MODE = @as(u32, 101);
pub const SQL_AUTOCOMMIT = @as(u32, 102);
pub const SQL_LOGIN_TIMEOUT = @as(u32, 103);
pub const SQL_OPT_TRACE = @as(u32, 104);
pub const SQL_OPT_TRACEFILE = @as(u32, 105);
pub const SQL_TRANSLATE_DLL = @as(u32, 106);
pub const SQL_TRANSLATE_OPTION = @as(u32, 107);
pub const SQL_TXN_ISOLATION = @as(u32, 108);
pub const SQL_CURRENT_QUALIFIER = @as(u32, 109);
pub const SQL_ODBC_CURSORS = @as(u32, 110);
pub const SQL_QUIET_MODE = @as(u32, 111);
pub const SQL_PACKET_SIZE = @as(u32, 112);
pub const SQL_ATTR_ACCESS_MODE = @as(u32, 101);
pub const SQL_ATTR_AUTOCOMMIT = @as(u32, 102);
pub const SQL_ATTR_CONNECTION_TIMEOUT = @as(u32, 113);
pub const SQL_ATTR_CURRENT_CATALOG = @as(u32, 109);
pub const SQL_ATTR_DISCONNECT_BEHAVIOR = @as(u32, 114);
pub const SQL_ATTR_ENLIST_IN_DTC = @as(u32, 1207);
pub const SQL_ATTR_ENLIST_IN_XA = @as(u32, 1208);
pub const SQL_ATTR_LOGIN_TIMEOUT = @as(u32, 103);
pub const SQL_ATTR_ODBC_CURSORS = @as(u32, 110);
pub const SQL_ATTR_PACKET_SIZE = @as(u32, 112);
pub const SQL_ATTR_QUIET_MODE = @as(u32, 111);
pub const SQL_ATTR_TRACE = @as(u32, 104);
pub const SQL_ATTR_TRACEFILE = @as(u32, 105);
pub const SQL_ATTR_TRANSLATE_LIB = @as(u32, 106);
pub const SQL_ATTR_TRANSLATE_OPTION = @as(u32, 107);
pub const SQL_ATTR_TXN_ISOLATION = @as(u32, 108);
pub const SQL_ATTR_CONNECTION_DEAD = @as(u32, 1209);
pub const SQL_ATTR_ANSI_APP = @as(u32, 115);
pub const SQL_ATTR_RESET_CONNECTION = @as(u32, 116);
pub const SQL_ATTR_ASYNC_DBC_FUNCTIONS_ENABLE = @as(u32, 117);
pub const SQL_ATTR_ASYNC_DBC_EVENT = @as(u32, 119);
pub const SQL_CONNECT_OPT_DRVR_START = @as(u32, 1000);
pub const SQL_CONN_OPT_MAX = @as(u32, 112);
pub const SQL_CONN_OPT_MIN = @as(u32, 101);
pub const SQL_MODE_READ_WRITE = @as(u32, 0);
pub const SQL_MODE_READ_ONLY = @as(u32, 1);
pub const SQL_MODE_DEFAULT = @as(u32, 0);
pub const SQL_AUTOCOMMIT_OFF = @as(u32, 0);
pub const SQL_AUTOCOMMIT_ON = @as(u32, 1);
pub const SQL_AUTOCOMMIT_DEFAULT = @as(u32, 1);
pub const SQL_LOGIN_TIMEOUT_DEFAULT = @as(u32, 15);
pub const SQL_OPT_TRACE_OFF = @as(u32, 0);
pub const SQL_OPT_TRACE_ON = @as(u32, 1);
pub const SQL_OPT_TRACE_DEFAULT = @as(u32, 0);
pub const SQL_CUR_USE_IF_NEEDED = @as(u32, 0);
pub const SQL_CUR_USE_ODBC = @as(u32, 1);
pub const SQL_CUR_USE_DRIVER = @as(u32, 2);
pub const SQL_CUR_DEFAULT = @as(u32, 2);
pub const SQL_DB_RETURN_TO_POOL = @as(u32, 0);
pub const SQL_DB_DISCONNECT = @as(u32, 1);
pub const SQL_DB_DEFAULT = @as(u32, 0);
pub const SQL_DTC_DONE = @as(i32, 0);
pub const SQL_CD_TRUE = @as(i32, 1);
pub const SQL_CD_FALSE = @as(i32, 0);
pub const SQL_AA_TRUE = @as(i32, 1);
pub const SQL_AA_FALSE = @as(i32, 0);
pub const SQL_RESET_CONNECTION_YES = @as(u32, 1);
pub const SQL_ASYNC_DBC_ENABLE_ON = @as(u32, 1);
pub const SQL_ASYNC_DBC_ENABLE_OFF = @as(u32, 0);
pub const SQL_ASYNC_DBC_ENABLE_DEFAULT = @as(u32, 0);
pub const SQL_QUERY_TIMEOUT = @as(u32, 0);
pub const SQL_MAX_ROWS = @as(u32, 1);
pub const SQL_NOSCAN = @as(u32, 2);
pub const SQL_MAX_LENGTH = @as(u32, 3);
pub const SQL_ASYNC_ENABLE = @as(u32, 4);
pub const SQL_BIND_TYPE = @as(u32, 5);
pub const SQL_CURSOR_TYPE = @as(u32, 6);
pub const SQL_CONCURRENCY = @as(u32, 7);
pub const SQL_KEYSET_SIZE = @as(u32, 8);
pub const SQL_ROWSET_SIZE = @as(u32, 9);
pub const SQL_SIMULATE_CURSOR = @as(u32, 10);
pub const SQL_RETRIEVE_DATA = @as(u32, 11);
pub const SQL_USE_BOOKMARKS = @as(u32, 12);
pub const SQL_GET_BOOKMARK = @as(u32, 13);
pub const SQL_ROW_NUMBER = @as(u32, 14);
pub const SQL_ATTR_ASYNC_ENABLE = @as(u32, 4);
pub const SQL_ATTR_CONCURRENCY = @as(u32, 7);
pub const SQL_ATTR_CURSOR_TYPE = @as(u32, 6);
pub const SQL_ATTR_ENABLE_AUTO_IPD = @as(u32, 15);
pub const SQL_ATTR_FETCH_BOOKMARK_PTR = @as(u32, 16);
pub const SQL_ATTR_KEYSET_SIZE = @as(u32, 8);
pub const SQL_ATTR_MAX_LENGTH = @as(u32, 3);
pub const SQL_ATTR_MAX_ROWS = @as(u32, 1);
pub const SQL_ATTR_NOSCAN = @as(u32, 2);
pub const SQL_ATTR_PARAM_BIND_OFFSET_PTR = @as(u32, 17);
pub const SQL_ATTR_PARAM_BIND_TYPE = @as(u32, 18);
pub const SQL_ATTR_PARAM_OPERATION_PTR = @as(u32, 19);
pub const SQL_ATTR_PARAM_STATUS_PTR = @as(u32, 20);
pub const SQL_ATTR_PARAMS_PROCESSED_PTR = @as(u32, 21);
pub const SQL_ATTR_PARAMSET_SIZE = @as(u32, 22);
pub const SQL_ATTR_QUERY_TIMEOUT = @as(u32, 0);
pub const SQL_ATTR_RETRIEVE_DATA = @as(u32, 11);
pub const SQL_ATTR_ROW_BIND_OFFSET_PTR = @as(u32, 23);
pub const SQL_ATTR_ROW_BIND_TYPE = @as(u32, 5);
pub const SQL_ATTR_ROW_NUMBER = @as(u32, 14);
pub const SQL_ATTR_ROW_OPERATION_PTR = @as(u32, 24);
pub const SQL_ATTR_ROW_STATUS_PTR = @as(u32, 25);
pub const SQL_ATTR_ROWS_FETCHED_PTR = @as(u32, 26);
pub const SQL_ATTR_ROW_ARRAY_SIZE = @as(u32, 27);
pub const SQL_ATTR_SIMULATE_CURSOR = @as(u32, 10);
pub const SQL_ATTR_USE_BOOKMARKS = @as(u32, 12);
pub const SQL_ATTR_ASYNC_STMT_EVENT = @as(u32, 29);
pub const SQL_STMT_OPT_MAX = @as(u32, 14);
pub const SQL_STMT_OPT_MIN = @as(u32, 0);
pub const SQL_IS_POINTER = @as(i32, -4);
pub const SQL_IS_UINTEGER = @as(i32, -5);
pub const SQL_IS_INTEGER = @as(i32, -6);
pub const SQL_IS_USMALLINT = @as(i32, -7);
pub const SQL_IS_SMALLINT = @as(i32, -8);
pub const SQL_PARAM_BIND_BY_COLUMN = @as(u32, 0);
pub const SQL_PARAM_BIND_TYPE_DEFAULT = @as(u32, 0);
pub const SQL_QUERY_TIMEOUT_DEFAULT = @as(u32, 0);
pub const SQL_MAX_ROWS_DEFAULT = @as(u32, 0);
pub const SQL_NOSCAN_OFF = @as(u32, 0);
pub const SQL_NOSCAN_ON = @as(u32, 1);
pub const SQL_NOSCAN_DEFAULT = @as(u32, 0);
pub const SQL_MAX_LENGTH_DEFAULT = @as(u32, 0);
pub const SQL_ASYNC_ENABLE_OFF = @as(u32, 0);
pub const SQL_ASYNC_ENABLE_ON = @as(u32, 1);
pub const SQL_ASYNC_ENABLE_DEFAULT = @as(u32, 0);
pub const SQL_BIND_BY_COLUMN = @as(u32, 0);
pub const SQL_BIND_TYPE_DEFAULT = @as(u32, 0);
pub const SQL_CONCUR_READ_ONLY = @as(u32, 1);
pub const SQL_CONCUR_LOCK = @as(u32, 2);
pub const SQL_CONCUR_ROWVER = @as(u32, 3);
pub const SQL_CONCUR_VALUES = @as(u32, 4);
pub const SQL_CONCUR_DEFAULT = @as(u32, 1);
pub const SQL_CURSOR_FORWARD_ONLY = @as(u32, 0);
pub const SQL_CURSOR_KEYSET_DRIVEN = @as(u32, 1);
pub const SQL_CURSOR_DYNAMIC = @as(u32, 2);
pub const SQL_CURSOR_STATIC = @as(u32, 3);
pub const SQL_CURSOR_TYPE_DEFAULT = @as(u32, 0);
pub const SQL_ROWSET_SIZE_DEFAULT = @as(u32, 1);
pub const SQL_KEYSET_SIZE_DEFAULT = @as(u32, 0);
pub const SQL_SC_NON_UNIQUE = @as(u32, 0);
pub const SQL_SC_TRY_UNIQUE = @as(u32, 1);
pub const SQL_SC_UNIQUE = @as(u32, 2);
pub const SQL_RD_OFF = @as(u32, 0);
pub const SQL_RD_ON = @as(u32, 1);
pub const SQL_RD_DEFAULT = @as(u32, 1);
pub const SQL_UB_OFF = @as(u32, 0);
pub const SQL_UB_ON = @as(u32, 1);
pub const SQL_UB_DEFAULT = @as(u32, 0);
pub const SQL_UB_FIXED = @as(u32, 1);
pub const SQL_UB_VARIABLE = @as(u32, 2);
pub const SQL_DESC_ARRAY_SIZE = @as(u32, 20);
pub const SQL_DESC_ARRAY_STATUS_PTR = @as(u32, 21);
pub const SQL_DESC_BASE_COLUMN_NAME = @as(u32, 22);
pub const SQL_DESC_BASE_TABLE_NAME = @as(u32, 23);
pub const SQL_DESC_BIND_OFFSET_PTR = @as(u32, 24);
pub const SQL_DESC_BIND_TYPE = @as(u32, 25);
pub const SQL_DESC_DATETIME_INTERVAL_PRECISION = @as(u32, 26);
pub const SQL_DESC_LITERAL_PREFIX = @as(u32, 27);
pub const SQL_DESC_LITERAL_SUFFIX = @as(u32, 28);
pub const SQL_DESC_LOCAL_TYPE_NAME = @as(u32, 29);
pub const SQL_DESC_MAXIMUM_SCALE = @as(u32, 30);
pub const SQL_DESC_MINIMUM_SCALE = @as(u32, 31);
pub const SQL_DESC_NUM_PREC_RADIX = @as(u32, 32);
pub const SQL_DESC_PARAMETER_TYPE = @as(u32, 33);
pub const SQL_DESC_ROWS_PROCESSED_PTR = @as(u32, 34);
pub const SQL_DESC_ROWVER = @as(u32, 35);
pub const SQL_DIAG_CURSOR_ROW_COUNT = @as(i32, -1249);
pub const SQL_DIAG_ROW_NUMBER = @as(i32, -1248);
pub const SQL_DIAG_COLUMN_NUMBER = @as(i32, -1247);
pub const SQL_DATE = @as(u32, 9);
pub const SQL_INTERVAL = @as(u32, 10);
pub const SQL_TIME = @as(u32, 10);
pub const SQL_TIMESTAMP = @as(u32, 11);
pub const SQL_LONGVARCHAR = @as(i32, -1);
pub const SQL_BINARY = @as(i32, -2);
pub const SQL_VARBINARY = @as(i32, -3);
pub const SQL_LONGVARBINARY = @as(i32, -4);
pub const SQL_BIGINT = @as(i32, -5);
pub const SQL_TINYINT = @as(i32, -6);
pub const SQL_BIT = @as(i32, -7);
pub const SQL_GUID = @as(i32, -11);
pub const SQL_CODE_YEAR = @as(u32, 1);
pub const SQL_CODE_MONTH = @as(u32, 2);
pub const SQL_CODE_DAY = @as(u32, 3);
pub const SQL_CODE_HOUR = @as(u32, 4);
pub const SQL_CODE_MINUTE = @as(u32, 5);
pub const SQL_CODE_SECOND = @as(u32, 6);
pub const SQL_CODE_YEAR_TO_MONTH = @as(u32, 7);
pub const SQL_CODE_DAY_TO_HOUR = @as(u32, 8);
pub const SQL_CODE_DAY_TO_MINUTE = @as(u32, 9);
pub const SQL_CODE_DAY_TO_SECOND = @as(u32, 10);
pub const SQL_CODE_HOUR_TO_MINUTE = @as(u32, 11);
pub const SQL_CODE_HOUR_TO_SECOND = @as(u32, 12);
pub const SQL_CODE_MINUTE_TO_SECOND = @as(u32, 13);
pub const SQL_INTERVAL_YEAR = @as(i32, -80);
pub const SQL_INTERVAL_MONTH = @as(i32, -81);
pub const SQL_INTERVAL_YEAR_TO_MONTH = @as(i32, -82);
pub const SQL_INTERVAL_DAY = @as(i32, -83);
pub const SQL_INTERVAL_HOUR = @as(i32, -84);
pub const SQL_INTERVAL_MINUTE = @as(i32, -85);
pub const SQL_INTERVAL_SECOND = @as(i32, -86);
pub const SQL_INTERVAL_DAY_TO_HOUR = @as(i32, -87);
pub const SQL_INTERVAL_DAY_TO_MINUTE = @as(i32, -88);
pub const SQL_INTERVAL_DAY_TO_SECOND = @as(i32, -89);
pub const SQL_INTERVAL_HOUR_TO_MINUTE = @as(i32, -90);
pub const SQL_INTERVAL_HOUR_TO_SECOND = @as(i32, -91);
pub const SQL_INTERVAL_MINUTE_TO_SECOND = @as(i32, -92);
pub const SQL_UNICODE = @as(i32, -95);
pub const SQL_UNICODE_VARCHAR = @as(i32, -96);
pub const SQL_UNICODE_LONGVARCHAR = @as(i32, -97);
pub const SQL_UNICODE_CHAR = @as(i32, -95);
pub const SQL_TYPE_DRIVER_START = @as(i32, -80);
pub const SQL_TYPE_DRIVER_END = @as(i32, -97);
pub const SQL_C_CHAR = @as(u32, 1);
pub const SQL_C_LONG = @as(u32, 4);
pub const SQL_C_SHORT = @as(u32, 5);
pub const SQL_C_FLOAT = @as(u32, 7);
pub const SQL_C_DOUBLE = @as(u32, 8);
pub const SQL_C_NUMERIC = @as(u32, 2);
pub const SQL_C_DEFAULT = @as(u32, 99);
pub const SQL_SIGNED_OFFSET = @as(i32, -20);
pub const SQL_UNSIGNED_OFFSET = @as(i32, -22);
pub const SQL_C_DATE = @as(u32, 9);
pub const SQL_C_TIME = @as(u32, 10);
pub const SQL_C_TIMESTAMP = @as(u32, 11);
pub const SQL_C_TYPE_DATE = @as(u32, 91);
pub const SQL_C_TYPE_TIME = @as(u32, 92);
pub const SQL_C_TYPE_TIMESTAMP = @as(u32, 93);
pub const SQL_C_INTERVAL_YEAR = @as(i32, -80);
pub const SQL_C_INTERVAL_MONTH = @as(i32, -81);
pub const SQL_C_INTERVAL_DAY = @as(i32, -83);
pub const SQL_C_INTERVAL_HOUR = @as(i32, -84);
pub const SQL_C_INTERVAL_MINUTE = @as(i32, -85);
pub const SQL_C_INTERVAL_SECOND = @as(i32, -86);
pub const SQL_C_INTERVAL_YEAR_TO_MONTH = @as(i32, -82);
pub const SQL_C_INTERVAL_DAY_TO_HOUR = @as(i32, -87);
pub const SQL_C_INTERVAL_DAY_TO_MINUTE = @as(i32, -88);
pub const SQL_C_INTERVAL_DAY_TO_SECOND = @as(i32, -89);
pub const SQL_C_INTERVAL_HOUR_TO_MINUTE = @as(i32, -90);
pub const SQL_C_INTERVAL_HOUR_TO_SECOND = @as(i32, -91);
pub const SQL_C_INTERVAL_MINUTE_TO_SECOND = @as(i32, -92);
pub const SQL_C_BINARY = @as(i32, -2);
pub const SQL_C_BIT = @as(i32, -7);
pub const SQL_C_TINYINT = @as(i32, -6);
pub const SQL_C_GUID = @as(i32, -11);
pub const SQL_TYPE_NULL = @as(u32, 0);
pub const SQL_TYPE_MIN = @as(i32, -7);
pub const SQL_TYPE_MAX = @as(u32, 12);
pub const SQL_DRIVER_C_TYPE_BASE = @as(u32, 16384);
pub const SQL_DRIVER_SQL_TYPE_BASE = @as(u32, 16384);
pub const SQL_DRIVER_DESC_FIELD_BASE = @as(u32, 16384);
pub const SQL_DRIVER_DIAG_FIELD_BASE = @as(u32, 16384);
pub const SQL_DRIVER_INFO_TYPE_BASE = @as(u32, 16384);
pub const SQL_DRIVER_CONN_ATTR_BASE = @as(u32, 16384);
pub const SQL_DRIVER_STMT_ATTR_BASE = @as(u32, 16384);
pub const SQL_C_VARBOOKMARK = @as(i32, -2);
pub const SQL_NO_ROW_NUMBER = @as(i32, -1);
pub const SQL_NO_COLUMN_NUMBER = @as(i32, -1);
pub const SQL_ROW_NUMBER_UNKNOWN = @as(i32, -2);
pub const SQL_COLUMN_NUMBER_UNKNOWN = @as(i32, -2);
pub const SQL_DEFAULT_PARAM = @as(i32, -5);
pub const SQL_IGNORE = @as(i32, -6);
pub const SQL_COLUMN_IGNORE = @as(i32, -6);
pub const SQL_LEN_DATA_AT_EXEC_OFFSET = @as(i32, -100);
pub const SQL_LEN_BINARY_ATTR_OFFSET = @as(i32, -100);
pub const SQL_SETPARAM_VALUE_MAX = @as(i32, -1);
pub const SQL_COLUMN_COUNT = @as(u32, 0);
pub const SQL_COLUMN_NAME = @as(u32, 1);
pub const SQL_COLUMN_TYPE = @as(u32, 2);
pub const SQL_COLUMN_LENGTH = @as(u32, 3);
pub const SQL_COLUMN_PRECISION = @as(u32, 4);
pub const SQL_COLUMN_SCALE = @as(u32, 5);
pub const SQL_COLUMN_DISPLAY_SIZE = @as(u32, 6);
pub const SQL_COLUMN_NULLABLE = @as(u32, 7);
pub const SQL_COLUMN_UNSIGNED = @as(u32, 8);
pub const SQL_COLUMN_MONEY = @as(u32, 9);
pub const SQL_COLUMN_UPDATABLE = @as(u32, 10);
pub const SQL_COLUMN_AUTO_INCREMENT = @as(u32, 11);
pub const SQL_COLUMN_CASE_SENSITIVE = @as(u32, 12);
pub const SQL_COLUMN_SEARCHABLE = @as(u32, 13);
pub const SQL_COLUMN_TYPE_NAME = @as(u32, 14);
pub const SQL_COLUMN_TABLE_NAME = @as(u32, 15);
pub const SQL_COLUMN_OWNER_NAME = @as(u32, 16);
pub const SQL_COLUMN_QUALIFIER_NAME = @as(u32, 17);
pub const SQL_COLUMN_LABEL = @as(u32, 18);
pub const SQL_COLATT_OPT_MAX = @as(u32, 18);
pub const SQL_COLUMN_DRIVER_START = @as(u32, 1000);
pub const SQL_COLATT_OPT_MIN = @as(u32, 0);
pub const SQL_ATTR_READONLY = @as(u32, 0);
pub const SQL_ATTR_WRITE = @as(u32, 1);
pub const SQL_ATTR_READWRITE_UNKNOWN = @as(u32, 2);
pub const SQL_UNSEARCHABLE = @as(u32, 0);
pub const SQL_LIKE_ONLY = @as(u32, 1);
pub const SQL_ALL_EXCEPT_LIKE = @as(u32, 2);
pub const SQL_SEARCHABLE = @as(u32, 3);
pub const SQL_PRED_SEARCHABLE = @as(u32, 3);
pub const SQL_NO_TOTAL = @as(i32, -4);
pub const SQL_API_SQLALLOCHANDLESTD = @as(u32, 73);
pub const SQL_API_SQLBULKOPERATIONS = @as(u32, 24);
pub const SQL_API_SQLBINDPARAMETER = @as(u32, 72);
pub const SQL_API_SQLBROWSECONNECT = @as(u32, 55);
pub const SQL_API_SQLCOLATTRIBUTES = @as(u32, 6);
pub const SQL_API_SQLCOLUMNPRIVILEGES = @as(u32, 56);
pub const SQL_API_SQLDESCRIBEPARAM = @as(u32, 58);
pub const SQL_API_SQLDRIVERCONNECT = @as(u32, 41);
pub const SQL_API_SQLDRIVERS = @as(u32, 71);
pub const SQL_API_SQLPRIVATEDRIVERS = @as(u32, 79);
pub const SQL_API_SQLEXTENDEDFETCH = @as(u32, 59);
pub const SQL_API_SQLFOREIGNKEYS = @as(u32, 60);
pub const SQL_API_SQLMORERESULTS = @as(u32, 61);
pub const SQL_API_SQLNATIVESQL = @as(u32, 62);
pub const SQL_API_SQLNUMPARAMS = @as(u32, 63);
pub const SQL_API_SQLPARAMOPTIONS = @as(u32, 64);
pub const SQL_API_SQLPRIMARYKEYS = @as(u32, 65);
pub const SQL_API_SQLPROCEDURECOLUMNS = @as(u32, 66);
pub const SQL_API_SQLPROCEDURES = @as(u32, 67);
pub const SQL_API_SQLSETPOS = @as(u32, 68);
pub const SQL_API_SQLSETSCROLLOPTIONS = @as(u32, 69);
pub const SQL_API_SQLTABLEPRIVILEGES = @as(u32, 70);
pub const SQL_EXT_API_LAST = @as(u32, 72);
pub const SQL_NUM_FUNCTIONS = @as(u32, 23);
pub const SQL_EXT_API_START = @as(u32, 40);
pub const SQL_API_ALL_FUNCTIONS = @as(u32, 0);
pub const SQL_API_LOADBYORDINAL = @as(u32, 199);
pub const SQL_API_ODBC3_ALL_FUNCTIONS = @as(u32, 999);
pub const SQL_API_ODBC3_ALL_FUNCTIONS_SIZE = @as(u32, 250);
pub const SQL_INFO_FIRST = @as(u32, 0);
pub const SQL_ACTIVE_CONNECTIONS = @as(u32, 0);
pub const SQL_ACTIVE_STATEMENTS = @as(u32, 1);
pub const SQL_DRIVER_HDBC = @as(u32, 3);
pub const SQL_DRIVER_HENV = @as(u32, 4);
pub const SQL_DRIVER_HSTMT = @as(u32, 5);
pub const SQL_DRIVER_NAME = @as(u32, 6);
pub const SQL_DRIVER_VER = @as(u32, 7);
pub const SQL_ODBC_API_CONFORMANCE = @as(u32, 9);
pub const SQL_ODBC_VER = @as(u32, 10);
pub const SQL_ROW_UPDATES = @as(u32, 11);
pub const SQL_ODBC_SAG_CLI_CONFORMANCE = @as(u32, 12);
pub const SQL_ODBC_SQL_CONFORMANCE = @as(u32, 15);
pub const SQL_PROCEDURES = @as(u32, 21);
pub const SQL_CONCAT_NULL_BEHAVIOR = @as(u32, 22);
pub const SQL_CURSOR_ROLLBACK_BEHAVIOR = @as(u32, 24);
pub const SQL_EXPRESSIONS_IN_ORDERBY = @as(u32, 27);
pub const SQL_MAX_OWNER_NAME_LEN = @as(u32, 32);
pub const SQL_MAX_PROCEDURE_NAME_LEN = @as(u32, 33);
pub const SQL_MAX_QUALIFIER_NAME_LEN = @as(u32, 34);
pub const SQL_MULT_RESULT_SETS = @as(u32, 36);
pub const SQL_MULTIPLE_ACTIVE_TXN = @as(u32, 37);
pub const SQL_OUTER_JOINS = @as(u32, 38);
pub const SQL_OWNER_TERM = @as(u32, 39);
pub const SQL_PROCEDURE_TERM = @as(u32, 40);
pub const SQL_QUALIFIER_NAME_SEPARATOR = @as(u32, 41);
pub const SQL_QUALIFIER_TERM = @as(u32, 42);
pub const SQL_SCROLL_OPTIONS = @as(u32, 44);
pub const SQL_TABLE_TERM = @as(u32, 45);
pub const SQL_CONVERT_FUNCTIONS = @as(u32, 48);
pub const SQL_NUMERIC_FUNCTIONS = @as(u32, 49);
pub const SQL_STRING_FUNCTIONS = @as(u32, 50);
pub const SQL_SYSTEM_FUNCTIONS = @as(u32, 51);
pub const SQL_TIMEDATE_FUNCTIONS = @as(u32, 52);
pub const SQL_CONVERT_BIGINT = @as(u32, 53);
pub const SQL_CONVERT_BINARY = @as(u32, 54);
pub const SQL_CONVERT_BIT = @as(u32, 55);
pub const SQL_CONVERT_CHAR = @as(u32, 56);
pub const SQL_CONVERT_DATE = @as(u32, 57);
pub const SQL_CONVERT_DECIMAL = @as(u32, 58);
pub const SQL_CONVERT_DOUBLE = @as(u32, 59);
pub const SQL_CONVERT_FLOAT = @as(u32, 60);
pub const SQL_CONVERT_INTEGER = @as(u32, 61);
pub const SQL_CONVERT_LONGVARCHAR = @as(u32, 62);
pub const SQL_CONVERT_NUMERIC = @as(u32, 63);
pub const SQL_CONVERT_REAL = @as(u32, 64);
pub const SQL_CONVERT_SMALLINT = @as(u32, 65);
pub const SQL_CONVERT_TIME = @as(u32, 66);
pub const SQL_CONVERT_TIMESTAMP = @as(u32, 67);
pub const SQL_CONVERT_TINYINT = @as(u32, 68);
pub const SQL_CONVERT_VARBINARY = @as(u32, 69);
pub const SQL_CONVERT_VARCHAR = @as(u32, 70);
pub const SQL_CONVERT_LONGVARBINARY = @as(u32, 71);
pub const SQL_ODBC_SQL_OPT_IEF = @as(u32, 73);
pub const SQL_CORRELATION_NAME = @as(u32, 74);
pub const SQL_NON_NULLABLE_COLUMNS = @as(u32, 75);
pub const SQL_DRIVER_HLIB = @as(u32, 76);
pub const SQL_DRIVER_ODBC_VER = @as(u32, 77);
pub const SQL_LOCK_TYPES = @as(u32, 78);
pub const SQL_POS_OPERATIONS = @as(u32, 79);
pub const SQL_POSITIONED_STATEMENTS = @as(u32, 80);
pub const SQL_BOOKMARK_PERSISTENCE = @as(u32, 82);
pub const SQL_STATIC_SENSITIVITY = @as(u32, 83);
pub const SQL_FILE_USAGE = @as(u32, 84);
pub const SQL_COLUMN_ALIAS = @as(u32, 87);
pub const SQL_GROUP_BY = @as(u32, 88);
pub const SQL_KEYWORDS = @as(u32, 89);
pub const SQL_OWNER_USAGE = @as(u32, 91);
pub const SQL_QUALIFIER_USAGE = @as(u32, 92);
pub const SQL_QUOTED_IDENTIFIER_CASE = @as(u32, 93);
pub const SQL_SUBQUERIES = @as(u32, 95);
pub const SQL_UNION = @as(u32, 96);
pub const SQL_MAX_ROW_SIZE_INCLUDES_LONG = @as(u32, 103);
pub const SQL_MAX_CHAR_LITERAL_LEN = @as(u32, 108);
pub const SQL_TIMEDATE_ADD_INTERVALS = @as(u32, 109);
pub const SQL_TIMEDATE_DIFF_INTERVALS = @as(u32, 110);
pub const SQL_NEED_LONG_DATA_LEN = @as(u32, 111);
pub const SQL_MAX_BINARY_LITERAL_LEN = @as(u32, 112);
pub const SQL_LIKE_ESCAPE_CLAUSE = @as(u32, 113);
pub const SQL_QUALIFIER_LOCATION = @as(u32, 114);
pub const SQL_INFO_LAST = @as(u32, 114);
pub const SQL_INFO_DRIVER_START = @as(u32, 1000);
pub const SQL_ACTIVE_ENVIRONMENTS = @as(u32, 116);
pub const SQL_ALTER_DOMAIN = @as(u32, 117);
pub const SQL_SQL_CONFORMANCE = @as(u32, 118);
pub const SQL_DATETIME_LITERALS = @as(u32, 119);
pub const SQL_ASYNC_MODE = @as(u32, 10021);
pub const SQL_BATCH_ROW_COUNT = @as(u32, 120);
pub const SQL_BATCH_SUPPORT = @as(u32, 121);
pub const SQL_CATALOG_LOCATION = @as(u32, 114);
pub const SQL_CATALOG_NAME_SEPARATOR = @as(u32, 41);
pub const SQL_CATALOG_TERM = @as(u32, 42);
pub const SQL_CATALOG_USAGE = @as(u32, 92);
pub const SQL_CONVERT_WCHAR = @as(u32, 122);
pub const SQL_CONVERT_INTERVAL_DAY_TIME = @as(u32, 123);
pub const SQL_CONVERT_INTERVAL_YEAR_MONTH = @as(u32, 124);
pub const SQL_CONVERT_WLONGVARCHAR = @as(u32, 125);
pub const SQL_CONVERT_WVARCHAR = @as(u32, 126);
pub const SQL_CREATE_ASSERTION = @as(u32, 127);
pub const SQL_CREATE_CHARACTER_SET = @as(u32, 128);
pub const SQL_CREATE_COLLATION = @as(u32, 129);
pub const SQL_CREATE_DOMAIN = @as(u32, 130);
pub const SQL_CREATE_SCHEMA = @as(u32, 131);
pub const SQL_CREATE_TABLE = @as(u32, 132);
pub const SQL_CREATE_TRANSLATION = @as(u32, 133);
pub const SQL_CREATE_VIEW = @as(u32, 134);
pub const SQL_DRIVER_HDESC = @as(u32, 135);
pub const SQL_DROP_ASSERTION = @as(u32, 136);
pub const SQL_DROP_CHARACTER_SET = @as(u32, 137);
pub const SQL_DROP_COLLATION = @as(u32, 138);
pub const SQL_DROP_DOMAIN = @as(u32, 139);
pub const SQL_DROP_SCHEMA = @as(u32, 140);
pub const SQL_DROP_TABLE = @as(u32, 141);
pub const SQL_DROP_TRANSLATION = @as(u32, 142);
pub const SQL_DROP_VIEW = @as(u32, 143);
pub const SQL_DYNAMIC_CURSOR_ATTRIBUTES1 = @as(u32, 144);
pub const SQL_DYNAMIC_CURSOR_ATTRIBUTES2 = @as(u32, 145);
pub const SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1 = @as(u32, 146);
pub const SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2 = @as(u32, 147);
pub const SQL_INDEX_KEYWORDS = @as(u32, 148);
pub const SQL_INFO_SCHEMA_VIEWS = @as(u32, 149);
pub const SQL_KEYSET_CURSOR_ATTRIBUTES1 = @as(u32, 150);
pub const SQL_KEYSET_CURSOR_ATTRIBUTES2 = @as(u32, 151);
pub const SQL_MAX_ASYNC_CONCURRENT_STATEMENTS = @as(u32, 10022);
pub const SQL_ODBC_INTERFACE_CONFORMANCE = @as(u32, 152);
pub const SQL_PARAM_ARRAY_ROW_COUNTS = @as(u32, 153);
pub const SQL_PARAM_ARRAY_SELECTS = @as(u32, 154);
pub const SQL_SCHEMA_TERM = @as(u32, 39);
pub const SQL_SCHEMA_USAGE = @as(u32, 91);
pub const SQL_SQL92_DATETIME_FUNCTIONS = @as(u32, 155);
pub const SQL_SQL92_FOREIGN_KEY_DELETE_RULE = @as(u32, 156);
pub const SQL_SQL92_FOREIGN_KEY_UPDATE_RULE = @as(u32, 157);
pub const SQL_SQL92_GRANT = @as(u32, 158);
pub const SQL_SQL92_NUMERIC_VALUE_FUNCTIONS = @as(u32, 159);
pub const SQL_SQL92_PREDICATES = @as(u32, 160);
pub const SQL_SQL92_RELATIONAL_JOIN_OPERATORS = @as(u32, 161);
pub const SQL_SQL92_REVOKE = @as(u32, 162);
pub const SQL_SQL92_ROW_VALUE_CONSTRUCTOR = @as(u32, 163);
pub const SQL_SQL92_STRING_FUNCTIONS = @as(u32, 164);
pub const SQL_SQL92_VALUE_EXPRESSIONS = @as(u32, 165);
pub const SQL_STANDARD_CLI_CONFORMANCE = @as(u32, 166);
pub const SQL_STATIC_CURSOR_ATTRIBUTES1 = @as(u32, 167);
pub const SQL_STATIC_CURSOR_ATTRIBUTES2 = @as(u32, 168);
pub const SQL_AGGREGATE_FUNCTIONS = @as(u32, 169);
pub const SQL_DDL_INDEX = @as(u32, 170);
pub const SQL_DM_VER = @as(u32, 171);
pub const SQL_INSERT_STATEMENT = @as(u32, 172);
pub const SQL_CONVERT_GUID = @as(u32, 173);
pub const SQL_UNION_STATEMENT = @as(u32, 96);
pub const SQL_ASYNC_DBC_FUNCTIONS = @as(u32, 10023);
pub const SQL_DRIVER_AWARE_POOLING_SUPPORTED = @as(u32, 10024);
pub const SQL_ASYNC_NOTIFICATION = @as(u32, 10025);
pub const SQL_ASYNC_NOTIFICATION_NOT_CAPABLE = @as(i32, 0);
pub const SQL_ASYNC_NOTIFICATION_CAPABLE = @as(i32, 1);
pub const SQL_DTC_TRANSITION_COST = @as(u32, 1750);
pub const SQL_AT_ADD_COLUMN_SINGLE = @as(i32, 32);
pub const SQL_AT_ADD_COLUMN_DEFAULT = @as(i32, 64);
pub const SQL_AT_ADD_COLUMN_COLLATION = @as(i32, 128);
pub const SQL_AT_SET_COLUMN_DEFAULT = @as(i32, 256);
pub const SQL_AT_DROP_COLUMN_DEFAULT = @as(i32, 512);
pub const SQL_AT_DROP_COLUMN_CASCADE = @as(i32, 1024);
pub const SQL_AT_DROP_COLUMN_RESTRICT = @as(i32, 2048);
pub const SQL_AT_ADD_TABLE_CONSTRAINT = @as(i32, 4096);
pub const SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE = @as(i32, 8192);
pub const SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT = @as(i32, 16384);
pub const SQL_AT_CONSTRAINT_NAME_DEFINITION = @as(i32, 32768);
pub const SQL_AT_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 65536);
pub const SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 131072);
pub const SQL_AT_CONSTRAINT_DEFERRABLE = @as(i32, 262144);
pub const SQL_AT_CONSTRAINT_NON_DEFERRABLE = @as(i32, 524288);
pub const SQL_CVT_CHAR = @as(i32, 1);
pub const SQL_CVT_NUMERIC = @as(i32, 2);
pub const SQL_CVT_DECIMAL = @as(i32, 4);
pub const SQL_CVT_INTEGER = @as(i32, 8);
pub const SQL_CVT_SMALLINT = @as(i32, 16);
pub const SQL_CVT_FLOAT = @as(i32, 32);
pub const SQL_CVT_REAL = @as(i32, 64);
pub const SQL_CVT_DOUBLE = @as(i32, 128);
pub const SQL_CVT_VARCHAR = @as(i32, 256);
pub const SQL_CVT_LONGVARCHAR = @as(i32, 512);
pub const SQL_CVT_BINARY = @as(i32, 1024);
pub const SQL_CVT_VARBINARY = @as(i32, 2048);
pub const SQL_CVT_BIT = @as(i32, 4096);
pub const SQL_CVT_TINYINT = @as(i32, 8192);
pub const SQL_CVT_BIGINT = @as(i32, 16384);
pub const SQL_CVT_DATE = @as(i32, 32768);
pub const SQL_CVT_TIME = @as(i32, 65536);
pub const SQL_CVT_TIMESTAMP = @as(i32, 131072);
pub const SQL_CVT_LONGVARBINARY = @as(i32, 262144);
pub const SQL_CVT_INTERVAL_YEAR_MONTH = @as(i32, 524288);
pub const SQL_CVT_INTERVAL_DAY_TIME = @as(i32, 1048576);
pub const SQL_CVT_WCHAR = @as(i32, 2097152);
pub const SQL_CVT_WLONGVARCHAR = @as(i32, 4194304);
pub const SQL_CVT_WVARCHAR = @as(i32, 8388608);
pub const SQL_CVT_GUID = @as(i32, 16777216);
pub const SQL_FN_CVT_CONVERT = @as(i32, 1);
pub const SQL_FN_CVT_CAST = @as(i32, 2);
pub const SQL_FN_STR_CONCAT = @as(i32, 1);
pub const SQL_FN_STR_INSERT = @as(i32, 2);
pub const SQL_FN_STR_LEFT = @as(i32, 4);
pub const SQL_FN_STR_LTRIM = @as(i32, 8);
pub const SQL_FN_STR_LENGTH = @as(i32, 16);
pub const SQL_FN_STR_LOCATE = @as(i32, 32);
pub const SQL_FN_STR_LCASE = @as(i32, 64);
pub const SQL_FN_STR_REPEAT = @as(i32, 128);
pub const SQL_FN_STR_REPLACE = @as(i32, 256);
pub const SQL_FN_STR_RIGHT = @as(i32, 512);
pub const SQL_FN_STR_RTRIM = @as(i32, 1024);
pub const SQL_FN_STR_SUBSTRING = @as(i32, 2048);
pub const SQL_FN_STR_UCASE = @as(i32, 4096);
pub const SQL_FN_STR_ASCII = @as(i32, 8192);
pub const SQL_FN_STR_CHAR = @as(i32, 16384);
pub const SQL_FN_STR_DIFFERENCE = @as(i32, 32768);
pub const SQL_FN_STR_LOCATE_2 = @as(i32, 65536);
pub const SQL_FN_STR_SOUNDEX = @as(i32, 131072);
pub const SQL_FN_STR_SPACE = @as(i32, 262144);
pub const SQL_FN_STR_BIT_LENGTH = @as(i32, 524288);
pub const SQL_FN_STR_CHAR_LENGTH = @as(i32, 1048576);
pub const SQL_FN_STR_CHARACTER_LENGTH = @as(i32, 2097152);
pub const SQL_FN_STR_OCTET_LENGTH = @as(i32, 4194304);
pub const SQL_FN_STR_POSITION = @as(i32, 8388608);
pub const SQL_SSF_CONVERT = @as(i32, 1);
pub const SQL_SSF_LOWER = @as(i32, 2);
pub const SQL_SSF_UPPER = @as(i32, 4);
pub const SQL_SSF_SUBSTRING = @as(i32, 8);
pub const SQL_SSF_TRANSLATE = @as(i32, 16);
pub const SQL_SSF_TRIM_BOTH = @as(i32, 32);
pub const SQL_SSF_TRIM_LEADING = @as(i32, 64);
pub const SQL_SSF_TRIM_TRAILING = @as(i32, 128);
pub const SQL_FN_NUM_ABS = @as(i32, 1);
pub const SQL_FN_NUM_ACOS = @as(i32, 2);
pub const SQL_FN_NUM_ASIN = @as(i32, 4);
pub const SQL_FN_NUM_ATAN = @as(i32, 8);
pub const SQL_FN_NUM_ATAN2 = @as(i32, 16);
pub const SQL_FN_NUM_CEILING = @as(i32, 32);
pub const SQL_FN_NUM_COS = @as(i32, 64);
pub const SQL_FN_NUM_COT = @as(i32, 128);
pub const SQL_FN_NUM_EXP = @as(i32, 256);
pub const SQL_FN_NUM_FLOOR = @as(i32, 512);
pub const SQL_FN_NUM_LOG = @as(i32, 1024);
pub const SQL_FN_NUM_MOD = @as(i32, 2048);
pub const SQL_FN_NUM_SIGN = @as(i32, 4096);
pub const SQL_FN_NUM_SIN = @as(i32, 8192);
pub const SQL_FN_NUM_SQRT = @as(i32, 16384);
pub const SQL_FN_NUM_TAN = @as(i32, 32768);
pub const SQL_FN_NUM_PI = @as(i32, 65536);
pub const SQL_FN_NUM_RAND = @as(i32, 131072);
pub const SQL_FN_NUM_DEGREES = @as(i32, 262144);
pub const SQL_FN_NUM_LOG10 = @as(i32, 524288);
pub const SQL_FN_NUM_POWER = @as(i32, 1048576);
pub const SQL_FN_NUM_RADIANS = @as(i32, 2097152);
pub const SQL_FN_NUM_ROUND = @as(i32, 4194304);
pub const SQL_FN_NUM_TRUNCATE = @as(i32, 8388608);
pub const SQL_SNVF_BIT_LENGTH = @as(i32, 1);
pub const SQL_SNVF_CHAR_LENGTH = @as(i32, 2);
pub const SQL_SNVF_CHARACTER_LENGTH = @as(i32, 4);
pub const SQL_SNVF_EXTRACT = @as(i32, 8);
pub const SQL_SNVF_OCTET_LENGTH = @as(i32, 16);
pub const SQL_SNVF_POSITION = @as(i32, 32);
pub const SQL_FN_TD_NOW = @as(i32, 1);
pub const SQL_FN_TD_CURDATE = @as(i32, 2);
pub const SQL_FN_TD_DAYOFMONTH = @as(i32, 4);
pub const SQL_FN_TD_DAYOFWEEK = @as(i32, 8);
pub const SQL_FN_TD_DAYOFYEAR = @as(i32, 16);
pub const SQL_FN_TD_MONTH = @as(i32, 32);
pub const SQL_FN_TD_QUARTER = @as(i32, 64);
pub const SQL_FN_TD_WEEK = @as(i32, 128);
pub const SQL_FN_TD_YEAR = @as(i32, 256);
pub const SQL_FN_TD_CURTIME = @as(i32, 512);
pub const SQL_FN_TD_HOUR = @as(i32, 1024);
pub const SQL_FN_TD_MINUTE = @as(i32, 2048);
pub const SQL_FN_TD_SECOND = @as(i32, 4096);
pub const SQL_FN_TD_TIMESTAMPADD = @as(i32, 8192);
pub const SQL_FN_TD_TIMESTAMPDIFF = @as(i32, 16384);
pub const SQL_FN_TD_DAYNAME = @as(i32, 32768);
pub const SQL_FN_TD_MONTHNAME = @as(i32, 65536);
pub const SQL_FN_TD_CURRENT_DATE = @as(i32, 131072);
pub const SQL_FN_TD_CURRENT_TIME = @as(i32, 262144);
pub const SQL_FN_TD_CURRENT_TIMESTAMP = @as(i32, 524288);
pub const SQL_FN_TD_EXTRACT = @as(i32, 1048576);
pub const SQL_SDF_CURRENT_DATE = @as(i32, 1);
pub const SQL_SDF_CURRENT_TIME = @as(i32, 2);
pub const SQL_SDF_CURRENT_TIMESTAMP = @as(i32, 4);
pub const SQL_FN_SYS_USERNAME = @as(i32, 1);
pub const SQL_FN_SYS_DBNAME = @as(i32, 2);
pub const SQL_FN_SYS_IFNULL = @as(i32, 4);
pub const SQL_FN_TSI_FRAC_SECOND = @as(i32, 1);
pub const SQL_FN_TSI_SECOND = @as(i32, 2);
pub const SQL_FN_TSI_MINUTE = @as(i32, 4);
pub const SQL_FN_TSI_HOUR = @as(i32, 8);
pub const SQL_FN_TSI_DAY = @as(i32, 16);
pub const SQL_FN_TSI_WEEK = @as(i32, 32);
pub const SQL_FN_TSI_MONTH = @as(i32, 64);
pub const SQL_FN_TSI_QUARTER = @as(i32, 128);
pub const SQL_FN_TSI_YEAR = @as(i32, 256);
pub const SQL_CA1_NEXT = @as(i32, 1);
pub const SQL_CA1_ABSOLUTE = @as(i32, 2);
pub const SQL_CA1_RELATIVE = @as(i32, 4);
pub const SQL_CA1_BOOKMARK = @as(i32, 8);
pub const SQL_CA1_LOCK_NO_CHANGE = @as(i32, 64);
pub const SQL_CA1_LOCK_EXCLUSIVE = @as(i32, 128);
pub const SQL_CA1_LOCK_UNLOCK = @as(i32, 256);
pub const SQL_CA1_POS_POSITION = @as(i32, 512);
pub const SQL_CA1_POS_UPDATE = @as(i32, 1024);
pub const SQL_CA1_POS_DELETE = @as(i32, 2048);
pub const SQL_CA1_POS_REFRESH = @as(i32, 4096);
pub const SQL_CA1_POSITIONED_UPDATE = @as(i32, 8192);
pub const SQL_CA1_POSITIONED_DELETE = @as(i32, 16384);
pub const SQL_CA1_SELECT_FOR_UPDATE = @as(i32, 32768);
pub const SQL_CA1_BULK_ADD = @as(i32, 65536);
pub const SQL_CA1_BULK_UPDATE_BY_BOOKMARK = @as(i32, 131072);
pub const SQL_CA1_BULK_DELETE_BY_BOOKMARK = @as(i32, 262144);
pub const SQL_CA1_BULK_FETCH_BY_BOOKMARK = @as(i32, 524288);
pub const SQL_CA2_READ_ONLY_CONCURRENCY = @as(i32, 1);
pub const SQL_CA2_LOCK_CONCURRENCY = @as(i32, 2);
pub const SQL_CA2_OPT_ROWVER_CONCURRENCY = @as(i32, 4);
pub const SQL_CA2_OPT_VALUES_CONCURRENCY = @as(i32, 8);
pub const SQL_CA2_SENSITIVITY_ADDITIONS = @as(i32, 16);
pub const SQL_CA2_SENSITIVITY_DELETIONS = @as(i32, 32);
pub const SQL_CA2_SENSITIVITY_UPDATES = @as(i32, 64);
pub const SQL_CA2_MAX_ROWS_SELECT = @as(i32, 128);
pub const SQL_CA2_MAX_ROWS_INSERT = @as(i32, 256);
pub const SQL_CA2_MAX_ROWS_DELETE = @as(i32, 512);
pub const SQL_CA2_MAX_ROWS_UPDATE = @as(i32, 1024);
pub const SQL_CA2_MAX_ROWS_CATALOG = @as(i32, 2048);
pub const SQL_CA2_CRC_EXACT = @as(i32, 4096);
pub const SQL_CA2_CRC_APPROXIMATE = @as(i32, 8192);
pub const SQL_CA2_SIMULATE_NON_UNIQUE = @as(i32, 16384);
pub const SQL_CA2_SIMULATE_TRY_UNIQUE = @as(i32, 32768);
pub const SQL_CA2_SIMULATE_UNIQUE = @as(i32, 65536);
pub const SQL_OAC_NONE = @as(u32, 0);
pub const SQL_OAC_LEVEL1 = @as(u32, 1);
pub const SQL_OAC_LEVEL2 = @as(u32, 2);
pub const SQL_OSCC_NOT_COMPLIANT = @as(u32, 0);
pub const SQL_OSCC_COMPLIANT = @as(u32, 1);
pub const SQL_OSC_MINIMUM = @as(u32, 0);
pub const SQL_OSC_CORE = @as(u32, 1);
pub const SQL_OSC_EXTENDED = @as(u32, 2);
pub const SQL_CB_NULL = @as(u32, 0);
pub const SQL_CB_NON_NULL = @as(u32, 1);
pub const SQL_SO_FORWARD_ONLY = @as(i32, 1);
pub const SQL_SO_KEYSET_DRIVEN = @as(i32, 2);
pub const SQL_SO_DYNAMIC = @as(i32, 4);
pub const SQL_SO_MIXED = @as(i32, 8);
pub const SQL_SO_STATIC = @as(i32, 16);
pub const SQL_FD_FETCH_RESUME = @as(i32, 64);
pub const SQL_FD_FETCH_BOOKMARK = @as(i32, 128);
pub const SQL_TXN_VERSIONING = @as(i32, 16);
pub const SQL_CN_NONE = @as(u32, 0);
pub const SQL_CN_DIFFERENT = @as(u32, 1);
pub const SQL_CN_ANY = @as(u32, 2);
pub const SQL_NNC_NULL = @as(u32, 0);
pub const SQL_NNC_NON_NULL = @as(u32, 1);
pub const SQL_NC_START = @as(u32, 2);
pub const SQL_NC_END = @as(u32, 4);
pub const SQL_FILE_NOT_SUPPORTED = @as(u32, 0);
pub const SQL_FILE_TABLE = @as(u32, 1);
pub const SQL_FILE_QUALIFIER = @as(u32, 2);
pub const SQL_FILE_CATALOG = @as(u32, 2);
pub const SQL_GD_BLOCK = @as(i32, 4);
pub const SQL_GD_BOUND = @as(i32, 8);
pub const SQL_GD_OUTPUT_PARAMS = @as(i32, 16);
pub const SQL_PS_POSITIONED_DELETE = @as(i32, 1);
pub const SQL_PS_POSITIONED_UPDATE = @as(i32, 2);
pub const SQL_PS_SELECT_FOR_UPDATE = @as(i32, 4);
pub const SQL_GB_NOT_SUPPORTED = @as(u32, 0);
pub const SQL_GB_GROUP_BY_EQUALS_SELECT = @as(u32, 1);
pub const SQL_GB_GROUP_BY_CONTAINS_SELECT = @as(u32, 2);
pub const SQL_GB_NO_RELATION = @as(u32, 3);
pub const SQL_GB_COLLATE = @as(u32, 4);
pub const SQL_OU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_OU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_OU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_OU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_OU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_SU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_SU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_SU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_SU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_SU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_QU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_QU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_QU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_QU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_QU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_CU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_CU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_CU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_CU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_CU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_SQ_COMPARISON = @as(i32, 1);
pub const SQL_SQ_EXISTS = @as(i32, 2);
pub const SQL_SQ_IN = @as(i32, 4);
pub const SQL_SQ_QUANTIFIED = @as(i32, 8);
pub const SQL_SQ_CORRELATED_SUBQUERIES = @as(i32, 16);
pub const SQL_U_UNION = @as(i32, 1);
pub const SQL_U_UNION_ALL = @as(i32, 2);
pub const SQL_BP_CLOSE = @as(i32, 1);
pub const SQL_BP_DELETE = @as(i32, 2);
pub const SQL_BP_DROP = @as(i32, 4);
pub const SQL_BP_TRANSACTION = @as(i32, 8);
pub const SQL_BP_UPDATE = @as(i32, 16);
pub const SQL_BP_OTHER_HSTMT = @as(i32, 32);
pub const SQL_BP_SCROLL = @as(i32, 64);
pub const SQL_SS_ADDITIONS = @as(i32, 1);
pub const SQL_SS_DELETIONS = @as(i32, 2);
pub const SQL_SS_UPDATES = @as(i32, 4);
pub const SQL_CV_CREATE_VIEW = @as(i32, 1);
pub const SQL_CV_CHECK_OPTION = @as(i32, 2);
pub const SQL_CV_CASCADED = @as(i32, 4);
pub const SQL_CV_LOCAL = @as(i32, 8);
pub const SQL_LCK_NO_CHANGE = @as(i32, 1);
pub const SQL_LCK_EXCLUSIVE = @as(i32, 2);
pub const SQL_LCK_UNLOCK = @as(i32, 4);
pub const SQL_POS_POSITION = @as(i32, 1);
pub const SQL_POS_REFRESH = @as(i32, 2);
pub const SQL_POS_UPDATE = @as(i32, 4);
pub const SQL_POS_DELETE = @as(i32, 8);
pub const SQL_POS_ADD = @as(i32, 16);
pub const SQL_QL_START = @as(u32, 1);
pub const SQL_QL_END = @as(u32, 2);
pub const SQL_AF_AVG = @as(i32, 1);
pub const SQL_AF_COUNT = @as(i32, 2);
pub const SQL_AF_MAX = @as(i32, 4);
pub const SQL_AF_MIN = @as(i32, 8);
pub const SQL_AF_SUM = @as(i32, 16);
pub const SQL_AF_DISTINCT = @as(i32, 32);
pub const SQL_AF_ALL = @as(i32, 64);
pub const SQL_SC_SQL92_ENTRY = @as(i32, 1);
pub const SQL_SC_FIPS127_2_TRANSITIONAL = @as(i32, 2);
pub const SQL_SC_SQL92_INTERMEDIATE = @as(i32, 4);
pub const SQL_SC_SQL92_FULL = @as(i32, 8);
pub const SQL_DL_SQL92_DATE = @as(i32, 1);
pub const SQL_DL_SQL92_TIME = @as(i32, 2);
pub const SQL_DL_SQL92_TIMESTAMP = @as(i32, 4);
pub const SQL_DL_SQL92_INTERVAL_YEAR = @as(i32, 8);
pub const SQL_DL_SQL92_INTERVAL_MONTH = @as(i32, 16);
pub const SQL_DL_SQL92_INTERVAL_DAY = @as(i32, 32);
pub const SQL_DL_SQL92_INTERVAL_HOUR = @as(i32, 64);
pub const SQL_DL_SQL92_INTERVAL_MINUTE = @as(i32, 128);
pub const SQL_DL_SQL92_INTERVAL_SECOND = @as(i32, 256);
pub const SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH = @as(i32, 512);
pub const SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR = @as(i32, 1024);
pub const SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE = @as(i32, 2048);
pub const SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND = @as(i32, 4096);
pub const SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE = @as(i32, 8192);
pub const SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND = @as(i32, 16384);
pub const SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND = @as(i32, 32768);
pub const SQL_CL_START = @as(u32, 1);
pub const SQL_CL_END = @as(u32, 2);
pub const SQL_BRC_PROCEDURES = @as(u32, 1);
pub const SQL_BRC_EXPLICIT = @as(u32, 2);
pub const SQL_BRC_ROLLED_UP = @as(u32, 4);
pub const SQL_BS_SELECT_EXPLICIT = @as(i32, 1);
pub const SQL_BS_ROW_COUNT_EXPLICIT = @as(i32, 2);
pub const SQL_BS_SELECT_PROC = @as(i32, 4);
pub const SQL_BS_ROW_COUNT_PROC = @as(i32, 8);
pub const SQL_PARC_BATCH = @as(u32, 1);
pub const SQL_PARC_NO_BATCH = @as(u32, 2);
pub const SQL_PAS_BATCH = @as(u32, 1);
pub const SQL_PAS_NO_BATCH = @as(u32, 2);
pub const SQL_PAS_NO_SELECT = @as(u32, 3);
pub const SQL_IK_NONE = @as(i32, 0);
pub const SQL_IK_ASC = @as(i32, 1);
pub const SQL_IK_DESC = @as(i32, 2);
pub const SQL_ISV_ASSERTIONS = @as(i32, 1);
pub const SQL_ISV_CHARACTER_SETS = @as(i32, 2);
pub const SQL_ISV_CHECK_CONSTRAINTS = @as(i32, 4);
pub const SQL_ISV_COLLATIONS = @as(i32, 8);
pub const SQL_ISV_COLUMN_DOMAIN_USAGE = @as(i32, 16);
pub const SQL_ISV_COLUMN_PRIVILEGES = @as(i32, 32);
pub const SQL_ISV_COLUMNS = @as(i32, 64);
pub const SQL_ISV_CONSTRAINT_COLUMN_USAGE = @as(i32, 128);
pub const SQL_ISV_CONSTRAINT_TABLE_USAGE = @as(i32, 256);
pub const SQL_ISV_DOMAIN_CONSTRAINTS = @as(i32, 512);
pub const SQL_ISV_DOMAINS = @as(i32, 1024);
pub const SQL_ISV_KEY_COLUMN_USAGE = @as(i32, 2048);
pub const SQL_ISV_REFERENTIAL_CONSTRAINTS = @as(i32, 4096);
pub const SQL_ISV_SCHEMATA = @as(i32, 8192);
pub const SQL_ISV_SQL_LANGUAGES = @as(i32, 16384);
pub const SQL_ISV_TABLE_CONSTRAINTS = @as(i32, 32768);
pub const SQL_ISV_TABLE_PRIVILEGES = @as(i32, 65536);
pub const SQL_ISV_TABLES = @as(i32, 131072);
pub const SQL_ISV_TRANSLATIONS = @as(i32, 262144);
pub const SQL_ISV_USAGE_PRIVILEGES = @as(i32, 524288);
pub const SQL_ISV_VIEW_COLUMN_USAGE = @as(i32, 1048576);
pub const SQL_ISV_VIEW_TABLE_USAGE = @as(i32, 2097152);
pub const SQL_ISV_VIEWS = @as(i32, 4194304);
pub const SQL_AD_CONSTRAINT_NAME_DEFINITION = @as(i32, 1);
pub const SQL_AD_ADD_DOMAIN_CONSTRAINT = @as(i32, 2);
pub const SQL_AD_DROP_DOMAIN_CONSTRAINT = @as(i32, 4);
pub const SQL_AD_ADD_DOMAIN_DEFAULT = @as(i32, 8);
pub const SQL_AD_DROP_DOMAIN_DEFAULT = @as(i32, 16);
pub const SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 32);
pub const SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 64);
pub const SQL_AD_ADD_CONSTRAINT_DEFERRABLE = @as(i32, 128);
pub const SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE = @as(i32, 256);
pub const SQL_CS_CREATE_SCHEMA = @as(i32, 1);
pub const SQL_CS_AUTHORIZATION = @as(i32, 2);
pub const SQL_CS_DEFAULT_CHARACTER_SET = @as(i32, 4);
pub const SQL_CTR_CREATE_TRANSLATION = @as(i32, 1);
pub const SQL_CA_CREATE_ASSERTION = @as(i32, 1);
pub const SQL_CA_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 16);
pub const SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 32);
pub const SQL_CA_CONSTRAINT_DEFERRABLE = @as(i32, 64);
pub const SQL_CA_CONSTRAINT_NON_DEFERRABLE = @as(i32, 128);
pub const SQL_CCS_CREATE_CHARACTER_SET = @as(i32, 1);
pub const SQL_CCS_COLLATE_CLAUSE = @as(i32, 2);
pub const SQL_CCS_LIMITED_COLLATION = @as(i32, 4);
pub const SQL_CCOL_CREATE_COLLATION = @as(i32, 1);
pub const SQL_CDO_CREATE_DOMAIN = @as(i32, 1);
pub const SQL_CDO_DEFAULT = @as(i32, 2);
pub const SQL_CDO_CONSTRAINT = @as(i32, 4);
pub const SQL_CDO_COLLATION = @as(i32, 8);
pub const SQL_CDO_CONSTRAINT_NAME_DEFINITION = @as(i32, 16);
pub const SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 32);
pub const SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 64);
pub const SQL_CDO_CONSTRAINT_DEFERRABLE = @as(i32, 128);
pub const SQL_CDO_CONSTRAINT_NON_DEFERRABLE = @as(i32, 256);
pub const SQL_CT_CREATE_TABLE = @as(i32, 1);
pub const SQL_CT_COMMIT_PRESERVE = @as(i32, 2);
pub const SQL_CT_COMMIT_DELETE = @as(i32, 4);
pub const SQL_CT_GLOBAL_TEMPORARY = @as(i32, 8);
pub const SQL_CT_LOCAL_TEMPORARY = @as(i32, 16);
pub const SQL_CT_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 32);
pub const SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 64);
pub const SQL_CT_CONSTRAINT_DEFERRABLE = @as(i32, 128);
pub const SQL_CT_CONSTRAINT_NON_DEFERRABLE = @as(i32, 256);
pub const SQL_CT_COLUMN_CONSTRAINT = @as(i32, 512);
pub const SQL_CT_COLUMN_DEFAULT = @as(i32, 1024);
pub const SQL_CT_COLUMN_COLLATION = @as(i32, 2048);
pub const SQL_CT_TABLE_CONSTRAINT = @as(i32, 4096);
pub const SQL_CT_CONSTRAINT_NAME_DEFINITION = @as(i32, 8192);
pub const SQL_DI_CREATE_INDEX = @as(i32, 1);
pub const SQL_DI_DROP_INDEX = @as(i32, 2);
pub const SQL_DC_DROP_COLLATION = @as(i32, 1);
pub const SQL_DD_DROP_DOMAIN = @as(i32, 1);
pub const SQL_DD_RESTRICT = @as(i32, 2);
pub const SQL_DD_CASCADE = @as(i32, 4);
pub const SQL_DS_DROP_SCHEMA = @as(i32, 1);
pub const SQL_DS_RESTRICT = @as(i32, 2);
pub const SQL_DS_CASCADE = @as(i32, 4);
pub const SQL_DCS_DROP_CHARACTER_SET = @as(i32, 1);
pub const SQL_DA_DROP_ASSERTION = @as(i32, 1);
pub const SQL_DT_DROP_TABLE = @as(i32, 1);
pub const SQL_DT_RESTRICT = @as(i32, 2);
pub const SQL_DT_CASCADE = @as(i32, 4);
pub const SQL_DTR_DROP_TRANSLATION = @as(i32, 1);
pub const SQL_DV_DROP_VIEW = @as(i32, 1);
pub const SQL_DV_RESTRICT = @as(i32, 2);
pub const SQL_DV_CASCADE = @as(i32, 4);
pub const SQL_IS_INSERT_LITERALS = @as(i32, 1);
pub const SQL_IS_INSERT_SEARCHED = @as(i32, 2);
pub const SQL_IS_SELECT_INTO = @as(i32, 4);
pub const SQL_OIC_CORE = @as(u32, 1);
pub const SQL_OIC_LEVEL1 = @as(u32, 2);
pub const SQL_OIC_LEVEL2 = @as(u32, 3);
pub const SQL_SFKD_CASCADE = @as(i32, 1);
pub const SQL_SFKD_NO_ACTION = @as(i32, 2);
pub const SQL_SFKD_SET_DEFAULT = @as(i32, 4);
pub const SQL_SFKD_SET_NULL = @as(i32, 8);
pub const SQL_SFKU_CASCADE = @as(i32, 1);
pub const SQL_SFKU_NO_ACTION = @as(i32, 2);
pub const SQL_SFKU_SET_DEFAULT = @as(i32, 4);
pub const SQL_SFKU_SET_NULL = @as(i32, 8);
pub const SQL_SG_USAGE_ON_DOMAIN = @as(i32, 1);
pub const SQL_SG_USAGE_ON_CHARACTER_SET = @as(i32, 2);
pub const SQL_SG_USAGE_ON_COLLATION = @as(i32, 4);
pub const SQL_SG_USAGE_ON_TRANSLATION = @as(i32, 8);
pub const SQL_SG_WITH_GRANT_OPTION = @as(i32, 16);
pub const SQL_SG_DELETE_TABLE = @as(i32, 32);
pub const SQL_SG_INSERT_TABLE = @as(i32, 64);
pub const SQL_SG_INSERT_COLUMN = @as(i32, 128);
pub const SQL_SG_REFERENCES_TABLE = @as(i32, 256);
pub const SQL_SG_REFERENCES_COLUMN = @as(i32, 512);
pub const SQL_SG_SELECT_TABLE = @as(i32, 1024);
pub const SQL_SG_UPDATE_TABLE = @as(i32, 2048);
pub const SQL_SG_UPDATE_COLUMN = @as(i32, 4096);
pub const SQL_SP_EXISTS = @as(i32, 1);
pub const SQL_SP_ISNOTNULL = @as(i32, 2);
pub const SQL_SP_ISNULL = @as(i32, 4);
pub const SQL_SP_MATCH_FULL = @as(i32, 8);
pub const SQL_SP_MATCH_PARTIAL = @as(i32, 16);
pub const SQL_SP_MATCH_UNIQUE_FULL = @as(i32, 32);
pub const SQL_SP_MATCH_UNIQUE_PARTIAL = @as(i32, 64);
pub const SQL_SP_OVERLAPS = @as(i32, 128);
pub const SQL_SP_UNIQUE = @as(i32, 256);
pub const SQL_SP_LIKE = @as(i32, 512);
pub const SQL_SP_IN = @as(i32, 1024);
pub const SQL_SP_BETWEEN = @as(i32, 2048);
pub const SQL_SP_COMPARISON = @as(i32, 4096);
pub const SQL_SP_QUANTIFIED_COMPARISON = @as(i32, 8192);
pub const SQL_SRJO_CORRESPONDING_CLAUSE = @as(i32, 1);
pub const SQL_SRJO_CROSS_JOIN = @as(i32, 2);
pub const SQL_SRJO_EXCEPT_JOIN = @as(i32, 4);
pub const SQL_SRJO_FULL_OUTER_JOIN = @as(i32, 8);
pub const SQL_SRJO_INNER_JOIN = @as(i32, 16);
pub const SQL_SRJO_INTERSECT_JOIN = @as(i32, 32);
pub const SQL_SRJO_LEFT_OUTER_JOIN = @as(i32, 64);
pub const SQL_SRJO_NATURAL_JOIN = @as(i32, 128);
pub const SQL_SRJO_RIGHT_OUTER_JOIN = @as(i32, 256);
pub const SQL_SRJO_UNION_JOIN = @as(i32, 512);
pub const SQL_SR_USAGE_ON_DOMAIN = @as(i32, 1);
pub const SQL_SR_USAGE_ON_CHARACTER_SET = @as(i32, 2);
pub const SQL_SR_USAGE_ON_COLLATION = @as(i32, 4);
pub const SQL_SR_USAGE_ON_TRANSLATION = @as(i32, 8);
pub const SQL_SR_GRANT_OPTION_FOR = @as(i32, 16);
pub const SQL_SR_CASCADE = @as(i32, 32);
pub const SQL_SR_RESTRICT = @as(i32, 64);
pub const SQL_SR_DELETE_TABLE = @as(i32, 128);
pub const SQL_SR_INSERT_TABLE = @as(i32, 256);
pub const SQL_SR_INSERT_COLUMN = @as(i32, 512);
pub const SQL_SR_REFERENCES_TABLE = @as(i32, 1024);
pub const SQL_SR_REFERENCES_COLUMN = @as(i32, 2048);
pub const SQL_SR_SELECT_TABLE = @as(i32, 4096);
pub const SQL_SR_UPDATE_TABLE = @as(i32, 8192);
pub const SQL_SR_UPDATE_COLUMN = @as(i32, 16384);
pub const SQL_SRVC_VALUE_EXPRESSION = @as(i32, 1);
pub const SQL_SRVC_NULL = @as(i32, 2);
pub const SQL_SRVC_DEFAULT = @as(i32, 4);
pub const SQL_SRVC_ROW_SUBQUERY = @as(i32, 8);
pub const SQL_SVE_CASE = @as(i32, 1);
pub const SQL_SVE_CAST = @as(i32, 2);
pub const SQL_SVE_COALESCE = @as(i32, 4);
pub const SQL_SVE_NULLIF = @as(i32, 8);
pub const SQL_SCC_XOPEN_CLI_VERSION1 = @as(i32, 1);
pub const SQL_SCC_ISO92_CLI = @as(i32, 2);
pub const SQL_US_UNION = @as(i32, 1);
pub const SQL_US_UNION_ALL = @as(i32, 2);
pub const SQL_DRIVER_AWARE_POOLING_NOT_CAPABLE = @as(i32, 0);
pub const SQL_DRIVER_AWARE_POOLING_CAPABLE = @as(i32, 1);
pub const SQL_DTC_ENLIST_EXPENSIVE = @as(i32, 1);
pub const SQL_DTC_UNENLIST_EXPENSIVE = @as(i32, 2);
pub const SQL_ASYNC_DBC_NOT_CAPABLE = @as(i32, 0);
pub const SQL_ASYNC_DBC_CAPABLE = @as(i32, 1);
pub const SQL_FETCH_FIRST_USER = @as(u32, 31);
pub const SQL_FETCH_FIRST_SYSTEM = @as(u32, 32);
pub const SQL_ENTIRE_ROWSET = @as(u32, 0);
pub const SQL_POSITION = @as(u32, 0);
pub const SQL_REFRESH = @as(u32, 1);
pub const SQL_UPDATE = @as(u32, 2);
pub const SQL_DELETE = @as(u32, 3);
pub const SQL_ADD = @as(u32, 4);
pub const SQL_SETPOS_MAX_OPTION_VALUE = @as(u32, 4);
pub const SQL_UPDATE_BY_BOOKMARK = @as(u32, 5);
pub const SQL_DELETE_BY_BOOKMARK = @as(u32, 6);
pub const SQL_FETCH_BY_BOOKMARK = @as(u32, 7);
pub const SQL_LOCK_NO_CHANGE = @as(u32, 0);
pub const SQL_LOCK_EXCLUSIVE = @as(u32, 1);
pub const SQL_LOCK_UNLOCK = @as(u32, 2);
pub const SQL_SETPOS_MAX_LOCK_VALUE = @as(u32, 2);
pub const SQL_BEST_ROWID = @as(u32, 1);
pub const SQL_ROWVER = @as(u32, 2);
pub const SQL_PC_NOT_PSEUDO = @as(u32, 1);
pub const SQL_QUICK = @as(u32, 0);
pub const SQL_ENSURE = @as(u32, 1);
pub const SQL_TABLE_STAT = @as(u32, 0);
pub const SQL_DRIVER_NOPROMPT = @as(u32, 0);
pub const SQL_DRIVER_COMPLETE = @as(u32, 1);
pub const SQL_DRIVER_PROMPT = @as(u32, 2);
pub const SQL_DRIVER_COMPLETE_REQUIRED = @as(u32, 3);
pub const SQL_FETCH_BOOKMARK = @as(u32, 8);
pub const SQL_ROW_SUCCESS = @as(u32, 0);
pub const SQL_ROW_DELETED = @as(u32, 1);
pub const SQL_ROW_UPDATED = @as(u32, 2);
pub const SQL_ROW_NOROW = @as(u32, 3);
pub const SQL_ROW_ADDED = @as(u32, 4);
pub const SQL_ROW_ERROR = @as(u32, 5);
pub const SQL_ROW_SUCCESS_WITH_INFO = @as(u32, 6);
pub const SQL_ROW_PROCEED = @as(u32, 0);
pub const SQL_ROW_IGNORE = @as(u32, 1);
pub const SQL_PARAM_SUCCESS = @as(u32, 0);
pub const SQL_PARAM_SUCCESS_WITH_INFO = @as(u32, 6);
pub const SQL_PARAM_ERROR = @as(u32, 5);
pub const SQL_PARAM_UNUSED = @as(u32, 7);
pub const SQL_PARAM_DIAG_UNAVAILABLE = @as(u32, 1);
pub const SQL_PARAM_PROCEED = @as(u32, 0);
pub const SQL_PARAM_IGNORE = @as(u32, 1);
pub const SQL_CASCADE = @as(u32, 0);
pub const SQL_RESTRICT = @as(u32, 1);
pub const SQL_SET_NULL = @as(u32, 2);
pub const SQL_NO_ACTION = @as(u32, 3);
pub const SQL_SET_DEFAULT = @as(u32, 4);
pub const SQL_INITIALLY_DEFERRED = @as(u32, 5);
pub const SQL_INITIALLY_IMMEDIATE = @as(u32, 6);
pub const SQL_NOT_DEFERRABLE = @as(u32, 7);
pub const SQL_PARAM_TYPE_UNKNOWN = @as(u32, 0);
pub const SQL_PARAM_INPUT = @as(u32, 1);
pub const SQL_PARAM_INPUT_OUTPUT = @as(u32, 2);
pub const SQL_RESULT_COL = @as(u32, 3);
pub const SQL_PARAM_OUTPUT = @as(u32, 4);
pub const SQL_RETURN_VALUE = @as(u32, 5);
pub const SQL_PARAM_INPUT_OUTPUT_STREAM = @as(u32, 8);
pub const SQL_PARAM_OUTPUT_STREAM = @as(u32, 16);
pub const SQL_PT_UNKNOWN = @as(u32, 0);
pub const SQL_PT_PROCEDURE = @as(u32, 1);
pub const SQL_PT_FUNCTION = @as(u32, 2);
pub const SQL_YEAR = @as(u32, 1);
pub const SQL_MONTH = @as(u32, 2);
pub const SQL_DAY = @as(u32, 3);
pub const SQL_HOUR = @as(u32, 4);
pub const SQL_MINUTE = @as(u32, 5);
pub const SQL_SECOND = @as(u32, 6);
pub const SQL_YEAR_TO_MONTH = @as(u32, 7);
pub const SQL_DAY_TO_HOUR = @as(u32, 8);
pub const SQL_DAY_TO_MINUTE = @as(u32, 9);
pub const SQL_DAY_TO_SECOND = @as(u32, 10);
pub const SQL_HOUR_TO_MINUTE = @as(u32, 11);
pub const SQL_HOUR_TO_SECOND = @as(u32, 12);
pub const SQL_MINUTE_TO_SECOND = @as(u32, 13);
pub const SQL_DATABASE_NAME = @as(u32, 16);
pub const SQL_FD_FETCH_PREV = @as(i32, 8);
pub const SQL_FETCH_PREV = @as(u32, 4);
pub const SQL_CONCUR_TIMESTAMP = @as(u32, 3);
pub const SQL_SCCO_OPT_TIMESTAMP = @as(i32, 4);
pub const SQL_CC_DELETE = @as(u32, 0);
pub const SQL_CR_DELETE = @as(u32, 0);
pub const SQL_CC_CLOSE = @as(u32, 1);
pub const SQL_CR_CLOSE = @as(u32, 1);
pub const SQL_CC_PRESERVE = @as(u32, 2);
pub const SQL_CR_PRESERVE = @as(u32, 2);
pub const SQL_FETCH_RESUME = @as(u32, 7);
pub const SQL_SCROLL_FORWARD_ONLY = @as(i32, 0);
pub const SQL_SCROLL_KEYSET_DRIVEN = @as(i32, -1);
pub const SQL_SCROLL_DYNAMIC = @as(i32, -2);
pub const SQL_SCROLL_STATIC = @as(i32, -3);
pub const TRACE_VERSION = @as(u32, 1000);
pub const TRACE_ON = @as(i32, 1);
pub const TRACE_VS_EVENT_ON = @as(i32, 2);
pub const ODBC_VS_FLAG_UNICODE_ARG = @as(i32, 1);
pub const ODBC_VS_FLAG_UNICODE_COR = @as(i32, 2);
pub const ODBC_VS_FLAG_RETCODE = @as(i32, 4);
pub const ODBC_VS_FLAG_STOP = @as(i32, 8);
pub const CRESTRICTIONS_DBSCHEMA_LINKEDSERVERS = @as(u32, 1);
pub const SSPROP_ENABLEFASTLOAD = @as(u32, 2);
pub const SSPROP_UNICODELCID = @as(u32, 2);
pub const SSPROP_UNICODECOMPARISONSTYLE = @as(u32, 3);
pub const SSPROP_COLUMNLEVELCOLLATION = @as(u32, 4);
pub const SSPROP_CHARACTERSET = @as(u32, 5);
pub const SSPROP_SORTORDER = @as(u32, 6);
pub const SSPROP_CURRENTCOLLATION = @as(u32, 7);
pub const SSPROP_INIT_CURRENTLANGUAGE = @as(u32, 4);
pub const SSPROP_INIT_NETWORKADDRESS = @as(u32, 5);
pub const SSPROP_INIT_NETWORKLIBRARY = @as(u32, 6);
pub const SSPROP_INIT_USEPROCFORPREP = @as(u32, 7);
pub const SSPROP_INIT_AUTOTRANSLATE = @as(u32, 8);
pub const SSPROP_INIT_PACKETSIZE = @as(u32, 9);
pub const SSPROP_INIT_APPNAME = @as(u32, 10);
pub const SSPROP_INIT_WSID = @as(u32, 11);
pub const SSPROP_INIT_FILENAME = @as(u32, 12);
pub const SSPROP_INIT_ENCRYPT = @as(u32, 13);
pub const SSPROP_AUTH_REPL_SERVER_NAME = @as(u32, 14);
pub const SSPROP_INIT_TAGCOLUMNCOLLATION = @as(u32, 15);
pub const SSPROPVAL_USEPROCFORPREP_OFF = @as(u32, 0);
pub const SSPROPVAL_USEPROCFORPREP_ON = @as(u32, 1);
pub const SSPROPVAL_USEPROCFORPREP_ON_DROP = @as(u32, 2);
pub const SSPROP_QUOTEDCATALOGNAMES = @as(u32, 2);
pub const SSPROP_ALLOWNATIVEVARIANT = @as(u32, 3);
pub const SSPROP_SQLXMLXPROGID = @as(u32, 4);
pub const SSPROP_MAXBLOBLENGTH = @as(u32, 8);
pub const SSPROP_FASTLOADOPTIONS = @as(u32, 9);
pub const SSPROP_FASTLOADKEEPNULLS = @as(u32, 10);
pub const SSPROP_FASTLOADKEEPIDENTITY = @as(u32, 11);
pub const SSPROP_CURSORAUTOFETCH = @as(u32, 12);
pub const SSPROP_DEFERPREPARE = @as(u32, 13);
pub const SSPROP_IRowsetFastLoad = @as(u32, 14);
pub const SSPROP_COL_COLLATIONNAME = @as(u32, 14);
pub const SSPROP_STREAM_MAPPINGSCHEMA = @as(u32, 15);
pub const SSPROP_STREAM_XSL = @as(u32, 16);
pub const SSPROP_STREAM_BASEPATH = @as(u32, 17);
pub const SSPROP_STREAM_COMMANDTYPE = @as(u32, 18);
pub const SSPROP_STREAM_XMLROOT = @as(u32, 19);
pub const SSPROP_STREAM_FLAGS = @as(u32, 20);
pub const SSPROP_STREAM_CONTENTTYPE = @as(u32, 23);
pub const STREAM_FLAGS_DISALLOW_URL = @as(u32, 1);
pub const STREAM_FLAGS_DISALLOW_ABSOLUTE_PATH = @as(u32, 2);
pub const STREAM_FLAGS_DISALLOW_QUERY = @as(u32, 4);
pub const STREAM_FLAGS_DONTCACHEMAPPINGSCHEMA = @as(u32, 8);
pub const STREAM_FLAGS_DONTCACHETEMPLATE = @as(u32, 16);
pub const STREAM_FLAGS_DONTCACHEXSL = @as(u32, 32);
pub const STREAM_FLAGS_DISALLOW_UPDATEGRAMS = @as(u32, 64);
pub const STREAM_FLAGS_RESERVED = @as(u32, 4294901760);
pub const SSPROPVAL_COMMANDTYPE_REGULAR = @as(u32, 21);
pub const SSPROPVAL_COMMANDTYPE_BULKLOAD = @as(u32, 22);
pub const DBTYPE_SQLVARIANT = @as(u32, 144);
pub const SQL_HANDLE_DBC_INFO_TOKEN = @as(u32, 6);
pub const SQL_CONN_POOL_RATING_BEST = @as(u32, 100);
pub const SQL_CONN_POOL_RATING_GOOD_ENOUGH = @as(u32, 99);
pub const SQL_CONN_POOL_RATING_USELESS = @as(u32, 0);
pub const SQL_ATTR_DBC_INFO_TOKEN = @as(u32, 118);
pub const SQL_ATTR_ASYNC_DBC_NOTIFICATION_CALLBACK = @as(u32, 120);
pub const SQL_ATTR_ASYNC_DBC_NOTIFICATION_CONTEXT = @as(u32, 121);
pub const SQL_ATTR_ASYNC_STMT_NOTIFICATION_CALLBACK = @as(u32, 30);
pub const SQL_ATTR_ASYNC_STMT_NOTIFICATION_CONTEXT = @as(u32, 31);
pub const SQL_MAX_NUMERIC_LEN = @as(u32, 16);
pub const SQL_WCHAR = @as(i32, -8);
pub const SQL_WVARCHAR = @as(i32, -9);
pub const SQL_WLONGVARCHAR = @as(i32, -10);
pub const SQL_C_WCHAR = @as(i32, -8);
pub const SQL_C_TCHAR = @as(i32, -8);
pub const SQL_SQLSTATE_SIZEW = @as(u32, 10);
pub const CSTORAGEPROPERTY = @as(u32, 23);
pub const CATEGORY_SEARCH = @as(i32, 1);
pub const CATEGORY_COLLATOR = @as(i32, 2);
pub const CATEGORY_GATHERER = @as(i32, 3);
pub const CATEGORY_INDEXER = @as(i32, 4);
pub const EVENT_SSSEARCH_STARTED = @as(i32, 1073742827);
pub const EVENT_SSSEARCH_STARTING_SETUP = @as(i32, 1073742828);
pub const EVENT_SSSEARCH_SETUP_SUCCEEDED = @as(i32, 1073742829);
pub const EVENT_SSSEARCH_SETUP_FAILED = @as(i32, -1073740818);
pub const EVENT_OUTOFMEMORY = @as(i32, -1073740817);
pub const EVENT_SSSEARCH_SETUP_CLEANUP_STARTED = @as(i32, -2147482640);
pub const EVENT_EXCEPTION = @as(i32, -1073740815);
pub const EVENT_SSSEARCH_SETUP_CLEANUP_SUCCEEDED = @as(i32, 1073742834);
pub const EVENT_SSSEARCH_SETUP_CLEANUP_FAILED = @as(i32, -1073740813);
pub const EVENT_SSSEARCH_STOPPED = @as(i32, 1073742837);
pub const EVENT_SSSEARCH_CREATE_PATH_RULES_FAILED = @as(i32, -2147482634);
pub const EVENT_SSSEARCH_DROPPED_EVENTS = @as(i32, -2147482633);
pub const EVENT_SSSEARCH_DATAFILES_MOVE_FAILED = @as(i32, -1073740808);
pub const EVENT_SSSEARCH_DATAFILES_MOVE_SUCCEEDED = @as(i32, 1073742841);
pub const EVENT_SSSEARCH_DATAFILES_MOVE_ROLLBACK_ERRORS = @as(i32, -2147482630);
pub const EVENT_SSSEARCH_CSM_SAVE_FAILED = @as(i32, -1073740805);
pub const EVENT_CONFIG_SYNTAX = @as(i32, -2147482604);
pub const EVENT_UNPRIVILEGED_SERVICE_ACCOUNT = @as(i32, -2147482596);
pub const EVENT_SYSTEM_EXCEPTION = @as(i32, -2147482595);
pub const EVENT_CONFIG_ERROR = @as(i32, -1073738821);
pub const EVENT_GATHERSVC_PERFMON = @as(i32, -1073738818);
pub const EVENT_GATHERER_PERFMON = @as(i32, -1073738817);
pub const EVENT_HASHMAP_INSERT = @as(i32, -1073738816);
pub const EVENT_TRANSLOG_CREATE_TRX = @as(i32, -1073738815);
pub const EVENT_TRANSLOG_APPEND = @as(i32, -1073738814);
pub const EVENT_TRANSLOG_UPDATE = @as(i32, -1073738813);
pub const EVENT_HASHMAP_UPDATE = @as(i32, -1073738811);
pub const EVENT_GATHER_EXCEPTION = @as(i32, -1073738810);
pub const EVENT_TRANSACTION_READ = @as(i32, -1073738809);
pub const EVENT_GATHER_END_CRAWL = @as(i32, 1073744842);
pub const EVENT_GATHER_START_CRAWL = @as(i32, 1073744843);
pub const EVENT_GATHER_INTERNAL = @as(i32, -1073738804);
pub const EVENT_GATHER_CRAWL_NOT_STARTED = @as(i32, -2147480625);
pub const EVENT_GATHER_CRAWL_SEED_ERROR = @as(i32, -2147480624);
pub const EVENT_GATHER_CRITICAL_ERROR = @as(i32, -1073738799);
pub const EVENT_GATHER_ADVISE_FAILED = @as(i32, -1073738798);
pub const EVENT_GATHER_TRANSACTION_FAIL = @as(i32, -1073738797);
pub const EVENT_GATHER_OBJ_INIT_FAILED = @as(i32, -1073738796);
pub const EVENT_GATHER_PLUGIN_INIT_FAILED = @as(i32, -1073738795);
pub const EVENT_GATHER_SERVICE_INIT = @as(i32, -1073738794);
pub const EVENT_GATHER_CANT_CREATE_DOCID = @as(i32, -1073738793);
pub const EVENT_GATHER_CANT_DELETE_DOCID = @as(i32, -1073738792);
pub const EVENT_TRANSLOG_CREATE = @as(i32, -1073738791);
pub const EVENT_REG_VERSION = @as(i32, -1073738790);
pub const EVENT_GATHER_CRAWL_SEED_FAILED = @as(i32, -2147480612);
pub const EVENT_GATHER_CRAWL_SEED_FAILED_INIT = @as(i32, -2147480611);
pub const EVENT_GATHER_REG_MISSING = @as(i32, -2147480610);
pub const EVENT_GATHER_CRAWL_IN_PROGRESS = @as(i32, -2147480609);
pub const EVENT_GATHER_LOCK_FAILED = @as(i32, -1073738784);
pub const EVENT_GATHER_RESET_START = @as(i32, 1073744865);
pub const EVENT_GATHER_START_PAUSE = @as(i32, -2147480606);
pub const EVENT_GATHER_THROTTLE = @as(i32, 1073744867);
pub const EVENT_GATHER_RESUME = @as(i32, 1073744868);
pub const EVENT_GATHER_AUTODESCLEN_ADJUSTED = @as(i32, -2147480603);
pub const EVENT_GATHER_NO_CRAWL_SEEDS = @as(i32, -2147480602);
pub const EVENT_GATHER_END_INCREMENTAL = @as(i32, 1073744871);
pub const EVENT_GATHER_FROM_NOT_SET = @as(i32, -1073738776);
pub const EVENT_GATHER_DELETING_HISTORY_ITEMS = @as(i32, -1073738774);
pub const EVENT_GATHER_STOP_START = @as(i32, 1073744876);
pub const EVENT_GATHER_START_CRAWL_IF_RESET = @as(i32, -2147480595);
pub const EVENT_GATHER_DISK_FULL = @as(i32, -2147480594);
pub const EVENT_GATHER_NO_SCHEMA = @as(i32, -2147480593);
pub const EVENT_GATHER_AUTODESCENCODE_INVALID = @as(i32, -2147480592);
pub const EVENT_GATHER_PLUGINMGR_INIT_FAILED = @as(i32, -1073738767);
pub const EVENT_GATHER_APP_INIT_FAILED = @as(i32, -1073738766);
pub const EVENT_FAILED_INITIALIZE_CRAWL = @as(i32, -1073738765);
pub const EVENT_CRAWL_SCHEDULED = @as(i32, 1073744884);
pub const EVENT_FAILED_CREATE_GATHERER_LOG = @as(i32, -2147480587);
pub const EVENT_WBREAKER_NOT_LOADED = @as(i32, -2147480586);
pub const EVENT_LEARN_PROPAGATION_COPY_FAILED = @as(i32, -2147480585);
pub const EVENT_LEARN_CREATE_DB_FAILED = @as(i32, -2147480584);
pub const EVENT_LEARN_COMPILE_FAILED = @as(i32, -2147480583);
pub const EVENT_LEARN_PROPAGATION_FAILED = @as(i32, -2147480582);
pub const EVENT_GATHER_END_ADAPTIVE = @as(i32, 1073744891);
pub const EVENT_USING_DIFFERENT_WORD_BREAKER = @as(i32, -2147480580);
pub const EVENT_GATHER_RESTORE_COMPLETE = @as(i32, 3069);
pub const EVENT_GATHER_RESTORE_ERROR = @as(i32, -1073738754);
pub const EVENT_AUTOCAT_PERFMON = @as(i32, -1073738753);
pub const EVENT_GATHER_DIRTY_STARTUP = @as(i32, -2147480576);
pub const EVENT_GATHER_HISTORY_CORRUPTION_DETECTED = @as(i32, -2147480575);
pub const EVENT_GATHER_RESTOREAPP_ERROR = @as(i32, -1073738750);
pub const EVENT_GATHER_RESTOREAPP_COMPLETE = @as(i32, 3075);
pub const EVENT_GATHER_BACKUPAPP_ERROR = @as(i32, -1073738748);
pub const EVENT_GATHER_BACKUPAPP_COMPLETE = @as(i32, 3077);
pub const EVENT_GATHER_DAEMON_TERMINATED = @as(i32, -2147480570);
pub const EVENT_NOTIFICATION_FAILURE = @as(i32, -1073738745);
pub const EVENT_NOTIFICATION_FAILURE_SCOPE_EXCEEDED_LOGGING = @as(i32, -2147480568);
pub const EVENT_NOTIFICATION_RESTORED = @as(i32, 1073744905);
pub const EVENT_NOTIFICATION_RESTORED_SCOPE_EXCEEDED_LOGGING = @as(i32, -2147480566);
pub const EVENT_GATHER_PROTOCOLHANDLER_LOAD_FAILED = @as(i32, -1073738741);
pub const EVENT_GATHER_PROTOCOLHANDLER_INIT_FAILED = @as(i32, -1073738740);
pub const EVENT_GATHER_INVALID_NETWORK_ACCESS_ACCOUNT = @as(i32, -1073738739);
pub const EVENT_GATHER_SYSTEM_LCID_CHANGED = @as(i32, -2147480562);
pub const EVENT_GATHER_FLUSH_FAILED = @as(i32, -1073738737);
pub const EVENT_GATHER_CHECKPOINT_FAILED = @as(i32, -1073738736);
pub const EVENT_GATHER_SAVE_FAILED = @as(i32, -1073738735);
pub const EVENT_GATHER_RESTORE_CHECKPOINT_FAILED = @as(i32, -1073738734);
pub const EVENT_GATHER_READ_CHECKPOINT_FAILED = @as(i32, -1073738733);
pub const EVENT_GATHER_CHECKPOINT_CORRUPT = @as(i32, -1073738732);
pub const EVENT_GATHER_CHECKPOINT_FILE_MISSING = @as(i32, -1073738731);
pub const EVENT_STS_INIT_SECURITY_FAILED = @as(i32, -2147480554);
pub const EVENT_LOCAL_GROUP_NOT_EXPANDED = @as(i32, 1073744919);
pub const EVENT_LOCAL_GROUPS_CACHE_FLUSHED = @as(i32, 1073744920);
pub const EVENT_GATHERER_DATASOURCE = @as(i32, -1073738727);
pub const EVENT_AUTOCAT_CANT_CREATE_FILE_SHARE = @as(i32, -1073738726);
pub const EVENT_NOTIFICATION_THREAD_EXIT_FAILED = @as(i32, -1073738725);
pub const EVENT_FILTER_HOST_NOT_INITIALIZED = @as(i32, -1073738724);
pub const EVENT_FILTER_HOST_NOT_TERMINATED = @as(i32, -1073738723);
pub const EVENT_FILTERPOOL_ADD_FAILED = @as(i32, -1073738722);
pub const EVENT_FILTERPOOL_DELETE_FAILED = @as(i32, -1073738721);
pub const EVENT_ENUMERATE_SESSIONS_FAILED = @as(i32, -1073738720);
pub const EVENT_DETAILED_FILTERPOOL_ADD_FAILED = @as(i32, -1073738719);
pub const EVENT_AUDIENCECOMPUTATION_CANNOTSTART = @as(i32, -1073738223);
pub const EVENT_GATHER_RECOVERY_FAILURE = @as(i32, -1073738222);
pub const EVENT_INDEXER_STARTED = @as(i32, 1073748824);
pub const EVENT_INDEXER_SCHEMA_COPY_ERROR = @as(i32, -1073734823);
pub const EVENT_INDEXER_INIT_ERROR = @as(i32, -1073734814);
pub const EVENT_INDEXER_INVALID_DIRECTORY = @as(i32, -1073734813);
pub const EVENT_INDEXER_PROP_ERROR = @as(i32, -1073734812);
pub const EVENT_INDEXER_PAUSED_FOR_DISKFULL = @as(i32, -1073734811);
pub const EVENT_INDEXER_PROP_STOPPED = @as(i32, -2147476633);
pub const EVENT_INDEXER_PROP_SUCCEEDED = @as(i32, 7016);
pub const EVENT_INDEXER_PROP_STARTED = @as(i32, 1073748841);
pub const EVENT_INDEXER_NO_SEARCH_SERVERS = @as(i32, -2147476630);
pub const EVENT_INDEXER_ADD_DSS_SUCCEEDED = @as(i32, 7019);
pub const EVENT_INDEXER_REMOVE_DSS_SUCCEEDED = @as(i32, 7020);
pub const EVENT_INDEXER_ADD_DSS_FAILED = @as(i32, -2147476627);
pub const EVENT_INDEXER_REMOVE_DSS_FAILED = @as(i32, -1073734801);
pub const EVENT_INDEXER_DSS_CONTACT_FAILED = @as(i32, -1073734800);
pub const EVENT_INDEXER_BUILD_FAILED = @as(i32, -1073734797);
pub const EVENT_INDEXER_REG_MISSING = @as(i32, -1073734796);
pub const EVENT_INDEXER_PROPSTORE_INIT_FAILED = @as(i32, -1073734787);
pub const EVENT_INDEXER_CI_LOAD_ERROR = @as(i32, -1073734785);
pub const EVENT_INDEXER_RESET_FOR_CORRUPTION = @as(i32, -1073734784);
pub const EVENT_INDEXER_SHUTDOWN = @as(i32, 1073748866);
pub const EVENT_INDEXER_LOAD_FAIL = @as(i32, -1073734781);
pub const EVENT_INDEXER_PROP_STATE_CORRUPT = @as(i32, -1073734780);
pub const EVENT_INDEXER_DSS_ALREADY_ADDED = @as(i32, 1073748870);
pub const EVENT_INDEXER_BUILD_START = @as(i32, 1073748872);
pub const EVENT_INDEXER_BUILD_ENDED = @as(i32, 1073748873);
pub const EVENT_INDEXER_VERIFY_PROP_ACCOUNT = @as(i32, -1073734768);
pub const EVENT_INDEXER_ADD_DSS_DISCONNECT = @as(i32, -2147476585);
pub const EVENT_INDEXER_PERFMON = @as(i32, -1073734760);
pub const EVENT_INDEXER_MISSING_APP_DIRECTORY = @as(i32, -1073734758);
pub const EVENT_INDEXER_REG_ERROR = @as(i32, -1073734756);
pub const EVENT_INDEXER_DSS_UNABLE_TO_REMOVE = @as(i32, -1073734755);
pub const EVENT_INDEXER_NEW_PROJECT = @as(i32, -1073734754);
pub const EVENT_INDEXER_REMOVED_PROJECT = @as(i32, -1073734753);
pub const EVENT_INDEXER_PROP_COMMITTED = @as(i32, 1073748898);
pub const EVENT_INDEXER_PROP_ABORTED = @as(i32, 1073748899);
pub const EVENT_DSS_NOT_ENABLED = @as(i32, -2147476572);
pub const EVENT_INDEXER_PROP_COMMIT_FAILED = @as(i32, -1073734747);
pub const JET_INIT_ERROR = @as(i32, -1073732824);
pub const JET_NEW_PROP_STORE_ERROR = @as(i32, -1073732823);
pub const JET_GET_PROP_STORE_ERROR = @as(i32, -1073732822);
pub const JET_MULTIINSTANCE_DISABLED = @as(i32, -2147474645);
pub const EVENT_WARNING_CANNOT_UPGRADE_NOISE_FILES = @as(i32, -2147473635);
pub const EVENT_WARNING_CANNOT_UPGRADE_NOISE_FILE = @as(i32, -2147473634);
pub const EVENT_WIN32_ERROR = @as(i32, -2147473633);
pub const EVENT_PERF_COUNTERS_NOT_LOADED = @as(i32, -2147473628);
pub const EVENT_PERF_COUNTERS_REGISTRY_TROUBLE = @as(i32, -2147473627);
pub const EVENT_PERF_COUNTERS_ALREADY_EXISTS = @as(i32, -2147473626);
pub const EVENT_PROTOCOL_HOST_FORCE_TERMINATE = @as(i32, -2147473625);
pub const EVENT_FILTER_HOST_FORCE_TERMINATE = @as(i32, -2147473624);
pub const EVENT_INDEXER_OUT_OF_DATABASE_INSTANCE = @as(i32, -1073731799);
pub const EVENT_INDEXER_FAIL_TO_SET_MAX_JETINSTANCE = @as(i32, -1073731798);
pub const EVENT_INDEXER_FAIL_TO_CREATE_PER_USER_CATALOG = @as(i32, -1073731797);
pub const EVENT_INDEXER_FAIL_TO_UNLOAD_PER_USER_CATALOG = @as(i32, -1073731796);
pub const ERROR_SOURCE_NETWORKING = @as(u32, 768);
pub const ERROR_SOURCE_DATASOURCE = @as(u32, 1024);
pub const ERROR_SOURCE_COLLATOR = @as(u32, 1280);
pub const ERROR_SOURCE_CONNMGR = @as(u32, 1536);
pub const ERROR_SOURCE_QUERY = @as(u32, 1792);
pub const ERROR_SOURCE_SCHEMA = @as(u32, 3072);
pub const ERROR_SOURCE_GATHERER = @as(u32, 3328);
pub const ERROR_SOURCE_INDEXER = @as(u32, 4352);
pub const ERROR_SOURCE_SETUP = @as(u32, 4864);
pub const ERROR_SOURCE_SECURITY = @as(u32, 5120);
pub const ERROR_SOURCE_CMDLINE = @as(u32, 5376);
pub const ERROR_SOURCE_NLADMIN = @as(u32, 6400);
pub const ERROR_SOURCE_SCRIPTPI = @as(u32, 8192);
pub const ERROR_SOURCE_MSS = @as(u32, 8448);
pub const ERROR_SOURCE_XML = @as(u32, 8704);
pub const ERROR_SOURCE_DAV = @as(u32, 8960);
pub const ERROR_SOURCE_FLTRDMN = @as(u32, 9216);
pub const ERROR_SOURCE_OLEDB_BINDER = @as(u32, 9472);
pub const ERROR_SOURCE_NOTESPH = @as(u32, 9728);
pub const ERROR_SOURCE_EXSTOREPH = @as(u32, 9984);
pub const ERROR_SOURCE_SRCH_SCHEMA_CACHE = @as(u32, 13056);
pub const ERROR_SOURCE_CONTENT_SOURCE = @as(u32, 13312);
pub const ERROR_SOURCE_REMOTE_EXSTOREPH = @as(u32, 13568);
pub const ERROR_SOURCE_PEOPLE_IMPORT = @as(u32, 16384);
pub const ERROR_FTE = @as(u32, 13824);
pub const ERROR_FTE_CB = @as(u32, 51968);
pub const ERROR_FTE_FD = @as(u32, 64768);
pub const XML_E_NODEFAULTNS = @as(i32, -2147212800);
pub const XML_E_BADSXQL = @as(i32, -2147212799);
pub const MSS_E_INVALIDAPPNAME = @as(i32, -2147213056);
pub const MSS_E_APPNOTFOUND = @as(i32, -2147213055);
pub const MSS_E_APPALREADYEXISTS = @as(i32, -2147213054);
pub const MSS_E_CATALOGNOTFOUND = @as(i32, -2147213053);
pub const MSS_E_CATALOGSTOPPING = @as(i32, -2147213052);
pub const MSS_E_UNICODEFILEHEADERMISSING = @as(i32, -2147213051);
pub const MSS_E_CATALOGALREADYEXISTS = @as(i32, -2147213050);
pub const NET_E_GENERAL = @as(i32, -2147220736);
pub const NET_E_DISCONNECTED = @as(i32, -2147220733);
pub const NET_E_INVALIDPARAMS = @as(i32, -2147220728);
pub const NET_E_OPERATIONINPROGRESS = @as(i32, -2147220727);
pub const SEC_E_INVALIDCONTEXT = @as(i32, -2147216381);
pub const SEC_E_INITFAILED = @as(i32, -2147216383);
pub const SEC_E_NOTINITIALIZED = @as(i32, -2147216382);
pub const SEC_E_ACCESSDENIED = @as(i32, -2147216129);
pub const DS_E_NOMOREDATA = @as(i32, -2147220480);
pub const DS_E_INVALIDDATASOURCE = @as(i32, -2147220479);
pub const DS_E_DATASOURCENOTAVAILABLE = @as(i32, -2147220478);
pub const DS_E_QUERYCANCELED = @as(i32, -2147220477);
pub const DS_E_UNKNOWNREQUEST = @as(i32, -2147220476);
pub const DS_E_BADREQUEST = @as(i32, -2147220475);
pub const DS_E_SERVERCAPACITY = @as(i32, -2147220474);
pub const DS_E_BADSEQUENCE = @as(i32, -2147220473);
pub const DS_E_MESSAGETOOLONG = @as(i32, -2147220472);
pub const DS_E_SERVERERROR = @as(i32, -2147220471);
pub const DS_E_CONFIGBAD = @as(i32, -2147220470);
pub const DS_E_DATANOTPRESENT = @as(i32, -2147220464);
pub const DS_E_SETSTATUSINPROGRESS = @as(i32, -2147220463);
pub const DS_E_DUPLICATEID = @as(i32, -2147220462);
pub const DS_E_TOOMANYDATASOURCES = @as(i32, -2147220461);
pub const DS_E_REGISTRY = @as(i32, -2147220460);
pub const DS_E_DATASOURCENOTDISABLED = @as(i32, -2147220459);
pub const DS_E_INVALIDTAGDB = @as(i32, -2147220458);
pub const DS_E_INVALIDCATALOGNAME = @as(i32, -2147220457);
pub const DS_E_CONFIGNOTRIGHTTYPE = @as(i32, -2147220456);
pub const DS_E_PROTOCOLVERSION = @as(i32, -2147220455);
pub const DS_E_ALREADYENABLED = @as(i32, -2147220454);
pub const DS_E_INDEXDIRECTORY = @as(i32, -2147220452);
pub const DS_E_VALUETOOLARGE = @as(i32, -2147220451);
pub const DS_E_UNKNOWNPARAM = @as(i32, -2147220450);
pub const DS_E_BUFFERTOOSMALL = @as(i32, -2147220449);
pub const DS_E_PARAMOUTOFRANGE = @as(i32, -2147220448);
pub const DS_E_ALREADYDISABLED = @as(i32, -2147220447);
pub const DS_E_QUERYHUNG = @as(i32, -2147220446);
pub const DS_E_BADRESULT = @as(i32, -2147220445);
pub const DS_E_CANNOTWRITEREGISTRY = @as(i32, -2147220444);
pub const DS_E_CANNOTREMOVECONCURRENT = @as(i32, -2147220443);
pub const DS_E_SEARCHCATNAMECOLLISION = @as(i32, -2147220442);
pub const DS_E_PROPVERSIONMISMATCH = @as(i32, -2147220441);
pub const DS_E_MISSINGCATALOG = @as(i32, -2147220440);
pub const COLL_E_BADSEQUENCE = @as(i32, -2147220223);
pub const COLL_E_NOMOREDATA = @as(i32, -2147220222);
pub const COLL_E_INCOMPATIBLECOLUMNS = @as(i32, -2147220221);
pub const COLL_E_BUFFERTOOSMALL = @as(i32, -2147220220);
pub const COLL_E_BADRESULT = @as(i32, -2147220218);
pub const COLL_E_NOSORTCOLUMN = @as(i32, -2147220217);
pub const COLL_E_DUPLICATEDBID = @as(i32, -2147220216);
pub const COLL_E_TOOMANYMERGECOLUMNS = @as(i32, -2147220215);
pub const COLL_E_NODEFAULTCATALOG = @as(i32, -2147220214);
pub const COLL_E_MAXCONNEXCEEDED = @as(i32, -2147220213);
pub const CM_E_TOOMANYDATASERVERS = @as(i32, -2147219967);
pub const CM_E_TOOMANYDATASOURCES = @as(i32, -2147219966);
pub const CM_E_NOQUERYCONNECTIONS = @as(i32, -2147219965);
pub const CM_E_DATASOURCENOTAVAILABLE = @as(i32, -2147219964);
pub const CM_E_CONNECTIONTIMEOUT = @as(i32, -2147219963);
pub const CM_E_SERVERNOTFOUND = @as(i32, -2147219962);
pub const CM_S_NODATASERVERS = @as(i32, 263687);
pub const CM_E_REGISTRY = @as(i32, -2147219960);
pub const CM_E_INVALIDDATASOURCE = @as(i32, -2147219959);
pub const CM_E_TIMEOUT = @as(i32, -2147219958);
pub const CM_E_INSUFFICIENTBUFFER = @as(i32, -2147219957);
pub const QRY_E_QUERYSYNTAX = @as(i32, -2147219711);
pub const QRY_E_TYPEMISMATCH = @as(i32, -2147219710);
pub const QRY_E_UNHANDLEDTYPE = @as(i32, -2147219709);
pub const QRY_S_NOROWSFOUND = @as(i32, 263940);
pub const QRY_E_TOOMANYCOLUMNS = @as(i32, -2147219707);
pub const QRY_E_TOOMANYDATABASES = @as(i32, -2147219706);
pub const QRY_E_STARTHITTOBIG = @as(i32, -2147219705);
pub const QRY_E_TOOMANYQUERYTERMS = @as(i32, -2147219704);
pub const QRY_E_NODATASOURCES = @as(i32, -2147219703);
pub const QRY_E_TIMEOUT = @as(i32, -2147219702);
pub const QRY_E_COLUMNNOTSORTABLE = @as(i32, -2147219701);
pub const QRY_E_COLUMNNOTSEARCHABLE = @as(i32, -2147219700);
pub const QRY_E_INVALIDCOLUMN = @as(i32, -2147219699);
pub const QRY_E_QUERYCORRUPT = @as(i32, -2147219698);
pub const QRY_E_PREFIXWILDCARD = @as(i32, -2147219697);
pub const QRY_E_INFIXWILDCARD = @as(i32, -2147219696);
pub const QRY_E_WILDCARDPREFIXLENGTH = @as(i32, -2147219695);
pub const QRY_S_TERMIGNORED = @as(i32, 263954);
pub const QRY_E_ENGINEFAILED = @as(i32, -2147219693);
pub const QRY_E_SEARCHTOOBIG = @as(i32, -2147219692);
pub const QRY_E_NULLQUERY = @as(i32, -2147219691);
pub const QRY_S_INEXACTRESULTS = @as(i32, 263958);
pub const QRY_E_NOCOLUMNS = @as(i32, -2147219689);
pub const QRY_E_INVALIDSCOPES = @as(i32, -2147219688);
pub const QRY_E_INVALIDCATALOG = @as(i32, -2147219687);
pub const QRY_E_SCOPECARDINALIDY = @as(i32, -2147219686);
pub const QRY_E_UNEXPECTED = @as(i32, -2147219685);
pub const QRY_E_INVALIDPATH = @as(i32, -2147219684);
pub const QRY_E_LMNOTINITIALIZED = @as(i32, -2147219683);
pub const QRY_E_INVALIDINTERVAL = @as(i32, -2147219682);
pub const QRY_E_NOLOGMANAGER = @as(i32, -2147219681);
pub const SCHEMA_E_LOAD_SPECIAL = @as(i32, -2147218431);
pub const SCHEMA_E_FILENOTFOUND = @as(i32, -2147218430);
pub const SCHEMA_E_NESTEDTAG = @as(i32, -2147218429);
pub const SCHEMA_E_UNEXPECTEDTAG = @as(i32, -2147218428);
pub const SCHEMA_E_VERSIONMISMATCH = @as(i32, -2147218427);
pub const SCHEMA_E_CANNOTCREATEFILE = @as(i32, -2147218426);
pub const SCHEMA_E_CANNOTWRITEFILE = @as(i32, -2147218425);
pub const SCHEMA_E_EMPTYFILE = @as(i32, -2147218424);
pub const SCHEMA_E_INVALIDFILETYPE = @as(i32, -2147218423);
pub const SCHEMA_E_INVALIDDATATYPE = @as(i32, -2147218422);
pub const SCHEMA_E_CANNOTCREATENOISEWORDFILE = @as(i32, -2147218421);
pub const SCHEMA_E_ADDSTOPWORDS = @as(i32, -2147218420);
pub const SCHEMA_E_NAMEEXISTS = @as(i32, -2147218419);
pub const SCHEMA_E_INVALIDVALUE = @as(i32, -2147218418);
pub const SCHEMA_E_BADPROPSPEC = @as(i32, -2147218417);
pub const SCHEMA_E_NOMORECOLUMNS = @as(i32, -2147218416);
pub const SCHEMA_E_FILECHANGED = @as(i32, -2147218415);
pub const SCHEMA_E_BADCOLUMNNAME = @as(i32, -2147218414);
pub const SCHEMA_E_BADPROPPID = @as(i32, -2147218413);
pub const SCHEMA_E_BADATTRIBUTE = @as(i32, -2147218412);
pub const SCHEMA_E_BADFILENAME = @as(i32, -2147218411);
pub const SCHEMA_E_PROPEXISTS = @as(i32, -2147218410);
pub const SCHEMA_E_DUPLICATENOISE = @as(i32, -2147218409);
pub const GTHR_E_DUPLICATE_OBJECT = @as(i32, -2147218174);
pub const GTHR_E_UNABLE_TO_READ_REGISTRY = @as(i32, -2147218173);
pub const GTHR_E_ERROR_WRITING_REGISTRY = @as(i32, -2147218172);
pub const GTHR_E_ERROR_INITIALIZING_PERFMON = @as(i32, -2147218171);
pub const GTHR_E_ERROR_OBJECT_NOT_FOUND = @as(i32, -2147218170);
pub const GTHR_E_URL_EXCLUDED = @as(i32, -2147218169);
pub const GTHR_E_CONFIG_DUP_PROJECT = @as(i32, -2147218166);
pub const GTHR_E_CONFIG_DUP_EXTENSION = @as(i32, -2147218165);
pub const GTHR_E_DUPLICATE_URL = @as(i32, -2147218163);
pub const GTHR_E_TOO_MANY_PLUGINS = @as(i32, -2147218162);
pub const GTHR_E_INVALIDFUNCTION = @as(i32, -2147218161);
pub const GTHR_E_NOFILTERSINK = @as(i32, -2147218160);
pub const GTHR_E_FILTER_PROCESS_TERMINATED = @as(i32, -2147218159);
pub const GTHR_E_FILTER_INVALID_MESSAGE = @as(i32, -2147218158);
pub const GTHR_E_UNSUPPORTED_PROPERTY_TYPE = @as(i32, -2147218157);
pub const GTHR_E_NAME_TOO_LONG = @as(i32, -2147218156);
pub const GTHR_E_NO_IDENTITY = @as(i32, -2147218155);
pub const GTHR_E_FILTER_NOT_FOUND = @as(i32, -2147218154);
pub const GTHR_E_FILTER_NO_MORE_THREADS = @as(i32, -2147218153);
pub const GTHR_E_PRT_HNDLR_PROGID_MISSING = @as(i32, -2147218152);
pub const GTHR_E_FILTER_PROCESS_TERMINATED_QUOTA = @as(i32, -2147218151);
pub const GTHR_E_UNKNOWN_PROTOCOL = @as(i32, -2147218150);
pub const GTHR_E_PROJECT_NOT_INITIALIZED = @as(i32, -2147218149);
pub const GTHR_S_STATUS_CHANGE_IGNORED = @as(i32, 265500);
pub const GTHR_S_STATUS_END_CRAWL = @as(i32, 265501);
pub const GTHR_S_STATUS_RESET = @as(i32, 265502);
pub const GTHR_S_STATUS_THROTTLE = @as(i32, 265503);
pub const GTHR_S_STATUS_RESUME = @as(i32, 265504);
pub const GTHR_S_STATUS_PAUSE = @as(i32, 265505);
pub const GTHR_E_INVALID_PROJECT_NAME = @as(i32, -2147218142);
pub const GTHR_E_SHUTTING_DOWN = @as(i32, -2147218141);
pub const GTHR_S_END_STD_CHUNKS = @as(i32, 265508);
pub const GTHR_E_VALUE_NOT_AVAILABLE = @as(i32, -2147218139);
pub const GTHR_E_OUT_OF_DOC_ID = @as(i32, -2147218138);
pub const GTHR_E_NOTIFICATION_START_PAGE = @as(i32, -2147218137);
pub const GTHR_E_DUP_PROPERTY_MAPPING = @as(i32, -2147218134);
pub const GTHR_S_NO_CRAWL_SEEDS = @as(i32, 265515);
pub const GTHR_E_INVALID_ACCOUNT = @as(i32, -2147218132);
pub const GTHR_E_FILTER_INIT = @as(i32, -2147218130);
pub const GTHR_E_INVALID_ACCOUNT_SYNTAX = @as(i32, -2147218129);
pub const GTHR_S_CANNOT_FILTER = @as(i32, 265520);
pub const GTHR_E_PROXY_NAME = @as(i32, -2147218127);
pub const GTHR_E_SERVER_UNAVAILABLE = @as(i32, -2147218126);
pub const GTHR_S_STATUS_STOP = @as(i32, 265523);
pub const GTHR_E_INVALID_PATH = @as(i32, -2147218124);
pub const GTHR_E_FILTER_NO_CODEPAGE = @as(i32, -2147218123);
pub const GTHR_S_STATUS_START = @as(i32, 265526);
pub const GTHR_E_NO_PRTCLHNLR = @as(i32, -2147218121);
pub const GTHR_E_IE_OFFLINE = @as(i32, -2147218120);
pub const GTHR_E_BAD_FILTER_DAEMON = @as(i32, -2147218119);
pub const GTHR_E_INVALID_MAPPING = @as(i32, -2147218112);
pub const GTHR_E_USER_AGENT_NOT_SPECIFIED = @as(i32, -2147218111);
pub const GTHR_E_FROM_NOT_SPECIFIED = @as(i32, -2147218109);
pub const GTHR_E_INVALID_STREAM_LOGS_COUNT = @as(i32, -2147218108);
pub const GTHR_E_INVALID_EXTENSION = @as(i32, -2147218107);
pub const GTHR_E_INVALID_GROW_FACTOR = @as(i32, -2147218106);
pub const GTHR_E_INVALID_TIME_OUT = @as(i32, -2147218105);
pub const GTHR_E_INVALID_RETRIES = @as(i32, -2147218104);
pub const GTHR_E_INVALID_LOG_FILE_NAME = @as(i32, -2147218103);
pub const GTHR_E_INVALID_HOST_NAME = @as(i32, -2147218096);
pub const GTHR_E_INVALID_START_PAGE = @as(i32, -2147218095);
pub const GTHR_E_DUPLICATE_PROJECT = @as(i32, -2147218094);
pub const GTHR_E_INVALID_DIRECTORY = @as(i32, -2147218093);
pub const GTHR_E_FILTER_INTERRUPTED = @as(i32, -2147218092);
pub const GTHR_E_INVALID_PROXY_PORT = @as(i32, -2147218091);
pub const GTHR_S_CONFIG_HAS_ACCOUNTS = @as(i32, 265558);
pub const GTHR_E_SECRET_NOT_FOUND = @as(i32, -2147218089);
pub const GTHR_E_INVALID_PATH_EXPRESSION = @as(i32, -2147218088);
pub const GTHR_E_INVALID_START_PAGE_HOST = @as(i32, -2147218087);
pub const GTHR_E_INVALID_START_PAGE_PATH = @as(i32, -2147218080);
pub const GTHR_E_APPLICATION_NOT_FOUND = @as(i32, -2147218079);
pub const GTHR_E_CANNOT_REMOVE_PLUGINMGR = @as(i32, -2147218078);
pub const GTHR_E_INVALID_APPLICATION_NAME = @as(i32, -2147218077);
pub const GTHR_E_FILTER_FAULT = @as(i32, -2147218075);
pub const GTHR_E_NON_FIXED_DRIVE = @as(i32, -2147218074);
pub const GTHR_S_PROB_NOT_MODIFIED = @as(i32, 265575);
pub const GTHR_S_CRAWL_SCHEDULED = @as(i32, 265576);
pub const GTHR_S_TRANSACTION_IGNORED = @as(i32, 265577);
pub const GTHR_S_START_FILTER_FROM_PROTOCOL = @as(i32, 265578);
pub const GTHR_E_FILTER_SINGLE_THREADED = @as(i32, -2147218069);
pub const GTHR_S_BAD_FILE_LINK = @as(i32, 265580);
pub const GTHR_E_URL_UNIDENTIFIED = @as(i32, -2147218067);
pub const GTHR_S_NOT_ALL_PARTS = @as(i32, 265582);
pub const GTHR_E_FORCE_NOTIFICATION_RESET = @as(i32, -2147218065);
pub const GTHR_S_END_PROCESS_LOOP_NOTIFY_QUEUE = @as(i32, 265584);
pub const GTHR_S_START_FILTER_FROM_BODY = @as(i32, 265585);
pub const GTHR_E_CONTENT_ID_CONFLICT = @as(i32, -2147218062);
pub const GTHR_E_UNABLE_TO_READ_EXCHANGE_STORE = @as(i32, -2147218061);
pub const GTHR_E_RECOVERABLE_EXOLEDB_ERROR = @as(i32, -2147218060);
pub const GTHR_E_INVALID_CALL_FROM_WBREAKER = @as(i32, -2147218058);
pub const GTHR_E_PROPERTY_LIST_NOT_INITIALIZED = @as(i32, -2147218057);
pub const GTHR_S_MODIFIED_PARTS = @as(i32, 265592);
pub const GHTR_E_LOCAL_SERVER_UNAVAILABLE = @as(i32, -2147218055);
pub const GTHR_E_SCHEMA_ERRORS_OCCURRED = @as(i32, -2147218054);
pub const GTHR_E_TIMEOUT = @as(i32, -2147218053);
pub const GTHR_S_CRAWL_FULL = @as(i32, 265603);
pub const GTHR_S_CRAWL_INCREMENTAL = @as(i32, 265604);
pub const GTHR_S_CRAWL_ADAPTIVE = @as(i32, 265605);
pub const GTHR_E_NOTIFICATION_START_ADDRESS_INVALID = @as(i32, -2147218042);
pub const GTHR_E_NOTIFICATION_TYPE_NOT_SUPPORTED = @as(i32, -2147218041);
pub const GTHR_E_NOTIFICATION_FILE_SHARE_INFO_NOT_AVAILABLE = @as(i32, -2147218040);
pub const GTHR_E_NOTIFICATION_LOCAL_PATH_MUST_USE_FIXED_DRIVE = @as(i32, -2147218039);
pub const GHTR_E_INSUFFICIENT_DISK_SPACE = @as(i32, -2147218037);
pub const GTHR_E_INVALID_RESOURCE_ID = @as(i32, -2147218035);
pub const GTHR_E_NESTED_HIERARCHICAL_START_ADDRESSES = @as(i32, -2147218034);
pub const GTHR_S_NO_INDEX = @as(i32, 265616);
pub const GTHR_S_PAUSE_REASON_EXTERNAL = @as(i32, 265618);
pub const GTHR_S_PAUSE_REASON_UPGRADING = @as(i32, 265619);
pub const GTHR_S_PAUSE_REASON_BACKOFF = @as(i32, 265620);
pub const GTHR_E_RETRY = @as(i32, -2147218027);
pub const GTHR_E_JET_BACKUP_ERROR = @as(i32, -2147218026);
pub const GTHR_E_JET_RESTORE_ERROR = @as(i32, -2147218025);
pub const GTHR_S_OFFICE_CHILD = @as(i32, 265626);
pub const GTHR_E_PLUGIN_NOT_REGISTERED = @as(i32, -2147218021);
pub const GTHR_E_NOTIF_ACCESS_TOKEN_UPDATED = @as(i32, -2147218020);
pub const GTHR_E_DIRMON_NOT_INITIALZED = @as(i32, -2147218019);
pub const GTHR_E_NOTIF_BEING_REMOVED = @as(i32, -2147218018);
pub const GTHR_E_NOTIF_EXCESSIVE_THROUGHPUT = @as(i32, -2147218017);
pub const GTHR_E_INVALID_PATH_SPEC = @as(i32, -2147218016);
pub const GTHR_E_INSUFFICIENT_FEATURE_TERMS = @as(i32, -2147218015);
pub const GTHR_E_INSUFFICIENT_EXAMPLE_CATEGORIES = @as(i32, -2147218014);
pub const GTHR_E_INSUFFICIENT_EXAMPLE_DOCUMENTS = @as(i32, -2147218013);
pub const GTHR_E_AUTOCAT_UNEXPECTED = @as(i32, -2147218012);
pub const GTHR_E_SINGLE_THREADED_EMBEDDING = @as(i32, -2147218011);
pub const GTHR_S_CANNOT_WORDBREAK = @as(i32, 265638);
pub const GTHR_S_USE_MIME_FILTER = @as(i32, 265639);
pub const GTHR_E_FOLDER_CRAWLED_BY_ANOTHER_WORKSPACE = @as(i32, -2147218007);
pub const GTHR_E_EMPTY_DACL = @as(i32, -2147218006);
pub const GTHR_E_OBJECT_NOT_VALID = @as(i32, -2147218005);
pub const GTHR_E_CANNOT_ENABLE_CHECKPOINT = @as(i32, -2147218002);
pub const GTHR_E_SCOPES_EXCEEDED = @as(i32, -2147218001);
pub const GTHR_E_PROPERTIES_EXCEEDED = @as(i32, -2147218000);
pub const GTHR_E_INVALID_START_ADDRESS = @as(i32, -2147217998);
pub const GTHR_S_PAUSE_REASON_PROFILE_IMPORT = @as(i32, 265651);
pub const GTHR_E_PIPE_NOT_CONNECTTED = @as(i32, -2147217996);
pub const GTHR_E_BACKUP_VALIDATION_FAIL = @as(i32, -2147217994);
pub const GTHR_E_BAD_FILTER_HOST = @as(i32, -2147217993);
pub const GTHR_E_NTF_CLIENT_NOT_SUBSCRIBED = @as(i32, -1073476167);
pub const GTHR_E_FILTERPOOL_NOTFOUND = @as(i32, -2147217990);
pub const GTHR_E_ADDLINKS_FAILED_WILL_RETRY_PARENT = @as(i32, -2147217989);
pub const IDX_E_INVALIDTAG = @as(i32, -2147217151);
pub const IDX_E_METAFILE_CORRUPT = @as(i32, -2147217150);
pub const IDX_E_TOO_MANY_SEARCH_SERVERS = @as(i32, -2147217149);
pub const IDX_E_SEARCH_SERVER_ALREADY_EXISTS = @as(i32, -2147217148);
pub const IDX_E_BUILD_IN_PROGRESS = @as(i32, -2147217147);
pub const IDX_E_IDXLSTFILE_CORRUPT = @as(i32, -2147217146);
pub const IDX_E_REGISTRY_ENTRY = @as(i32, -2147217145);
pub const IDX_E_OBJECT_NOT_FOUND = @as(i32, -2147217144);
pub const IDX_E_SEARCH_SERVER_NOT_FOUND = @as(i32, -2147217143);
pub const IDX_E_WB_NOTFOUND = @as(i32, -2147217142);
pub const IDX_E_NOISELIST_NOTFOUND = @as(i32, -2147217141);
pub const IDX_E_STEMMER_NOTFOUND = @as(i32, -2147217140);
pub const IDX_E_PROP_STOPPED = @as(i32, -2147217139);
pub const IDX_E_DISKFULL = @as(i32, -2147217138);
pub const IDX_E_INVALID_INDEX = @as(i32, -2147217137);
pub const IDX_E_CORRUPT_INDEX = @as(i32, -2147217136);
pub const IDX_E_PROPSTORE_INIT_FAILED = @as(i32, -2147217134);
pub const IDX_E_PROP_STATE_CORRUPT = @as(i32, -2147217133);
pub const IDX_S_NO_BUILD_IN_PROGRESS = @as(i32, 266516);
pub const IDX_S_SEARCH_SERVER_ALREADY_EXISTS = @as(i32, 266517);
pub const IDX_S_SEARCH_SERVER_DOES_NOT_EXIST = @as(i32, 266518);
pub const IDX_E_NOT_LOADED = @as(i32, -2147217129);
pub const IDX_E_PROP_MAJOR_VERSION_MISMATCH = @as(i32, -2147217128);
pub const IDX_E_PROP_MINOR_VERSION_MISMATCH = @as(i32, -2147217127);
pub const IDX_E_DSS_NOT_CONNECTED = @as(i32, -2147217126);
pub const IDX_E_DOCUMENT_ABORTED = @as(i32, -2147217125);
pub const IDX_E_CATALOG_DISMOUNTED = @as(i32, -2147217124);
pub const IDX_S_DSS_NOT_AVAILABLE = @as(i32, 266525);
pub const IDX_E_USE_DEFAULT_CONTENTCLASS = @as(i32, -2147217121);
pub const IDX_E_USE_APPGLOBAL_PROPTABLE = @as(i32, -2147217120);
pub const JPS_E_JET_ERR = @as(i32, -2147217025);
pub const JPS_S_DUPLICATE_DOC_DETECTED = @as(i32, 266624);
pub const JPS_E_CATALOG_DECSRIPTION_MISSING = @as(i32, -2147217023);
pub const JPS_E_MISSING_INFORMATION = @as(i32, -2147217022);
pub const JPS_E_INSUFFICIENT_VERSION_STORAGE = @as(i32, -2147217021);
pub const JPS_E_INSUFFICIENT_DATABASE_SESSIONS = @as(i32, -2147217020);
pub const JPS_E_INSUFFICIENT_DATABASE_RESOURCES = @as(i32, -2147217019);
pub const JPS_E_SCHEMA_ERROR = @as(i32, -2147217018);
pub const JPS_E_PROPAGATION_FILE = @as(i32, -2147217017);
pub const JPS_E_PROPAGATION_CORRUPTION = @as(i32, -2147217016);
pub const JPS_E_PROPAGATION_VERSION_MISMATCH = @as(i32, -2147217015);
pub const JPS_E_SHARING_VIOLATION = @as(i32, -2147217014);
pub const EXCI_E_NO_CONFIG = @as(i32, -2147216992);
pub const EXCI_E_INVALID_SERVER_CONFIG = @as(i32, -2147216991);
pub const EXCI_E_ACCESS_DENIED = @as(i32, -2147216990);
pub const EXCI_E_INVALID_EXCHANGE_SERVER = @as(i32, -2147216989);
pub const EXCI_E_BADCONFIG_OR_ACCESSDENIED = @as(i32, -2147216988);
pub const EXCI_E_WRONG_SERVER_OR_ACCT = @as(i32, -2147216987);
pub const EXCI_E_NOT_ADMIN_OR_WRONG_SITE = @as(i32, -2147216986);
pub const EXCI_E_NO_MAPI = @as(i32, -2147216985);
pub const EXCI_E_INVALID_ACCOUNT_INFO = @as(i32, -2147216984);
pub const PRTH_E_INTERNAL_ERROR = @as(i32, -2147216892);
pub const PRTH_S_MAX_GROWTH = @as(i32, 266761);
pub const PRTH_E_WININET = @as(i32, -2147216886);
pub const PRTH_E_RETRY = @as(i32, -2147216885);
pub const PRTH_S_MAX_DOWNLOAD = @as(i32, 266764);
pub const PRTH_E_MIME_EXCLUDED = @as(i32, -2147216883);
pub const PRTH_E_CANT_TRANSFORM_EXTERNAL_ACL = @as(i32, -2147216882);
pub const PRTH_E_CANT_TRANSFORM_DENIED_ACE = @as(i32, -2147216881);
pub const PRTH_E_NO_PROPERTY = @as(i32, -2147216877);
pub const PRTH_S_USE_ROSEBUD = @as(i32, 266772);
pub const PRTH_E_DATABASE_OPEN_ERROR = @as(i32, -2147216875);
pub const PRTH_E_OPLOCK_BROKEN = @as(i32, -2147216874);
pub const PRTH_E_LOAD_FAILED = @as(i32, -2147216873);
pub const PRTH_E_INIT_FAILED = @as(i32, -2147216872);
pub const PRTH_E_VOLUME_MOUNT_POINT = @as(i32, -2147216871);
pub const PRTH_E_TRUNCATED = @as(i32, -2147216870);
pub const GTHR_E_LOCAL_GROUPS_EXPANSION_INTERNAL_ERROR = @as(i32, -2147216867);
pub const PRTH_E_HTTPS_CERTIFICATE_ERROR = @as(i32, -2147216861);
pub const PRTH_E_HTTPS_REQUIRE_CERTIFICATE = @as(i32, -2147216860);
pub const PRTH_S_TRY_IMPERSONATING = @as(i32, 266789);
pub const CMDLINE_E_UNEXPECTED = @as(i32, -2147216127);
pub const CMDLINE_E_PAREN = @as(i32, -2147216126);
pub const CMDLINE_E_PARAM_SIZE = @as(i32, -2147216125);
pub const CMDLINE_E_NOT_INIT = @as(i32, -2147216124);
pub const CMDLINE_E_ALREADY_INIT = @as(i32, -2147216123);
pub const CMDLINE_E_NUM_PARAMS = @as(i32, -2147216122);
pub const NLADMIN_E_DUPLICATE_CATALOG = @as(i32, -2147215103);
pub const NLADMIN_S_NOT_ALL_BUILD_CATALOGS_INITIALIZED = @as(i32, 268546);
pub const NLADMIN_E_FAILED_TO_GIVE_ACCOUNT_PRIVILEGE = @as(i32, -2147215101);
pub const NLADMIN_E_BUILD_CATALOG_NOT_INITIALIZED = @as(i32, -2147215100);
pub const SCRIPTPI_E_CHUNK_NOT_TEXT = @as(i32, -2147213312);
pub const SCRIPTPI_E_PID_NOT_NAME = @as(i32, -2147213311);
pub const SCRIPTPI_E_PID_NOT_NUMERIC = @as(i32, -2147213310);
pub const SCRIPTPI_E_CHUNK_NOT_VALUE = @as(i32, -2147213309);
pub const SCRIPTPI_E_CANNOT_ALTER_CHUNK = @as(i32, -2147213308);
pub const SCRIPTPI_E_ALREADY_COMPLETED = @as(i32, -2147213307);
pub const _MAPI_E_NO_SUPPORT = @as(i32, -2147221246);
pub const _MAPI_E_BAD_CHARWIDTH = @as(i32, -2147221245);
pub const _MAPI_E_STRING_TOO_LONG = @as(i32, -2147221243);
pub const _MAPI_E_UNKNOWN_FLAGS = @as(i32, -2147221242);
pub const _MAPI_E_INVALID_ENTRYID = @as(i32, -2147221241);
pub const _MAPI_E_INVALID_OBJECT = @as(i32, -2147221240);
pub const _MAPI_E_OBJECT_CHANGED = @as(i32, -2147221239);
pub const _MAPI_E_OBJECT_DELETED = @as(i32, -2147221238);
pub const _MAPI_E_BUSY = @as(i32, -2147221237);
pub const _MAPI_E_NOT_ENOUGH_DISK = @as(i32, -2147221235);
pub const _MAPI_E_NOT_ENOUGH_RESOURCES = @as(i32, -2147221234);
pub const _MAPI_E_NOT_FOUND = @as(i32, -2147221233);
pub const _MAPI_E_VERSION = @as(i32, -2147221232);
pub const _MAPI_E_LOGON_FAILED = @as(i32, -2147221231);
pub const _MAPI_E_SESSION_LIMIT = @as(i32, -2147221230);
pub const _MAPI_E_USER_CANCEL = @as(i32, -2147221229);
pub const _MAPI_E_UNABLE_TO_ABORT = @as(i32, -2147221228);
pub const _MAPI_E_NETWORK_ERROR = @as(i32, -2147221227);
pub const _MAPI_E_DISK_ERROR = @as(i32, -2147221226);
pub const _MAPI_E_TOO_COMPLEX = @as(i32, -2147221225);
pub const _MAPI_E_BAD_COLUMN = @as(i32, -2147221224);
pub const _MAPI_E_EXTENDED_ERROR = @as(i32, -2147221223);
pub const _MAPI_E_COMPUTED = @as(i32, -2147221222);
pub const _MAPI_E_CORRUPT_DATA = @as(i32, -2147221221);
pub const _MAPI_E_UNCONFIGURED = @as(i32, -2147221220);
pub const _MAPI_E_FAILONEPROVIDER = @as(i32, -2147221219);
pub const _MAPI_E_UNKNOWN_CPID = @as(i32, -2147221218);
pub const _MAPI_E_UNKNOWN_LCID = @as(i32, -2147221217);
pub const _MAPI_E_PASSWORD_CHANGE_REQUIRED = @as(i32, -2147221216);
pub const _MAPI_E_PASSWORD_EXPIRED = @as(i32, -2147221215);
pub const _MAPI_E_INVALID_WORKSTATION_ACCOUNT = @as(i32, -2147221214);
pub const _MAPI_E_INVALID_ACCESS_TIME = @as(i32, -2147221213);
pub const _MAPI_E_ACCOUNT_DISABLED = @as(i32, -2147221212);
pub const _MAPI_E_END_OF_SESSION = @as(i32, -2147220992);
pub const _MAPI_E_UNKNOWN_ENTRYID = @as(i32, -2147220991);
pub const _MAPI_E_MISSING_REQUIRED_COLUMN = @as(i32, -2147220990);
pub const _MAPI_W_NO_SERVICE = @as(i32, 262659);
pub const MSG_TEST_MESSAGE = @as(i32, 1074008064);
pub const FLTRDMN_E_UNEXPECTED = @as(i32, -2147212287);
pub const FLTRDMN_E_QI_FILTER_FAILED = @as(i32, -2147212286);
pub const FLTRDMN_E_FILTER_INIT_FAILED = @as(i32, -2147212284);
pub const FLTRDMN_E_ENCRYPTED_DOCUMENT = @as(i32, -2147212283);
pub const FLTRDMN_E_CANNOT_DECRYPT_PASSWORD = @as(i32, -2147212282);
pub const OLEDB_BINDER_CUSTOM_ERROR = @as(i32, -2147212032);
pub const NOTESPH_E_UNEXPECTED_STATE = @as(i32, -2147211775);
pub const NOTESPH_S_IGNORE_ID = @as(i32, 271874);
pub const NOTESPH_E_UNSUPPORTED_CONTENT_FIELD_TYPE = @as(i32, -2147211773);
pub const NOTESPH_E_ITEM_NOT_FOUND = @as(i32, -2147211772);
pub const NOTESPH_E_SERVER_CONFIG = @as(i32, -2147211771);
pub const NOTESPH_E_ATTACHMENTS = @as(i32, -2147211770);
pub const NOTESPH_E_NO_NTID = @as(i32, -2147211769);
pub const NOTESPH_E_DB_ACCESS_DENIED = @as(i32, -2147211768);
pub const NOTESPH_E_NOTESSETUP_ID_MAPPING_ERROR = @as(i32, -2147211767);
pub const NOTESPH_S_LISTKNOWNFIELDS = @as(i32, 271888);
pub const NOTESPH_E_FAIL = @as(i32, -2147211759);
pub const STS_ABORTXMLPARSE = @as(i32, -2147211756);
pub const STS_WS_ERROR = @as(i32, -2147211754);
pub const SPS_WS_ERROR = @as(i32, -2147211753);
pub const EXSTOREPH_E_UNEXPECTED = @as(i32, -2147211519);
pub const CERT_E_NOT_FOUND_OR_NO_PERMISSSION = @as(i32, -2147211263);
pub const SRCH_SCHEMA_CACHE_E_UNEXPECTED = @as(i32, -2147208447);
pub const CONTENT_SOURCE_E_PROPERTY_MAPPING_READ = @as(i32, -2147208191);
pub const CONTENT_SOURCE_E_UNEXPECTED_NULL_POINTER = @as(i32, -2147208190);
pub const CONTENT_SOURCE_E_PROPERTY_MAPPING_BAD_VECTOR_SIZE = @as(i32, -2147208189);
pub const CONTENT_SOURCE_E_CONTENT_CLASS_READ = @as(i32, -2147208188);
pub const CONTENT_SOURCE_E_UNEXPECTED_EXCEPTION = @as(i32, -2147208187);
pub const CONTENT_SOURCE_E_NULL_CONTENT_CLASS_BSTR = @as(i32, -2147208186);
pub const CONTENT_SOURCE_E_CONTENT_SOURCE_COLUMN_TYPE = @as(i32, -2147208185);
pub const CONTENT_SOURCE_E_OUT_OF_RANGE = @as(i32, -2147208184);
pub const CONTENT_SOURCE_E_NULL_URI = @as(i32, -2147208183);
pub const REXSPH_E_INVALID_CALL = @as(i32, -2147207936);
pub const REXSPH_S_REDIRECTED = @as(i32, 275713);
pub const REXSPH_E_REDIRECT_ON_SECURITY_UPDATE = @as(i32, -2147207934);
pub const REXSPH_E_MULTIPLE_REDIRECT = @as(i32, -2147207933);
pub const REXSPH_E_NO_PROPERTY_ON_ROW = @as(i32, -2147207932);
pub const REXSPH_E_TYPE_MISMATCH_ON_READ = @as(i32, -2147207931);
pub const REXSPH_E_UNEXPECTED_DATA_STATUS = @as(i32, -2147207930);
pub const REXSPH_E_UNKNOWN_DATA_TYPE = @as(i32, -2147207929);
pub const REXSPH_E_UNEXPECTED_FILTER_STATE = @as(i32, -2147207928);
pub const REXSPH_E_DUPLICATE_PROPERTY = @as(i32, -2147207927);
pub const PEOPLE_IMPORT_E_DBCONNFAIL = @as(i32, -2147205120);
pub const PEOPLE_IMPORT_NODSDEFINED = @as(i32, -2147205119);
pub const PEOPLE_IMPORT_E_FAILTOGETDSDEF = @as(i32, -2147205118);
pub const PEOPLE_IMPORT_NOMAPPINGDEFINED = @as(i32, -2147205117);
pub const PEOPLE_IMPORT_E_FAILTOGETDSMAPPING = @as(i32, -2147205116);
pub const PEOPLE_IMPORT_E_DATATYPENOTSUPPORTED = @as(i32, -2147205115);
pub const PEOPLE_IMPORT_E_NOCASTINGSUPPORTED = @as(i32, -2147205114);
pub const PEOPLE_IMPORT_E_UPDATE_DIRSYNC_COOKIE = @as(i32, -2147205113);
pub const PEOPLE_IMPORT_E_DIRSYNC_ZERO_COOKIE = @as(i32, -2147205112);
pub const PEOPLE_IMPORT_E_LDAPPATH_TOOLONG = @as(i32, -2147205111);
pub const PEOPLE_IMPORT_E_CANONICALURL_TOOLONG = @as(i32, -2147205110);
pub const PEOPLE_IMPORT_E_USERNAME_NOTRESOLVED = @as(i32, -2147205109);
pub const PEOPLE_IMPORT_E_DC_NOT_AVAILABLE = @as(i32, -2147205108);
pub const PEOPLE_IMPORT_E_DOMAIN_DISCOVER_FAILED = @as(i32, -2147205107);
pub const PEOPLE_IMPORT_E_FAILTOGETLCID = @as(i32, -2147205106);
pub const PEOPLE_IMPORT_E_DOMAIN_REMOVED = @as(i32, -2147205105);
pub const PEOPLE_IMPORT_E_ENUM_ACCESSDENIED = @as(i32, -2147205104);
pub const PEOPLE_IMPORT_E_DIRSYNC_NOTREFRESHED = @as(i32, -2147205103);
pub const FTE_E_SECRET_NOT_FOUND = @as(i32, -2147207678);
pub const FTE_E_PIPE_NOT_CONNECTED = @as(i32, -2147207677);
pub const FTE_E_ADMIN_BLOB_CORRUPT = @as(i32, -2147207676);
pub const FTE_E_FILTER_SINGLE_THREADED = @as(i32, -2147207675);
pub const FTE_E_ERROR_WRITING_REGISTRY = @as(i32, -2147207674);
pub const FTE_E_PROJECT_SHUTDOWN = @as(i32, -2147207673);
pub const FTE_E_PROJECT_NOT_INITALIZED = @as(i32, -2147207672);
pub const FTE_E_PIPE_DATA_CORRUPTED = @as(i32, -2147207671);
pub const FTE_E_URB_TOO_BIG = @as(i32, -2147207664);
pub const FTE_E_INVALID_DOCID = @as(i32, -2147207663);
pub const FTE_E_PAUSE_EXTERNAL = @as(i32, -2147207662);
pub const FTE_E_REJECTED_DUE_TO_PROJECT_STATUS = @as(i32, -2147207661);
pub const FTE_E_FD_DID_NOT_CONNECT = @as(i32, -2147207660);
pub const FTE_E_PROGID_REQUIRED = @as(i32, -2147207658);
pub const FTE_E_STATIC_THREAD_INVALID_ARGUMENTS = @as(i32, -2147207657);
pub const FTE_E_CATALOG_ALREADY_EXISTS = @as(i32, -2147207656);
pub const FTE_S_RESOURCES_STARTING_TO_GET_LOW = @as(i32, 275993);
pub const FTE_E_PATH_TOO_LONG = @as(i32, -2147207654);
pub const FTE_INVALID_ADMIN_CLIENT = @as(i32, -2147207653);
pub const FTE_E_COM_SIGNATURE_VALIDATION = @as(i32, -2147207652);
pub const FTE_E_AFFINITY_MASK = @as(i32, -2147207651);
pub const FTE_E_FD_OWNERSHIP_OBSOLETE = @as(i32, -2147207650);
pub const FTE_E_EXCEEDED_MAX_PLUGINS = @as(i32, -2147207647);
pub const FTE_S_BEYOND_QUOTA = @as(i32, 276002);
pub const FTE_E_DUPLICATE_OBJECT = @as(i32, -2147207644);
pub const FTE_S_REDUNDANT = @as(i32, 276005);
pub const FTE_E_REDUNDANT_TRAN_FAILURE = @as(i32, -2147207642);
pub const FTE_E_DEPENDENT_TRAN_FAILED_TO_PERSIST = @as(i32, -2147207641);
pub const FTE_E_FD_SHUTDOWN = @as(i32, -2147207640);
pub const FTE_E_CATALOG_DOES_NOT_EXIST = @as(i32, -2147207639);
pub const FTE_E_NO_PLUGINS = @as(i32, -2147207638);
pub const FTE_S_STATUS_CHANGE_REQUEST = @as(i32, 276011);
pub const FTE_E_BATCH_ABORTED = @as(i32, -2147207636);
pub const FTE_E_ANOTHER_STATUS_CHANGE_IS_ALREADY_ACTIVE = @as(i32, -2147207635);
pub const FTE_S_RESUME = @as(i32, 276014);
pub const FTE_E_NOT_PROCESSED_DUE_TO_PREVIOUS_ERRORS = @as(i32, -2147207633);
pub const FTE_E_FD_TIMEOUT = @as(i32, -2147207632);
pub const FTE_E_RESOURCE_SHUTDOWN = @as(i32, -2147207631);
pub const FTE_E_INVALID_PROPERTY = @as(i32, -2147207630);
pub const FTE_E_NO_MORE_PROPERTIES = @as(i32, -2147207629);
pub const FTE_E_UNKNOWN_PLUGIN = @as(i32, -2147207628);
pub const FTE_E_LIBRARY_NOT_LOADED = @as(i32, -2147207627);
pub const FTE_E_PERFMON_FULL = @as(i32, -2147207626);
pub const FTE_E_FAILED_TO_CREATE_ACCESSOR = @as(i32, -2147207625);
pub const FTE_E_INVALID_TYPE = @as(i32, -2147207624);
pub const FTE_E_OUT_OF_RANGE = @as(i32, -2147207623);
pub const FTE_E_CORRUPT_PROPERTY_STORE = @as(i32, -2147207622);
pub const FTE_E_PROPERTY_STORE_WORKID_NOTVALID = @as(i32, -2147207621);
pub const FTE_S_PROPERTY_STORE_END_OF_ENUMERATION = @as(i32, 276028);
pub const FTE_E_CORRUPT_GATHERER_HASH_MAP = @as(i32, -2147207619);
pub const FTE_E_KEY_NOT_CACHED = @as(i32, -2147207618);
pub const FTE_E_UPGRADE_INTERFACE_ALREADY_SHUTDOWN = @as(i32, -2147207617);
pub const FTE_E_UPGRADE_INTERFACE_ALREADY_INSTANTIATED = @as(i32, -2147207616);
pub const FTE_E_STACK_CORRUPTED = @as(i32, -2147207615);
pub const FTE_E_INVALID_PROG_ID = @as(i32, -2147207614);
pub const FTE_E_SERIAL_STREAM_CORRUPT = @as(i32, -2147207613);
pub const FTE_E_READONLY_CATALOG = @as(i32, -2147207612);
pub const FTE_E_PERF_NOT_LOADED = @as(i32, -2147207611);
pub const FTE_S_READONLY_CATALOG = @as(i32, 276038);
pub const FTE_E_RETRY_HUGE_DOC = @as(i32, -2147207608);
pub const FTE_E_UNKNOWN_FD_TYPE = @as(i32, -2147207607);
pub const FTE_E_DOC_TOO_HUGE = @as(i32, -2147207606);
pub const FTE_E_DATATYPE_MISALIGNMENT = @as(i32, -2147207605);
pub const FTE_E_ALREADY_INITIALIZED = @as(i32, -2147207604);
pub const FTE_E_FD_USED_TOO_MUCH_MEMORY = @as(i32, -2147207603);
pub const FTE_E_UNEXPECTED_EXIT = @as(i32, -2147207602);
pub const FTE_E_HIGH_MEMORY_PRESSURE = @as(i32, -2147207601);
pub const FTE_E_INVALID_ISOLATE_ERROR_BATCH = @as(i32, -2147207600);
pub const FTE_E_RETRY_SINGLE_DOC_PER_BATCH = @as(i32, -2147207599);
pub const FTE_E_INVALID_PROJECT_ID = @as(i32, -2147207598);
pub const FTE_E_FAILURE_TO_POST_SETCOMPLETION_STATUS = @as(i32, -2147207597);
pub const FTE_E_INVALID_CODEPAGE = @as(i32, -2147207596);
pub const FTE_E_FD_IDLE = @as(i32, -2147207595);
pub const FTE_E_FD_UNRESPONSIVE = @as(i32, -2147207594);
pub const FTE_S_TRY_TO_FLUSH = @as(i32, 276055);
pub const FTE_S_CATALOG_BLOB_MISMATCHED = @as(i32, 276056);
pub const FTE_S_PROPERTY_RESET = @as(i32, 276057);
pub const FTE_E_NO_PROPERTY_STORE = @as(i32, -1073465766);
pub const FTE_E_CB_OUT_OF_MEMORY = @as(i32, -2147169536);
pub const FTE_E_CB_CBID_OUT_OF_BOUND = @as(i32, -2147169535);
pub const FTE_E_CB_NOT_ENOUGH_AVAIL_PHY_MEM = @as(i32, -2147169534);
pub const FTE_E_CB_NOT_ENOUGH_OCC_BUFFER = @as(i32, -2147169533);
pub const FTE_E_CORRUPT_WORDLIST = @as(i32, -2147169532);
pub const FTE_E_FD_NO_IPERSIST_INTERFACE = @as(i32, -2147156736);
pub const FTE_E_FD_IFILTER_INIT_FAILED = @as(i32, -2147156735);
pub const FTE_E_FD_FAILED_TO_LOAD_IFILTER = @as(i32, -2147156734);
pub const FTE_E_FD_DOC_TIMEOUT = @as(i32, -2147156733);
pub const FTE_E_FD_UNEXPECTED_EXIT = @as(i32, -2147156732);
pub const FTE_E_FD_DOC_UNEXPECTED_EXIT = @as(i32, -2147156731);
pub const FTE_E_FD_NOISE_NO_TEXT_FILTER = @as(i32, -2147156730);
pub const FTE_E_FD_NOISE_NO_IPERSISTSTREAM_ON_TEXT_FILTER = @as(i32, -2147156729);
pub const FTE_E_FD_NOISE_TEXT_FILTER_LOAD_FAILED = @as(i32, -2147156728);
pub const FTE_E_FD_NOISE_TEXT_FILTER_INIT_FAILED = @as(i32, -2147156727);
pub const FTE_E_FD_OCCURRENCE_OVERFLOW = @as(i32, -2147156726);
pub const FTE_E_FD_FILTER_CAUSED_SHARING_VIOLATION = @as(i32, -2147156725);
pub const ERROR_SOURCE_PROTHNDLR = @as(u32, 4608);
pub const QUERY_E_ALLNOISE_AND_NO_RELDOC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215859));
pub const QUERY_E_NO_RELDOC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215858));
pub const QUERY_E_ALLNOISE_AND_NO_RELPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215857));
pub const QUERY_E_NO_RELPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215856));
pub const QUERY_E_REPEATED_RELDOC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215855));
pub const QUERY_E_RELDOC_SYNTAX_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215854));
pub const QUERY_E_INVALID_DOCUMENT_IDENTIFIER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215853));
pub const QUERY_E_INCORRECT_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215852));
pub const QUERY_E_INVALIDSCOPE_COALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215851));
pub const QUERY_E_INVALIDSORT_COALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215850));
pub const QUERY_E_INVALIDCOALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215849));
pub const QUERY_E_UPGRADEINPROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215848));
pub const QUERY_E_AGGREGATE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215847));
pub const QUERY_E_TOP_LEVEL_IN_GROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215846));
pub const QUERY_E_DUPLICATE_RANGE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215845));
pub const CI_S_NEW_AUXMETADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268329));
pub const CI_E_NO_AUXMETADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215318));
pub const CI_S_CLIENT_REQUESTED_ABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268331));
pub const CI_S_RETRY_DOCUMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268332));
pub const CI_E_CORRUPT_FWIDX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473491));
pub const CI_E_DIACRITIC_SETTINGS_DIFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473490));
pub const CI_E_INVALID_CATALOG_LIST_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215313));
pub const CI_S_CATALOG_RESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268336));
pub const CI_E_NO_CATALOG_MANAGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473487));
pub const CI_E_INCONSISTENT_TRANSACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473486));
pub const CI_E_PROTECTED_CATALOG_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473485));
pub const CI_E_NO_PROTECTED_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473484));
pub const CI_E_MULTIPLE_PROTECTED_USERS_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473483));
pub const CI_E_PROTECTED_CATALOG_SID_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473482));
pub const CI_E_PROTECTED_CATALOG_NON_INTERACTIVE_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473481));
pub const MSG_CI_MASTER_MERGE_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745926));
pub const MSG_CI_MASTER_MERGE_COMPLETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745927));
pub const MSG_CI_MASTER_MERGE_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745928));
pub const MSG_CI_MASTER_MERGE_CANT_START = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073737719));
pub const MSG_CI_MASTER_MERGE_CANT_RESTART = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073737718));
pub const MSG_CI_MASTER_MERGE_RESTARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745945));
pub const MSG_CI_CORRUPT_INDEX_COMPONENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745962));
pub const MSG_CI_MASTER_MERGE_ABORTED_LOW_DISK = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745987));
pub const MSG_CI_MASTER_MERGE_REASON_EXTERNAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745988));
pub const MSG_CI_MASTER_MERGE_REASON_INDEX_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745989));
pub const MSG_CI_MASTER_MERGE_REASON_EXPECTED_DOCS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745990));
pub const MSG_CI_MASTER_MERGE_REASON_NUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745991));
pub const MSG_CI_CREATE_SEVER_ITEM_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479480));
pub const NOT_N_PARSE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 526638));
pub const IDS_MON_DEFAULT_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264495));
pub const IDS_MON_ILLEGAL_PASSTHROUGH = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264496));
pub const IDS_MON_PARSE_ERR_1_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264497));
pub const IDS_MON_PARSE_ERR_2_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264498));
pub const IDS_MON_SEMI_COLON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264499));
pub const IDS_MON_ORDINAL_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264500));
pub const IDS_MON_VIEW_NOT_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264501));
pub const IDS_MON_COLUMN_NOT_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264502));
pub const IDS_MON_BUILTIN_VIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264503));
pub const IDS_MON_OUT_OF_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264504));
pub const IDS_MON_SELECT_STAR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264505));
pub const IDS_MON_OR_NOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264506));
pub const IDS_MON_CANNOT_CONVERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264507));
pub const IDS_MON_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264508));
pub const IDS_MON_RELATIVE_INTERVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264509));
pub const IDS_MON_NOT_COLUMN_OF_VIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264510));
pub const IDS_MON_BUILTIN_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264511));
pub const IDS_MON_WEIGHT_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264512));
pub const IDS_MON_MATCH_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264513));
pub const IDS_MON_PROPERTY_NAME_IN_VIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264514));
pub const IDS_MON_VIEW_ALREADY_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264515));
pub const IDS_MON_INVALID_CATALOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264516));
pub const IDS_MON_INVALIDSELECT_COALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264517));
pub const IDS_MON_CANNOT_CAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264518));
pub const IDS_MON_DATE_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264519));
pub const IDS_MON_INVALID_IN_GROUP_CLAUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264520));
pub const DBPROPSET_MSDAORA_ROWSET = Guid.initString("e8cc4cbd-fdff-11d0-b865-00a0c9081c1d");
pub const DBPROPSET_MSDAORA8_ROWSET = Guid.initString("7f06a375-dd6a-43db-b4e0-1fc121e5e62b");
pub const CLSID_MSDASQL = Guid.initString("c8b522cb-5cf3-11ce-ade5-00aa0044773d");
pub const CLSID_MSDASQL_ENUMERATOR = Guid.initString("c8b522cd-5cf3-11ce-ade5-00aa0044773d");
pub const DBPROPSET_PROVIDERDATASOURCEINFO = Guid.initString("497c60e0-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERROWSET = Guid.initString("497c60e1-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERDBINIT = Guid.initString("497c60e2-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERSTMTATTR = Guid.initString("497c60e3-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERCONNATTR = Guid.initString("497c60e4-7123-11cf-b171-00aa0057599e");
pub const CLSID_DataShapeProvider = Guid.initString("3449a1c8-c56c-11d0-ad72-00c04fc29863");
pub const DBPROPSET_MSDSDBINIT = Guid.initString("55cb91a8-5c7a-11d1-adad-00c04fc29863");
pub const DBPROPSET_MSDSSESSION = Guid.initString("edf17536-afbf-11d1-8847-0000f879f98c");
pub const CLSID_MSPersist = Guid.initString("7c07e0d0-4418-11d2-9212-00c04fbbbfb3");
pub const DBPROPSET_PERSIST = Guid.initString("4d7839a0-5b8e-11d1-a6b3-00a0c9138c66");
pub const PROGID_MSPersist_W = "MSPersist";
pub const PROGID_MSPersist_Version_W = "MSPersist.1";
pub const CLSID_SQLOLEDB = Guid.initString("0c7ff16c-38e3-11d0-97ab-00c04fc2ad98");
pub const CLSID_SQLOLEDB_ERROR = Guid.initString("c0932c62-38e5-11d0-97ab-00c04fc2ad98");
pub const CLSID_SQLOLEDB_ENUMERATOR = Guid.initString("dfa22b8e-e68d-11d0-97e4-00c04fc2ad98");
pub const DBGUID_MSSQLXML = Guid.initString("5d531cb2-e6ed-11d2-b252-00c04f681b71");
pub const DBGUID_XPATH = Guid.initString("ec2a4293-e898-11d2-b1b7-00c04f680c56");
pub const DBSCHEMA_LINKEDSERVERS = Guid.initString("9093caf4-2eac-11d1-9809-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERDATASOURCE = Guid.initString("28efaee4-2d2c-11d1-9807-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERDATASOURCEINFO = Guid.initString("df10cb94-35f6-11d2-9c54-00c04f7971d3");
pub const DBPROPSET_SQLSERVERDBINIT = Guid.initString("5cf4ca10-ef21-11d0-97e7-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERROWSET = Guid.initString("5cf4ca11-ef21-11d0-97e7-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERSESSION = Guid.initString("28efaee5-2d2c-11d1-9807-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERCOLUMN = Guid.initString("3b63fb5e-3fbb-11d3-9f29-00c04f8ee9dc");
pub const DBPROPSET_SQLSERVERSTREAM = Guid.initString("9f79c073-8a6d-4bca-a8a8-c9b79a9b962d");

//--------------------------------------------------------------------------------
// Section: Types (437)
//--------------------------------------------------------------------------------
pub const IRowsetExactScroll = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IWordSink_Value = Guid.initString("cc907054-c058-101a-b554-08002b33b0e6");
pub const IID_IWordSink = &IID_IWordSink_Value;
pub const IWordSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordSink,
                cwc: u32,
                pwcInBuf: ?[*:0]const u16,
                cwcSrcLen: u32,
                cwcSrcPos: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordSink,
                cwc: u32,
                pwcInBuf: ?[*:0]const u16,
                cwcSrcLen: u32,
                cwcSrcPos: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutAltWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordSink,
                cwc: u32,
                pwcInBuf: ?[*:0]const u16,
                cwcSrcLen: u32,
                cwcSrcPos: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordSink,
                cwc: u32,
                pwcInBuf: ?[*:0]const u16,
                cwcSrcLen: u32,
                cwcSrcPos: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartAltPhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndAltPhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutBreak: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordSink,
                breakType: WORDREP_BREAK_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordSink,
                breakType: WORDREP_BREAK_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordSink_PutWord(self: *const T, cwc: u32, pwcInBuf: ?[*:0]const u16, cwcSrcLen: u32, cwcSrcPos: u32) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).PutWord(@as(*const IWordSink, @ptrCast(self)), cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordSink_PutAltWord(self: *const T, cwc: u32, pwcInBuf: ?[*:0]const u16, cwcSrcLen: u32, cwcSrcPos: u32) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).PutAltWord(@as(*const IWordSink, @ptrCast(self)), cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordSink_StartAltPhrase(self: *const T) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).StartAltPhrase(@as(*const IWordSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordSink_EndAltPhrase(self: *const T) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).EndAltPhrase(@as(*const IWordSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordSink_PutBreak(self: *const T, breakType: WORDREP_BREAK_TYPE) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).PutBreak(@as(*const IWordSink, @ptrCast(self)), breakType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const PFNFILLTEXTBUFFER = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const TEXT_SOURCE = extern struct {
    pfnFillTextBuffer: ?PFNFILLTEXTBUFFER,
    awcBuffer: ?[*:0]const u16,
    iEnd: u32,
    iCur: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWordBreaker_Value = Guid.initString("d53552c8-77e3-101a-b552-08002b33b0e6");
pub const IID_IWordBreaker = &IID_IWordBreaker_Value;
pub const IWordBreaker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordBreaker,
                fQuery: BOOL,
                ulMaxTokenSize: u32,
                pfLicense: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordBreaker,
                fQuery: BOOL,
                ulMaxTokenSize: u32,
                pfLicense: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BreakText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordBreaker,
                pTextSource: ?*TEXT_SOURCE,
                pWordSink: ?*IWordSink,
                pPhraseSink: ?*IPhraseSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordBreaker,
                pTextSource: ?*TEXT_SOURCE,
                pWordSink: ?*IWordSink,
                pPhraseSink: ?*IPhraseSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComposePhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordBreaker,
                pwcNoun: ?[*:0]const u16,
                cwcNoun: u32,
                pwcModifier: ?[*:0]const u16,
                cwcModifier: u32,
                ulAttachmentType: u32,
                pwcPhrase: ?PWSTR,
                pcwcPhrase: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordBreaker,
                pwcNoun: ?[*:0]const u16,
                cwcNoun: u32,
                pwcModifier: ?[*:0]const u16,
                cwcModifier: u32,
                ulAttachmentType: u32,
                pwcPhrase: ?PWSTR,
                pcwcPhrase: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLicenseToUse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordBreaker,
                ppwcsLicense: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordBreaker,
                ppwcsLicense: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordBreaker_Init(self: *const T, fQuery: BOOL, ulMaxTokenSize: u32, pfLicense: ?*BOOL) HRESULT {
                return @as(*const IWordBreaker.VTable, @ptrCast(self.vtable)).Init(@as(*const IWordBreaker, @ptrCast(self)), fQuery, ulMaxTokenSize, pfLicense);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordBreaker_BreakText(self: *const T, pTextSource: ?*TEXT_SOURCE, pWordSink: ?*IWordSink, pPhraseSink: ?*IPhraseSink) HRESULT {
                return @as(*const IWordBreaker.VTable, @ptrCast(self.vtable)).BreakText(@as(*const IWordBreaker, @ptrCast(self)), pTextSource, pWordSink, pPhraseSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordBreaker_ComposePhrase(self: *const T, pwcNoun: ?[*:0]const u16, cwcNoun: u32, pwcModifier: ?[*:0]const u16, cwcModifier: u32, ulAttachmentType: u32, pwcPhrase: ?PWSTR, pcwcPhrase: ?*u32) HRESULT {
                return @as(*const IWordBreaker.VTable, @ptrCast(self.vtable)).ComposePhrase(@as(*const IWordBreaker, @ptrCast(self)), pwcNoun, cwcNoun, pwcModifier, cwcModifier, ulAttachmentType, pwcPhrase, pcwcPhrase);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordBreaker_GetLicenseToUse(self: *const T, ppwcsLicense: ?*const ?*u16) HRESULT {
                return @as(*const IWordBreaker.VTable, @ptrCast(self.vtable)).GetLicenseToUse(@as(*const IWordBreaker, @ptrCast(self)), ppwcsLicense);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWordFormSink_Value = Guid.initString("fe77c330-7f42-11ce-be57-00aa0051fe20");
pub const IID_IWordFormSink = &IID_IWordFormSink_Value;
pub const IWordFormSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutAltWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordFormSink,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordFormSink,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWordFormSink,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWordFormSink,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordFormSink_PutAltWord(self: *const T, pwcInBuf: ?[*:0]const u16, cwc: u32) HRESULT {
                return @as(*const IWordFormSink.VTable, @ptrCast(self.vtable)).PutAltWord(@as(*const IWordFormSink, @ptrCast(self)), pwcInBuf, cwc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWordFormSink_PutWord(self: *const T, pwcInBuf: ?[*:0]const u16, cwc: u32) HRESULT {
                return @as(*const IWordFormSink.VTable, @ptrCast(self.vtable)).PutWord(@as(*const IWordFormSink, @ptrCast(self)), pwcInBuf, cwc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStemmer_Value = Guid.initString("efbaf140-7f42-11ce-be57-00aa0051fe20");
pub const IID_IStemmer = &IID_IStemmer_Value;
pub const IStemmer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStemmer,
                ulMaxTokenSize: u32,
                pfLicense: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStemmer,
                ulMaxTokenSize: u32,
                pfLicense: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateWordForms: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStemmer,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
                pStemSink: ?*IWordFormSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStemmer,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
                pStemSink: ?*IWordFormSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLicenseToUse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStemmer,
                ppwcsLicense: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStemmer,
                ppwcsLicense: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStemmer_Init(self: *const T, ulMaxTokenSize: u32, pfLicense: ?*BOOL) HRESULT {
                return @as(*const IStemmer.VTable, @ptrCast(self.vtable)).Init(@as(*const IStemmer, @ptrCast(self)), ulMaxTokenSize, pfLicense);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStemmer_GenerateWordForms(self: *const T, pwcInBuf: ?[*:0]const u16, cwc: u32, pStemSink: ?*IWordFormSink) HRESULT {
                return @as(*const IStemmer.VTable, @ptrCast(self.vtable)).GenerateWordForms(@as(*const IStemmer, @ptrCast(self)), pwcInBuf, cwc, pStemSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStemmer_GetLicenseToUse(self: *const T, ppwcsLicense: ?*const ?*u16) HRESULT {
                return @as(*const IStemmer.VTable, @ptrCast(self.vtable)).GetLicenseToUse(@as(*const IStemmer, @ptrCast(self)), ppwcsLicense);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISimpleCommandCreator_Value = Guid.initString("5e341ab7-02d0-11d1-900c-00a0c9063796");
pub const IID_ISimpleCommandCreator = &IID_ISimpleCommandCreator_Value;
pub const ISimpleCommandCreator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateICommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleCommandCreator,
                ppIUnknown: ?*?*IUnknown,
                pOuterUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleCommandCreator,
                ppIUnknown: ?*?*IUnknown,
                pOuterUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VerifyCatalog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleCommandCreator,
                pwszMachine: ?[*:0]const u16,
                pwszCatalogName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleCommandCreator,
                pwszMachine: ?[*:0]const u16,
                pwszCatalogName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultCatalog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleCommandCreator,
                pwszCatalogName: ?PWSTR,
                cwcIn: u32,
                pcwcOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleCommandCreator,
                pwszCatalogName: ?PWSTR,
                cwcIn: u32,
                pcwcOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleCommandCreator_CreateICommand(self: *const T, ppIUnknown: ?*?*IUnknown, pOuterUnk: ?*IUnknown) HRESULT {
                return @as(*const ISimpleCommandCreator.VTable, @ptrCast(self.vtable)).CreateICommand(@as(*const ISimpleCommandCreator, @ptrCast(self)), ppIUnknown, pOuterUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleCommandCreator_VerifyCatalog(self: *const T, pwszMachine: ?[*:0]const u16, pwszCatalogName: ?[*:0]const u16) HRESULT {
                return @as(*const ISimpleCommandCreator.VTable, @ptrCast(self.vtable)).VerifyCatalog(@as(*const ISimpleCommandCreator, @ptrCast(self)), pwszMachine, pwszCatalogName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleCommandCreator_GetDefaultCatalog(self: *const T, pwszCatalogName: ?PWSTR, cwcIn: u32, pcwcOut: ?*u32) HRESULT {
                return @as(*const ISimpleCommandCreator.VTable, @ptrCast(self.vtable)).GetDefaultCatalog(@as(*const ISimpleCommandCreator, @ptrCast(self)), pwszCatalogName, cwcIn, pcwcOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnMapper_Value = Guid.initString("0b63e37a-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IColumnMapper = &IID_IColumnMapper_Value;
pub const IColumnMapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropInfoFromName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnMapper,
                wcsPropName: ?[*:0]const u16,
                ppPropId: ?*?*DBID,
                pPropType: ?*u16,
                puiWidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnMapper,
                wcsPropName: ?[*:0]const u16,
                ppPropId: ?*?*DBID,
                pPropType: ?*u16,
                puiWidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropInfoFromId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnMapper,
                pPropId: ?*const DBID,
                pwcsName: ?*?*u16,
                pPropType: ?*u16,
                puiWidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnMapper,
                pPropId: ?*const DBID,
                pwcsName: ?*?*u16,
                pPropType: ?*u16,
                puiWidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumPropInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnMapper,
                iEntry: u32,
                pwcsName: ?*const ?*u16,
                ppPropId: ?*?*DBID,
                pPropType: ?*u16,
                puiWidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnMapper,
                iEntry: u32,
                pwcsName: ?*const ?*u16,
                ppPropId: ?*?*DBID,
                pPropType: ?*u16,
                puiWidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsMapUpToDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnMapper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnMapper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnMapper_GetPropInfoFromName(self: *const T, wcsPropName: ?[*:0]const u16, ppPropId: ?*?*DBID, pPropType: ?*u16, puiWidth: ?*u32) HRESULT {
                return @as(*const IColumnMapper.VTable, @ptrCast(self.vtable)).GetPropInfoFromName(@as(*const IColumnMapper, @ptrCast(self)), wcsPropName, ppPropId, pPropType, puiWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnMapper_GetPropInfoFromId(self: *const T, pPropId: ?*const DBID, pwcsName: ?*?*u16, pPropType: ?*u16, puiWidth: ?*u32) HRESULT {
                return @as(*const IColumnMapper.VTable, @ptrCast(self.vtable)).GetPropInfoFromId(@as(*const IColumnMapper, @ptrCast(self)), pPropId, pwcsName, pPropType, puiWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnMapper_EnumPropInfo(self: *const T, iEntry: u32, pwcsName: ?*const ?*u16, ppPropId: ?*?*DBID, pPropType: ?*u16, puiWidth: ?*u32) HRESULT {
                return @as(*const IColumnMapper.VTable, @ptrCast(self.vtable)).EnumPropInfo(@as(*const IColumnMapper, @ptrCast(self)), iEntry, pwcsName, ppPropId, pPropType, puiWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnMapper_IsMapUpToDate(self: *const T) HRESULT {
                return @as(*const IColumnMapper.VTable, @ptrCast(self.vtable)).IsMapUpToDate(@as(*const IColumnMapper, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnMapperCreator_Value = Guid.initString("0b63e37b-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IColumnMapperCreator = &IID_IColumnMapperCreator_Value;
pub const IColumnMapperCreator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnMapper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnMapperCreator,
                wcsMachineName: ?[*:0]const u16,
                wcsCatalogName: ?[*:0]const u16,
                ppColumnMapper: ?*?*IColumnMapper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnMapperCreator,
                wcsMachineName: ?[*:0]const u16,
                wcsCatalogName: ?[*:0]const u16,
                ppColumnMapper: ?*?*IColumnMapper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnMapperCreator_GetColumnMapper(self: *const T, wcsMachineName: ?[*:0]const u16, wcsCatalogName: ?[*:0]const u16, ppColumnMapper: ?*?*IColumnMapper) HRESULT {
                return @as(*const IColumnMapperCreator.VTable, @ptrCast(self.vtable)).GetColumnMapper(@as(*const IColumnMapperCreator, @ptrCast(self)), wcsMachineName, wcsCatalogName, ppColumnMapper);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CSearchManager_Value = Guid.initString("7d096c5f-ac08-4f1f-beb7-5c22c517ce39");
pub const CLSID_CSearchManager = &CLSID_CSearchManager_Value;

const CLSID_CSearchRoot_Value = Guid.initString("30766bd2-ea1c-4f28-bf27-0b44e2f68db7");
pub const CLSID_CSearchRoot = &CLSID_CSearchRoot_Value;

const CLSID_CSearchScopeRule_Value = Guid.initString("e63de750-3bd7-4be5-9c84-6b4281988c44");
pub const CLSID_CSearchScopeRule = &CLSID_CSearchScopeRule_Value;

const CLSID_FilterRegistration_Value = Guid.initString("9e175b8d-f52a-11d8-b9a5-505054503030");
pub const CLSID_FilterRegistration = &CLSID_FilterRegistration_Value;

pub const FILTERED_DATA_SOURCES = extern struct {
    pwcsExtension: ?[*:0]const u16,
    pwcsMime: ?[*:0]const u16,
    pClsid: ?*const Guid,
    pwcsOverride: ?[*:0]const u16,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ILoadFilter_Value = Guid.initString("c7310722-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_ILoadFilter = &IID_ILoadFilter_Value;
pub const ILoadFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadIFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILoadFilter,
                pwcsPath: ?[*:0]const u16,
                pFilteredSources: ?*FILTERED_DATA_SOURCES,
                pUnkOuter: ?*IUnknown,
                fUseDefault: BOOL,
                pFilterClsid: ?*Guid,
                SearchDecSize: ?*i32,
                pwcsSearchDesc: ?*?*u16,
                ppIFilt: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILoadFilter,
                pwcsPath: ?[*:0]const u16,
                pFilteredSources: ?*FILTERED_DATA_SOURCES,
                pUnkOuter: ?*IUnknown,
                fUseDefault: BOOL,
                pFilterClsid: ?*Guid,
                SearchDecSize: ?*i32,
                pwcsSearchDesc: ?*?*u16,
                ppIFilt: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadIFilterFromStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILoadFilter,
                pStg: ?*IStorage,
                pUnkOuter: ?*IUnknown,
                pwcsOverride: ?[*:0]const u16,
                fUseDefault: BOOL,
                pFilterClsid: ?*Guid,
                SearchDecSize: ?*i32,
                pwcsSearchDesc: ?*?*u16,
                ppIFilt: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILoadFilter,
                pStg: ?*IStorage,
                pUnkOuter: ?*IUnknown,
                pwcsOverride: ?[*:0]const u16,
                fUseDefault: BOOL,
                pFilterClsid: ?*Guid,
                SearchDecSize: ?*i32,
                pwcsSearchDesc: ?*?*u16,
                ppIFilt: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadIFilterFromStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILoadFilter,
                pStm: ?*IStream,
                pFilteredSources: ?*FILTERED_DATA_SOURCES,
                pUnkOuter: ?*IUnknown,
                fUseDefault: BOOL,
                pFilterClsid: ?*Guid,
                SearchDecSize: ?*i32,
                pwcsSearchDesc: ?*?*u16,
                ppIFilt: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILoadFilter,
                pStm: ?*IStream,
                pFilteredSources: ?*FILTERED_DATA_SOURCES,
                pUnkOuter: ?*IUnknown,
                fUseDefault: BOOL,
                pFilterClsid: ?*Guid,
                SearchDecSize: ?*i32,
                pwcsSearchDesc: ?*?*u16,
                ppIFilt: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILoadFilter_LoadIFilter(self: *const T, pwcsPath: ?[*:0]const u16, pFilteredSources: ?*FILTERED_DATA_SOURCES, pUnkOuter: ?*IUnknown, fUseDefault: BOOL, pFilterClsid: ?*Guid, SearchDecSize: ?*i32, pwcsSearchDesc: ?*?*u16, ppIFilt: ?*?*IFilter) HRESULT {
                return @as(*const ILoadFilter.VTable, @ptrCast(self.vtable)).LoadIFilter(@as(*const ILoadFilter, @ptrCast(self)), pwcsPath, pFilteredSources, pUnkOuter, fUseDefault, pFilterClsid, SearchDecSize, pwcsSearchDesc, ppIFilt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILoadFilter_LoadIFilterFromStorage(self: *const T, pStg: ?*IStorage, pUnkOuter: ?*IUnknown, pwcsOverride: ?[*:0]const u16, fUseDefault: BOOL, pFilterClsid: ?*Guid, SearchDecSize: ?*i32, pwcsSearchDesc: ?*?*u16, ppIFilt: ?*?*IFilter) HRESULT {
                return @as(*const ILoadFilter.VTable, @ptrCast(self.vtable)).LoadIFilterFromStorage(@as(*const ILoadFilter, @ptrCast(self)), pStg, pUnkOuter, pwcsOverride, fUseDefault, pFilterClsid, SearchDecSize, pwcsSearchDesc, ppIFilt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILoadFilter_LoadIFilterFromStream(self: *const T, pStm: ?*IStream, pFilteredSources: ?*FILTERED_DATA_SOURCES, pUnkOuter: ?*IUnknown, fUseDefault: BOOL, pFilterClsid: ?*Guid, SearchDecSize: ?*i32, pwcsSearchDesc: ?*?*u16, ppIFilt: ?*?*IFilter) HRESULT {
                return @as(*const ILoadFilter.VTable, @ptrCast(self.vtable)).LoadIFilterFromStream(@as(*const ILoadFilter, @ptrCast(self)), pStm, pFilteredSources, pUnkOuter, fUseDefault, pFilterClsid, SearchDecSize, pwcsSearchDesc, ppIFilt);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ILoadFilterWithPrivateComActivation_Value = Guid.initString("40bdbd34-780b-48d3-9bb6-12ebd4ad2e75");
pub const IID_ILoadFilterWithPrivateComActivation = &IID_ILoadFilterWithPrivateComActivation_Value;
pub const ILoadFilterWithPrivateComActivation = extern struct {
    pub const VTable = extern struct {
        base: ILoadFilter.VTable,
        LoadIFilterWithPrivateComActivation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILoadFilterWithPrivateComActivation,
                filteredSources: ?*FILTERED_DATA_SOURCES,
                useDefault: BOOL,
                filterClsid: ?*Guid,
                isFilterPrivateComActivated: ?*BOOL,
                filterObj: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILoadFilterWithPrivateComActivation,
                filteredSources: ?*FILTERED_DATA_SOURCES,
                useDefault: BOOL,
                filterClsid: ?*Guid,
                isFilterPrivateComActivated: ?*BOOL,
                filterObj: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ILoadFilter.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILoadFilterWithPrivateComActivation_LoadIFilterWithPrivateComActivation(self: *const T, filteredSources: ?*FILTERED_DATA_SOURCES, useDefault: BOOL, filterClsid: ?*Guid, isFilterPrivateComActivated: ?*BOOL, filterObj: ?*?*IFilter) HRESULT {
                return @as(*const ILoadFilterWithPrivateComActivation.VTable, @ptrCast(self.vtable)).LoadIFilterWithPrivateComActivation(@as(*const ILoadFilterWithPrivateComActivation, @ptrCast(self)), filteredSources, useDefault, filterClsid, isFilterPrivateComActivated, filterObj);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRichChunk_Value = Guid.initString("4fdef69c-dbc9-454e-9910-b34f3c64b510");
pub const IID_IRichChunk = &IID_IRichChunk_Value;
pub const IRichChunk = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichChunk,
                pFirstPos: ?*u32,
                pLength: ?*u32,
                ppsz: ?*?PWSTR,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichChunk,
                pFirstPos: ?*u32,
                pLength: ?*u32,
                ppsz: ?*?PWSTR,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichChunk_GetData(self: *const T, pFirstPos: ?*u32, pLength: ?*u32, ppsz: ?*?PWSTR, pValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IRichChunk.VTable, @ptrCast(self.vtable)).GetData(@as(*const IRichChunk, @ptrCast(self)), pFirstPos, pLength, ppsz, pValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICondition_Value = Guid.initString("0fc988d4-c935-4b97-a973-46282ea175c8");
pub const IID_ICondition = &IID_ICondition_Value;
pub const ICondition = extern struct {
    pub const VTable = extern struct {
        base: IPersistStream.VTable,
        GetConditionType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICondition,
                pNodeType: ?*CONDITION_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICondition,
                pNodeType: ?*CONDITION_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubConditions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICondition,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICondition,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComparisonInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICondition,
                ppszPropertyName: ?*?PWSTR,
                pcop: ?*CONDITION_OPERATION,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICondition,
                ppszPropertyName: ?*?PWSTR,
                pcop: ?*CONDITION_OPERATION,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValueType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICondition,
                ppszValueTypeName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICondition,
                ppszValueTypeName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValueNormalization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICondition,
                ppszNormalization: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICondition,
                ppszNormalization: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputTerms: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICondition,
                ppPropertyTerm: ?*?*IRichChunk,
                ppOperationTerm: ?*?*IRichChunk,
                ppValueTerm: ?*?*IRichChunk,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICondition,
                ppPropertyTerm: ?*?*IRichChunk,
                ppOperationTerm: ?*?*IRichChunk,
                ppValueTerm: ?*?*IRichChunk,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICondition,
                ppc: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICondition,
                ppc: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersistStream.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICondition_GetConditionType(self: *const T, pNodeType: ?*CONDITION_TYPE) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetConditionType(@as(*const ICondition, @ptrCast(self)), pNodeType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICondition_GetSubConditions(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetSubConditions(@as(*const ICondition, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICondition_GetComparisonInfo(self: *const T, ppszPropertyName: ?*?PWSTR, pcop: ?*CONDITION_OPERATION, ppropvar: ?*PROPVARIANT) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetComparisonInfo(@as(*const ICondition, @ptrCast(self)), ppszPropertyName, pcop, ppropvar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICondition_GetValueType(self: *const T, ppszValueTypeName: ?*?PWSTR) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetValueType(@as(*const ICondition, @ptrCast(self)), ppszValueTypeName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICondition_GetValueNormalization(self: *const T, ppszNormalization: ?*?PWSTR) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetValueNormalization(@as(*const ICondition, @ptrCast(self)), ppszNormalization);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICondition_GetInputTerms(self: *const T, ppPropertyTerm: ?*?*IRichChunk, ppOperationTerm: ?*?*IRichChunk, ppValueTerm: ?*?*IRichChunk) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetInputTerms(@as(*const ICondition, @ptrCast(self)), ppPropertyTerm, ppOperationTerm, ppValueTerm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICondition_Clone(self: *const T, ppc: ?*?*ICondition) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).Clone(@as(*const ICondition, @ptrCast(self)), ppc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ICondition2_Value = Guid.initString("0db8851d-2e5b-47eb-9208-d28c325a01d7");
pub const IID_ICondition2 = &IID_ICondition2_Value;
pub const ICondition2 = extern struct {
    pub const VTable = extern struct {
        base: ICondition.VTable,
        GetLocale: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICondition2,
                ppszLocaleName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICondition2,
                ppszLocaleName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLeafConditionInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICondition2,
                ppropkey: ?*PROPERTYKEY,
                pcop: ?*CONDITION_OPERATION,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICondition2,
                ppropkey: ?*PROPERTYKEY,
                pcop: ?*CONDITION_OPERATION,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICondition.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICondition2_GetLocale(self: *const T, ppszLocaleName: ?*?PWSTR) HRESULT {
                return @as(*const ICondition2.VTable, @ptrCast(self.vtable)).GetLocale(@as(*const ICondition2, @ptrCast(self)), ppszLocaleName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICondition2_GetLeafConditionInfo(self: *const T, ppropkey: ?*PROPERTYKEY, pcop: ?*CONDITION_OPERATION, ppropvar: ?*PROPVARIANT) HRESULT {
                return @as(*const ICondition2.VTable, @ptrCast(self.vtable)).GetLeafConditionInfo(@as(*const ICondition2, @ptrCast(self)), ppropkey, pcop, ppropvar);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DB_NUMERIC = extern struct {
    precision: u8,
    scale: u8,
    sign: u8,
    val: [16]u8,
};

pub const DBDATE = extern struct {
    year: i16,
    month: u16,
    day: u16,
};

pub const DBTIME = extern struct {
    hour: u16,
    minute: u16,
    second: u16,
};

pub const DB_VARNUMERIC = extern struct {
    precision: u8,
    scale: i8,
    sign: u8,
    val: [1]u8,
};

pub const DBTYPEENUM = enum(i32) {
    EMPTY = 0,
    NULL = 1,
    I2 = 2,
    I4 = 3,
    R4 = 4,
    R8 = 5,
    CY = 6,
    DATE = 7,
    BSTR = 8,
    IDISPATCH = 9,
    ERROR = 10,
    BOOL = 11,
    VARIANT = 12,
    IUNKNOWN = 13,
    DECIMAL = 14,
    UI1 = 17,
    ARRAY = 8192,
    BYREF = 16384,
    I1 = 16,
    UI2 = 18,
    UI4 = 19,
    I8 = 20,
    UI8 = 21,
    GUID = 72,
    VECTOR = 4096,
    RESERVED = 32768,
    BYTES = 128,
    STR = 129,
    WSTR = 130,
    NUMERIC = 131,
    UDT = 132,
    DBDATE = 133,
    DBTIME = 134,
    DBTIMESTAMP = 135,
};
pub const DBTYPE_EMPTY = DBTYPEENUM.EMPTY;
pub const DBTYPE_NULL = DBTYPEENUM.NULL;
pub const DBTYPE_I2 = DBTYPEENUM.I2;
pub const DBTYPE_I4 = DBTYPEENUM.I4;
pub const DBTYPE_R4 = DBTYPEENUM.R4;
pub const DBTYPE_R8 = DBTYPEENUM.R8;
pub const DBTYPE_CY = DBTYPEENUM.CY;
pub const DBTYPE_DATE = DBTYPEENUM.DATE;
pub const DBTYPE_BSTR = DBTYPEENUM.BSTR;
pub const DBTYPE_IDISPATCH = DBTYPEENUM.IDISPATCH;
pub const DBTYPE_ERROR = DBTYPEENUM.ERROR;
pub const DBTYPE_BOOL = DBTYPEENUM.BOOL;
pub const DBTYPE_VARIANT = DBTYPEENUM.VARIANT;
pub const DBTYPE_IUNKNOWN = DBTYPEENUM.IUNKNOWN;
pub const DBTYPE_DECIMAL = DBTYPEENUM.DECIMAL;
pub const DBTYPE_UI1 = DBTYPEENUM.UI1;
pub const DBTYPE_ARRAY = DBTYPEENUM.ARRAY;
pub const DBTYPE_BYREF = DBTYPEENUM.BYREF;
pub const DBTYPE_I1 = DBTYPEENUM.I1;
pub const DBTYPE_UI2 = DBTYPEENUM.UI2;
pub const DBTYPE_UI4 = DBTYPEENUM.UI4;
pub const DBTYPE_I8 = DBTYPEENUM.I8;
pub const DBTYPE_UI8 = DBTYPEENUM.UI8;
pub const DBTYPE_GUID = DBTYPEENUM.GUID;
pub const DBTYPE_VECTOR = DBTYPEENUM.VECTOR;
pub const DBTYPE_RESERVED = DBTYPEENUM.RESERVED;
pub const DBTYPE_BYTES = DBTYPEENUM.BYTES;
pub const DBTYPE_STR = DBTYPEENUM.STR;
pub const DBTYPE_WSTR = DBTYPEENUM.WSTR;
pub const DBTYPE_NUMERIC = DBTYPEENUM.NUMERIC;
pub const DBTYPE_UDT = DBTYPEENUM.UDT;
pub const DBTYPE_DBDATE = DBTYPEENUM.DBDATE;
pub const DBTYPE_DBTIME = DBTYPEENUM.DBTIME;
pub const DBTYPE_DBTIMESTAMP = DBTYPEENUM.DBTIMESTAMP;

pub const DBTYPEENUM15 = enum(i32) {
    R = 136,
};
pub const DBTYPE_HCHAPTER = DBTYPEENUM15.R;

pub const DBTYPEENUM20 = enum(i32) {
    FILETIME = 64,
    PROPVARIANT = 138,
    VARNUMERIC = 139,
};
pub const DBTYPE_FILETIME = DBTYPEENUM20.FILETIME;
pub const DBTYPE_PROPVARIANT = DBTYPEENUM20.PROPVARIANT;
pub const DBTYPE_VARNUMERIC = DBTYPEENUM20.VARNUMERIC;

pub const DBPARTENUM = enum(i32) {
    INVALID = 0,
    VALUE = 1,
    LENGTH = 2,
    STATUS = 4,
};
pub const DBPART_INVALID = DBPARTENUM.INVALID;
pub const DBPART_VALUE = DBPARTENUM.VALUE;
pub const DBPART_LENGTH = DBPARTENUM.LENGTH;
pub const DBPART_STATUS = DBPARTENUM.STATUS;

pub const DBPARAMIOENUM = enum(i32) {
    NOTPARAM = 0,
    INPUT = 1,
    OUTPUT = 2,
};
pub const DBPARAMIO_NOTPARAM = DBPARAMIOENUM.NOTPARAM;
pub const DBPARAMIO_INPUT = DBPARAMIOENUM.INPUT;
pub const DBPARAMIO_OUTPUT = DBPARAMIOENUM.OUTPUT;

pub const DBBINDFLAGENUM = enum(i32) {
    L = 1,
};
pub const DBBINDFLAG_HTML = DBBINDFLAGENUM.L;

pub const DBMEMOWNERENUM = enum(i32) {
    CLIENTOWNED = 0,
    PROVIDEROWNED = 1,
};
pub const DBMEMOWNER_CLIENTOWNED = DBMEMOWNERENUM.CLIENTOWNED;
pub const DBMEMOWNER_PROVIDEROWNED = DBMEMOWNERENUM.PROVIDEROWNED;

pub const DBSTATUSENUM = enum(i32) {
    S_OK = 0,
    E_BADACCESSOR = 1,
    E_CANTCONVERTVALUE = 2,
    S_ISNULL = 3,
    S_TRUNCATED = 4,
    E_SIGNMISMATCH = 5,
    E_DATAOVERFLOW = 6,
    E_CANTCREATE = 7,
    E_UNAVAILABLE = 8,
    E_PERMISSIONDENIED = 9,
    E_INTEGRITYVIOLATION = 10,
    E_SCHEMAVIOLATION = 11,
    E_BADSTATUS = 12,
    S_DEFAULT = 13,
};
pub const DBSTATUS_S_OK = DBSTATUSENUM.S_OK;
pub const DBSTATUS_E_BADACCESSOR = DBSTATUSENUM.E_BADACCESSOR;
pub const DBSTATUS_E_CANTCONVERTVALUE = DBSTATUSENUM.E_CANTCONVERTVALUE;
pub const DBSTATUS_S_ISNULL = DBSTATUSENUM.S_ISNULL;
pub const DBSTATUS_S_TRUNCATED = DBSTATUSENUM.S_TRUNCATED;
pub const DBSTATUS_E_SIGNMISMATCH = DBSTATUSENUM.E_SIGNMISMATCH;
pub const DBSTATUS_E_DATAOVERFLOW = DBSTATUSENUM.E_DATAOVERFLOW;
pub const DBSTATUS_E_CANTCREATE = DBSTATUSENUM.E_CANTCREATE;
pub const DBSTATUS_E_UNAVAILABLE = DBSTATUSENUM.E_UNAVAILABLE;
pub const DBSTATUS_E_PERMISSIONDENIED = DBSTATUSENUM.E_PERMISSIONDENIED;
pub const DBSTATUS_E_INTEGRITYVIOLATION = DBSTATUSENUM.E_INTEGRITYVIOLATION;
pub const DBSTATUS_E_SCHEMAVIOLATION = DBSTATUSENUM.E_SCHEMAVIOLATION;
pub const DBSTATUS_E_BADSTATUS = DBSTATUSENUM.E_BADSTATUS;
pub const DBSTATUS_S_DEFAULT = DBSTATUSENUM.S_DEFAULT;

pub const DBSTATUSENUM20 = enum(i32) {
    MDSTATUS_S_CELLEMPTY = 14,
    DBSTATUS_S_IGNORE = 15,
};
pub const MDSTATUS_S_CELLEMPTY = DBSTATUSENUM20.MDSTATUS_S_CELLEMPTY;
pub const DBSTATUS_S_IGNORE = DBSTATUSENUM20.DBSTATUS_S_IGNORE;

pub const DBSTATUSENUM21 = enum(i32) {
    E_DOESNOTEXIST = 16,
    E_INVALIDURL = 17,
    E_RESOURCELOCKED = 18,
    E_RESOURCEEXISTS = 19,
    E_CANNOTCOMPLETE = 20,
    E_VOLUMENOTFOUND = 21,
    E_OUTOFSPACE = 22,
    S_CANNOTDELETESOURCE = 23,
    E_READONLY = 24,
    E_RESOURCEOUTOFSCOPE = 25,
    S_ALREADYEXISTS = 26,
};
pub const DBSTATUS_E_DOESNOTEXIST = DBSTATUSENUM21.E_DOESNOTEXIST;
pub const DBSTATUS_E_INVALIDURL = DBSTATUSENUM21.E_INVALIDURL;
pub const DBSTATUS_E_RESOURCELOCKED = DBSTATUSENUM21.E_RESOURCELOCKED;
pub const DBSTATUS_E_RESOURCEEXISTS = DBSTATUSENUM21.E_RESOURCEEXISTS;
pub const DBSTATUS_E_CANNOTCOMPLETE = DBSTATUSENUM21.E_CANNOTCOMPLETE;
pub const DBSTATUS_E_VOLUMENOTFOUND = DBSTATUSENUM21.E_VOLUMENOTFOUND;
pub const DBSTATUS_E_OUTOFSPACE = DBSTATUSENUM21.E_OUTOFSPACE;
pub const DBSTATUS_S_CANNOTDELETESOURCE = DBSTATUSENUM21.S_CANNOTDELETESOURCE;
pub const DBSTATUS_E_READONLY = DBSTATUSENUM21.E_READONLY;
pub const DBSTATUS_E_RESOURCEOUTOFSCOPE = DBSTATUSENUM21.E_RESOURCEOUTOFSCOPE;
pub const DBSTATUS_S_ALREADYEXISTS = DBSTATUSENUM21.S_ALREADYEXISTS;

pub const DBBINDURLFLAGENUM = enum(i32) {
    READ = 1,
    WRITE = 2,
    READWRITE = 3,
    SHARE_DENY_READ = 4,
    SHARE_DENY_WRITE = 8,
    SHARE_EXCLUSIVE = 12,
    SHARE_DENY_NONE = 16,
    ASYNCHRONOUS = 4096,
    COLLECTION = 8192,
    DELAYFETCHSTREAM = 16384,
    DELAYFETCHCOLUMNS = 32768,
    RECURSIVE = 4194304,
    OUTPUT = 8388608,
    WAITFORINIT = 16777216,
    OPENIFEXISTS = 33554432,
    OVERWRITE = 67108864,
    ISSTRUCTUREDDOCUMENT = 134217728,
};
pub const DBBINDURLFLAG_READ = DBBINDURLFLAGENUM.READ;
pub const DBBINDURLFLAG_WRITE = DBBINDURLFLAGENUM.WRITE;
pub const DBBINDURLFLAG_READWRITE = DBBINDURLFLAGENUM.READWRITE;
pub const DBBINDURLFLAG_SHARE_DENY_READ = DBBINDURLFLAGENUM.SHARE_DENY_READ;
pub const DBBINDURLFLAG_SHARE_DENY_WRITE = DBBINDURLFLAGENUM.SHARE_DENY_WRITE;
pub const DBBINDURLFLAG_SHARE_EXCLUSIVE = DBBINDURLFLAGENUM.SHARE_EXCLUSIVE;
pub const DBBINDURLFLAG_SHARE_DENY_NONE = DBBINDURLFLAGENUM.SHARE_DENY_NONE;
pub const DBBINDURLFLAG_ASYNCHRONOUS = DBBINDURLFLAGENUM.ASYNCHRONOUS;
pub const DBBINDURLFLAG_COLLECTION = DBBINDURLFLAGENUM.COLLECTION;
pub const DBBINDURLFLAG_DELAYFETCHSTREAM = DBBINDURLFLAGENUM.DELAYFETCHSTREAM;
pub const DBBINDURLFLAG_DELAYFETCHCOLUMNS = DBBINDURLFLAGENUM.DELAYFETCHCOLUMNS;
pub const DBBINDURLFLAG_RECURSIVE = DBBINDURLFLAGENUM.RECURSIVE;
pub const DBBINDURLFLAG_OUTPUT = DBBINDURLFLAGENUM.OUTPUT;
pub const DBBINDURLFLAG_WAITFORINIT = DBBINDURLFLAGENUM.WAITFORINIT;
pub const DBBINDURLFLAG_OPENIFEXISTS = DBBINDURLFLAGENUM.OPENIFEXISTS;
pub const DBBINDURLFLAG_OVERWRITE = DBBINDURLFLAGENUM.OVERWRITE;
pub const DBBINDURLFLAG_ISSTRUCTUREDDOCUMENT = DBBINDURLFLAGENUM.ISSTRUCTUREDDOCUMENT;

pub const DBBINDURLSTATUSENUM = enum(i32) {
    OK = 0,
    DENYNOTSUPPORTED = 1,
    DENYTYPENOTSUPPORTED = 4,
    REDIRECTED = 8,
};
pub const DBBINDURLSTATUS_S_OK = DBBINDURLSTATUSENUM.OK;
pub const DBBINDURLSTATUS_S_DENYNOTSUPPORTED = DBBINDURLSTATUSENUM.DENYNOTSUPPORTED;
pub const DBBINDURLSTATUS_S_DENYTYPENOTSUPPORTED = DBBINDURLSTATUSENUM.DENYTYPENOTSUPPORTED;
pub const DBBINDURLSTATUS_S_REDIRECTED = DBBINDURLSTATUSENUM.REDIRECTED;

pub const DBSTATUSENUM25 = enum(i32) {
    CANCELED = 27,
    NOTCOLLECTION = 28,
};
pub const DBSTATUS_E_CANCELED = DBSTATUSENUM25.CANCELED;
pub const DBSTATUS_E_NOTCOLLECTION = DBSTATUSENUM25.NOTCOLLECTION;

pub const DBROWSTATUSENUM = enum(i32) {
    S_OK = 0,
    S_MULTIPLECHANGES = 2,
    S_PENDINGCHANGES = 3,
    E_CANCELED = 4,
    E_CANTRELEASE = 6,
    E_CONCURRENCYVIOLATION = 7,
    E_DELETED = 8,
    E_PENDINGINSERT = 9,
    E_NEWLYINSERTED = 10,
    E_INTEGRITYVIOLATION = 11,
    E_INVALID = 12,
    E_MAXPENDCHANGESEXCEEDED = 13,
    E_OBJECTOPEN = 14,
    E_OUTOFMEMORY = 15,
    E_PERMISSIONDENIED = 16,
    E_LIMITREACHED = 17,
    E_SCHEMAVIOLATION = 18,
    E_FAIL = 19,
};
pub const DBROWSTATUS_S_OK = DBROWSTATUSENUM.S_OK;
pub const DBROWSTATUS_S_MULTIPLECHANGES = DBROWSTATUSENUM.S_MULTIPLECHANGES;
pub const DBROWSTATUS_S_PENDINGCHANGES = DBROWSTATUSENUM.S_PENDINGCHANGES;
pub const DBROWSTATUS_E_CANCELED = DBROWSTATUSENUM.E_CANCELED;
pub const DBROWSTATUS_E_CANTRELEASE = DBROWSTATUSENUM.E_CANTRELEASE;
pub const DBROWSTATUS_E_CONCURRENCYVIOLATION = DBROWSTATUSENUM.E_CONCURRENCYVIOLATION;
pub const DBROWSTATUS_E_DELETED = DBROWSTATUSENUM.E_DELETED;
pub const DBROWSTATUS_E_PENDINGINSERT = DBROWSTATUSENUM.E_PENDINGINSERT;
pub const DBROWSTATUS_E_NEWLYINSERTED = DBROWSTATUSENUM.E_NEWLYINSERTED;
pub const DBROWSTATUS_E_INTEGRITYVIOLATION = DBROWSTATUSENUM.E_INTEGRITYVIOLATION;
pub const DBROWSTATUS_E_INVALID = DBROWSTATUSENUM.E_INVALID;
pub const DBROWSTATUS_E_MAXPENDCHANGESEXCEEDED = DBROWSTATUSENUM.E_MAXPENDCHANGESEXCEEDED;
pub const DBROWSTATUS_E_OBJECTOPEN = DBROWSTATUSENUM.E_OBJECTOPEN;
pub const DBROWSTATUS_E_OUTOFMEMORY = DBROWSTATUSENUM.E_OUTOFMEMORY;
pub const DBROWSTATUS_E_PERMISSIONDENIED = DBROWSTATUSENUM.E_PERMISSIONDENIED;
pub const DBROWSTATUS_E_LIMITREACHED = DBROWSTATUSENUM.E_LIMITREACHED;
pub const DBROWSTATUS_E_SCHEMAVIOLATION = DBROWSTATUSENUM.E_SCHEMAVIOLATION;
pub const DBROWSTATUS_E_FAIL = DBROWSTATUSENUM.E_FAIL;

pub const DBROWSTATUSENUM20 = enum(i32) {
    E = 20,
};
pub const DBROWSTATUS_S_NOCHANGE = DBROWSTATUSENUM20.E;

pub const DBSTATUSENUM26 = enum(i32) {
    N = 29,
};
pub const DBSTATUS_S_ROWSETCOLUMN = DBSTATUSENUM26.N;

pub const DBCOLUMNFLAGSENUM = enum(i32) {
    ISBOOKMARK = 1,
    MAYDEFER = 2,
    WRITE = 4,
    WRITEUNKNOWN = 8,
    ISFIXEDLENGTH = 16,
    ISNULLABLE = 32,
    MAYBENULL = 64,
    ISLONG = 128,
    ISROWID = 256,
    ISROWVER = 512,
    CACHEDEFERRED = 4096,
};
pub const DBCOLUMNFLAGS_ISBOOKMARK = DBCOLUMNFLAGSENUM.ISBOOKMARK;
pub const DBCOLUMNFLAGS_MAYDEFER = DBCOLUMNFLAGSENUM.MAYDEFER;
pub const DBCOLUMNFLAGS_WRITE = DBCOLUMNFLAGSENUM.WRITE;
pub const DBCOLUMNFLAGS_WRITEUNKNOWN = DBCOLUMNFLAGSENUM.WRITEUNKNOWN;
pub const DBCOLUMNFLAGS_ISFIXEDLENGTH = DBCOLUMNFLAGSENUM.ISFIXEDLENGTH;
pub const DBCOLUMNFLAGS_ISNULLABLE = DBCOLUMNFLAGSENUM.ISNULLABLE;
pub const DBCOLUMNFLAGS_MAYBENULL = DBCOLUMNFLAGSENUM.MAYBENULL;
pub const DBCOLUMNFLAGS_ISLONG = DBCOLUMNFLAGSENUM.ISLONG;
pub const DBCOLUMNFLAGS_ISROWID = DBCOLUMNFLAGSENUM.ISROWID;
pub const DBCOLUMNFLAGS_ISROWVER = DBCOLUMNFLAGSENUM.ISROWVER;
pub const DBCOLUMNFLAGS_CACHEDEFERRED = DBCOLUMNFLAGSENUM.CACHEDEFERRED;

pub const DBCOLUMNFLAGSENUM20 = enum(i32) {
    SCALEISNEGATIVE = 16384,
    RESERVED = 32768,
};
pub const DBCOLUMNFLAGS_SCALEISNEGATIVE = DBCOLUMNFLAGSENUM20.SCALEISNEGATIVE;
pub const DBCOLUMNFLAGS_RESERVED = DBCOLUMNFLAGSENUM20.RESERVED;

pub const DBCOLUMNFLAGS15ENUM = enum(i32) {
    R = 8192,
};
pub const DBCOLUMNFLAGS_ISCHAPTER = DBCOLUMNFLAGS15ENUM.R;

pub const DBCOLUMNFLAGSENUM21 = enum(i32) {
    ROWURL = 65536,
    DEFAULTSTREAM = 131072,
    COLLECTION = 262144,
};
pub const DBCOLUMNFLAGS_ISROWURL = DBCOLUMNFLAGSENUM21.ROWURL;
pub const DBCOLUMNFLAGS_ISDEFAULTSTREAM = DBCOLUMNFLAGSENUM21.DEFAULTSTREAM;
pub const DBCOLUMNFLAGS_ISCOLLECTION = DBCOLUMNFLAGSENUM21.COLLECTION;

pub const DBCOLUMNFLAGSENUM26 = enum(i32) {
    ISSTREAM = 524288,
    ISROWSET = 1048576,
    ISROW = 2097152,
    ROWSPECIFICCOLUMN = 4194304,
};
pub const DBCOLUMNFLAGS_ISSTREAM = DBCOLUMNFLAGSENUM26.ISSTREAM;
pub const DBCOLUMNFLAGS_ISROWSET = DBCOLUMNFLAGSENUM26.ISROWSET;
pub const DBCOLUMNFLAGS_ISROW = DBCOLUMNFLAGSENUM26.ISROW;
pub const DBCOLUMNFLAGS_ROWSPECIFICCOLUMN = DBCOLUMNFLAGSENUM26.ROWSPECIFICCOLUMN;

pub const DBTABLESTATISTICSTYPE26 = enum(i32) {
    HISTOGRAM = 1,
    COLUMN_CARDINALITY = 2,
    TUPLE_CARDINALITY = 4,
};
pub const DBSTAT_HISTOGRAM = DBTABLESTATISTICSTYPE26.HISTOGRAM;
pub const DBSTAT_COLUMN_CARDINALITY = DBTABLESTATISTICSTYPE26.COLUMN_CARDINALITY;
pub const DBSTAT_TUPLE_CARDINALITY = DBTABLESTATISTICSTYPE26.TUPLE_CARDINALITY;

pub const DBBOOKMARK = enum(i32) {
    INVALID = 0,
    FIRST = 1,
    LAST = 2,
};
pub const DBBMK_INVALID = DBBOOKMARK.INVALID;
pub const DBBMK_FIRST = DBBOOKMARK.FIRST;
pub const DBBMK_LAST = DBBOOKMARK.LAST;

pub const DBPROPENUM = enum(i32) {
    ABORTPRESERVE = 2,
    ACTIVESESSIONS = 3,
    APPENDONLY = 187,
    ASYNCTXNABORT = 168,
    ASYNCTXNCOMMIT = 4,
    AUTH_CACHE_AUTHINFO = 5,
    AUTH_ENCRYPT_PASSWORD = 6,
    AUTH_INTEGRATED = 7,
    AUTH_MASK_PASSWORD = 8,
    AUTH_PASSWORD = 9,
    AUTH_PERSIST_ENCRYPTED = 10,
    AUTH_PERSIST_SENSITIVE_AUTHINFO = 11,
    AUTH_USERID = 12,
    BLOCKINGSTORAGEOBJECTS = 13,
    BOOKMARKS = 14,
    BOOKMARKSKIPPED = 15,
    BOOKMARKTYPE = 16,
    BYREFACCESSORS = 120,
    CACHEDEFERRED = 17,
    CANFETCHBACKWARDS = 18,
    CANHOLDROWS = 19,
    CANSCROLLBACKWARDS = 21,
    CATALOGLOCATION = 22,
    CATALOGTERM = 23,
    CATALOGUSAGE = 24,
    CHANGEINSERTEDROWS = 188,
    COL_AUTOINCREMENT = 26,
    COL_DEFAULT = 27,
    COL_DESCRIPTION = 28,
    COL_FIXEDLENGTH = 167,
    COL_NULLABLE = 29,
    COL_PRIMARYKEY = 30,
    COL_UNIQUE = 31,
    COLUMNDEFINITION = 32,
    COLUMNRESTRICT = 33,
    COMMANDTIMEOUT = 34,
    COMMITPRESERVE = 35,
    CONCATNULLBEHAVIOR = 36,
    CURRENTCATALOG = 37,
    DATASOURCENAME = 38,
    DATASOURCEREADONLY = 39,
    DBMSNAME = 40,
    DBMSVER = 41,
    DEFERRED = 42,
    DELAYSTORAGEOBJECTS = 43,
    DSOTHREADMODEL = 169,
    GROUPBY = 44,
    HETEROGENEOUSTABLES = 45,
    IAccessor = 121,
    IColumnsInfo = 122,
    IColumnsRowset = 123,
    IConnectionPointContainer = 124,
    IConvertType = 194,
    IRowset = 126,
    IRowsetChange = 127,
    IRowsetIdentity = 128,
    IRowsetIndex = 159,
    IRowsetInfo = 129,
    IRowsetLocate = 130,
    IRowsetResynch = 132,
    IRowsetScroll = 133,
    IRowsetUpdate = 134,
    ISupportErrorInfo = 135,
    ILockBytes = 136,
    ISequentialStream = 137,
    IStorage = 138,
    IStream = 139,
    IDENTIFIERCASE = 46,
    IMMOBILEROWS = 47,
    INDEX_AUTOUPDATE = 48,
    INDEX_CLUSTERED = 49,
    INDEX_FILLFACTOR = 50,
    INDEX_INITIALSIZE = 51,
    INDEX_NULLCOLLATION = 52,
    INDEX_NULLS = 53,
    INDEX_PRIMARYKEY = 54,
    INDEX_SORTBOOKMARKS = 55,
    INDEX_TEMPINDEX = 163,
    INDEX_TYPE = 56,
    INDEX_UNIQUE = 57,
    INIT_DATASOURCE = 59,
    INIT_HWND = 60,
    INIT_IMPERSONATION_LEVEL = 61,
    INIT_LCID = 186,
    INIT_LOCATION = 62,
    INIT_MODE = 63,
    INIT_PROMPT = 64,
    INIT_PROTECTION_LEVEL = 65,
    INIT_PROVIDERSTRING = 160,
    INIT_TIMEOUT = 66,
    LITERALBOOKMARKS = 67,
    LITERALIDENTITY = 68,
    MAXINDEXSIZE = 70,
    MAXOPENROWS = 71,
    MAXPENDINGROWS = 72,
    MAXROWS = 73,
    MAXROWSIZE = 74,
    MAXROWSIZEINCLUDESBLOB = 75,
    MAXTABLESINSELECT = 76,
    MAYWRITECOLUMN = 77,
    MEMORYUSAGE = 78,
    MULTIPLEPARAMSETS = 191,
    MULTIPLERESULTS = 196,
    MULTIPLESTORAGEOBJECTS = 80,
    MULTITABLEUPDATE = 81,
    NOTIFICATIONGRANULARITY = 198,
    NOTIFICATIONPHASES = 82,
    NOTIFYCOLUMNSET = 171,
    NOTIFYROWDELETE = 173,
    NOTIFYROWFIRSTCHANGE = 174,
    NOTIFYROWINSERT = 175,
    NOTIFYROWRESYNCH = 177,
    NOTIFYROWSETCHANGED = 211,
    NOTIFYROWSETRELEASE = 178,
    NOTIFYROWSETFETCHPOSITIONCHANGE = 179,
    NOTIFYROWUNDOCHANGE = 180,
    NOTIFYROWUNDODELETE = 181,
    NOTIFYROWUNDOINSERT = 182,
    NOTIFYROWUPDATE = 183,
    NULLCOLLATION = 83,
    OLEOBJECTS = 84,
    ORDERBYCOLUMNSINSELECT = 85,
    ORDEREDBOOKMARKS = 86,
    OTHERINSERT = 87,
    OTHERUPDATEDELETE = 88,
    OUTPUTPARAMETERAVAILABILITY = 184,
    OWNINSERT = 89,
    OWNUPDATEDELETE = 90,
    PERSISTENTIDTYPE = 185,
    PREPAREABORTBEHAVIOR = 91,
    PREPARECOMMITBEHAVIOR = 92,
    PROCEDURETERM = 93,
    PROVIDERNAME = 96,
    PROVIDEROLEDBVER = 97,
    PROVIDERVER = 98,
    QUICKRESTART = 99,
    QUOTEDIDENTIFIERCASE = 100,
    REENTRANTEVENTS = 101,
    REMOVEDELETED = 102,
    REPORTMULTIPLECHANGES = 103,
    RETURNPENDINGINSERTS = 189,
    ROWRESTRICT = 104,
    ROWSETCONVERSIONSONCOMMAND = 192,
    ROWTHREADMODEL = 105,
    SCHEMATERM = 106,
    SCHEMAUSAGE = 107,
    SERVERCURSOR = 108,
    SESS_AUTOCOMMITISOLEVELS = 190,
    SQLSUPPORT = 109,
    STRONGIDENTITY = 119,
    STRUCTUREDSTORAGE = 111,
    SUBQUERIES = 112,
    SUPPORTEDTXNDDL = 161,
    SUPPORTEDTXNISOLEVELS = 113,
    SUPPORTEDTXNISORETAIN = 114,
    TABLETERM = 115,
    TBL_TEMPTABLE = 140,
    TRANSACTEDOBJECT = 116,
    UPDATABILITY = 117,
    USERNAME = 118,
};
pub const DBPROP_ABORTPRESERVE = DBPROPENUM.ABORTPRESERVE;
pub const DBPROP_ACTIVESESSIONS = DBPROPENUM.ACTIVESESSIONS;
pub const DBPROP_APPENDONLY = DBPROPENUM.APPENDONLY;
pub const DBPROP_ASYNCTXNABORT = DBPROPENUM.ASYNCTXNABORT;
pub const DBPROP_ASYNCTXNCOMMIT = DBPROPENUM.ASYNCTXNCOMMIT;
pub const DBPROP_AUTH_CACHE_AUTHINFO = DBPROPENUM.AUTH_CACHE_AUTHINFO;
pub const DBPROP_AUTH_ENCRYPT_PASSWORD = DBPROPENUM.AUTH_ENCRYPT_PASSWORD;
pub const DBPROP_AUTH_INTEGRATED = DBPROPENUM.AUTH_INTEGRATED;
pub const DBPROP_AUTH_MASK_PASSWORD = DBPROPENUM.AUTH_MASK_PASSWORD;
pub const DBPROP_AUTH_PASSWORD = DBPROPENUM.AUTH_PASSWORD;
pub const DBPROP_AUTH_PERSIST_ENCRYPTED = DBPROPENUM.AUTH_PERSIST_ENCRYPTED;
pub const DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO = DBPROPENUM.AUTH_PERSIST_SENSITIVE_AUTHINFO;
pub const DBPROP_AUTH_USERID = DBPROPENUM.AUTH_USERID;
pub const DBPROP_BLOCKINGSTORAGEOBJECTS = DBPROPENUM.BLOCKINGSTORAGEOBJECTS;
pub const DBPROP_BOOKMARKS = DBPROPENUM.BOOKMARKS;
pub const DBPROP_BOOKMARKSKIPPED = DBPROPENUM.BOOKMARKSKIPPED;
pub const DBPROP_BOOKMARKTYPE = DBPROPENUM.BOOKMARKTYPE;
pub const DBPROP_BYREFACCESSORS = DBPROPENUM.BYREFACCESSORS;
pub const DBPROP_CACHEDEFERRED = DBPROPENUM.CACHEDEFERRED;
pub const DBPROP_CANFETCHBACKWARDS = DBPROPENUM.CANFETCHBACKWARDS;
pub const DBPROP_CANHOLDROWS = DBPROPENUM.CANHOLDROWS;
pub const DBPROP_CANSCROLLBACKWARDS = DBPROPENUM.CANSCROLLBACKWARDS;
pub const DBPROP_CATALOGLOCATION = DBPROPENUM.CATALOGLOCATION;
pub const DBPROP_CATALOGTERM = DBPROPENUM.CATALOGTERM;
pub const DBPROP_CATALOGUSAGE = DBPROPENUM.CATALOGUSAGE;
pub const DBPROP_CHANGEINSERTEDROWS = DBPROPENUM.CHANGEINSERTEDROWS;
pub const DBPROP_COL_AUTOINCREMENT = DBPROPENUM.COL_AUTOINCREMENT;
pub const DBPROP_COL_DEFAULT = DBPROPENUM.COL_DEFAULT;
pub const DBPROP_COL_DESCRIPTION = DBPROPENUM.COL_DESCRIPTION;
pub const DBPROP_COL_FIXEDLENGTH = DBPROPENUM.COL_FIXEDLENGTH;
pub const DBPROP_COL_NULLABLE = DBPROPENUM.COL_NULLABLE;
pub const DBPROP_COL_PRIMARYKEY = DBPROPENUM.COL_PRIMARYKEY;
pub const DBPROP_COL_UNIQUE = DBPROPENUM.COL_UNIQUE;
pub const DBPROP_COLUMNDEFINITION = DBPROPENUM.COLUMNDEFINITION;
pub const DBPROP_COLUMNRESTRICT = DBPROPENUM.COLUMNRESTRICT;
pub const DBPROP_COMMANDTIMEOUT = DBPROPENUM.COMMANDTIMEOUT;
pub const DBPROP_COMMITPRESERVE = DBPROPENUM.COMMITPRESERVE;
pub const DBPROP_CONCATNULLBEHAVIOR = DBPROPENUM.CONCATNULLBEHAVIOR;
pub const DBPROP_CURRENTCATALOG = DBPROPENUM.CURRENTCATALOG;
pub const DBPROP_DATASOURCENAME = DBPROPENUM.DATASOURCENAME;
pub const DBPROP_DATASOURCEREADONLY = DBPROPENUM.DATASOURCEREADONLY;
pub const DBPROP_DBMSNAME = DBPROPENUM.DBMSNAME;
pub const DBPROP_DBMSVER = DBPROPENUM.DBMSVER;
pub const DBPROP_DEFERRED = DBPROPENUM.DEFERRED;
pub const DBPROP_DELAYSTORAGEOBJECTS = DBPROPENUM.DELAYSTORAGEOBJECTS;
pub const DBPROP_DSOTHREADMODEL = DBPROPENUM.DSOTHREADMODEL;
pub const DBPROP_GROUPBY = DBPROPENUM.GROUPBY;
pub const DBPROP_HETEROGENEOUSTABLES = DBPROPENUM.HETEROGENEOUSTABLES;
pub const DBPROP_IAccessor = DBPROPENUM.IAccessor;
pub const DBPROP_IColumnsInfo = DBPROPENUM.IColumnsInfo;
pub const DBPROP_IColumnsRowset = DBPROPENUM.IColumnsRowset;
pub const DBPROP_IConnectionPointContainer = DBPROPENUM.IConnectionPointContainer;
pub const DBPROP_IConvertType = DBPROPENUM.IConvertType;
pub const DBPROP_IRowset = DBPROPENUM.IRowset;
pub const DBPROP_IRowsetChange = DBPROPENUM.IRowsetChange;
pub const DBPROP_IRowsetIdentity = DBPROPENUM.IRowsetIdentity;
pub const DBPROP_IRowsetIndex = DBPROPENUM.IRowsetIndex;
pub const DBPROP_IRowsetInfo = DBPROPENUM.IRowsetInfo;
pub const DBPROP_IRowsetLocate = DBPROPENUM.IRowsetLocate;
pub const DBPROP_IRowsetResynch = DBPROPENUM.IRowsetResynch;
pub const DBPROP_IRowsetScroll = DBPROPENUM.IRowsetScroll;
pub const DBPROP_IRowsetUpdate = DBPROPENUM.IRowsetUpdate;
pub const DBPROP_ISupportErrorInfo = DBPROPENUM.ISupportErrorInfo;
pub const DBPROP_ILockBytes = DBPROPENUM.ILockBytes;
pub const DBPROP_ISequentialStream = DBPROPENUM.ISequentialStream;
pub const DBPROP_IStorage = DBPROPENUM.IStorage;
pub const DBPROP_IStream = DBPROPENUM.IStream;
pub const DBPROP_IDENTIFIERCASE = DBPROPENUM.IDENTIFIERCASE;
pub const DBPROP_IMMOBILEROWS = DBPROPENUM.IMMOBILEROWS;
pub const DBPROP_INDEX_AUTOUPDATE = DBPROPENUM.INDEX_AUTOUPDATE;
pub const DBPROP_INDEX_CLUSTERED = DBPROPENUM.INDEX_CLUSTERED;
pub const DBPROP_INDEX_FILLFACTOR = DBPROPENUM.INDEX_FILLFACTOR;
pub const DBPROP_INDEX_INITIALSIZE = DBPROPENUM.INDEX_INITIALSIZE;
pub const DBPROP_INDEX_NULLCOLLATION = DBPROPENUM.INDEX_NULLCOLLATION;
pub const DBPROP_INDEX_NULLS = DBPROPENUM.INDEX_NULLS;
pub const DBPROP_INDEX_PRIMARYKEY = DBPROPENUM.INDEX_PRIMARYKEY;
pub const DBPROP_INDEX_SORTBOOKMARKS = DBPROPENUM.INDEX_SORTBOOKMARKS;
pub const DBPROP_INDEX_TEMPINDEX = DBPROPENUM.INDEX_TEMPINDEX;
pub const DBPROP_INDEX_TYPE = DBPROPENUM.INDEX_TYPE;
pub const DBPROP_INDEX_UNIQUE = DBPROPENUM.INDEX_UNIQUE;
pub const DBPROP_INIT_DATASOURCE = DBPROPENUM.INIT_DATASOURCE;
pub const DBPROP_INIT_HWND = DBPROPENUM.INIT_HWND;
pub const DBPROP_INIT_IMPERSONATION_LEVEL = DBPROPENUM.INIT_IMPERSONATION_LEVEL;
pub const DBPROP_INIT_LCID = DBPROPENUM.INIT_LCID;
pub const DBPROP_INIT_LOCATION = DBPROPENUM.INIT_LOCATION;
pub const DBPROP_INIT_MODE = DBPROPENUM.INIT_MODE;
pub const DBPROP_INIT_PROMPT = DBPROPENUM.INIT_PROMPT;
pub const DBPROP_INIT_PROTECTION_LEVEL = DBPROPENUM.INIT_PROTECTION_LEVEL;
pub const DBPROP_INIT_PROVIDERSTRING = DBPROPENUM.INIT_PROVIDERSTRING;
pub const DBPROP_INIT_TIMEOUT = DBPROPENUM.INIT_TIMEOUT;
pub const DBPROP_LITERALBOOKMARKS = DBPROPENUM.LITERALBOOKMARKS;
pub const DBPROP_LITERALIDENTITY = DBPROPENUM.LITERALIDENTITY;
pub const DBPROP_MAXINDEXSIZE = DBPROPENUM.MAXINDEXSIZE;
pub const DBPROP_MAXOPENROWS = DBPROPENUM.MAXOPENROWS;
pub const DBPROP_MAXPENDINGROWS = DBPROPENUM.MAXPENDINGROWS;
pub const DBPROP_MAXROWS = DBPROPENUM.MAXROWS;
pub const DBPROP_MAXROWSIZE = DBPROPENUM.MAXROWSIZE;
pub const DBPROP_MAXROWSIZEINCLUDESBLOB = DBPROPENUM.MAXROWSIZEINCLUDESBLOB;
pub const DBPROP_MAXTABLESINSELECT = DBPROPENUM.MAXTABLESINSELECT;
pub const DBPROP_MAYWRITECOLUMN = DBPROPENUM.MAYWRITECOLUMN;
pub const DBPROP_MEMORYUSAGE = DBPROPENUM.MEMORYUSAGE;
pub const DBPROP_MULTIPLEPARAMSETS = DBPROPENUM.MULTIPLEPARAMSETS;
pub const DBPROP_MULTIPLERESULTS = DBPROPENUM.MULTIPLERESULTS;
pub const DBPROP_MULTIPLESTORAGEOBJECTS = DBPROPENUM.MULTIPLESTORAGEOBJECTS;
pub const DBPROP_MULTITABLEUPDATE = DBPROPENUM.MULTITABLEUPDATE;
pub const DBPROP_NOTIFICATIONGRANULARITY = DBPROPENUM.NOTIFICATIONGRANULARITY;
pub const DBPROP_NOTIFICATIONPHASES = DBPROPENUM.NOTIFICATIONPHASES;
pub const DBPROP_NOTIFYCOLUMNSET = DBPROPENUM.NOTIFYCOLUMNSET;
pub const DBPROP_NOTIFYROWDELETE = DBPROPENUM.NOTIFYROWDELETE;
pub const DBPROP_NOTIFYROWFIRSTCHANGE = DBPROPENUM.NOTIFYROWFIRSTCHANGE;
pub const DBPROP_NOTIFYROWINSERT = DBPROPENUM.NOTIFYROWINSERT;
pub const DBPROP_NOTIFYROWRESYNCH = DBPROPENUM.NOTIFYROWRESYNCH;
pub const DBPROP_NOTIFYROWSETCHANGED = DBPROPENUM.NOTIFYROWSETCHANGED;
pub const DBPROP_NOTIFYROWSETRELEASE = DBPROPENUM.NOTIFYROWSETRELEASE;
pub const DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE = DBPROPENUM.NOTIFYROWSETFETCHPOSITIONCHANGE;
pub const DBPROP_NOTIFYROWUNDOCHANGE = DBPROPENUM.NOTIFYROWUNDOCHANGE;
pub const DBPROP_NOTIFYROWUNDODELETE = DBPROPENUM.NOTIFYROWUNDODELETE;
pub const DBPROP_NOTIFYROWUNDOINSERT = DBPROPENUM.NOTIFYROWUNDOINSERT;
pub const DBPROP_NOTIFYROWUPDATE = DBPROPENUM.NOTIFYROWUPDATE;
pub const DBPROP_NULLCOLLATION = DBPROPENUM.NULLCOLLATION;
pub const DBPROP_OLEOBJECTS = DBPROPENUM.OLEOBJECTS;
pub const DBPROP_ORDERBYCOLUMNSINSELECT = DBPROPENUM.ORDERBYCOLUMNSINSELECT;
pub const DBPROP_ORDEREDBOOKMARKS = DBPROPENUM.ORDEREDBOOKMARKS;
pub const DBPROP_OTHERINSERT = DBPROPENUM.OTHERINSERT;
pub const DBPROP_OTHERUPDATEDELETE = DBPROPENUM.OTHERUPDATEDELETE;
pub const DBPROP_OUTPUTPARAMETERAVAILABILITY = DBPROPENUM.OUTPUTPARAMETERAVAILABILITY;
pub const DBPROP_OWNINSERT = DBPROPENUM.OWNINSERT;
pub const DBPROP_OWNUPDATEDELETE = DBPROPENUM.OWNUPDATEDELETE;
pub const DBPROP_PERSISTENTIDTYPE = DBPROPENUM.PERSISTENTIDTYPE;
pub const DBPROP_PREPAREABORTBEHAVIOR = DBPROPENUM.PREPAREABORTBEHAVIOR;
pub const DBPROP_PREPARECOMMITBEHAVIOR = DBPROPENUM.PREPARECOMMITBEHAVIOR;
pub const DBPROP_PROCEDURETERM = DBPROPENUM.PROCEDURETERM;
pub const DBPROP_PROVIDERNAME = DBPROPENUM.PROVIDERNAME;
pub const DBPROP_PROVIDEROLEDBVER = DBPROPENUM.PROVIDEROLEDBVER;
pub const DBPROP_PROVIDERVER = DBPROPENUM.PROVIDERVER;
pub const DBPROP_QUICKRESTART = DBPROPENUM.QUICKRESTART;
pub const DBPROP_QUOTEDIDENTIFIERCASE = DBPROPENUM.QUOTEDIDENTIFIERCASE;
pub const DBPROP_REENTRANTEVENTS = DBPROPENUM.REENTRANTEVENTS;
pub const DBPROP_REMOVEDELETED = DBPROPENUM.REMOVEDELETED;
pub const DBPROP_REPORTMULTIPLECHANGES = DBPROPENUM.REPORTMULTIPLECHANGES;
pub const DBPROP_RETURNPENDINGINSERTS = DBPROPENUM.RETURNPENDINGINSERTS;
pub const DBPROP_ROWRESTRICT = DBPROPENUM.ROWRESTRICT;
pub const DBPROP_ROWSETCONVERSIONSONCOMMAND = DBPROPENUM.ROWSETCONVERSIONSONCOMMAND;
pub const DBPROP_ROWTHREADMODEL = DBPROPENUM.ROWTHREADMODEL;
pub const DBPROP_SCHEMATERM = DBPROPENUM.SCHEMATERM;
pub const DBPROP_SCHEMAUSAGE = DBPROPENUM.SCHEMAUSAGE;
pub const DBPROP_SERVERCURSOR = DBPROPENUM.SERVERCURSOR;
pub const DBPROP_SESS_AUTOCOMMITISOLEVELS = DBPROPENUM.SESS_AUTOCOMMITISOLEVELS;
pub const DBPROP_SQLSUPPORT = DBPROPENUM.SQLSUPPORT;
pub const DBPROP_STRONGIDENTITY = DBPROPENUM.STRONGIDENTITY;
pub const DBPROP_STRUCTUREDSTORAGE = DBPROPENUM.STRUCTUREDSTORAGE;
pub const DBPROP_SUBQUERIES = DBPROPENUM.SUBQUERIES;
pub const DBPROP_SUPPORTEDTXNDDL = DBPROPENUM.SUPPORTEDTXNDDL;
pub const DBPROP_SUPPORTEDTXNISOLEVELS = DBPROPENUM.SUPPORTEDTXNISOLEVELS;
pub const DBPROP_SUPPORTEDTXNISORETAIN = DBPROPENUM.SUPPORTEDTXNISORETAIN;
pub const DBPROP_TABLETERM = DBPROPENUM.TABLETERM;
pub const DBPROP_TBL_TEMPTABLE = DBPROPENUM.TBL_TEMPTABLE;
pub const DBPROP_TRANSACTEDOBJECT = DBPROPENUM.TRANSACTEDOBJECT;
pub const DBPROP_UPDATABILITY = DBPROPENUM.UPDATABILITY;
pub const DBPROP_USERNAME = DBPROPENUM.USERNAME;

pub const DBPROPENUM15 = enum(i32) {
    FILTERCOMPAREOPS = 209,
    FINDCOMPAREOPS = 210,
    IChapteredRowset = 202,
    IDBAsynchStatus = 203,
    IRowsetFind = 204,
    IRowsetView = 212,
    IViewChapter = 213,
    IViewFilter = 214,
    IViewRowset = 215,
    IViewSort = 216,
    INIT_ASYNCH = 200,
    MAXOPENCHAPTERS = 199,
    MAXORSINFILTER = 205,
    MAXSORTCOLUMNS = 206,
    ROWSET_ASYNCH = 201,
    SORTONINDEX = 207,
};
pub const DBPROP_FILTERCOMPAREOPS = DBPROPENUM15.FILTERCOMPAREOPS;
pub const DBPROP_FINDCOMPAREOPS = DBPROPENUM15.FINDCOMPAREOPS;
pub const DBPROP_IChapteredRowset = DBPROPENUM15.IChapteredRowset;
pub const DBPROP_IDBAsynchStatus = DBPROPENUM15.IDBAsynchStatus;
pub const DBPROP_IRowsetFind = DBPROPENUM15.IRowsetFind;
pub const DBPROP_IRowsetView = DBPROPENUM15.IRowsetView;
pub const DBPROP_IViewChapter = DBPROPENUM15.IViewChapter;
pub const DBPROP_IViewFilter = DBPROPENUM15.IViewFilter;
pub const DBPROP_IViewRowset = DBPROPENUM15.IViewRowset;
pub const DBPROP_IViewSort = DBPROPENUM15.IViewSort;
pub const DBPROP_INIT_ASYNCH = DBPROPENUM15.INIT_ASYNCH;
pub const DBPROP_MAXOPENCHAPTERS = DBPROPENUM15.MAXOPENCHAPTERS;
pub const DBPROP_MAXORSINFILTER = DBPROPENUM15.MAXORSINFILTER;
pub const DBPROP_MAXSORTCOLUMNS = DBPROPENUM15.MAXSORTCOLUMNS;
pub const DBPROP_ROWSET_ASYNCH = DBPROPENUM15.ROWSET_ASYNCH;
pub const DBPROP_SORTONINDEX = DBPROPENUM15.SORTONINDEX;

pub const DBPROPENUM20 = enum(i32) {
    DBPROP_IMultipleResults = 217,
    DBPROP_DATASOURCE_TYPE = 251,
    MDPROP_AXES = 252,
    MDPROP_FLATTENING_SUPPORT = 253,
    MDPROP_MDX_JOINCUBES = 254,
    MDPROP_NAMED_LEVELS = 255,
    MDPROP_RANGEROWSET = 256,
    MDPROP_MDX_SLICER = 218,
    MDPROP_MDX_CUBEQUALIFICATION = 219,
    MDPROP_MDX_OUTERREFERENCE = 220,
    MDPROP_MDX_QUERYBYPROPERTY = 221,
    MDPROP_MDX_CASESUPPORT = 222,
    MDPROP_MDX_STRING_COMPOP = 224,
    MDPROP_MDX_DESCFLAGS = 225,
    MDPROP_MDX_SET_FUNCTIONS = 226,
    MDPROP_MDX_MEMBER_FUNCTIONS = 227,
    MDPROP_MDX_NUMERIC_FUNCTIONS = 228,
    MDPROP_MDX_FORMULAS = 229,
    MDPROP_AGGREGATECELL_UPDATE = 230,
    // MDPROP_MDX_AGGREGATECELL_UPDATE = 230, this enum value conflicts with MDPROP_AGGREGATECELL_UPDATE
    MDPROP_MDX_OBJQUALIFICATION = 261,
    MDPROP_MDX_NONMEASURE_EXPRESSIONS = 262,
    DBPROP_ACCESSORDER = 231,
    DBPROP_BOOKMARKINFO = 232,
    DBPROP_INIT_CATALOG = 233,
    DBPROP_ROW_BULKOPS = 234,
    DBPROP_PROVIDERFRIENDLYNAME = 235,
    DBPROP_LOCKMODE = 236,
    DBPROP_MULTIPLECONNECTIONS = 237,
    DBPROP_UNIQUEROWS = 238,
    DBPROP_SERVERDATAONINSERT = 239,
    DBPROP_STORAGEFLAGS = 240,
    DBPROP_CONNECTIONSTATUS = 244,
    DBPROP_ALTERCOLUMN = 245,
    DBPROP_COLUMNLCID = 246,
    DBPROP_RESETDATASOURCE = 247,
    DBPROP_INIT_OLEDBSERVICES = 248,
    DBPROP_IRowsetRefresh = 249,
    DBPROP_SERVERNAME = 250,
    DBPROP_IParentRowset = 257,
    DBPROP_HIDDENCOLUMNS = 258,
    DBPROP_PROVIDERMEMORY = 259,
    DBPROP_CLIENTCURSOR = 260,
};
pub const DBPROP_IMultipleResults = DBPROPENUM20.DBPROP_IMultipleResults;
pub const DBPROP_DATASOURCE_TYPE = DBPROPENUM20.DBPROP_DATASOURCE_TYPE;
pub const MDPROP_AXES = DBPROPENUM20.MDPROP_AXES;
pub const MDPROP_FLATTENING_SUPPORT = DBPROPENUM20.MDPROP_FLATTENING_SUPPORT;
pub const MDPROP_MDX_JOINCUBES = DBPROPENUM20.MDPROP_MDX_JOINCUBES;
pub const MDPROP_NAMED_LEVELS = DBPROPENUM20.MDPROP_NAMED_LEVELS;
pub const MDPROP_RANGEROWSET = DBPROPENUM20.MDPROP_RANGEROWSET;
pub const MDPROP_MDX_SLICER = DBPROPENUM20.MDPROP_MDX_SLICER;
pub const MDPROP_MDX_CUBEQUALIFICATION = DBPROPENUM20.MDPROP_MDX_CUBEQUALIFICATION;
pub const MDPROP_MDX_OUTERREFERENCE = DBPROPENUM20.MDPROP_MDX_OUTERREFERENCE;
pub const MDPROP_MDX_QUERYBYPROPERTY = DBPROPENUM20.MDPROP_MDX_QUERYBYPROPERTY;
pub const MDPROP_MDX_CASESUPPORT = DBPROPENUM20.MDPROP_MDX_CASESUPPORT;
pub const MDPROP_MDX_STRING_COMPOP = DBPROPENUM20.MDPROP_MDX_STRING_COMPOP;
pub const MDPROP_MDX_DESCFLAGS = DBPROPENUM20.MDPROP_MDX_DESCFLAGS;
pub const MDPROP_MDX_SET_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_SET_FUNCTIONS;
pub const MDPROP_MDX_MEMBER_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_MEMBER_FUNCTIONS;
pub const MDPROP_MDX_NUMERIC_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_NUMERIC_FUNCTIONS;
pub const MDPROP_MDX_FORMULAS = DBPROPENUM20.MDPROP_MDX_FORMULAS;
pub const MDPROP_AGGREGATECELL_UPDATE = DBPROPENUM20.MDPROP_AGGREGATECELL_UPDATE;
pub const MDPROP_MDX_AGGREGATECELL_UPDATE = DBPROPENUM20.MDPROP_AGGREGATECELL_UPDATE;
pub const MDPROP_MDX_OBJQUALIFICATION = DBPROPENUM20.MDPROP_MDX_OBJQUALIFICATION;
pub const MDPROP_MDX_NONMEASURE_EXPRESSIONS = DBPROPENUM20.MDPROP_MDX_NONMEASURE_EXPRESSIONS;
pub const DBPROP_ACCESSORDER = DBPROPENUM20.DBPROP_ACCESSORDER;
pub const DBPROP_BOOKMARKINFO = DBPROPENUM20.DBPROP_BOOKMARKINFO;
pub const DBPROP_INIT_CATALOG = DBPROPENUM20.DBPROP_INIT_CATALOG;
pub const DBPROP_ROW_BULKOPS = DBPROPENUM20.DBPROP_ROW_BULKOPS;
pub const DBPROP_PROVIDERFRIENDLYNAME = DBPROPENUM20.DBPROP_PROVIDERFRIENDLYNAME;
pub const DBPROP_LOCKMODE = DBPROPENUM20.DBPROP_LOCKMODE;
pub const DBPROP_MULTIPLECONNECTIONS = DBPROPENUM20.DBPROP_MULTIPLECONNECTIONS;
pub const DBPROP_UNIQUEROWS = DBPROPENUM20.DBPROP_UNIQUEROWS;
pub const DBPROP_SERVERDATAONINSERT = DBPROPENUM20.DBPROP_SERVERDATAONINSERT;
pub const DBPROP_STORAGEFLAGS = DBPROPENUM20.DBPROP_STORAGEFLAGS;
pub const DBPROP_CONNECTIONSTATUS = DBPROPENUM20.DBPROP_CONNECTIONSTATUS;
pub const DBPROP_ALTERCOLUMN = DBPROPENUM20.DBPROP_ALTERCOLUMN;
pub const DBPROP_COLUMNLCID = DBPROPENUM20.DBPROP_COLUMNLCID;
pub const DBPROP_RESETDATASOURCE = DBPROPENUM20.DBPROP_RESETDATASOURCE;
pub const DBPROP_INIT_OLEDBSERVICES = DBPROPENUM20.DBPROP_INIT_OLEDBSERVICES;
pub const DBPROP_IRowsetRefresh = DBPROPENUM20.DBPROP_IRowsetRefresh;
pub const DBPROP_SERVERNAME = DBPROPENUM20.DBPROP_SERVERNAME;
pub const DBPROP_IParentRowset = DBPROPENUM20.DBPROP_IParentRowset;
pub const DBPROP_HIDDENCOLUMNS = DBPROPENUM20.DBPROP_HIDDENCOLUMNS;
pub const DBPROP_PROVIDERMEMORY = DBPROPENUM20.DBPROP_PROVIDERMEMORY;
pub const DBPROP_CLIENTCURSOR = DBPROPENUM20.DBPROP_CLIENTCURSOR;

pub const DBPROPENUM21 = enum(i32) {
    TRUSTEE_USERNAME = 241,
    TRUSTEE_AUTHENTICATION = 242,
    TRUSTEE_NEWAUTHENTICATION = 243,
    IRow = 263,
    IRowChange = 264,
    IRowSchemaChange = 265,
    IGetRow = 266,
    IScopedOperations = 267,
    IBindResource = 268,
    ICreateRow = 269,
    INIT_BINDFLAGS = 270,
    INIT_LOCKOWNER = 271,
    GENERATEURL = 273,
    IDBBinderProperties = 274,
    IColumnsInfo2 = 275,
    IRegisterProvider = 276,
    IGetSession = 277,
    IGetSourceRow = 278,
    IRowsetCurrentIndex = 279,
    OPENROWSETSUPPORT = 280,
    COL_ISLONG = 281,
};
pub const DBPROP_TRUSTEE_USERNAME = DBPROPENUM21.TRUSTEE_USERNAME;
pub const DBPROP_TRUSTEE_AUTHENTICATION = DBPROPENUM21.TRUSTEE_AUTHENTICATION;
pub const DBPROP_TRUSTEE_NEWAUTHENTICATION = DBPROPENUM21.TRUSTEE_NEWAUTHENTICATION;
pub const DBPROP_IRow = DBPROPENUM21.IRow;
pub const DBPROP_IRowChange = DBPROPENUM21.IRowChange;
pub const DBPROP_IRowSchemaChange = DBPROPENUM21.IRowSchemaChange;
pub const DBPROP_IGetRow = DBPROPENUM21.IGetRow;
pub const DBPROP_IScopedOperations = DBPROPENUM21.IScopedOperations;
pub const DBPROP_IBindResource = DBPROPENUM21.IBindResource;
pub const DBPROP_ICreateRow = DBPROPENUM21.ICreateRow;
pub const DBPROP_INIT_BINDFLAGS = DBPROPENUM21.INIT_BINDFLAGS;
pub const DBPROP_INIT_LOCKOWNER = DBPROPENUM21.INIT_LOCKOWNER;
pub const DBPROP_GENERATEURL = DBPROPENUM21.GENERATEURL;
pub const DBPROP_IDBBinderProperties = DBPROPENUM21.IDBBinderProperties;
pub const DBPROP_IColumnsInfo2 = DBPROPENUM21.IColumnsInfo2;
pub const DBPROP_IRegisterProvider = DBPROPENUM21.IRegisterProvider;
pub const DBPROP_IGetSession = DBPROPENUM21.IGetSession;
pub const DBPROP_IGetSourceRow = DBPROPENUM21.IGetSourceRow;
pub const DBPROP_IRowsetCurrentIndex = DBPROPENUM21.IRowsetCurrentIndex;
pub const DBPROP_OPENROWSETSUPPORT = DBPROPENUM21.OPENROWSETSUPPORT;
pub const DBPROP_COL_ISLONG = DBPROPENUM21.COL_ISLONG;

pub const DBPROPENUM25 = enum(i32) {
    COL_SEED = 282,
    COL_INCREMENT = 283,
    INIT_GENERALTIMEOUT = 284,
    COMSERVICES = 285,
};
pub const DBPROP_COL_SEED = DBPROPENUM25.COL_SEED;
pub const DBPROP_COL_INCREMENT = DBPROPENUM25.COL_INCREMENT;
pub const DBPROP_INIT_GENERALTIMEOUT = DBPROPENUM25.INIT_GENERALTIMEOUT;
pub const DBPROP_COMSERVICES = DBPROPENUM25.COMSERVICES;

pub const DBPROPENUM26 = enum(i32) {
    DBPROP_OUTPUTSTREAM = 286,
    DBPROP_OUTPUTENCODING = 287,
    DBPROP_TABLESTATISTICS = 288,
    DBPROP_SKIPROWCOUNTRESULTS = 291,
    DBPROP_IRowsetBookmark = 292,
    MDPROP_VISUALMODE = 293,
};
pub const DBPROP_OUTPUTSTREAM = DBPROPENUM26.DBPROP_OUTPUTSTREAM;
pub const DBPROP_OUTPUTENCODING = DBPROPENUM26.DBPROP_OUTPUTENCODING;
pub const DBPROP_TABLESTATISTICS = DBPROPENUM26.DBPROP_TABLESTATISTICS;
pub const DBPROP_SKIPROWCOUNTRESULTS = DBPROPENUM26.DBPROP_SKIPROWCOUNTRESULTS;
pub const DBPROP_IRowsetBookmark = DBPROPENUM26.DBPROP_IRowsetBookmark;
pub const MDPROP_VISUALMODE = DBPROPENUM26.MDPROP_VISUALMODE;

pub const DBPARAMFLAGSENUM = enum(i32) {
    INPUT = 1,
    OUTPUT = 2,
    SIGNED = 16,
    NULLABLE = 64,
    LONG = 128,
};
pub const DBPARAMFLAGS_ISINPUT = DBPARAMFLAGSENUM.INPUT;
pub const DBPARAMFLAGS_ISOUTPUT = DBPARAMFLAGSENUM.OUTPUT;
pub const DBPARAMFLAGS_ISSIGNED = DBPARAMFLAGSENUM.SIGNED;
pub const DBPARAMFLAGS_ISNULLABLE = DBPARAMFLAGSENUM.NULLABLE;
pub const DBPARAMFLAGS_ISLONG = DBPARAMFLAGSENUM.LONG;

pub const DBPARAMFLAGSENUM20 = enum(i32) {
    E = 256,
};
pub const DBPARAMFLAGS_SCALEISNEGATIVE = DBPARAMFLAGSENUM20.E;

pub const DBPROPFLAGSENUM = enum(i32) {
    NOTSUPPORTED = 0,
    COLUMN = 1,
    DATASOURCE = 2,
    DATASOURCECREATE = 4,
    DATASOURCEINFO = 8,
    DBINIT = 16,
    INDEX = 32,
    ROWSET = 64,
    TABLE = 128,
    COLUMNOK = 256,
    READ = 512,
    WRITE = 1024,
    REQUIRED = 2048,
    SESSION = 4096,
};
pub const DBPROPFLAGS_NOTSUPPORTED = DBPROPFLAGSENUM.NOTSUPPORTED;
pub const DBPROPFLAGS_COLUMN = DBPROPFLAGSENUM.COLUMN;
pub const DBPROPFLAGS_DATASOURCE = DBPROPFLAGSENUM.DATASOURCE;
pub const DBPROPFLAGS_DATASOURCECREATE = DBPROPFLAGSENUM.DATASOURCECREATE;
pub const DBPROPFLAGS_DATASOURCEINFO = DBPROPFLAGSENUM.DATASOURCEINFO;
pub const DBPROPFLAGS_DBINIT = DBPROPFLAGSENUM.DBINIT;
pub const DBPROPFLAGS_INDEX = DBPROPFLAGSENUM.INDEX;
pub const DBPROPFLAGS_ROWSET = DBPROPFLAGSENUM.ROWSET;
pub const DBPROPFLAGS_TABLE = DBPROPFLAGSENUM.TABLE;
pub const DBPROPFLAGS_COLUMNOK = DBPROPFLAGSENUM.COLUMNOK;
pub const DBPROPFLAGS_READ = DBPROPFLAGSENUM.READ;
pub const DBPROPFLAGS_WRITE = DBPROPFLAGSENUM.WRITE;
pub const DBPROPFLAGS_REQUIRED = DBPROPFLAGSENUM.REQUIRED;
pub const DBPROPFLAGS_SESSION = DBPROPFLAGSENUM.SESSION;

pub const DBPROPFLAGSENUM21 = enum(i32) {
    E = 8192,
};
pub const DBPROPFLAGS_TRUSTEE = DBPROPFLAGSENUM21.E;

pub const DBPROPFLAGSENUM25 = enum(i32) {
    W = 16384,
};
pub const DBPROPFLAGS_VIEW = DBPROPFLAGSENUM25.W;

pub const DBPROPFLAGSENUM26 = enum(i32) {
    M = 32768,
};
pub const DBPROPFLAGS_STREAM = DBPROPFLAGSENUM26.M;

pub const DBPROPOPTIONSENUM = enum(i32) {
    REQUIRED = 0,
    SETIFCHEAP = 1,
    // OPTIONAL = 1, this enum value conflicts with SETIFCHEAP
};
pub const DBPROPOPTIONS_REQUIRED = DBPROPOPTIONSENUM.REQUIRED;
pub const DBPROPOPTIONS_SETIFCHEAP = DBPROPOPTIONSENUM.SETIFCHEAP;
pub const DBPROPOPTIONS_OPTIONAL = DBPROPOPTIONSENUM.SETIFCHEAP;

pub const DBPROPSTATUSENUM = enum(i32) {
    OK = 0,
    NOTSUPPORTED = 1,
    BADVALUE = 2,
    BADOPTION = 3,
    BADCOLUMN = 4,
    NOTALLSETTABLE = 5,
    NOTSETTABLE = 6,
    NOTSET = 7,
    CONFLICTING = 8,
};
pub const DBPROPSTATUS_OK = DBPROPSTATUSENUM.OK;
pub const DBPROPSTATUS_NOTSUPPORTED = DBPROPSTATUSENUM.NOTSUPPORTED;
pub const DBPROPSTATUS_BADVALUE = DBPROPSTATUSENUM.BADVALUE;
pub const DBPROPSTATUS_BADOPTION = DBPROPSTATUSENUM.BADOPTION;
pub const DBPROPSTATUS_BADCOLUMN = DBPROPSTATUSENUM.BADCOLUMN;
pub const DBPROPSTATUS_NOTALLSETTABLE = DBPROPSTATUSENUM.NOTALLSETTABLE;
pub const DBPROPSTATUS_NOTSETTABLE = DBPROPSTATUSENUM.NOTSETTABLE;
pub const DBPROPSTATUS_NOTSET = DBPROPSTATUSENUM.NOTSET;
pub const DBPROPSTATUS_CONFLICTING = DBPROPSTATUSENUM.CONFLICTING;

pub const DBPROPSTATUSENUM21 = enum(i32) {
    E = 9,
};
pub const DBPROPSTATUS_NOTAVAILABLE = DBPROPSTATUSENUM21.E;

pub const DBINDEX_COL_ORDERENUM = enum(i32) {
    ASC = 0,
    DESC = 1,
};
pub const DBINDEX_COL_ORDER_ASC = DBINDEX_COL_ORDERENUM.ASC;
pub const DBINDEX_COL_ORDER_DESC = DBINDEX_COL_ORDERENUM.DESC;

pub const DBCOLUMNDESCFLAGSENUM = enum(i32) {
    TYPENAME = 1,
    ITYPEINFO = 2,
    PROPERTIES = 4,
    CLSID = 8,
    COLSIZE = 16,
    DBCID = 32,
    WTYPE = 64,
    PRECISION = 128,
    SCALE = 256,
};
pub const DBCOLUMNDESCFLAGS_TYPENAME = DBCOLUMNDESCFLAGSENUM.TYPENAME;
pub const DBCOLUMNDESCFLAGS_ITYPEINFO = DBCOLUMNDESCFLAGSENUM.ITYPEINFO;
pub const DBCOLUMNDESCFLAGS_PROPERTIES = DBCOLUMNDESCFLAGSENUM.PROPERTIES;
pub const DBCOLUMNDESCFLAGS_CLSID = DBCOLUMNDESCFLAGSENUM.CLSID;
pub const DBCOLUMNDESCFLAGS_COLSIZE = DBCOLUMNDESCFLAGSENUM.COLSIZE;
pub const DBCOLUMNDESCFLAGS_DBCID = DBCOLUMNDESCFLAGSENUM.DBCID;
pub const DBCOLUMNDESCFLAGS_WTYPE = DBCOLUMNDESCFLAGSENUM.WTYPE;
pub const DBCOLUMNDESCFLAGS_PRECISION = DBCOLUMNDESCFLAGSENUM.PRECISION;
pub const DBCOLUMNDESCFLAGS_SCALE = DBCOLUMNDESCFLAGSENUM.SCALE;

pub const DBEVENTPHASEENUM = enum(i32) {
    OKTODO = 0,
    ABOUTTODO = 1,
    SYNCHAFTER = 2,
    FAILEDTODO = 3,
    DIDEVENT = 4,
};
pub const DBEVENTPHASE_OKTODO = DBEVENTPHASEENUM.OKTODO;
pub const DBEVENTPHASE_ABOUTTODO = DBEVENTPHASEENUM.ABOUTTODO;
pub const DBEVENTPHASE_SYNCHAFTER = DBEVENTPHASEENUM.SYNCHAFTER;
pub const DBEVENTPHASE_FAILEDTODO = DBEVENTPHASEENUM.FAILEDTODO;
pub const DBEVENTPHASE_DIDEVENT = DBEVENTPHASEENUM.DIDEVENT;

pub const DBREASONENUM = enum(i32) {
    ROWSET_FETCHPOSITIONCHANGE = 0,
    ROWSET_RELEASE = 1,
    COLUMN_SET = 2,
    COLUMN_RECALCULATED = 3,
    ROW_ACTIVATE = 4,
    ROW_RELEASE = 5,
    ROW_DELETE = 6,
    ROW_FIRSTCHANGE = 7,
    ROW_INSERT = 8,
    ROW_RESYNCH = 9,
    ROW_UNDOCHANGE = 10,
    ROW_UNDOINSERT = 11,
    ROW_UNDODELETE = 12,
    ROW_UPDATE = 13,
    ROWSET_CHANGED = 14,
};
pub const DBREASON_ROWSET_FETCHPOSITIONCHANGE = DBREASONENUM.ROWSET_FETCHPOSITIONCHANGE;
pub const DBREASON_ROWSET_RELEASE = DBREASONENUM.ROWSET_RELEASE;
pub const DBREASON_COLUMN_SET = DBREASONENUM.COLUMN_SET;
pub const DBREASON_COLUMN_RECALCULATED = DBREASONENUM.COLUMN_RECALCULATED;
pub const DBREASON_ROW_ACTIVATE = DBREASONENUM.ROW_ACTIVATE;
pub const DBREASON_ROW_RELEASE = DBREASONENUM.ROW_RELEASE;
pub const DBREASON_ROW_DELETE = DBREASONENUM.ROW_DELETE;
pub const DBREASON_ROW_FIRSTCHANGE = DBREASONENUM.ROW_FIRSTCHANGE;
pub const DBREASON_ROW_INSERT = DBREASONENUM.ROW_INSERT;
pub const DBREASON_ROW_RESYNCH = DBREASONENUM.ROW_RESYNCH;
pub const DBREASON_ROW_UNDOCHANGE = DBREASONENUM.ROW_UNDOCHANGE;
pub const DBREASON_ROW_UNDOINSERT = DBREASONENUM.ROW_UNDOINSERT;
pub const DBREASON_ROW_UNDODELETE = DBREASONENUM.ROW_UNDODELETE;
pub const DBREASON_ROW_UPDATE = DBREASONENUM.ROW_UPDATE;
pub const DBREASON_ROWSET_CHANGED = DBREASONENUM.ROWSET_CHANGED;

pub const DBREASONENUM15 = enum(i32) {
    POSITION_CHANGED = 15,
    POSITION_CHAPTERCHANGED = 16,
    POSITION_CLEARED = 17,
    _ASYNCHINSERT = 18,
};
pub const DBREASON_ROWPOSITION_CHANGED = DBREASONENUM15.POSITION_CHANGED;
pub const DBREASON_ROWPOSITION_CHAPTERCHANGED = DBREASONENUM15.POSITION_CHAPTERCHANGED;
pub const DBREASON_ROWPOSITION_CLEARED = DBREASONENUM15.POSITION_CLEARED;
pub const DBREASON_ROW_ASYNCHINSERT = DBREASONENUM15._ASYNCHINSERT;

pub const DBCOMPAREOPSENUM = enum(i32) {
    LT = 0,
    LE = 1,
    EQ = 2,
    GE = 3,
    GT = 4,
    BEGINSWITH = 5,
    CONTAINS = 6,
    NE = 7,
    IGNORE = 8,
    CASESENSITIVE = 4096,
    CASEINSENSITIVE = 8192,
};
pub const DBCOMPAREOPS_LT = DBCOMPAREOPSENUM.LT;
pub const DBCOMPAREOPS_LE = DBCOMPAREOPSENUM.LE;
pub const DBCOMPAREOPS_EQ = DBCOMPAREOPSENUM.EQ;
pub const DBCOMPAREOPS_GE = DBCOMPAREOPSENUM.GE;
pub const DBCOMPAREOPS_GT = DBCOMPAREOPSENUM.GT;
pub const DBCOMPAREOPS_BEGINSWITH = DBCOMPAREOPSENUM.BEGINSWITH;
pub const DBCOMPAREOPS_CONTAINS = DBCOMPAREOPSENUM.CONTAINS;
pub const DBCOMPAREOPS_NE = DBCOMPAREOPSENUM.NE;
pub const DBCOMPAREOPS_IGNORE = DBCOMPAREOPSENUM.IGNORE;
pub const DBCOMPAREOPS_CASESENSITIVE = DBCOMPAREOPSENUM.CASESENSITIVE;
pub const DBCOMPAREOPS_CASEINSENSITIVE = DBCOMPAREOPSENUM.CASEINSENSITIVE;

pub const DBCOMPAREOPSENUM20 = enum(i32) {
    BEGINSWITH = 9,
    CONTAINS = 10,
};
pub const DBCOMPAREOPS_NOTBEGINSWITH = DBCOMPAREOPSENUM20.BEGINSWITH;
pub const DBCOMPAREOPS_NOTCONTAINS = DBCOMPAREOPSENUM20.CONTAINS;

pub const DBASYNCHOPENUM = enum(i32) {
    N = 0,
};
pub const DBASYNCHOP_OPEN = DBASYNCHOPENUM.N;

pub const DBASYNCHPHASEENUM = enum(i32) {
    INITIALIZATION = 0,
    POPULATION = 1,
    COMPLETE = 2,
    CANCELED = 3,
};
pub const DBASYNCHPHASE_INITIALIZATION = DBASYNCHPHASEENUM.INITIALIZATION;
pub const DBASYNCHPHASE_POPULATION = DBASYNCHPHASEENUM.POPULATION;
pub const DBASYNCHPHASE_COMPLETE = DBASYNCHPHASEENUM.COMPLETE;
pub const DBASYNCHPHASE_CANCELED = DBASYNCHPHASEENUM.CANCELED;

pub const DBSORTENUM = enum(i32) {
    ASCENDING = 0,
    DESCENDING = 1,
};
pub const DBSORT_ASCENDING = DBSORTENUM.ASCENDING;
pub const DBSORT_DESCENDING = DBSORTENUM.DESCENDING;

pub const DBCOMMANDPERSISTFLAGENUM = enum(i32) {
    E = 1,
};
pub const DBCOMMANDPERSISTFLAG_NOSAVE = DBCOMMANDPERSISTFLAGENUM.E;

pub const DBCOMMANDPERSISTFLAGENUM21 = enum(i32) {
    DEFAULT = 0,
    PERSISTVIEW = 2,
    PERSISTPROCEDURE = 4,
};
pub const DBCOMMANDPERSISTFLAG_DEFAULT = DBCOMMANDPERSISTFLAGENUM21.DEFAULT;
pub const DBCOMMANDPERSISTFLAG_PERSISTVIEW = DBCOMMANDPERSISTFLAGENUM21.PERSISTVIEW;
pub const DBCOMMANDPERSISTFLAG_PERSISTPROCEDURE = DBCOMMANDPERSISTFLAGENUM21.PERSISTPROCEDURE;

pub const DBCONSTRAINTTYPEENUM = enum(i32) {
    UNIQUE = 0,
    FOREIGNKEY = 1,
    PRIMARYKEY = 2,
    CHECK = 3,
};
pub const DBCONSTRAINTTYPE_UNIQUE = DBCONSTRAINTTYPEENUM.UNIQUE;
pub const DBCONSTRAINTTYPE_FOREIGNKEY = DBCONSTRAINTTYPEENUM.FOREIGNKEY;
pub const DBCONSTRAINTTYPE_PRIMARYKEY = DBCONSTRAINTTYPEENUM.PRIMARYKEY;
pub const DBCONSTRAINTTYPE_CHECK = DBCONSTRAINTTYPEENUM.CHECK;

pub const DBUPDELRULEENUM = enum(i32) {
    NOACTION = 0,
    CASCADE = 1,
    SETNULL = 2,
    SETDEFAULT = 3,
};
pub const DBUPDELRULE_NOACTION = DBUPDELRULEENUM.NOACTION;
pub const DBUPDELRULE_CASCADE = DBUPDELRULEENUM.CASCADE;
pub const DBUPDELRULE_SETNULL = DBUPDELRULEENUM.SETNULL;
pub const DBUPDELRULE_SETDEFAULT = DBUPDELRULEENUM.SETDEFAULT;

pub const DBMATCHTYPEENUM = enum(i32) {
    FULL = 0,
    NONE = 1,
    PARTIAL = 2,
};
pub const DBMATCHTYPE_FULL = DBMATCHTYPEENUM.FULL;
pub const DBMATCHTYPE_NONE = DBMATCHTYPEENUM.NONE;
pub const DBMATCHTYPE_PARTIAL = DBMATCHTYPEENUM.PARTIAL;

pub const DBDEFERRABILITYENUM = enum(i32) {
    ED = 1,
    ABLE = 2,
};
pub const DBDEFERRABILITY_DEFERRED = DBDEFERRABILITYENUM.ED;
pub const DBDEFERRABILITY_DEFERRABLE = DBDEFERRABILITYENUM.ABLE;

pub const DBACCESSORFLAGSENUM = enum(i32) {
    INVALID = 0,
    PASSBYREF = 1,
    ROWDATA = 2,
    PARAMETERDATA = 4,
    OPTIMIZED = 8,
    INHERITED = 16,
};
pub const DBACCESSOR_INVALID = DBACCESSORFLAGSENUM.INVALID;
pub const DBACCESSOR_PASSBYREF = DBACCESSORFLAGSENUM.PASSBYREF;
pub const DBACCESSOR_ROWDATA = DBACCESSORFLAGSENUM.ROWDATA;
pub const DBACCESSOR_PARAMETERDATA = DBACCESSORFLAGSENUM.PARAMETERDATA;
pub const DBACCESSOR_OPTIMIZED = DBACCESSORFLAGSENUM.OPTIMIZED;
pub const DBACCESSOR_INHERITED = DBACCESSORFLAGSENUM.INHERITED;

pub const DBBINDSTATUSENUM = enum(i32) {
    OK = 0,
    BADORDINAL = 1,
    UNSUPPORTEDCONVERSION = 2,
    BADBINDINFO = 3,
    BADSTORAGEFLAGS = 4,
    NOINTERFACE = 5,
    MULTIPLESTORAGE = 6,
};
pub const DBBINDSTATUS_OK = DBBINDSTATUSENUM.OK;
pub const DBBINDSTATUS_BADORDINAL = DBBINDSTATUSENUM.BADORDINAL;
pub const DBBINDSTATUS_UNSUPPORTEDCONVERSION = DBBINDSTATUSENUM.UNSUPPORTEDCONVERSION;
pub const DBBINDSTATUS_BADBINDINFO = DBBINDSTATUSENUM.BADBINDINFO;
pub const DBBINDSTATUS_BADSTORAGEFLAGS = DBBINDSTATUSENUM.BADSTORAGEFLAGS;
pub const DBBINDSTATUS_NOINTERFACE = DBBINDSTATUSENUM.NOINTERFACE;
pub const DBBINDSTATUS_MULTIPLESTORAGE = DBBINDSTATUSENUM.MULTIPLESTORAGE;

const IID_IAccessor_Value = Guid.initString("0c733a8c-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IAccessor = &IID_IAccessor_Value;
pub const IAccessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefAccessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccessor,
                hAccessor: usize,
                pcRefCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccessor,
                hAccessor: usize,
                pcRefCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAccessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccessor,
                dwAccessorFlags: u32,
                cBindings: usize,
                rgBindings: [*]const DBBINDING,
                cbRowSize: usize,
                phAccessor: ?*usize,
                rgStatus: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccessor,
                dwAccessorFlags: u32,
                cBindings: usize,
                rgBindings: [*]const DBBINDING,
                cbRowSize: usize,
                phAccessor: ?*usize,
                rgStatus: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBindings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccessor,
                hAccessor: usize,
                pdwAccessorFlags: ?*u32,
                pcBindings: ?*usize,
                prgBindings: ?*?*DBBINDING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccessor,
                hAccessor: usize,
                pdwAccessorFlags: ?*u32,
                pcBindings: ?*usize,
                prgBindings: ?*?*DBBINDING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseAccessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccessor,
                hAccessor: usize,
                pcRefCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccessor,
                hAccessor: usize,
                pcRefCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccessor_AddRefAccessor(self: *const T, hAccessor: usize, pcRefCount: ?*u32) HRESULT {
                return @as(*const IAccessor.VTable, @ptrCast(self.vtable)).AddRefAccessor(@as(*const IAccessor, @ptrCast(self)), hAccessor, pcRefCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccessor_CreateAccessor(self: *const T, dwAccessorFlags: u32, cBindings: usize, rgBindings: [*]const DBBINDING, cbRowSize: usize, phAccessor: ?*usize, rgStatus: ?[*]u32) HRESULT {
                return @as(*const IAccessor.VTable, @ptrCast(self.vtable)).CreateAccessor(@as(*const IAccessor, @ptrCast(self)), dwAccessorFlags, cBindings, rgBindings, cbRowSize, phAccessor, rgStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccessor_GetBindings(self: *const T, hAccessor: usize, pdwAccessorFlags: ?*u32, pcBindings: ?*usize, prgBindings: ?*?*DBBINDING) HRESULT {
                return @as(*const IAccessor.VTable, @ptrCast(self.vtable)).GetBindings(@as(*const IAccessor, @ptrCast(self)), hAccessor, pdwAccessorFlags, pcBindings, prgBindings);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccessor_ReleaseAccessor(self: *const T, hAccessor: usize, pcRefCount: ?*u32) HRESULT {
                return @as(*const IAccessor.VTable, @ptrCast(self.vtable)).ReleaseAccessor(@as(*const IAccessor, @ptrCast(self)), hAccessor, pcRefCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowset_Value = Guid.initString("0c733a7c-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowset = &IID_IRowset_Value;
pub const IRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowset,
                cRows: usize,
                rghRows: ?*const usize,
                rgRefCounts: ?*u32,
                rgRowStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowset,
                cRows: usize,
                rghRows: ?*const usize,
                rgRefCounts: ?*u32,
                rgRowStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowset,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowset,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowset,
                hReserved: usize,
                lRowsOffset: isize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                prghRows: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowset,
                hReserved: usize,
                lRowsOffset: isize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                prghRows: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowset,
                cRows: usize,
                rghRows: ?*const usize,
                rgRowOptions: ?*u32,
                rgRefCounts: ?*u32,
                rgRowStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowset,
                cRows: usize,
                rghRows: ?*const usize,
                rgRowOptions: ?*u32,
                rgRefCounts: ?*u32,
                rgRowStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestartPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowset,
                hReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowset,
                hReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowset_AddRefRows(self: *const T, cRows: usize, rghRows: ?*const usize, rgRefCounts: ?*u32, rgRowStatus: ?*u32) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).AddRefRows(@as(*const IRowset, @ptrCast(self)), cRows, rghRows, rgRefCounts, rgRowStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowset_GetData(self: *const T, hRow: usize, hAccessor: usize, pData: ?*anyopaque) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).GetData(@as(*const IRowset, @ptrCast(self)), hRow, hAccessor, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowset_GetNextRows(self: *const T, hReserved: usize, lRowsOffset: isize, cRows: isize, pcRowsObtained: ?*usize, prghRows: ?*?*usize) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).GetNextRows(@as(*const IRowset, @ptrCast(self)), hReserved, lRowsOffset, cRows, pcRowsObtained, prghRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowset_ReleaseRows(self: *const T, cRows: usize, rghRows: ?*const usize, rgRowOptions: ?*u32, rgRefCounts: ?*u32, rgRowStatus: ?*u32) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).ReleaseRows(@as(*const IRowset, @ptrCast(self)), cRows, rghRows, rgRowOptions, rgRefCounts, rgRowStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowset_RestartPosition(self: *const T, hReserved: usize) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).RestartPosition(@as(*const IRowset, @ptrCast(self)), hReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetInfo_Value = Guid.initString("0c733a55-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetInfo = &IID_IRowsetInfo_Value;
pub const IRowsetInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetInfo,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetInfo,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReferencedRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetInfo,
                iOrdinal: usize,
                riid: ?*const Guid,
                ppReferencedRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetInfo,
                iOrdinal: usize,
                riid: ?*const Guid,
                ppReferencedRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetInfo,
                riid: ?*const Guid,
                ppSpecification: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetInfo,
                riid: ?*const Guid,
                ppSpecification: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetInfo_GetProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) HRESULT {
                return @as(*const IRowsetInfo.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IRowsetInfo, @ptrCast(self)), cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetInfo_GetReferencedRowset(self: *const T, iOrdinal: usize, riid: ?*const Guid, ppReferencedRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetInfo.VTable, @ptrCast(self.vtable)).GetReferencedRowset(@as(*const IRowsetInfo, @ptrCast(self)), iOrdinal, riid, ppReferencedRowset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetInfo_GetSpecification(self: *const T, riid: ?*const Guid, ppSpecification: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetInfo.VTable, @ptrCast(self.vtable)).GetSpecification(@as(*const IRowsetInfo, @ptrCast(self)), riid, ppSpecification);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBCOMPAREENUM = enum(i32) {
    LT = 0,
    EQ = 1,
    GT = 2,
    NE = 3,
    NOTCOMPARABLE = 4,
};
pub const DBCOMPARE_LT = DBCOMPAREENUM.LT;
pub const DBCOMPARE_EQ = DBCOMPAREENUM.EQ;
pub const DBCOMPARE_GT = DBCOMPAREENUM.GT;
pub const DBCOMPARE_NE = DBCOMPAREENUM.NE;
pub const DBCOMPARE_NOTCOMPARABLE = DBCOMPAREENUM.NOTCOMPARABLE;

const IID_IRowsetLocate_Value = Guid.initString("0c733a7d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetLocate = &IID_IRowsetLocate_Value;
pub const IRowsetLocate = extern struct {
    pub const VTable = extern struct {
        base: IRowset.VTable,
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetLocate,
                hReserved: usize,
                cbBookmark1: usize,
                pBookmark1: ?*const u8,
                cbBookmark2: usize,
                pBookmark2: ?*const u8,
                pComparison: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetLocate,
                hReserved: usize,
                cbBookmark1: usize,
                pBookmark1: ?*const u8,
                cbBookmark2: usize,
                pBookmark2: ?*const u8,
                pComparison: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRowsAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetLocate,
                hReserved1: usize,
                hReserved2: usize,
                cbBookmark: usize,
                pBookmark: ?*const u8,
                lRowsOffset: isize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                prghRows: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetLocate,
                hReserved1: usize,
                hReserved2: usize,
                cbBookmark: usize,
                pBookmark: ?*const u8,
                lRowsOffset: isize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                prghRows: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRowsByBookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetLocate,
                hReserved: usize,
                cRows: usize,
                rgcbBookmarks: ?*const usize,
                rgpBookmarks: ?*const ?*u8,
                rghRows: ?*usize,
                rgRowStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetLocate,
                hReserved: usize,
                cRows: usize,
                rgcbBookmarks: ?*const usize,
                rgpBookmarks: ?*const ?*u8,
                rghRows: ?*usize,
                rgRowStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Hash: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetLocate,
                hReserved: usize,
                cBookmarks: usize,
                rgcbBookmarks: ?*const usize,
                rgpBookmarks: ?*const ?*u8,
                rgHashedValues: ?*usize,
                rgBookmarkStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetLocate,
                hReserved: usize,
                cBookmarks: usize,
                rgcbBookmarks: ?*const usize,
                rgpBookmarks: ?*const ?*u8,
                rgHashedValues: ?*usize,
                rgBookmarkStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowset.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetLocate_Compare(self: *const T, hReserved: usize, cbBookmark1: usize, pBookmark1: ?*const u8, cbBookmark2: usize, pBookmark2: ?*const u8, pComparison: ?*u32) HRESULT {
                return @as(*const IRowsetLocate.VTable, @ptrCast(self.vtable)).Compare(@as(*const IRowsetLocate, @ptrCast(self)), hReserved, cbBookmark1, pBookmark1, cbBookmark2, pBookmark2, pComparison);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetLocate_GetRowsAt(self: *const T, hReserved1: usize, hReserved2: usize, cbBookmark: usize, pBookmark: ?*const u8, lRowsOffset: isize, cRows: isize, pcRowsObtained: ?*usize, prghRows: ?*?*usize) HRESULT {
                return @as(*const IRowsetLocate.VTable, @ptrCast(self.vtable)).GetRowsAt(@as(*const IRowsetLocate, @ptrCast(self)), hReserved1, hReserved2, cbBookmark, pBookmark, lRowsOffset, cRows, pcRowsObtained, prghRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetLocate_GetRowsByBookmark(self: *const T, hReserved: usize, cRows: usize, rgcbBookmarks: ?*const usize, rgpBookmarks: ?*const ?*u8, rghRows: ?*usize, rgRowStatus: ?*u32) HRESULT {
                return @as(*const IRowsetLocate.VTable, @ptrCast(self.vtable)).GetRowsByBookmark(@as(*const IRowsetLocate, @ptrCast(self)), hReserved, cRows, rgcbBookmarks, rgpBookmarks, rghRows, rgRowStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetLocate_Hash(self: *const T, hReserved: usize, cBookmarks: usize, rgcbBookmarks: ?*const usize, rgpBookmarks: ?*const ?*u8, rgHashedValues: ?*usize, rgBookmarkStatus: ?*u32) HRESULT {
                return @as(*const IRowsetLocate.VTable, @ptrCast(self.vtable)).Hash(@as(*const IRowsetLocate, @ptrCast(self)), hReserved, cBookmarks, rgcbBookmarks, rgpBookmarks, rgHashedValues, rgBookmarkStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetResynch_Value = Guid.initString("0c733a84-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetResynch = &IID_IRowsetResynch_Value;
pub const IRowsetResynch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVisibleData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetResynch,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetResynch,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResynchRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetResynch,
                cRows: usize,
                rghRows: ?*const usize,
                pcRowsResynched: ?*usize,
                prghRowsResynched: ?*?*usize,
                prgRowStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetResynch,
                cRows: usize,
                rghRows: ?*const usize,
                pcRowsResynched: ?*usize,
                prghRowsResynched: ?*?*usize,
                prgRowStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetResynch_GetVisibleData(self: *const T, hRow: usize, hAccessor: usize, pData: ?*anyopaque) HRESULT {
                return @as(*const IRowsetResynch.VTable, @ptrCast(self.vtable)).GetVisibleData(@as(*const IRowsetResynch, @ptrCast(self)), hRow, hAccessor, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetResynch_ResynchRows(self: *const T, cRows: usize, rghRows: ?*const usize, pcRowsResynched: ?*usize, prghRowsResynched: ?*?*usize, prgRowStatus: ?*?*u32) HRESULT {
                return @as(*const IRowsetResynch.VTable, @ptrCast(self.vtable)).ResynchRows(@as(*const IRowsetResynch, @ptrCast(self)), cRows, rghRows, pcRowsResynched, prghRowsResynched, prgRowStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetScroll_Value = Guid.initString("0c733a7e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetScroll = &IID_IRowsetScroll_Value;
pub const IRowsetScroll = extern struct {
    pub const VTable = extern struct {
        base: IRowsetLocate.VTable,
        GetApproximatePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetScroll,
                hReserved: usize,
                cbBookmark: usize,
                pBookmark: ?*const u8,
                pulPosition: ?*usize,
                pcRows: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetScroll,
                hReserved: usize,
                cbBookmark: usize,
                pBookmark: ?*const u8,
                pulPosition: ?*usize,
                pcRows: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRowsAtRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetScroll,
                hReserved1: usize,
                hReserved2: usize,
                ulNumerator: usize,
                ulDenominator: usize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                prghRows: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetScroll,
                hReserved1: usize,
                hReserved2: usize,
                ulNumerator: usize,
                ulDenominator: usize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                prghRows: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowsetLocate.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetScroll_GetApproximatePosition(self: *const T, hReserved: usize, cbBookmark: usize, pBookmark: ?*const u8, pulPosition: ?*usize, pcRows: ?*usize) HRESULT {
                return @as(*const IRowsetScroll.VTable, @ptrCast(self.vtable)).GetApproximatePosition(@as(*const IRowsetScroll, @ptrCast(self)), hReserved, cbBookmark, pBookmark, pulPosition, pcRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetScroll_GetRowsAtRatio(self: *const T, hReserved1: usize, hReserved2: usize, ulNumerator: usize, ulDenominator: usize, cRows: isize, pcRowsObtained: ?*usize, prghRows: ?*?*usize) HRESULT {
                return @as(*const IRowsetScroll.VTable, @ptrCast(self.vtable)).GetRowsAtRatio(@as(*const IRowsetScroll, @ptrCast(self)), hReserved1, hReserved2, ulNumerator, ulDenominator, cRows, pcRowsObtained, prghRows);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IChapteredRowset_Value = Guid.initString("0c733a93-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IChapteredRowset = &IID_IChapteredRowset_Value;
pub const IChapteredRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChapteredRowset,
                hChapter: usize,
                pcRefCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IChapteredRowset,
                hChapter: usize,
                pcRefCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChapteredRowset,
                hChapter: usize,
                pcRefCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IChapteredRowset,
                hChapter: usize,
                pcRefCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChapteredRowset_AddRefChapter(self: *const T, hChapter: usize, pcRefCount: ?*u32) HRESULT {
                return @as(*const IChapteredRowset.VTable, @ptrCast(self.vtable)).AddRefChapter(@as(*const IChapteredRowset, @ptrCast(self)), hChapter, pcRefCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChapteredRowset_ReleaseChapter(self: *const T, hChapter: usize, pcRefCount: ?*u32) HRESULT {
                return @as(*const IChapteredRowset.VTable, @ptrCast(self.vtable)).ReleaseChapter(@as(*const IChapteredRowset, @ptrCast(self)), hChapter, pcRefCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetFind_Value = Guid.initString("0c733a9d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetFind = &IID_IRowsetFind_Value;
pub const IRowsetFind = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindNextRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetFind,
                hChapter: usize,
                hAccessor: usize,
                pFindValue: ?*anyopaque,
                CompareOp: u32,
                cbBookmark: usize,
                pBookmark: ?*const u8,
                lRowsOffset: isize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                prghRows: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetFind,
                hChapter: usize,
                hAccessor: usize,
                pFindValue: ?*anyopaque,
                CompareOp: u32,
                cbBookmark: usize,
                pBookmark: ?*const u8,
                lRowsOffset: isize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                prghRows: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetFind_FindNextRow(self: *const T, hChapter: usize, hAccessor: usize, pFindValue: ?*anyopaque, CompareOp: u32, cbBookmark: usize, pBookmark: ?*const u8, lRowsOffset: isize, cRows: isize, pcRowsObtained: ?*usize, prghRows: ?*?*usize) HRESULT {
                return @as(*const IRowsetFind.VTable, @ptrCast(self.vtable)).FindNextRow(@as(*const IRowsetFind, @ptrCast(self)), hChapter, hAccessor, pFindValue, CompareOp, cbBookmark, pBookmark, lRowsOffset, cRows, pcRowsObtained, prghRows);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBPOSITIONFLAGSENUM = enum(i32) {
    OK = 0,
    NOROW = 1,
    BOF = 2,
    EOF = 3,
};
pub const DBPOSITION_OK = DBPOSITIONFLAGSENUM.OK;
pub const DBPOSITION_NOROW = DBPOSITIONFLAGSENUM.NOROW;
pub const DBPOSITION_BOF = DBPOSITIONFLAGSENUM.BOF;
pub const DBPOSITION_EOF = DBPOSITIONFLAGSENUM.EOF;

const IID_IRowPosition_Value = Guid.initString("0c733a94-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowPosition = &IID_IRowPosition_Value;
pub const IRowPosition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ClearRowPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRowPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowPosition,
                phChapter: ?*usize,
                phRow: ?*usize,
                pdwPositionFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowPosition,
                phChapter: ?*usize,
                phRow: ?*usize,
                pdwPositionFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowPosition,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowPosition,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowPosition,
                pRowset: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowPosition,
                pRowset: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRowPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowPosition,
                hChapter: usize,
                hRow: usize,
                dwPositionFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowPosition,
                hChapter: usize,
                hRow: usize,
                dwPositionFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowPosition_ClearRowPosition(self: *const T) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).ClearRowPosition(@as(*const IRowPosition, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowPosition_GetRowPosition(self: *const T, phChapter: ?*usize, phRow: ?*usize, pdwPositionFlags: ?*u32) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).GetRowPosition(@as(*const IRowPosition, @ptrCast(self)), phChapter, phRow, pdwPositionFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowPosition_GetRowset(self: *const T, riid: ?*const Guid, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).GetRowset(@as(*const IRowPosition, @ptrCast(self)), riid, ppRowset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowPosition_Initialize(self: *const T, pRowset: ?*IUnknown) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IRowPosition, @ptrCast(self)), pRowset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowPosition_SetRowPosition(self: *const T, hChapter: usize, hRow: usize, dwPositionFlags: u32) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).SetRowPosition(@as(*const IRowPosition, @ptrCast(self)), hChapter, hRow, dwPositionFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowPositionChange_Value = Guid.initString("0997a571-126e-11d0-9f8a-00a0c9a0631e");
pub const IID_IRowPositionChange = &IID_IRowPositionChange_Value;
pub const IRowPositionChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRowPositionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowPositionChange,
                eReason: u32,
                ePhase: u32,
                fCantDeny: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowPositionChange,
                eReason: u32,
                ePhase: u32,
                fCantDeny: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowPositionChange_OnRowPositionChange(self: *const T, eReason: u32, ePhase: u32, fCantDeny: BOOL) HRESULT {
                return @as(*const IRowPositionChange.VTable, @ptrCast(self.vtable)).OnRowPositionChange(@as(*const IRowPositionChange, @ptrCast(self)), eReason, ePhase, fCantDeny);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewRowset_Value = Guid.initString("0c733a97-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewRowset = &IID_IViewRowset_Value;
pub const IViewRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSpecification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewRowset,
                riid: ?*const Guid,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewRowset,
                riid: ?*const Guid,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenViewRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewRowset,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewRowset,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewRowset_GetSpecification(self: *const T, riid: ?*const Guid, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IViewRowset.VTable, @ptrCast(self.vtable)).GetSpecification(@as(*const IViewRowset, @ptrCast(self)), riid, ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewRowset_OpenViewRowset(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IViewRowset.VTable, @ptrCast(self.vtable)).OpenViewRowset(@as(*const IViewRowset, @ptrCast(self)), pUnkOuter, riid, ppRowset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewChapter_Value = Guid.initString("0c733a98-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewChapter = &IID_IViewChapter_Value;
pub const IViewChapter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSpecification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewChapter,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewChapter,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenViewChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewChapter,
                hSource: usize,
                phViewChapter: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewChapter,
                hSource: usize,
                phViewChapter: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewChapter_GetSpecification(self: *const T, riid: ?*const Guid, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IViewChapter.VTable, @ptrCast(self.vtable)).GetSpecification(@as(*const IViewChapter, @ptrCast(self)), riid, ppRowset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewChapter_OpenViewChapter(self: *const T, hSource: usize, phViewChapter: ?*usize) HRESULT {
                return @as(*const IViewChapter.VTable, @ptrCast(self.vtable)).OpenViewChapter(@as(*const IViewChapter, @ptrCast(self)), hSource, phViewChapter);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewSort_Value = Guid.initString("0c733a9a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewSort = &IID_IViewSort_Value;
pub const IViewSort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSortOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewSort,
                pcValues: ?*usize,
                prgColumns: ?*?*usize,
                prgOrders: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewSort,
                pcValues: ?*usize,
                prgColumns: ?*?*usize,
                prgOrders: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSortOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewSort,
                cValues: usize,
                rgColumns: [*]const usize,
                rgOrders: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewSort,
                cValues: usize,
                rgColumns: [*]const usize,
                rgOrders: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewSort_GetSortOrder(self: *const T, pcValues: ?*usize, prgColumns: ?*?*usize, prgOrders: ?*?*u32) HRESULT {
                return @as(*const IViewSort.VTable, @ptrCast(self.vtable)).GetSortOrder(@as(*const IViewSort, @ptrCast(self)), pcValues, prgColumns, prgOrders);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewSort_SetSortOrder(self: *const T, cValues: usize, rgColumns: [*]const usize, rgOrders: [*]const u32) HRESULT {
                return @as(*const IViewSort.VTable, @ptrCast(self.vtable)).SetSortOrder(@as(*const IViewSort, @ptrCast(self)), cValues, rgColumns, rgOrders);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewFilter_Value = Guid.initString("0c733a9b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewFilter = &IID_IViewFilter_Value;
pub const IViewFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewFilter,
                hAccessor: usize,
                pcRows: ?*usize,
                pCompareOps: [*]?*u32,
                pCriteriaData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewFilter,
                hAccessor: usize,
                pcRows: ?*usize,
                pCompareOps: [*]?*u32,
                pCriteriaData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterBindings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewFilter,
                pcBindings: ?*usize,
                prgBindings: ?*?*DBBINDING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewFilter,
                pcBindings: ?*usize,
                prgBindings: ?*?*DBBINDING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewFilter,
                hAccessor: usize,
                cRows: usize,
                CompareOps: [*]u32,
                pCriteriaData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewFilter,
                hAccessor: usize,
                cRows: usize,
                CompareOps: [*]u32,
                pCriteriaData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewFilter_GetFilter(self: *const T, hAccessor: usize, pcRows: ?*usize, pCompareOps: [*]?*u32, pCriteriaData: ?*anyopaque) HRESULT {
                return @as(*const IViewFilter.VTable, @ptrCast(self.vtable)).GetFilter(@as(*const IViewFilter, @ptrCast(self)), hAccessor, pcRows, pCompareOps, pCriteriaData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewFilter_GetFilterBindings(self: *const T, pcBindings: ?*usize, prgBindings: ?*?*DBBINDING) HRESULT {
                return @as(*const IViewFilter.VTable, @ptrCast(self.vtable)).GetFilterBindings(@as(*const IViewFilter, @ptrCast(self)), pcBindings, prgBindings);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewFilter_SetFilter(self: *const T, hAccessor: usize, cRows: usize, CompareOps: [*]u32, pCriteriaData: ?*anyopaque) HRESULT {
                return @as(*const IViewFilter.VTable, @ptrCast(self.vtable)).SetFilter(@as(*const IViewFilter, @ptrCast(self)), hAccessor, cRows, CompareOps, pCriteriaData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetView_Value = Guid.initString("0c733a99-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetView = &IID_IRowsetView_Value;
pub const IRowsetView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetView,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppView: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetView,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppView: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetView,
                hChapter: usize,
                riid: ?*const Guid,
                phChapterSource: ?*usize,
                ppView: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetView,
                hChapter: usize,
                riid: ?*const Guid,
                phChapterSource: ?*usize,
                ppView: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetView_CreateView(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppView: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetView.VTable, @ptrCast(self.vtable)).CreateView(@as(*const IRowsetView, @ptrCast(self)), pUnkOuter, riid, ppView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetView_GetView(self: *const T, hChapter: usize, riid: ?*const Guid, phChapterSource: ?*usize, ppView: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetView.VTable, @ptrCast(self.vtable)).GetView(@as(*const IRowsetView, @ptrCast(self)), hChapter, riid, phChapterSource, ppView);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetChange_Value = Guid.initString("0c733a05-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetChange = &IID_IRowsetChange_Value;
pub const IRowsetChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetChange,
                hReserved: usize,
                cRows: usize,
                rghRows: ?*const usize,
                rgRowStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetChange,
                hReserved: usize,
                cRows: usize,
                rghRows: ?*const usize,
                rgRowStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetChange,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetChange,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetChange,
                hReserved: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
                phRow: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetChange,
                hReserved: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
                phRow: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetChange_DeleteRows(self: *const T, hReserved: usize, cRows: usize, rghRows: ?*const usize, rgRowStatus: ?*u32) HRESULT {
                return @as(*const IRowsetChange.VTable, @ptrCast(self.vtable)).DeleteRows(@as(*const IRowsetChange, @ptrCast(self)), hReserved, cRows, rghRows, rgRowStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetChange_SetData(self: *const T, hRow: usize, hAccessor: usize, pData: ?*anyopaque) HRESULT {
                return @as(*const IRowsetChange.VTable, @ptrCast(self.vtable)).SetData(@as(*const IRowsetChange, @ptrCast(self)), hRow, hAccessor, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetChange_InsertRow(self: *const T, hReserved: usize, hAccessor: usize, pData: ?*anyopaque, phRow: ?*usize) HRESULT {
                return @as(*const IRowsetChange.VTable, @ptrCast(self.vtable)).InsertRow(@as(*const IRowsetChange, @ptrCast(self)), hReserved, hAccessor, pData, phRow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBPENDINGSTATUSENUM = enum(i32) {
    NEW = 1,
    CHANGED = 2,
    DELETED = 4,
    UNCHANGED = 8,
    INVALIDROW = 16,
};
pub const DBPENDINGSTATUS_NEW = DBPENDINGSTATUSENUM.NEW;
pub const DBPENDINGSTATUS_CHANGED = DBPENDINGSTATUSENUM.CHANGED;
pub const DBPENDINGSTATUS_DELETED = DBPENDINGSTATUSENUM.DELETED;
pub const DBPENDINGSTATUS_UNCHANGED = DBPENDINGSTATUSENUM.UNCHANGED;
pub const DBPENDINGSTATUS_INVALIDROW = DBPENDINGSTATUSENUM.INVALIDROW;

const IID_IRowsetUpdate_Value = Guid.initString("0c733a6d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetUpdate = &IID_IRowsetUpdate_Value;
pub const IRowsetUpdate = extern struct {
    pub const VTable = extern struct {
        base: IRowsetChange.VTable,
        GetOriginalData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetUpdate,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetUpdate,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPendingRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetUpdate,
                hReserved: usize,
                dwRowStatus: u32,
                pcPendingRows: ?*usize,
                prgPendingRows: ?*?*usize,
                prgPendingStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetUpdate,
                hReserved: usize,
                dwRowStatus: u32,
                pcPendingRows: ?*usize,
                prgPendingRows: ?*?*usize,
                prgPendingStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRowStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetUpdate,
                hReserved: usize,
                cRows: usize,
                rghRows: ?*const usize,
                rgPendingStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetUpdate,
                hReserved: usize,
                cRows: usize,
                rghRows: ?*const usize,
                rgPendingStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Undo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetUpdate,
                hReserved: usize,
                cRows: usize,
                rghRows: ?*const usize,
                pcRowsUndone: ?*usize,
                prgRowsUndone: ?*?*usize,
                prgRowStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetUpdate,
                hReserved: usize,
                cRows: usize,
                rghRows: ?*const usize,
                pcRowsUndone: ?*usize,
                prgRowsUndone: ?*?*usize,
                prgRowStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetUpdate,
                hReserved: usize,
                cRows: usize,
                rghRows: ?*const usize,
                pcRows: ?*usize,
                prgRows: ?*?*usize,
                prgRowStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetUpdate,
                hReserved: usize,
                cRows: usize,
                rghRows: ?*const usize,
                pcRows: ?*usize,
                prgRows: ?*?*usize,
                prgRowStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowsetChange.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetUpdate_GetOriginalData(self: *const T, hRow: usize, hAccessor: usize, pData: ?*anyopaque) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).GetOriginalData(@as(*const IRowsetUpdate, @ptrCast(self)), hRow, hAccessor, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetUpdate_GetPendingRows(self: *const T, hReserved: usize, dwRowStatus: u32, pcPendingRows: ?*usize, prgPendingRows: ?*?*usize, prgPendingStatus: ?*?*u32) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).GetPendingRows(@as(*const IRowsetUpdate, @ptrCast(self)), hReserved, dwRowStatus, pcPendingRows, prgPendingRows, prgPendingStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetUpdate_GetRowStatus(self: *const T, hReserved: usize, cRows: usize, rghRows: ?*const usize, rgPendingStatus: ?*u32) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).GetRowStatus(@as(*const IRowsetUpdate, @ptrCast(self)), hReserved, cRows, rghRows, rgPendingStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetUpdate_Undo(self: *const T, hReserved: usize, cRows: usize, rghRows: ?*const usize, pcRowsUndone: ?*usize, prgRowsUndone: ?*?*usize, prgRowStatus: ?*?*u32) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).Undo(@as(*const IRowsetUpdate, @ptrCast(self)), hReserved, cRows, rghRows, pcRowsUndone, prgRowsUndone, prgRowStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetUpdate_Update(self: *const T, hReserved: usize, cRows: usize, rghRows: ?*const usize, pcRows: ?*usize, prgRows: ?*?*usize, prgRowStatus: ?*?*u32) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).Update(@as(*const IRowsetUpdate, @ptrCast(self)), hReserved, cRows, rghRows, pcRows, prgRows, prgRowStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetIdentity_Value = Guid.initString("0c733a09-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetIdentity = &IID_IRowsetIdentity_Value;
pub const IRowsetIdentity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSameRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetIdentity,
                hThisRow: usize,
                hThatRow: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetIdentity,
                hThisRow: usize,
                hThatRow: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetIdentity_IsSameRow(self: *const T, hThisRow: usize, hThatRow: usize) HRESULT {
                return @as(*const IRowsetIdentity.VTable, @ptrCast(self.vtable)).IsSameRow(@as(*const IRowsetIdentity, @ptrCast(self)), hThisRow, hThatRow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetNotify_Value = Guid.initString("0c733a83-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetNotify = &IID_IRowsetNotify_Value;
pub const IRowsetNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFieldChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetNotify,
                pRowset: ?*IRowset,
                hRow: usize,
                cColumns: usize,
                rgColumns: [*]usize,
                eReason: u32,
                ePhase: u32,
                fCantDeny: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetNotify,
                pRowset: ?*IRowset,
                hRow: usize,
                cColumns: usize,
                rgColumns: [*]usize,
                eReason: u32,
                ePhase: u32,
                fCantDeny: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnRowChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetNotify,
                pRowset: ?*IRowset,
                cRows: usize,
                rghRows: [*]const usize,
                eReason: u32,
                ePhase: u32,
                fCantDeny: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetNotify,
                pRowset: ?*IRowset,
                cRows: usize,
                rghRows: [*]const usize,
                eReason: u32,
                ePhase: u32,
                fCantDeny: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnRowsetChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetNotify,
                pRowset: ?*IRowset,
                eReason: u32,
                ePhase: u32,
                fCantDeny: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetNotify,
                pRowset: ?*IRowset,
                eReason: u32,
                ePhase: u32,
                fCantDeny: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetNotify_OnFieldChange(self: *const T, pRowset: ?*IRowset, hRow: usize, cColumns: usize, rgColumns: [*]usize, eReason: u32, ePhase: u32, fCantDeny: BOOL) HRESULT {
                return @as(*const IRowsetNotify.VTable, @ptrCast(self.vtable)).OnFieldChange(@as(*const IRowsetNotify, @ptrCast(self)), pRowset, hRow, cColumns, rgColumns, eReason, ePhase, fCantDeny);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetNotify_OnRowChange(self: *const T, pRowset: ?*IRowset, cRows: usize, rghRows: [*]const usize, eReason: u32, ePhase: u32, fCantDeny: BOOL) HRESULT {
                return @as(*const IRowsetNotify.VTable, @ptrCast(self.vtable)).OnRowChange(@as(*const IRowsetNotify, @ptrCast(self)), pRowset, cRows, rghRows, eReason, ePhase, fCantDeny);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetNotify_OnRowsetChange(self: *const T, pRowset: ?*IRowset, eReason: u32, ePhase: u32, fCantDeny: BOOL) HRESULT {
                return @as(*const IRowsetNotify.VTable, @ptrCast(self.vtable)).OnRowsetChange(@as(*const IRowsetNotify, @ptrCast(self)), pRowset, eReason, ePhase, fCantDeny);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBSEEKENUM = enum(i32) {
    INVALID = 0,
    FIRSTEQ = 1,
    LASTEQ = 2,
    AFTEREQ = 4,
    AFTER = 8,
    BEFOREEQ = 16,
    BEFORE = 32,
};
pub const DBSEEK_INVALID = DBSEEKENUM.INVALID;
pub const DBSEEK_FIRSTEQ = DBSEEKENUM.FIRSTEQ;
pub const DBSEEK_LASTEQ = DBSEEKENUM.LASTEQ;
pub const DBSEEK_AFTEREQ = DBSEEKENUM.AFTEREQ;
pub const DBSEEK_AFTER = DBSEEKENUM.AFTER;
pub const DBSEEK_BEFOREEQ = DBSEEKENUM.BEFOREEQ;
pub const DBSEEK_BEFORE = DBSEEKENUM.BEFORE;

pub const DBRANGEENUM = enum(i32) {
    INCLUSIVESTART = 0,
    // INCLUSIVEEND = 0, this enum value conflicts with INCLUSIVESTART
    EXCLUSIVESTART = 1,
    EXCLUSIVEEND = 2,
    EXCLUDENULLS = 4,
    PREFIX = 8,
    MATCH = 16,
};
pub const DBRANGE_INCLUSIVESTART = DBRANGEENUM.INCLUSIVESTART;
pub const DBRANGE_INCLUSIVEEND = DBRANGEENUM.INCLUSIVESTART;
pub const DBRANGE_EXCLUSIVESTART = DBRANGEENUM.EXCLUSIVESTART;
pub const DBRANGE_EXCLUSIVEEND = DBRANGEENUM.EXCLUSIVEEND;
pub const DBRANGE_EXCLUDENULLS = DBRANGEENUM.EXCLUDENULLS;
pub const DBRANGE_PREFIX = DBRANGEENUM.PREFIX;
pub const DBRANGE_MATCH = DBRANGEENUM.MATCH;

pub const DBRANGEENUM20 = enum(i32) {
    SHIFT = 24,
    MASK = 255,
};
pub const DBRANGE_MATCH_N_SHIFT = DBRANGEENUM20.SHIFT;
pub const DBRANGE_MATCH_N_MASK = DBRANGEENUM20.MASK;

const IID_IRowsetIndex_Value = Guid.initString("0c733a82-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetIndex = &IID_IRowsetIndex_Value;
pub const IRowsetIndex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIndexInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetIndex,
                pcKeyColumns: ?*usize,
                prgIndexColumnDesc: ?*?*DBINDEXCOLUMNDESC,
                pcIndexPropertySets: ?*u32,
                prgIndexPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetIndex,
                pcKeyColumns: ?*usize,
                prgIndexColumnDesc: ?*?*DBINDEXCOLUMNDESC,
                pcIndexPropertySets: ?*u32,
                prgIndexPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetIndex,
                hAccessor: usize,
                cKeyValues: usize,
                pData: ?*anyopaque,
                dwSeekOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetIndex,
                hAccessor: usize,
                cKeyValues: usize,
                pData: ?*anyopaque,
                dwSeekOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetIndex,
                hAccessor: usize,
                cStartKeyColumns: usize,
                pStartData: ?*anyopaque,
                cEndKeyColumns: usize,
                pEndData: ?*anyopaque,
                dwRangeOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetIndex,
                hAccessor: usize,
                cStartKeyColumns: usize,
                pStartData: ?*anyopaque,
                cEndKeyColumns: usize,
                pEndData: ?*anyopaque,
                dwRangeOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetIndex_GetIndexInfo(self: *const T, pcKeyColumns: ?*usize, prgIndexColumnDesc: ?*?*DBINDEXCOLUMNDESC, pcIndexPropertySets: ?*u32, prgIndexPropertySets: ?*?*DBPROPSET) HRESULT {
                return @as(*const IRowsetIndex.VTable, @ptrCast(self.vtable)).GetIndexInfo(@as(*const IRowsetIndex, @ptrCast(self)), pcKeyColumns, prgIndexColumnDesc, pcIndexPropertySets, prgIndexPropertySets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetIndex_Seek(self: *const T, hAccessor: usize, cKeyValues: usize, pData: ?*anyopaque, dwSeekOptions: u32) HRESULT {
                return @as(*const IRowsetIndex.VTable, @ptrCast(self.vtable)).Seek(@as(*const IRowsetIndex, @ptrCast(self)), hAccessor, cKeyValues, pData, dwSeekOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetIndex_SetRange(self: *const T, hAccessor: usize, cStartKeyColumns: usize, pStartData: ?*anyopaque, cEndKeyColumns: usize, pEndData: ?*anyopaque, dwRangeOptions: u32) HRESULT {
                return @as(*const IRowsetIndex.VTable, @ptrCast(self.vtable)).SetRange(@as(*const IRowsetIndex, @ptrCast(self)), hAccessor, cStartKeyColumns, pStartData, cEndKeyColumns, pEndData, dwRangeOptions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommand_Value = Guid.initString("0c733a63-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommand = &IID_ICommand_Value;
pub const ICommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommand,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                pParams: ?*DBPARAMS,
                pcRowsAffected: ?*isize,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommand,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                pParams: ?*DBPARAMS,
                pcRowsAffected: ?*isize,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDBSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommand,
                riid: ?*const Guid,
                ppSession: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommand,
                riid: ?*const Guid,
                ppSession: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommand_Cancel(self: *const T) HRESULT {
                return @as(*const ICommand.VTable, @ptrCast(self.vtable)).Cancel(@as(*const ICommand, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommand_Execute(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, pParams: ?*DBPARAMS, pcRowsAffected: ?*isize, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const ICommand.VTable, @ptrCast(self.vtable)).Execute(@as(*const ICommand, @ptrCast(self)), pUnkOuter, riid, pParams, pcRowsAffected, ppRowset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommand_GetDBSession(self: *const T, riid: ?*const Guid, ppSession: ?*?*IUnknown) HRESULT {
                return @as(*const ICommand.VTable, @ptrCast(self.vtable)).GetDBSession(@as(*const ICommand, @ptrCast(self)), riid, ppSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBRESULTFLAGENUM = enum(i32) {
    DEFAULT = 0,
    ROWSET = 1,
    ROW = 2,
};
pub const DBRESULTFLAG_DEFAULT = DBRESULTFLAGENUM.DEFAULT;
pub const DBRESULTFLAG_ROWSET = DBRESULTFLAGENUM.ROWSET;
pub const DBRESULTFLAG_ROW = DBRESULTFLAGENUM.ROW;

const IID_IMultipleResults_Value = Guid.initString("0c733a90-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IMultipleResults = &IID_IMultipleResults_Value;
pub const IMultipleResults = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMultipleResults,
                pUnkOuter: ?*IUnknown,
                lResultFlag: isize,
                riid: ?*const Guid,
                pcRowsAffected: ?*isize,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMultipleResults,
                pUnkOuter: ?*IUnknown,
                lResultFlag: isize,
                riid: ?*const Guid,
                pcRowsAffected: ?*isize,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMultipleResults_GetResult(self: *const T, pUnkOuter: ?*IUnknown, lResultFlag: isize, riid: ?*const Guid, pcRowsAffected: ?*isize, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IMultipleResults.VTable, @ptrCast(self.vtable)).GetResult(@as(*const IMultipleResults, @ptrCast(self)), pUnkOuter, lResultFlag, riid, pcRowsAffected, ppRowset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBCONVERTFLAGSENUM = enum(i32) {
    COLUMN = 0,
    PARAMETER = 1,
};
pub const DBCONVERTFLAGS_COLUMN = DBCONVERTFLAGSENUM.COLUMN;
pub const DBCONVERTFLAGS_PARAMETER = DBCONVERTFLAGSENUM.PARAMETER;

pub const DBCONVERTFLAGSENUM20 = enum(i32) {
    ISLONG = 2,
    ISFIXEDLENGTH = 4,
    FROMVARIANT = 8,
};
pub const DBCONVERTFLAGS_ISLONG = DBCONVERTFLAGSENUM20.ISLONG;
pub const DBCONVERTFLAGS_ISFIXEDLENGTH = DBCONVERTFLAGSENUM20.ISFIXEDLENGTH;
pub const DBCONVERTFLAGS_FROMVARIANT = DBCONVERTFLAGSENUM20.FROMVARIANT;

const IID_IConvertType_Value = Guid.initString("0c733a88-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IConvertType = &IID_IConvertType_Value;
pub const IConvertType = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanConvert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConvertType,
                wFromType: u16,
                wToType: u16,
                dwConvertFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConvertType,
                wFromType: u16,
                wToType: u16,
                dwConvertFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConvertType_CanConvert(self: *const T, wFromType: u16, wToType: u16, dwConvertFlags: u32) HRESULT {
                return @as(*const IConvertType.VTable, @ptrCast(self.vtable)).CanConvert(@as(*const IConvertType, @ptrCast(self)), wFromType, wToType, dwConvertFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandPrepare_Value = Guid.initString("0c733a26-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandPrepare = &IID_ICommandPrepare_Value;
pub const ICommandPrepare = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Prepare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandPrepare,
                cExpectedRuns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandPrepare,
                cExpectedRuns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unprepare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandPrepare,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandPrepare,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandPrepare_Prepare(self: *const T, cExpectedRuns: u32) HRESULT {
                return @as(*const ICommandPrepare.VTable, @ptrCast(self.vtable)).Prepare(@as(*const ICommandPrepare, @ptrCast(self)), cExpectedRuns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandPrepare_Unprepare(self: *const T) HRESULT {
                return @as(*const ICommandPrepare.VTable, @ptrCast(self.vtable)).Unprepare(@as(*const ICommandPrepare, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandProperties_Value = Guid.initString("0c733a79-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandProperties = &IID_ICommandProperties_Value;
pub const ICommandProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandProperties,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandProperties,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandProperties,
                cPropertySets: u32,
                rgPropertySets: [*]DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandProperties,
                cPropertySets: u32,
                rgPropertySets: [*]DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandProperties_GetProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) HRESULT {
                return @as(*const ICommandProperties.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const ICommandProperties, @ptrCast(self)), cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandProperties_SetProperties(self: *const T, cPropertySets: u32, rgPropertySets: [*]DBPROPSET) HRESULT {
                return @as(*const ICommandProperties.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const ICommandProperties, @ptrCast(self)), cPropertySets, rgPropertySets);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandText_Value = Guid.initString("0c733a27-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandText = &IID_ICommandText_Value;
pub const ICommandText = extern struct {
    pub const VTable = extern struct {
        base: ICommand.VTable,
        GetCommandText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandText,
                pguidDialect: ?*Guid,
                ppwszCommand: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandText,
                pguidDialect: ?*Guid,
                ppwszCommand: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommandText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandText,
                rguidDialect: ?*const Guid,
                pwszCommand: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandText,
                rguidDialect: ?*const Guid,
                pwszCommand: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICommand.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandText_GetCommandText(self: *const T, pguidDialect: ?*Guid, ppwszCommand: ?*?PWSTR) HRESULT {
                return @as(*const ICommandText.VTable, @ptrCast(self.vtable)).GetCommandText(@as(*const ICommandText, @ptrCast(self)), pguidDialect, ppwszCommand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandText_SetCommandText(self: *const T, rguidDialect: ?*const Guid, pwszCommand: ?[*:0]const u16) HRESULT {
                return @as(*const ICommandText.VTable, @ptrCast(self.vtable)).SetCommandText(@as(*const ICommandText, @ptrCast(self)), rguidDialect, pwszCommand);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandWithParameters_Value = Guid.initString("0c733a64-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandWithParameters = &IID_ICommandWithParameters_Value;
pub const ICommandWithParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParameterInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandWithParameters,
                pcParams: ?*usize,
                prgParamInfo: ?*?*DBPARAMINFO,
                ppNamesBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandWithParameters,
                pcParams: ?*usize,
                prgParamInfo: ?*?*DBPARAMINFO,
                ppNamesBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapParameterNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandWithParameters,
                cParamNames: usize,
                rgParamNames: [*]?PWSTR,
                rgParamOrdinals: [*]isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandWithParameters,
                cParamNames: usize,
                rgParamNames: [*]?PWSTR,
                rgParamOrdinals: [*]isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParameterInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandWithParameters,
                cParams: usize,
                rgParamOrdinals: ?[*]const usize,
                rgParamBindInfo: ?[*]const DBPARAMBINDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandWithParameters,
                cParams: usize,
                rgParamOrdinals: ?[*]const usize,
                rgParamBindInfo: ?[*]const DBPARAMBINDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandWithParameters_GetParameterInfo(self: *const T, pcParams: ?*usize, prgParamInfo: ?*?*DBPARAMINFO, ppNamesBuffer: ?*?*u16) HRESULT {
                return @as(*const ICommandWithParameters.VTable, @ptrCast(self.vtable)).GetParameterInfo(@as(*const ICommandWithParameters, @ptrCast(self)), pcParams, prgParamInfo, ppNamesBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandWithParameters_MapParameterNames(self: *const T, cParamNames: usize, rgParamNames: [*]?PWSTR, rgParamOrdinals: [*]isize) HRESULT {
                return @as(*const ICommandWithParameters.VTable, @ptrCast(self.vtable)).MapParameterNames(@as(*const ICommandWithParameters, @ptrCast(self)), cParamNames, rgParamNames, rgParamOrdinals);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandWithParameters_SetParameterInfo(self: *const T, cParams: usize, rgParamOrdinals: ?[*]const usize, rgParamBindInfo: ?[*]const DBPARAMBINDINFO) HRESULT {
                return @as(*const ICommandWithParameters.VTable, @ptrCast(self.vtable)).SetParameterInfo(@as(*const ICommandWithParameters, @ptrCast(self)), cParams, rgParamOrdinals, rgParamBindInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnsRowset_Value = Guid.initString("0c733a10-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IColumnsRowset = &IID_IColumnsRowset_Value;
pub const IColumnsRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnsRowset,
                pcOptColumns: ?*usize,
                prgOptColumns: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnsRowset,
                pcOptColumns: ?*usize,
                prgOptColumns: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnsRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnsRowset,
                pUnkOuter: ?*IUnknown,
                cOptColumns: usize,
                rgOptColumns: [*]const DBID,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                ppColRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnsRowset,
                pUnkOuter: ?*IUnknown,
                cOptColumns: usize,
                rgOptColumns: [*]const DBID,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                ppColRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnsRowset_GetAvailableColumns(self: *const T, pcOptColumns: ?*usize, prgOptColumns: ?*?*DBID) HRESULT {
                return @as(*const IColumnsRowset.VTable, @ptrCast(self.vtable)).GetAvailableColumns(@as(*const IColumnsRowset, @ptrCast(self)), pcOptColumns, prgOptColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnsRowset_GetColumnsRowset(self: *const T, pUnkOuter: ?*IUnknown, cOptColumns: usize, rgOptColumns: [*]const DBID, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppColRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IColumnsRowset.VTable, @ptrCast(self.vtable)).GetColumnsRowset(@as(*const IColumnsRowset, @ptrCast(self)), pUnkOuter, cOptColumns, rgOptColumns, riid, cPropertySets, rgPropertySets, ppColRowset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnsInfo_Value = Guid.initString("0c733a11-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IColumnsInfo = &IID_IColumnsInfo_Value;
pub const IColumnsInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnsInfo,
                pcColumns: ?*usize,
                prgInfo: ?*?*DBCOLUMNINFO,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnsInfo,
                pcColumns: ?*usize,
                prgInfo: ?*?*DBCOLUMNINFO,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapColumnIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnsInfo,
                cColumnIDs: usize,
                rgColumnIDs: ?[*]const DBID,
                rgColumns: ?[*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnsInfo,
                cColumnIDs: usize,
                rgColumnIDs: ?[*]const DBID,
                rgColumns: ?[*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnsInfo_GetColumnInfo(self: *const T, pcColumns: ?*usize, prgInfo: ?*?*DBCOLUMNINFO, ppStringsBuffer: ?*?*u16) HRESULT {
                return @as(*const IColumnsInfo.VTable, @ptrCast(self.vtable)).GetColumnInfo(@as(*const IColumnsInfo, @ptrCast(self)), pcColumns, prgInfo, ppStringsBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnsInfo_MapColumnIDs(self: *const T, cColumnIDs: usize, rgColumnIDs: ?[*]const DBID, rgColumns: ?[*]usize) HRESULT {
                return @as(*const IColumnsInfo.VTable, @ptrCast(self.vtable)).MapColumnIDs(@as(*const IColumnsInfo, @ptrCast(self)), cColumnIDs, rgColumnIDs, rgColumns);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBCreateCommand_Value = Guid.initString("0c733a1d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBCreateCommand = &IID_IDBCreateCommand_Value;
pub const IDBCreateCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBCreateCommand,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppCommand: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBCreateCommand,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppCommand: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBCreateCommand_CreateCommand(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppCommand: ?*?*IUnknown) HRESULT {
                return @as(*const IDBCreateCommand.VTable, @ptrCast(self.vtable)).CreateCommand(@as(*const IDBCreateCommand, @ptrCast(self)), pUnkOuter, riid, ppCommand);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBCreateSession_Value = Guid.initString("0c733a5d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBCreateSession = &IID_IDBCreateSession_Value;
pub const IDBCreateSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBCreateSession,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppDBSession: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBCreateSession,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppDBSession: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBCreateSession_CreateSession(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppDBSession: ?*?*IUnknown) HRESULT {
                return @as(*const IDBCreateSession.VTable, @ptrCast(self.vtable)).CreateSession(@as(*const IDBCreateSession, @ptrCast(self)), pUnkOuter, riid, ppDBSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBSOURCETYPEENUM = enum(i32) {
    DATASOURCE = 1,
    ENUMERATOR = 2,
};
pub const DBSOURCETYPE_DATASOURCE = DBSOURCETYPEENUM.DATASOURCE;
pub const DBSOURCETYPE_ENUMERATOR = DBSOURCETYPEENUM.ENUMERATOR;

pub const DBSOURCETYPEENUM20 = enum(i32) {
    TDP = 1,
    MDP = 3,
};
pub const DBSOURCETYPE_DATASOURCE_TDP = DBSOURCETYPEENUM20.TDP;
pub const DBSOURCETYPE_DATASOURCE_MDP = DBSOURCETYPEENUM20.MDP;

pub const DBSOURCETYPEENUM25 = enum(i32) {
    R = 4,
};
pub const DBSOURCETYPE_BINDER = DBSOURCETYPEENUM25.R;

const IID_ISourcesRowset_Value = Guid.initString("0c733a1e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISourcesRowset = &IID_ISourcesRowset_Value;
pub const ISourcesRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourcesRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISourcesRowset,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgProperties: ?[*]DBPROPSET,
                ppSourcesRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISourcesRowset,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgProperties: ?[*]DBPROPSET,
                ppSourcesRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISourcesRowset_GetSourcesRowset(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, cPropertySets: u32, rgProperties: ?[*]DBPROPSET, ppSourcesRowset: ?*?*IUnknown) HRESULT {
                return @as(*const ISourcesRowset.VTable, @ptrCast(self.vtable)).GetSourcesRowset(@as(*const ISourcesRowset, @ptrCast(self)), pUnkOuter, riid, cPropertySets, rgProperties, ppSourcesRowset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBProperties_Value = Guid.initString("0c733a8a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBProperties = &IID_IDBProperties_Value;
pub const IDBProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBProperties,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBProperties,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBProperties,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertyInfoSets: ?*u32,
                prgPropertyInfoSets: ?*?*DBPROPINFOSET,
                ppDescBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBProperties,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertyInfoSets: ?*u32,
                prgPropertyInfoSets: ?*?*DBPROPINFOSET,
                ppDescBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBProperties,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBProperties,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBProperties_GetProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) HRESULT {
                return @as(*const IDBProperties.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IDBProperties, @ptrCast(self)), cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBProperties_GetPropertyInfo(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertyInfoSets: ?*u32, prgPropertyInfoSets: ?*?*DBPROPINFOSET, ppDescBuffer: ?*?*u16) HRESULT {
                return @as(*const IDBProperties.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const IDBProperties, @ptrCast(self)), cPropertyIDSets, rgPropertyIDSets, pcPropertyInfoSets, prgPropertyInfoSets, ppDescBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBProperties_SetProperties(self: *const T, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET) HRESULT {
                return @as(*const IDBProperties.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const IDBProperties, @ptrCast(self)), cPropertySets, rgPropertySets);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBInitialize_Value = Guid.initString("0c733a8b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBInitialize = &IID_IDBInitialize_Value;
pub const IDBInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBInitialize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBInitialize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Uninitialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBInitialize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBInitialize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBInitialize_Initialize(self: *const T) HRESULT {
                return @as(*const IDBInitialize.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDBInitialize, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBInitialize_Uninitialize(self: *const T) HRESULT {
                return @as(*const IDBInitialize.VTable, @ptrCast(self.vtable)).Uninitialize(@as(*const IDBInitialize, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBLITERALENUM = enum(i32) {
    INVALID = 0,
    BINARY_LITERAL = 1,
    CATALOG_NAME = 2,
    CATALOG_SEPARATOR = 3,
    CHAR_LITERAL = 4,
    COLUMN_ALIAS = 5,
    COLUMN_NAME = 6,
    CORRELATION_NAME = 7,
    CURSOR_NAME = 8,
    ESCAPE_PERCENT = 9,
    ESCAPE_UNDERSCORE = 10,
    INDEX_NAME = 11,
    LIKE_PERCENT = 12,
    LIKE_UNDERSCORE = 13,
    PROCEDURE_NAME = 14,
    QUOTE = 15,
    SCHEMA_NAME = 16,
    TABLE_NAME = 17,
    TEXT_COMMAND = 18,
    USER_NAME = 19,
    VIEW_NAME = 20,
};
pub const DBLITERAL_INVALID = DBLITERALENUM.INVALID;
pub const DBLITERAL_BINARY_LITERAL = DBLITERALENUM.BINARY_LITERAL;
pub const DBLITERAL_CATALOG_NAME = DBLITERALENUM.CATALOG_NAME;
pub const DBLITERAL_CATALOG_SEPARATOR = DBLITERALENUM.CATALOG_SEPARATOR;
pub const DBLITERAL_CHAR_LITERAL = DBLITERALENUM.CHAR_LITERAL;
pub const DBLITERAL_COLUMN_ALIAS = DBLITERALENUM.COLUMN_ALIAS;
pub const DBLITERAL_COLUMN_NAME = DBLITERALENUM.COLUMN_NAME;
pub const DBLITERAL_CORRELATION_NAME = DBLITERALENUM.CORRELATION_NAME;
pub const DBLITERAL_CURSOR_NAME = DBLITERALENUM.CURSOR_NAME;
pub const DBLITERAL_ESCAPE_PERCENT = DBLITERALENUM.ESCAPE_PERCENT;
pub const DBLITERAL_ESCAPE_UNDERSCORE = DBLITERALENUM.ESCAPE_UNDERSCORE;
pub const DBLITERAL_INDEX_NAME = DBLITERALENUM.INDEX_NAME;
pub const DBLITERAL_LIKE_PERCENT = DBLITERALENUM.LIKE_PERCENT;
pub const DBLITERAL_LIKE_UNDERSCORE = DBLITERALENUM.LIKE_UNDERSCORE;
pub const DBLITERAL_PROCEDURE_NAME = DBLITERALENUM.PROCEDURE_NAME;
pub const DBLITERAL_QUOTE = DBLITERALENUM.QUOTE;
pub const DBLITERAL_SCHEMA_NAME = DBLITERALENUM.SCHEMA_NAME;
pub const DBLITERAL_TABLE_NAME = DBLITERALENUM.TABLE_NAME;
pub const DBLITERAL_TEXT_COMMAND = DBLITERALENUM.TEXT_COMMAND;
pub const DBLITERAL_USER_NAME = DBLITERALENUM.USER_NAME;
pub const DBLITERAL_VIEW_NAME = DBLITERALENUM.VIEW_NAME;

pub const DBLITERALENUM20 = enum(i32) {
    CUBE_NAME = 21,
    DIMENSION_NAME = 22,
    HIERARCHY_NAME = 23,
    LEVEL_NAME = 24,
    MEMBER_NAME = 25,
    PROPERTY_NAME = 26,
    SCHEMA_SEPARATOR = 27,
    QUOTE_SUFFIX = 28,
};
pub const DBLITERAL_CUBE_NAME = DBLITERALENUM20.CUBE_NAME;
pub const DBLITERAL_DIMENSION_NAME = DBLITERALENUM20.DIMENSION_NAME;
pub const DBLITERAL_HIERARCHY_NAME = DBLITERALENUM20.HIERARCHY_NAME;
pub const DBLITERAL_LEVEL_NAME = DBLITERALENUM20.LEVEL_NAME;
pub const DBLITERAL_MEMBER_NAME = DBLITERALENUM20.MEMBER_NAME;
pub const DBLITERAL_PROPERTY_NAME = DBLITERALENUM20.PROPERTY_NAME;
pub const DBLITERAL_SCHEMA_SEPARATOR = DBLITERALENUM20.SCHEMA_SEPARATOR;
pub const DBLITERAL_QUOTE_SUFFIX = DBLITERALENUM20.QUOTE_SUFFIX;

pub const DBLITERALENUM21 = enum(i32) {
    PERCENT_SUFFIX = 29,
    UNDERSCORE_SUFFIX = 30,
};
pub const DBLITERAL_ESCAPE_PERCENT_SUFFIX = DBLITERALENUM21.PERCENT_SUFFIX;
pub const DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX = DBLITERALENUM21.UNDERSCORE_SUFFIX;

const IID_IDBInfo_Value = Guid.initString("0c733a89-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBInfo = &IID_IDBInfo_Value;
pub const IDBInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKeywords: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBInfo,
                ppwszKeywords: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBInfo,
                ppwszKeywords: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLiteralInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBInfo,
                cLiterals: u32,
                rgLiterals: ?[*]const u32,
                pcLiteralInfo: ?*u32,
                prgLiteralInfo: ?*?*DBLITERALINFO,
                ppCharBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBInfo,
                cLiterals: u32,
                rgLiterals: ?[*]const u32,
                pcLiteralInfo: ?*u32,
                prgLiteralInfo: ?*?*DBLITERALINFO,
                ppCharBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBInfo_GetKeywords(self: *const T, ppwszKeywords: ?*?PWSTR) HRESULT {
                return @as(*const IDBInfo.VTable, @ptrCast(self.vtable)).GetKeywords(@as(*const IDBInfo, @ptrCast(self)), ppwszKeywords);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBInfo_GetLiteralInfo(self: *const T, cLiterals: u32, rgLiterals: ?[*]const u32, pcLiteralInfo: ?*u32, prgLiteralInfo: ?*?*DBLITERALINFO, ppCharBuffer: ?*?*u16) HRESULT {
                return @as(*const IDBInfo.VTable, @ptrCast(self.vtable)).GetLiteralInfo(@as(*const IDBInfo, @ptrCast(self)), cLiterals, rgLiterals, pcLiteralInfo, prgLiteralInfo, ppCharBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBDataSourceAdmin_Value = Guid.initString("0c733a7a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBDataSourceAdmin = &IID_IDBDataSourceAdmin_Value;
pub const IDBDataSourceAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateDataSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBDataSourceAdmin,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppDBSession: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBDataSourceAdmin,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppDBSession: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyDataSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBDataSourceAdmin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBDataSourceAdmin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCreationProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBDataSourceAdmin,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertyInfoSets: ?*u32,
                prgPropertyInfoSets: ?*?*DBPROPINFOSET,
                ppDescBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBDataSourceAdmin,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertyInfoSets: ?*u32,
                prgPropertyInfoSets: ?*?*DBPROPINFOSET,
                ppDescBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifyDataSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBDataSourceAdmin,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBDataSourceAdmin,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBDataSourceAdmin_CreateDataSource(self: *const T, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppDBSession: ?*?*IUnknown) HRESULT {
                return @as(*const IDBDataSourceAdmin.VTable, @ptrCast(self.vtable)).CreateDataSource(@as(*const IDBDataSourceAdmin, @ptrCast(self)), cPropertySets, rgPropertySets, pUnkOuter, riid, ppDBSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBDataSourceAdmin_DestroyDataSource(self: *const T) HRESULT {
                return @as(*const IDBDataSourceAdmin.VTable, @ptrCast(self.vtable)).DestroyDataSource(@as(*const IDBDataSourceAdmin, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBDataSourceAdmin_GetCreationProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertyInfoSets: ?*u32, prgPropertyInfoSets: ?*?*DBPROPINFOSET, ppDescBuffer: ?*?*u16) HRESULT {
                return @as(*const IDBDataSourceAdmin.VTable, @ptrCast(self.vtable)).GetCreationProperties(@as(*const IDBDataSourceAdmin, @ptrCast(self)), cPropertyIDSets, rgPropertyIDSets, pcPropertyInfoSets, prgPropertyInfoSets, ppDescBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBDataSourceAdmin_ModifyDataSource(self: *const T, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET) HRESULT {
                return @as(*const IDBDataSourceAdmin.VTable, @ptrCast(self.vtable)).ModifyDataSource(@as(*const IDBDataSourceAdmin, @ptrCast(self)), cPropertySets, rgPropertySets);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBAsynchNotify_Value = Guid.initString("0c733a96-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBAsynchNotify = &IID_IDBAsynchNotify_Value;
pub const IDBAsynchNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLowResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBAsynchNotify,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBAsynchNotify,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBAsynchNotify,
                hChapter: usize,
                eOperation: u32,
                ulProgress: usize,
                ulProgressMax: usize,
                eAsynchPhase: u32,
                pwszStatusText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBAsynchNotify,
                hChapter: usize,
                eOperation: u32,
                ulProgress: usize,
                ulProgressMax: usize,
                eAsynchPhase: u32,
                pwszStatusText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBAsynchNotify,
                hChapter: usize,
                eOperation: u32,
                hrStatus: HRESULT,
                pwszStatusText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBAsynchNotify,
                hChapter: usize,
                eOperation: u32,
                hrStatus: HRESULT,
                pwszStatusText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBAsynchNotify_OnLowResource(self: *const T, dwReserved: usize) HRESULT {
                return @as(*const IDBAsynchNotify.VTable, @ptrCast(self.vtable)).OnLowResource(@as(*const IDBAsynchNotify, @ptrCast(self)), dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBAsynchNotify_OnProgress(self: *const T, hChapter: usize, eOperation: u32, ulProgress: usize, ulProgressMax: usize, eAsynchPhase: u32, pwszStatusText: ?PWSTR) HRESULT {
                return @as(*const IDBAsynchNotify.VTable, @ptrCast(self.vtable)).OnProgress(@as(*const IDBAsynchNotify, @ptrCast(self)), hChapter, eOperation, ulProgress, ulProgressMax, eAsynchPhase, pwszStatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBAsynchNotify_OnStop(self: *const T, hChapter: usize, eOperation: u32, hrStatus: HRESULT, pwszStatusText: ?PWSTR) HRESULT {
                return @as(*const IDBAsynchNotify.VTable, @ptrCast(self.vtable)).OnStop(@as(*const IDBAsynchNotify, @ptrCast(self)), hChapter, eOperation, hrStatus, pwszStatusText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBAsynchStatus_Value = Guid.initString("0c733a95-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBAsynchStatus = &IID_IDBAsynchStatus_Value;
pub const IDBAsynchStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBAsynchStatus,
                hChapter: usize,
                eOperation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBAsynchStatus,
                hChapter: usize,
                eOperation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBAsynchStatus,
                hChapter: usize,
                eOperation: u32,
                pulProgress: ?*usize,
                pulProgressMax: ?*usize,
                peAsynchPhase: ?*u32,
                ppwszStatusText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBAsynchStatus,
                hChapter: usize,
                eOperation: u32,
                pulProgress: ?*usize,
                pulProgressMax: ?*usize,
                peAsynchPhase: ?*u32,
                ppwszStatusText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBAsynchStatus_Abort(self: *const T, hChapter: usize, eOperation: u32) HRESULT {
                return @as(*const IDBAsynchStatus.VTable, @ptrCast(self.vtable)).Abort(@as(*const IDBAsynchStatus, @ptrCast(self)), hChapter, eOperation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBAsynchStatus_GetStatus(self: *const T, hChapter: usize, eOperation: u32, pulProgress: ?*usize, pulProgressMax: ?*usize, peAsynchPhase: ?*u32, ppwszStatusText: ?*?PWSTR) HRESULT {
                return @as(*const IDBAsynchStatus.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IDBAsynchStatus, @ptrCast(self)), hChapter, eOperation, pulProgress, pulProgressMax, peAsynchPhase, ppwszStatusText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISessionProperties_Value = Guid.initString("0c733a85-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISessionProperties = &IID_ISessionProperties_Value;
pub const ISessionProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISessionProperties,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISessionProperties,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?[*]const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISessionProperties,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISessionProperties,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISessionProperties_GetProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) HRESULT {
                return @as(*const ISessionProperties.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const ISessionProperties, @ptrCast(self)), cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISessionProperties_SetProperties(self: *const T, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET) HRESULT {
                return @as(*const ISessionProperties.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const ISessionProperties, @ptrCast(self)), cPropertySets, rgPropertySets);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IIndexDefinition_Value = Guid.initString("0c733a68-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IIndexDefinition = &IID_IIndexDefinition_Value;
pub const IIndexDefinition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IIndexDefinition,
                pTableID: ?*DBID,
                pIndexID: ?*DBID,
                cIndexColumnDescs: usize,
                rgIndexColumnDescs: [*]const DBINDEXCOLUMNDESC,
                cPropertySets: u32,
                rgPropertySets: [*]DBPROPSET,
                ppIndexID: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IIndexDefinition,
                pTableID: ?*DBID,
                pIndexID: ?*DBID,
                cIndexColumnDescs: usize,
                rgIndexColumnDescs: [*]const DBINDEXCOLUMNDESC,
                cPropertySets: u32,
                rgPropertySets: [*]DBPROPSET,
                ppIndexID: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DropIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IIndexDefinition,
                pTableID: ?*DBID,
                pIndexID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IIndexDefinition,
                pTableID: ?*DBID,
                pIndexID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IIndexDefinition_CreateIndex(self: *const T, pTableID: ?*DBID, pIndexID: ?*DBID, cIndexColumnDescs: usize, rgIndexColumnDescs: [*]const DBINDEXCOLUMNDESC, cPropertySets: u32, rgPropertySets: [*]DBPROPSET, ppIndexID: ?*?*DBID) HRESULT {
                return @as(*const IIndexDefinition.VTable, @ptrCast(self.vtable)).CreateIndex(@as(*const IIndexDefinition, @ptrCast(self)), pTableID, pIndexID, cIndexColumnDescs, rgIndexColumnDescs, cPropertySets, rgPropertySets, ppIndexID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IIndexDefinition_DropIndex(self: *const T, pTableID: ?*DBID, pIndexID: ?*DBID) HRESULT {
                return @as(*const IIndexDefinition.VTable, @ptrCast(self.vtable)).DropIndex(@as(*const IIndexDefinition, @ptrCast(self)), pTableID, pIndexID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableDefinition_Value = Guid.initString("0c733a86-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableDefinition = &IID_ITableDefinition_Value;
pub const ITableDefinition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableDefinition,
                pUnkOuter: ?*IUnknown,
                pTableID: ?*DBID,
                cColumnDescs: usize,
                rgColumnDescs: ?[*]const DBCOLUMNDESC,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                ppTableID: ?*?*DBID,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableDefinition,
                pUnkOuter: ?*IUnknown,
                pTableID: ?*DBID,
                cColumnDescs: usize,
                rgColumnDescs: ?[*]const DBCOLUMNDESC,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                ppTableID: ?*?*DBID,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DropTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableDefinition,
                pTableID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableDefinition,
                pTableID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableDefinition,
                pTableID: ?*DBID,
                pColumnDesc: ?*DBCOLUMNDESC,
                ppColumnID: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableDefinition,
                pTableID: ?*DBID,
                pColumnDesc: ?*DBCOLUMNDESC,
                ppColumnID: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DropColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableDefinition,
                pTableID: ?*DBID,
                pColumnID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableDefinition,
                pTableID: ?*DBID,
                pColumnID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableDefinition_CreateTable(self: *const T, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, cColumnDescs: usize, rgColumnDescs: ?[*]const DBCOLUMNDESC, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppTableID: ?*?*DBID, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const ITableDefinition.VTable, @ptrCast(self.vtable)).CreateTable(@as(*const ITableDefinition, @ptrCast(self)), pUnkOuter, pTableID, cColumnDescs, rgColumnDescs, riid, cPropertySets, rgPropertySets, ppTableID, ppRowset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableDefinition_DropTable(self: *const T, pTableID: ?*DBID) HRESULT {
                return @as(*const ITableDefinition.VTable, @ptrCast(self.vtable)).DropTable(@as(*const ITableDefinition, @ptrCast(self)), pTableID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableDefinition_AddColumn(self: *const T, pTableID: ?*DBID, pColumnDesc: ?*DBCOLUMNDESC, ppColumnID: ?*?*DBID) HRESULT {
                return @as(*const ITableDefinition.VTable, @ptrCast(self.vtable)).AddColumn(@as(*const ITableDefinition, @ptrCast(self)), pTableID, pColumnDesc, ppColumnID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableDefinition_DropColumn(self: *const T, pTableID: ?*DBID, pColumnID: ?*DBID) HRESULT {
                return @as(*const ITableDefinition.VTable, @ptrCast(self.vtable)).DropColumn(@as(*const ITableDefinition, @ptrCast(self)), pTableID, pColumnID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IOpenRowset_Value = Guid.initString("0c733a69-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IOpenRowset = &IID_IOpenRowset_Value;
pub const IOpenRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOpenRowset,
                pUnkOuter: ?*IUnknown,
                pTableID: ?*DBID,
                pIndexID: ?*DBID,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOpenRowset,
                pUnkOuter: ?*IUnknown,
                pTableID: ?*DBID,
                pIndexID: ?*DBID,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOpenRowset_OpenRowset(self: *const T, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, pIndexID: ?*DBID, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IOpenRowset.VTable, @ptrCast(self.vtable)).OpenRowset(@as(*const IOpenRowset, @ptrCast(self)), pUnkOuter, pTableID, pIndexID, riid, cPropertySets, rgPropertySets, ppRowset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBSchemaRowset_Value = Guid.initString("0c733a7b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBSchemaRowset = &IID_IDBSchemaRowset_Value;
pub const IDBSchemaRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBSchemaRowset,
                pUnkOuter: ?*IUnknown,
                rguidSchema: ?*const Guid,
                cRestrictions: u32,
                rgRestrictions: ?[*]const VARIANT,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBSchemaRowset,
                pUnkOuter: ?*IUnknown,
                rguidSchema: ?*const Guid,
                cRestrictions: u32,
                rgRestrictions: ?[*]const VARIANT,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?[*]DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSchemas: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBSchemaRowset,
                pcSchemas: ?*u32,
                prgSchemas: ?*?*Guid,
                prgRestrictionSupport: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBSchemaRowset,
                pcSchemas: ?*u32,
                prgSchemas: ?*?*Guid,
                prgRestrictionSupport: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBSchemaRowset_GetRowset(self: *const T, pUnkOuter: ?*IUnknown, rguidSchema: ?*const Guid, cRestrictions: u32, rgRestrictions: ?[*]const VARIANT, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IDBSchemaRowset.VTable, @ptrCast(self.vtable)).GetRowset(@as(*const IDBSchemaRowset, @ptrCast(self)), pUnkOuter, rguidSchema, cRestrictions, rgRestrictions, riid, cPropertySets, rgPropertySets, ppRowset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBSchemaRowset_GetSchemas(self: *const T, pcSchemas: ?*u32, prgSchemas: ?*?*Guid, prgRestrictionSupport: ?*?*u32) HRESULT {
                return @as(*const IDBSchemaRowset.VTable, @ptrCast(self.vtable)).GetSchemas(@as(*const IDBSchemaRowset, @ptrCast(self)), pcSchemas, prgSchemas, prgRestrictionSupport);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDDataset_Value = Guid.initString("a07cccd1-8148-11d0-87bb-00c04fc33942");
pub const IID_IMDDataset = &IID_IMDDataset_Value;
pub const IMDDataset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FreeAxisInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDDataset,
                cAxes: usize,
                rgAxisInfo: ?*MDAXISINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDDataset,
                cAxes: usize,
                rgAxisInfo: ?*MDAXISINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAxisInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDDataset,
                pcAxes: ?*usize,
                prgAxisInfo: ?*?*MDAXISINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDDataset,
                pcAxes: ?*usize,
                prgAxisInfo: ?*?*MDAXISINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAxisRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDDataset,
                pUnkOuter: ?*IUnknown,
                iAxis: usize,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDDataset,
                pUnkOuter: ?*IUnknown,
                iAxis: usize,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDDataset,
                hAccessor: usize,
                ulStartCell: usize,
                ulEndCell: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDDataset,
                hAccessor: usize,
                ulStartCell: usize,
                ulEndCell: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDDataset,
                riid: ?*const Guid,
                ppSpecification: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDDataset,
                riid: ?*const Guid,
                ppSpecification: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDDataset_FreeAxisInfo(self: *const T, cAxes: usize, rgAxisInfo: ?*MDAXISINFO) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).FreeAxisInfo(@as(*const IMDDataset, @ptrCast(self)), cAxes, rgAxisInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDDataset_GetAxisInfo(self: *const T, pcAxes: ?*usize, prgAxisInfo: ?*?*MDAXISINFO) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).GetAxisInfo(@as(*const IMDDataset, @ptrCast(self)), pcAxes, prgAxisInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDDataset_GetAxisRowset(self: *const T, pUnkOuter: ?*IUnknown, iAxis: usize, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?*DBPROPSET, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).GetAxisRowset(@as(*const IMDDataset, @ptrCast(self)), pUnkOuter, iAxis, riid, cPropertySets, rgPropertySets, ppRowset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDDataset_GetCellData(self: *const T, hAccessor: usize, ulStartCell: usize, ulEndCell: usize, pData: ?*anyopaque) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).GetCellData(@as(*const IMDDataset, @ptrCast(self)), hAccessor, ulStartCell, ulEndCell, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDDataset_GetSpecification(self: *const T, riid: ?*const Guid, ppSpecification: ?*?*IUnknown) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).GetSpecification(@as(*const IMDDataset, @ptrCast(self)), riid, ppSpecification);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDFind_Value = Guid.initString("a07cccd2-8148-11d0-87bb-00c04fc33942");
pub const IID_IMDFind = &IID_IMDFind_Value;
pub const IMDFind = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindCell: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDFind,
                ulStartingOrdinal: usize,
                cMembers: usize,
                rgpwszMember: ?*?PWSTR,
                pulCellOrdinal: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDFind,
                ulStartingOrdinal: usize,
                cMembers: usize,
                rgpwszMember: ?*?PWSTR,
                pulCellOrdinal: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindTuple: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDFind,
                ulAxisIdentifier: u32,
                ulStartingOrdinal: usize,
                cMembers: usize,
                rgpwszMember: ?*?PWSTR,
                pulTupleOrdinal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDFind,
                ulAxisIdentifier: u32,
                ulStartingOrdinal: usize,
                cMembers: usize,
                rgpwszMember: ?*?PWSTR,
                pulTupleOrdinal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDFind_FindCell(self: *const T, ulStartingOrdinal: usize, cMembers: usize, rgpwszMember: ?*?PWSTR, pulCellOrdinal: ?*usize) HRESULT {
                return @as(*const IMDFind.VTable, @ptrCast(self.vtable)).FindCell(@as(*const IMDFind, @ptrCast(self)), ulStartingOrdinal, cMembers, rgpwszMember, pulCellOrdinal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDFind_FindTuple(self: *const T, ulAxisIdentifier: u32, ulStartingOrdinal: usize, cMembers: usize, rgpwszMember: ?*?PWSTR, pulTupleOrdinal: ?*u32) HRESULT {
                return @as(*const IMDFind.VTable, @ptrCast(self.vtable)).FindTuple(@as(*const IMDFind, @ptrCast(self)), ulAxisIdentifier, ulStartingOrdinal, cMembers, rgpwszMember, pulTupleOrdinal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDRangeRowset_Value = Guid.initString("0c733aa0-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IMDRangeRowset = &IID_IMDRangeRowset_Value;
pub const IMDRangeRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRangeRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDRangeRowset,
                pUnkOuter: ?*IUnknown,
                ulStartCell: usize,
                ulEndCell: usize,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDRangeRowset,
                pUnkOuter: ?*IUnknown,
                ulStartCell: usize,
                ulEndCell: usize,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDRangeRowset_GetRangeRowset(self: *const T, pUnkOuter: ?*IUnknown, ulStartCell: usize, ulEndCell: usize, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?*DBPROPSET, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IMDRangeRowset.VTable, @ptrCast(self.vtable)).GetRangeRowset(@as(*const IMDRangeRowset, @ptrCast(self)), pUnkOuter, ulStartCell, ulEndCell, riid, cPropertySets, rgPropertySets, ppRowset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAlterTable_Value = Guid.initString("0c733aa5-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IAlterTable = &IID_IAlterTable_Value;
pub const IAlterTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AlterColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAlterTable,
                pTableId: ?*DBID,
                pColumnId: ?*DBID,
                dwColumnDescFlags: u32,
                pColumnDesc: ?*DBCOLUMNDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAlterTable,
                pTableId: ?*DBID,
                pColumnId: ?*DBID,
                dwColumnDescFlags: u32,
                pColumnDesc: ?*DBCOLUMNDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AlterTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAlterTable,
                pTableId: ?*DBID,
                pNewTableId: ?*DBID,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAlterTable,
                pTableId: ?*DBID,
                pNewTableId: ?*DBID,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAlterTable_AlterColumn(self: *const T, pTableId: ?*DBID, pColumnId: ?*DBID, dwColumnDescFlags: u32, pColumnDesc: ?*DBCOLUMNDESC) HRESULT {
                return @as(*const IAlterTable.VTable, @ptrCast(self.vtable)).AlterColumn(@as(*const IAlterTable, @ptrCast(self)), pTableId, pColumnId, dwColumnDescFlags, pColumnDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAlterTable_AlterTable(self: *const T, pTableId: ?*DBID, pNewTableId: ?*DBID, cPropertySets: u32, rgPropertySets: ?*DBPROPSET) HRESULT {
                return @as(*const IAlterTable.VTable, @ptrCast(self.vtable)).AlterTable(@as(*const IAlterTable, @ptrCast(self)), pTableId, pNewTableId, cPropertySets, rgPropertySets);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAlterIndex_Value = Guid.initString("0c733aa6-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IAlterIndex = &IID_IAlterIndex_Value;
pub const IAlterIndex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AlterIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAlterIndex,
                pTableId: ?*DBID,
                pIndexId: ?*DBID,
                pNewIndexId: ?*DBID,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAlterIndex,
                pTableId: ?*DBID,
                pIndexId: ?*DBID,
                pNewIndexId: ?*DBID,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAlterIndex_AlterIndex(self: *const T, pTableId: ?*DBID, pIndexId: ?*DBID, pNewIndexId: ?*DBID, cPropertySets: u32, rgPropertySets: ?*DBPROPSET) HRESULT {
                return @as(*const IAlterIndex.VTable, @ptrCast(self.vtable)).AlterIndex(@as(*const IAlterIndex, @ptrCast(self)), pTableId, pIndexId, pNewIndexId, cPropertySets, rgPropertySets);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetChapterMember_Value = Guid.initString("0c733aa8-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetChapterMember = &IID_IRowsetChapterMember_Value;
pub const IRowsetChapterMember = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsRowInChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetChapterMember,
                hChapter: usize,
                hRow: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetChapterMember,
                hChapter: usize,
                hRow: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetChapterMember_IsRowInChapter(self: *const T, hChapter: usize, hRow: usize) HRESULT {
                return @as(*const IRowsetChapterMember.VTable, @ptrCast(self.vtable)).IsRowInChapter(@as(*const IRowsetChapterMember, @ptrCast(self)), hChapter, hRow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandPersist_Value = Guid.initString("0c733aa7-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandPersist = &IID_ICommandPersist_Value;
pub const ICommandPersist = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandPersist,
                pCommandID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandPersist,
                pCommandID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandPersist,
                ppCommandID: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandPersist,
                ppCommandID: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandPersist,
                pCommandID: ?*DBID,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandPersist,
                pCommandID: ?*DBID,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandPersist,
                pCommandID: ?*DBID,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandPersist,
                pCommandID: ?*DBID,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandPersist_DeleteCommand(self: *const T, pCommandID: ?*DBID) HRESULT {
                return @as(*const ICommandPersist.VTable, @ptrCast(self.vtable)).DeleteCommand(@as(*const ICommandPersist, @ptrCast(self)), pCommandID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandPersist_GetCurrentCommand(self: *const T, ppCommandID: ?*?*DBID) HRESULT {
                return @as(*const ICommandPersist.VTable, @ptrCast(self.vtable)).GetCurrentCommand(@as(*const ICommandPersist, @ptrCast(self)), ppCommandID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandPersist_LoadCommand(self: *const T, pCommandID: ?*DBID, dwFlags: u32) HRESULT {
                return @as(*const ICommandPersist.VTable, @ptrCast(self.vtable)).LoadCommand(@as(*const ICommandPersist, @ptrCast(self)), pCommandID, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandPersist_SaveCommand(self: *const T, pCommandID: ?*DBID, dwFlags: u32) HRESULT {
                return @as(*const ICommandPersist.VTable, @ptrCast(self.vtable)).SaveCommand(@as(*const ICommandPersist, @ptrCast(self)), pCommandID, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetRefresh_Value = Guid.initString("0c733aa9-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetRefresh = &IID_IRowsetRefresh_Value;
pub const IRowsetRefresh = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RefreshVisibleData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetRefresh,
                hChapter: usize,
                cRows: usize,
                rghRows: ?*const usize,
                fOverWrite: BOOL,
                pcRowsRefreshed: ?*usize,
                prghRowsRefreshed: ?*?*usize,
                prgRowStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetRefresh,
                hChapter: usize,
                cRows: usize,
                rghRows: ?*const usize,
                fOverWrite: BOOL,
                pcRowsRefreshed: ?*usize,
                prghRowsRefreshed: ?*?*usize,
                prgRowStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastVisibleData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetRefresh,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetRefresh,
                hRow: usize,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetRefresh_RefreshVisibleData(self: *const T, hChapter: usize, cRows: usize, rghRows: ?*const usize, fOverWrite: BOOL, pcRowsRefreshed: ?*usize, prghRowsRefreshed: ?*?*usize, prgRowStatus: ?*?*u32) HRESULT {
                return @as(*const IRowsetRefresh.VTable, @ptrCast(self.vtable)).RefreshVisibleData(@as(*const IRowsetRefresh, @ptrCast(self)), hChapter, cRows, rghRows, fOverWrite, pcRowsRefreshed, prghRowsRefreshed, prgRowStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetRefresh_GetLastVisibleData(self: *const T, hRow: usize, hAccessor: usize, pData: ?*anyopaque) HRESULT {
                return @as(*const IRowsetRefresh.VTable, @ptrCast(self.vtable)).GetLastVisibleData(@as(*const IRowsetRefresh, @ptrCast(self)), hRow, hAccessor, pData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IParentRowset_Value = Guid.initString("0c733aaa-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IParentRowset = &IID_IParentRowset_Value;
pub const IParentRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChildRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IParentRowset,
                pUnkOuter: ?*IUnknown,
                iOrdinal: usize,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IParentRowset,
                pUnkOuter: ?*IUnknown,
                iOrdinal: usize,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IParentRowset_GetChildRowset(self: *const T, pUnkOuter: ?*IUnknown, iOrdinal: usize, riid: ?*const Guid, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IParentRowset.VTable, @ptrCast(self.vtable)).GetChildRowset(@as(*const IParentRowset, @ptrCast(self)), pUnkOuter, iOrdinal, riid, ppRowset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorRecords_Value = Guid.initString("0c733a67-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IErrorRecords = &IID_IErrorRecords_Value;
pub const IErrorRecords = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddErrorRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorRecords,
                pErrorInfo: ?*ERRORINFO,
                dwLookupID: u32,
                pdispparams: ?*DISPPARAMS,
                punkCustomError: ?*IUnknown,
                dwDynamicErrorID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorRecords,
                pErrorInfo: ?*ERRORINFO,
                dwLookupID: u32,
                pdispparams: ?*DISPPARAMS,
                punkCustomError: ?*IUnknown,
                dwDynamicErrorID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBasicErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorRecords,
                ulRecordNum: u32,
                pErrorInfo: ?*ERRORINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorRecords,
                ulRecordNum: u32,
                pErrorInfo: ?*ERRORINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCustomErrorObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorRecords,
                ulRecordNum: u32,
                riid: ?*const Guid,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorRecords,
                ulRecordNum: u32,
                riid: ?*const Guid,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorRecords,
                ulRecordNum: u32,
                lcid: u32,
                ppErrorInfo: ?*?*IErrorInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorRecords,
                ulRecordNum: u32,
                lcid: u32,
                ppErrorInfo: ?*?*IErrorInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorRecords,
                ulRecordNum: u32,
                pdispparams: ?*DISPPARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorRecords,
                ulRecordNum: u32,
                pdispparams: ?*DISPPARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorRecords,
                pcRecords: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorRecords,
                pcRecords: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorRecords_AddErrorRecord(self: *const T, pErrorInfo: ?*ERRORINFO, dwLookupID: u32, pdispparams: ?*DISPPARAMS, punkCustomError: ?*IUnknown, dwDynamicErrorID: u32) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).AddErrorRecord(@as(*const IErrorRecords, @ptrCast(self)), pErrorInfo, dwLookupID, pdispparams, punkCustomError, dwDynamicErrorID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorRecords_GetBasicErrorInfo(self: *const T, ulRecordNum: u32, pErrorInfo: ?*ERRORINFO) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetBasicErrorInfo(@as(*const IErrorRecords, @ptrCast(self)), ulRecordNum, pErrorInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorRecords_GetCustomErrorObject(self: *const T, ulRecordNum: u32, riid: ?*const Guid, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetCustomErrorObject(@as(*const IErrorRecords, @ptrCast(self)), ulRecordNum, riid, ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorRecords_GetErrorInfo(self: *const T, ulRecordNum: u32, lcid: u32, ppErrorInfo: ?*?*IErrorInfo) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetErrorInfo(@as(*const IErrorRecords, @ptrCast(self)), ulRecordNum, lcid, ppErrorInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorRecords_GetErrorParameters(self: *const T, ulRecordNum: u32, pdispparams: ?*DISPPARAMS) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetErrorParameters(@as(*const IErrorRecords, @ptrCast(self)), ulRecordNum, pdispparams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorRecords_GetRecordCount(self: *const T, pcRecords: ?*u32) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetRecordCount(@as(*const IErrorRecords, @ptrCast(self)), pcRecords);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorLookup_Value = Guid.initString("0c733a66-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IErrorLookup = &IID_IErrorLookup_Value;
pub const IErrorLookup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorLookup,
                hrError: HRESULT,
                dwLookupID: u32,
                pdispparams: ?*DISPPARAMS,
                lcid: u32,
                pbstrSource: ?*?BSTR,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorLookup,
                hrError: HRESULT,
                dwLookupID: u32,
                pdispparams: ?*DISPPARAMS,
                lcid: u32,
                pbstrSource: ?*?BSTR,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHelpInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorLookup,
                hrError: HRESULT,
                dwLookupID: u32,
                lcid: u32,
                pbstrHelpFile: ?*?BSTR,
                pdwHelpContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorLookup,
                hrError: HRESULT,
                dwLookupID: u32,
                lcid: u32,
                pbstrHelpFile: ?*?BSTR,
                pdwHelpContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseErrors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorLookup,
                dwDynamicErrorID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorLookup,
                dwDynamicErrorID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorLookup_GetErrorDescription(self: *const T, hrError: HRESULT, dwLookupID: u32, pdispparams: ?*DISPPARAMS, lcid: u32, pbstrSource: ?*?BSTR, pbstrDescription: ?*?BSTR) HRESULT {
                return @as(*const IErrorLookup.VTable, @ptrCast(self.vtable)).GetErrorDescription(@as(*const IErrorLookup, @ptrCast(self)), hrError, dwLookupID, pdispparams, lcid, pbstrSource, pbstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorLookup_GetHelpInfo(self: *const T, hrError: HRESULT, dwLookupID: u32, lcid: u32, pbstrHelpFile: ?*?BSTR, pdwHelpContext: ?*u32) HRESULT {
                return @as(*const IErrorLookup.VTable, @ptrCast(self.vtable)).GetHelpInfo(@as(*const IErrorLookup, @ptrCast(self)), hrError, dwLookupID, lcid, pbstrHelpFile, pdwHelpContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorLookup_ReleaseErrors(self: *const T, dwDynamicErrorID: u32) HRESULT {
                return @as(*const IErrorLookup.VTable, @ptrCast(self.vtable)).ReleaseErrors(@as(*const IErrorLookup, @ptrCast(self)), dwDynamicErrorID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISQLErrorInfo_Value = Guid.initString("0c733a74-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISQLErrorInfo = &IID_ISQLErrorInfo_Value;
pub const ISQLErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSQLInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISQLErrorInfo,
                pbstrSQLState: ?*?BSTR,
                plNativeError: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISQLErrorInfo,
                pbstrSQLState: ?*?BSTR,
                plNativeError: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISQLErrorInfo_GetSQLInfo(self: *const T, pbstrSQLState: ?*?BSTR, plNativeError: ?*i32) HRESULT {
                return @as(*const ISQLErrorInfo.VTable, @ptrCast(self.vtable)).GetSQLInfo(@as(*const ISQLErrorInfo, @ptrCast(self)), pbstrSQLState, plNativeError);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetDataSource_Value = Guid.initString("0c733a75-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetDataSource = &IID_IGetDataSource_Value;
pub const IGetDataSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGetDataSource,
                riid: ?*const Guid,
                ppDataSource: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGetDataSource,
                riid: ?*const Guid,
                ppDataSource: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGetDataSource_GetDataSource(self: *const T, riid: ?*const Guid, ppDataSource: ?*?*IUnknown) HRESULT {
                return @as(*const IGetDataSource.VTable, @ptrCast(self.vtable)).GetDataSource(@as(*const IGetDataSource, @ptrCast(self)), riid, ppDataSource);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransactionLocal_Value = Guid.initString("0c733a5f-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITransactionLocal = &IID_ITransactionLocal_Value;
pub const ITransactionLocal = extern struct {
    pub const VTable = extern struct {
        base: ITransaction.VTable,
        GetOptionsObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransactionLocal,
                ppOptions: ?*?*ITransactionOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransactionLocal,
                ppOptions: ?*?*ITransactionOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartTransaction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransactionLocal,
                isoLevel: i32,
                isoFlags: u32,
                pOtherOptions: ?*ITransactionOptions,
                pulTransactionLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransactionLocal,
                isoLevel: i32,
                isoFlags: u32,
                pOtherOptions: ?*ITransactionOptions,
                pulTransactionLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITransaction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransactionLocal_GetOptionsObject(self: *const T, ppOptions: ?*?*ITransactionOptions) HRESULT {
                return @as(*const ITransactionLocal.VTable, @ptrCast(self.vtable)).GetOptionsObject(@as(*const ITransactionLocal, @ptrCast(self)), ppOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransactionLocal_StartTransaction(self: *const T, isoLevel: i32, isoFlags: u32, pOtherOptions: ?*ITransactionOptions, pulTransactionLevel: ?*u32) HRESULT {
                return @as(*const ITransactionLocal.VTable, @ptrCast(self.vtable)).StartTransaction(@as(*const ITransactionLocal, @ptrCast(self)), isoLevel, isoFlags, pOtherOptions, pulTransactionLevel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransactionJoin_Value = Guid.initString("0c733a5e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITransactionJoin = &IID_ITransactionJoin_Value;
pub const ITransactionJoin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOptionsObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransactionJoin,
                ppOptions: ?*?*ITransactionOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransactionJoin,
                ppOptions: ?*?*ITransactionOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JoinTransaction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransactionJoin,
                punkTransactionCoord: ?*IUnknown,
                isoLevel: i32,
                isoFlags: u32,
                pOtherOptions: ?*ITransactionOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransactionJoin,
                punkTransactionCoord: ?*IUnknown,
                isoLevel: i32,
                isoFlags: u32,
                pOtherOptions: ?*ITransactionOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransactionJoin_GetOptionsObject(self: *const T, ppOptions: ?*?*ITransactionOptions) HRESULT {
                return @as(*const ITransactionJoin.VTable, @ptrCast(self.vtable)).GetOptionsObject(@as(*const ITransactionJoin, @ptrCast(self)), ppOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransactionJoin_JoinTransaction(self: *const T, punkTransactionCoord: ?*IUnknown, isoLevel: i32, isoFlags: u32, pOtherOptions: ?*ITransactionOptions) HRESULT {
                return @as(*const ITransactionJoin.VTable, @ptrCast(self.vtable)).JoinTransaction(@as(*const ITransactionJoin, @ptrCast(self)), punkTransactionCoord, isoLevel, isoFlags, pOtherOptions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransactionObject_Value = Guid.initString("0c733a60-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITransactionObject = &IID_ITransactionObject_Value;
pub const ITransactionObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTransactionObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransactionObject,
                ulTransactionLevel: u32,
                ppTransactionObject: ?*?*ITransaction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransactionObject,
                ulTransactionLevel: u32,
                ppTransactionObject: ?*?*ITransaction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransactionObject_GetTransactionObject(self: *const T, ulTransactionLevel: u32, ppTransactionObject: ?*?*ITransaction) HRESULT {
                return @as(*const ITransactionObject.VTable, @ptrCast(self.vtable)).GetTransactionObject(@as(*const ITransactionObject, @ptrCast(self)), ulTransactionLevel, ppTransactionObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITrusteeAdmin_Value = Guid.initString("0c733aa1-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITrusteeAdmin = &IID_ITrusteeAdmin_Value;
pub const ITrusteeAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareTrustees: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeAdmin,
                pTrustee1: ?*TRUSTEE_W,
                pTrustee2: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeAdmin,
                pTrustee1: ?*TRUSTEE_W,
                pTrustee2: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTrustee: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeAdmin,
                pTrustee: ?*TRUSTEE_W,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeAdmin,
                pTrustee: ?*TRUSTEE_W,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteTrustee: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeAdmin,
                pTrustee: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeAdmin,
                pTrustee: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTrusteeProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeAdmin,
                pTrustee: ?*TRUSTEE_W,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeAdmin,
                pTrustee: ?*TRUSTEE_W,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTrusteeProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeAdmin,
                pTrustee: ?*TRUSTEE_W,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?*const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeAdmin,
                pTrustee: ?*TRUSTEE_W,
                cPropertyIDSets: u32,
                rgPropertyIDSets: ?*const DBPROPIDSET,
                pcPropertySets: ?*u32,
                prgPropertySets: ?*?*DBPROPSET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeAdmin_CompareTrustees(self: *const T, pTrustee1: ?*TRUSTEE_W, pTrustee2: ?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).CompareTrustees(@as(*const ITrusteeAdmin, @ptrCast(self)), pTrustee1, pTrustee2);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeAdmin_CreateTrustee(self: *const T, pTrustee: ?*TRUSTEE_W, cPropertySets: u32, rgPropertySets: ?*DBPROPSET) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).CreateTrustee(@as(*const ITrusteeAdmin, @ptrCast(self)), pTrustee, cPropertySets, rgPropertySets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeAdmin_DeleteTrustee(self: *const T, pTrustee: ?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).DeleteTrustee(@as(*const ITrusteeAdmin, @ptrCast(self)), pTrustee);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeAdmin_SetTrusteeProperties(self: *const T, pTrustee: ?*TRUSTEE_W, cPropertySets: u32, rgPropertySets: ?*DBPROPSET) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).SetTrusteeProperties(@as(*const ITrusteeAdmin, @ptrCast(self)), pTrustee, cPropertySets, rgPropertySets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeAdmin_GetTrusteeProperties(self: *const T, pTrustee: ?*TRUSTEE_W, cPropertyIDSets: u32, rgPropertyIDSets: ?*const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).GetTrusteeProperties(@as(*const ITrusteeAdmin, @ptrCast(self)), pTrustee, cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITrusteeGroupAdmin_Value = Guid.initString("0c733aa2-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITrusteeGroupAdmin = &IID_ITrusteeGroupAdmin_Value;
pub const ITrusteeGroupAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddMember: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeGroupAdmin,
                pMembershipTrustee: ?*TRUSTEE_W,
                pMemberTrustee: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeGroupAdmin,
                pMembershipTrustee: ?*TRUSTEE_W,
                pMemberTrustee: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteMember: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeGroupAdmin,
                pMembershipTrustee: ?*TRUSTEE_W,
                pMemberTrustee: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeGroupAdmin,
                pMembershipTrustee: ?*TRUSTEE_W,
                pMemberTrustee: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsMember: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeGroupAdmin,
                pMembershipTrustee: ?*TRUSTEE_W,
                pMemberTrustee: ?*TRUSTEE_W,
                pfStatus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeGroupAdmin,
                pMembershipTrustee: ?*TRUSTEE_W,
                pMemberTrustee: ?*TRUSTEE_W,
                pfStatus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMembers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeGroupAdmin,
                pMembershipTrustee: ?*TRUSTEE_W,
                pcMembers: ?*u32,
                prgMembers: ?*?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeGroupAdmin,
                pMembershipTrustee: ?*TRUSTEE_W,
                pcMembers: ?*u32,
                prgMembers: ?*?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemberships: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrusteeGroupAdmin,
                pTrustee: ?*TRUSTEE_W,
                pcMemberships: ?*u32,
                prgMemberships: ?*?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrusteeGroupAdmin,
                pTrustee: ?*TRUSTEE_W,
                pcMemberships: ?*u32,
                prgMemberships: ?*?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeGroupAdmin_AddMember(self: *const T, pMembershipTrustee: ?*TRUSTEE_W, pMemberTrustee: ?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).AddMember(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), pMembershipTrustee, pMemberTrustee);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeGroupAdmin_DeleteMember(self: *const T, pMembershipTrustee: ?*TRUSTEE_W, pMemberTrustee: ?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).DeleteMember(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), pMembershipTrustee, pMemberTrustee);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeGroupAdmin_IsMember(self: *const T, pMembershipTrustee: ?*TRUSTEE_W, pMemberTrustee: ?*TRUSTEE_W, pfStatus: ?*BOOL) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).IsMember(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), pMembershipTrustee, pMemberTrustee, pfStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeGroupAdmin_GetMembers(self: *const T, pMembershipTrustee: ?*TRUSTEE_W, pcMembers: ?*u32, prgMembers: ?*?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).GetMembers(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), pMembershipTrustee, pcMembers, prgMembers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrusteeGroupAdmin_GetMemberships(self: *const T, pTrustee: ?*TRUSTEE_W, pcMemberships: ?*u32, prgMemberships: ?*?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).GetMemberships(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), pTrustee, pcMemberships, prgMemberships);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IObjectAccessControl_Value = Guid.initString("0c733aa3-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IObjectAccessControl = &IID_IObjectAccessControl_Value;
pub const IObjectAccessControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectAccessRights: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                pcAccessEntries: ?*u32,
                prgAccessEntries: ?*?*EXPLICIT_ACCESS_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                pcAccessEntries: ?*u32,
                prgAccessEntries: ?*?*EXPLICIT_ACCESS_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectOwner: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                ppOwner: ?*?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                ppOwner: ?*?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsObjectAccessAllowed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                pAccessEntry: ?*EXPLICIT_ACCESS_W,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                pAccessEntry: ?*EXPLICIT_ACCESS_W,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetObjectAccessRights: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                cAccessEntries: u32,
                prgAccessEntries: ?*EXPLICIT_ACCESS_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                cAccessEntries: u32,
                prgAccessEntries: ?*EXPLICIT_ACCESS_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetObjectOwner: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                pOwner: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectAccessControl,
                pObject: ?*SEC_OBJECT,
                pOwner: ?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectAccessControl_GetObjectAccessRights(self: *const T, pObject: ?*SEC_OBJECT, pcAccessEntries: ?*u32, prgAccessEntries: ?*?*EXPLICIT_ACCESS_W) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).GetObjectAccessRights(@as(*const IObjectAccessControl, @ptrCast(self)), pObject, pcAccessEntries, prgAccessEntries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectAccessControl_GetObjectOwner(self: *const T, pObject: ?*SEC_OBJECT, ppOwner: ?*?*TRUSTEE_W) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).GetObjectOwner(@as(*const IObjectAccessControl, @ptrCast(self)), pObject, ppOwner);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectAccessControl_IsObjectAccessAllowed(self: *const T, pObject: ?*SEC_OBJECT, pAccessEntry: ?*EXPLICIT_ACCESS_W, pfResult: ?*BOOL) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).IsObjectAccessAllowed(@as(*const IObjectAccessControl, @ptrCast(self)), pObject, pAccessEntry, pfResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectAccessControl_SetObjectAccessRights(self: *const T, pObject: ?*SEC_OBJECT, cAccessEntries: u32, prgAccessEntries: ?*EXPLICIT_ACCESS_W) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).SetObjectAccessRights(@as(*const IObjectAccessControl, @ptrCast(self)), pObject, cAccessEntries, prgAccessEntries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectAccessControl_SetObjectOwner(self: *const T, pObject: ?*SEC_OBJECT, pOwner: ?*TRUSTEE_W) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).SetObjectOwner(@as(*const IObjectAccessControl, @ptrCast(self)), pObject, pOwner);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ACCESS_MASKENUM = enum(i32) {
    EXCLUSIVE = 512,
    READDESIGN = 1024,
    WRITEDESIGN = 2048,
    WITHGRANT = 4096,
    REFERENCE = 8192,
    CREATE = 16384,
    INSERT = 32768,
    DELETE = 65536,
    READCONTROL = 131072,
    WRITEPERMISSIONS = 262144,
    WRITEOWNER = 524288,
    MAXIMUM_ALLOWED = 33554432,
    ALL = 268435456,
    EXECUTE = 536870912,
    READ = -2147483648,
    UPDATE = 1073741824,
    DROP = 256,
};
pub const PERM_EXCLUSIVE = ACCESS_MASKENUM.EXCLUSIVE;
pub const PERM_READDESIGN = ACCESS_MASKENUM.READDESIGN;
pub const PERM_WRITEDESIGN = ACCESS_MASKENUM.WRITEDESIGN;
pub const PERM_WITHGRANT = ACCESS_MASKENUM.WITHGRANT;
pub const PERM_REFERENCE = ACCESS_MASKENUM.REFERENCE;
pub const PERM_CREATE = ACCESS_MASKENUM.CREATE;
pub const PERM_INSERT = ACCESS_MASKENUM.INSERT;
pub const PERM_DELETE = ACCESS_MASKENUM.DELETE;
pub const PERM_READCONTROL = ACCESS_MASKENUM.READCONTROL;
pub const PERM_WRITEPERMISSIONS = ACCESS_MASKENUM.WRITEPERMISSIONS;
pub const PERM_WRITEOWNER = ACCESS_MASKENUM.WRITEOWNER;
pub const PERM_MAXIMUM_ALLOWED = ACCESS_MASKENUM.MAXIMUM_ALLOWED;
pub const PERM_ALL = ACCESS_MASKENUM.ALL;
pub const PERM_EXECUTE = ACCESS_MASKENUM.EXECUTE;
pub const PERM_READ = ACCESS_MASKENUM.READ;
pub const PERM_UPDATE = ACCESS_MASKENUM.UPDATE;
pub const PERM_DROP = ACCESS_MASKENUM.DROP;

const IID_ISecurityInfo_Value = Guid.initString("0c733aa4-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISecurityInfo = &IID_ISecurityInfo_Value;
pub const ISecurityInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentTrustee: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISecurityInfo,
                ppTrustee: ?*?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISecurityInfo,
                ppTrustee: ?*?*TRUSTEE_W,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISecurityInfo,
                cObjectTypes: ?*u32,
                rgObjectTypes: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISecurityInfo,
                cObjectTypes: ?*u32,
                rgObjectTypes: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPermissions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISecurityInfo,
                ObjectType: Guid,
                pPermissions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISecurityInfo,
                ObjectType: Guid,
                pPermissions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISecurityInfo_GetCurrentTrustee(self: *const T, ppTrustee: ?*?*TRUSTEE_W) HRESULT {
                return @as(*const ISecurityInfo.VTable, @ptrCast(self.vtable)).GetCurrentTrustee(@as(*const ISecurityInfo, @ptrCast(self)), ppTrustee);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISecurityInfo_GetObjectTypes(self: *const T, cObjectTypes: ?*u32, rgObjectTypes: ?*?*Guid) HRESULT {
                return @as(*const ISecurityInfo.VTable, @ptrCast(self.vtable)).GetObjectTypes(@as(*const ISecurityInfo, @ptrCast(self)), cObjectTypes, rgObjectTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISecurityInfo_GetPermissions(self: *const T, ObjectType: Guid, pPermissions: ?*u32) HRESULT {
                return @as(*const ISecurityInfo.VTable, @ptrCast(self.vtable)).GetPermissions(@as(*const ISecurityInfo, @ptrCast(self)), ObjectType, pPermissions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableCreation_Value = Guid.initString("0c733abc-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableCreation = &IID_ITableCreation_Value;
pub const ITableCreation = extern struct {
    pub const VTable = extern struct {
        base: ITableDefinition.VTable,
        GetTableDefinition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableCreation,
                pTableID: ?*DBID,
                pcColumnDescs: ?*usize,
                prgColumnDescs: ?[*]?*DBCOLUMNDESC,
                pcPropertySets: ?*u32,
                prgPropertySets: ?[*]?*DBPROPSET,
                pcConstraintDescs: ?*u32,
                prgConstraintDescs: ?[*]?*DBCONSTRAINTDESC,
                ppwszStringBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableCreation,
                pTableID: ?*DBID,
                pcColumnDescs: ?*usize,
                prgColumnDescs: ?[*]?*DBCOLUMNDESC,
                pcPropertySets: ?*u32,
                prgPropertySets: ?[*]?*DBPROPSET,
                pcConstraintDescs: ?*u32,
                prgConstraintDescs: ?[*]?*DBCONSTRAINTDESC,
                ppwszStringBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITableDefinition.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableCreation_GetTableDefinition(self: *const T, pTableID: ?*DBID, pcColumnDescs: ?*usize, prgColumnDescs: ?[*]?*DBCOLUMNDESC, pcPropertySets: ?*u32, prgPropertySets: ?[*]?*DBPROPSET, pcConstraintDescs: ?*u32, prgConstraintDescs: ?[*]?*DBCONSTRAINTDESC, ppwszStringBuffer: ?*?*u16) HRESULT {
                return @as(*const ITableCreation.VTable, @ptrCast(self.vtable)).GetTableDefinition(@as(*const ITableCreation, @ptrCast(self)), pTableID, pcColumnDescs, prgColumnDescs, pcPropertySets, prgPropertySets, pcConstraintDescs, prgConstraintDescs, ppwszStringBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableDefinitionWithConstraints_Value = Guid.initString("0c733aab-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableDefinitionWithConstraints = &IID_ITableDefinitionWithConstraints_Value;
pub const ITableDefinitionWithConstraints = extern struct {
    pub const VTable = extern struct {
        base: ITableCreation.VTable,
        AddConstraint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableDefinitionWithConstraints,
                pTableID: ?*DBID,
                pConstraintDesc: ?*DBCONSTRAINTDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableDefinitionWithConstraints,
                pTableID: ?*DBID,
                pConstraintDesc: ?*DBCONSTRAINTDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTableWithConstraints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableDefinitionWithConstraints,
                pUnkOuter: ?*IUnknown,
                pTableID: ?*DBID,
                cColumnDescs: usize,
                rgColumnDescs: ?*DBCOLUMNDESC,
                cConstraintDescs: u32,
                rgConstraintDescs: ?*DBCONSTRAINTDESC,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
                ppTableID: ?*?*DBID,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableDefinitionWithConstraints,
                pUnkOuter: ?*IUnknown,
                pTableID: ?*DBID,
                cColumnDescs: usize,
                rgColumnDescs: ?*DBCOLUMNDESC,
                cConstraintDescs: u32,
                rgConstraintDescs: ?*DBCONSTRAINTDESC,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: ?*DBPROPSET,
                ppTableID: ?*?*DBID,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DropConstraint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableDefinitionWithConstraints,
                pTableID: ?*DBID,
                pConstraintID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableDefinitionWithConstraints,
                pTableID: ?*DBID,
                pConstraintID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITableCreation.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableDefinitionWithConstraints_AddConstraint(self: *const T, pTableID: ?*DBID, pConstraintDesc: ?*DBCONSTRAINTDESC) HRESULT {
                return @as(*const ITableDefinitionWithConstraints.VTable, @ptrCast(self.vtable)).AddConstraint(@as(*const ITableDefinitionWithConstraints, @ptrCast(self)), pTableID, pConstraintDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableDefinitionWithConstraints_CreateTableWithConstraints(self: *const T, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, cColumnDescs: usize, rgColumnDescs: ?*DBCOLUMNDESC, cConstraintDescs: u32, rgConstraintDescs: ?*DBCONSTRAINTDESC, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?*DBPROPSET, ppTableID: ?*?*DBID, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const ITableDefinitionWithConstraints.VTable, @ptrCast(self.vtable)).CreateTableWithConstraints(@as(*const ITableDefinitionWithConstraints, @ptrCast(self)), pUnkOuter, pTableID, cColumnDescs, rgColumnDescs, cConstraintDescs, rgConstraintDescs, riid, cPropertySets, rgPropertySets, ppTableID, ppRowset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableDefinitionWithConstraints_DropConstraint(self: *const T, pTableID: ?*DBID, pConstraintID: ?*DBID) HRESULT {
                return @as(*const ITableDefinitionWithConstraints.VTable, @ptrCast(self.vtable)).DropConstraint(@as(*const ITableDefinitionWithConstraints, @ptrCast(self)), pTableID, pConstraintID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRow_Value = Guid.initString("0c733ab4-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRow = &IID_IRow_Value;
pub const IRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRow,
                cColumns: usize,
                rgColumns: [*]DBCOLUMNACCESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRow,
                cColumns: usize,
                rgColumns: [*]DBCOLUMNACCESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRow,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
                phRow: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRow,
                riid: ?*const Guid,
                ppRowset: ?*?*IUnknown,
                phRow: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRow,
                pUnkOuter: ?*IUnknown,
                pColumnID: ?*DBID,
                rguidColumnType: ?*const Guid,
                dwBindFlags: u32,
                riid: ?*const Guid,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRow,
                pUnkOuter: ?*IUnknown,
                pColumnID: ?*DBID,
                rguidColumnType: ?*const Guid,
                dwBindFlags: u32,
                riid: ?*const Guid,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRow_GetColumns(self: *const T, cColumns: usize, rgColumns: [*]DBCOLUMNACCESS) HRESULT {
                return @as(*const IRow.VTable, @ptrCast(self.vtable)).GetColumns(@as(*const IRow, @ptrCast(self)), cColumns, rgColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRow_GetSourceRowset(self: *const T, riid: ?*const Guid, ppRowset: ?*?*IUnknown, phRow: ?*usize) HRESULT {
                return @as(*const IRow.VTable, @ptrCast(self.vtable)).GetSourceRowset(@as(*const IRow, @ptrCast(self)), riid, ppRowset, phRow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRow_Open(self: *const T, pUnkOuter: ?*IUnknown, pColumnID: ?*DBID, rguidColumnType: ?*const Guid, dwBindFlags: u32, riid: ?*const Guid, ppUnk: ?*?*IUnknown) HRESULT {
                return @as(*const IRow.VTable, @ptrCast(self.vtable)).Open(@as(*const IRow, @ptrCast(self)), pUnkOuter, pColumnID, rguidColumnType, dwBindFlags, riid, ppUnk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowChange_Value = Guid.initString("0c733ab5-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowChange = &IID_IRowChange_Value;
pub const IRowChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowChange,
                cColumns: usize,
                rgColumns: [*]DBCOLUMNACCESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowChange,
                cColumns: usize,
                rgColumns: [*]DBCOLUMNACCESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowChange_SetColumns(self: *const T, cColumns: usize, rgColumns: [*]DBCOLUMNACCESS) HRESULT {
                return @as(*const IRowChange.VTable, @ptrCast(self.vtable)).SetColumns(@as(*const IRowChange, @ptrCast(self)), cColumns, rgColumns);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowSchemaChange_Value = Guid.initString("0c733aae-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowSchemaChange = &IID_IRowSchemaChange_Value;
pub const IRowSchemaChange = extern struct {
    pub const VTable = extern struct {
        base: IRowChange.VTable,
        DeleteColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowSchemaChange,
                cColumns: usize,
                rgColumnIDs: ?*const DBID,
                rgdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowSchemaChange,
                cColumns: usize,
                rgColumnIDs: ?*const DBID,
                rgdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowSchemaChange,
                cColumns: usize,
                rgNewColumnInfo: ?*const DBCOLUMNINFO,
                rgColumns: ?*DBCOLUMNACCESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowSchemaChange,
                cColumns: usize,
                rgNewColumnInfo: ?*const DBCOLUMNINFO,
                rgColumns: ?*DBCOLUMNACCESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowChange.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowSchemaChange_DeleteColumns(self: *const T, cColumns: usize, rgColumnIDs: ?*const DBID, rgdwStatus: ?*u32) HRESULT {
                return @as(*const IRowSchemaChange.VTable, @ptrCast(self.vtable)).DeleteColumns(@as(*const IRowSchemaChange, @ptrCast(self)), cColumns, rgColumnIDs, rgdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowSchemaChange_AddColumns(self: *const T, cColumns: usize, rgNewColumnInfo: ?*const DBCOLUMNINFO, rgColumns: ?*DBCOLUMNACCESS) HRESULT {
                return @as(*const IRowSchemaChange.VTable, @ptrCast(self.vtable)).AddColumns(@as(*const IRowSchemaChange, @ptrCast(self)), cColumns, rgNewColumnInfo, rgColumns);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetRow_Value = Guid.initString("0c733aaf-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetRow = &IID_IGetRow_Value;
pub const IGetRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowFromHROW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGetRow,
                pUnkOuter: ?*IUnknown,
                hRow: usize,
                riid: ?*const Guid,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGetRow,
                pUnkOuter: ?*IUnknown,
                hRow: usize,
                riid: ?*const Guid,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetURLFromHROW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGetRow,
                hRow: usize,
                ppwszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGetRow,
                hRow: usize,
                ppwszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGetRow_GetRowFromHROW(self: *const T, pUnkOuter: ?*IUnknown, hRow: usize, riid: ?*const Guid, ppUnk: ?*?*IUnknown) HRESULT {
                return @as(*const IGetRow.VTable, @ptrCast(self.vtable)).GetRowFromHROW(@as(*const IGetRow, @ptrCast(self)), pUnkOuter, hRow, riid, ppUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGetRow_GetURLFromHROW(self: *const T, hRow: usize, ppwszURL: ?*?PWSTR) HRESULT {
                return @as(*const IGetRow.VTable, @ptrCast(self.vtable)).GetURLFromHROW(@as(*const IGetRow, @ptrCast(self)), hRow, ppwszURL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindResource_Value = Guid.initString("0c733ab1-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IBindResource = &IID_IBindResource_Value;
pub const IBindResource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Bind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindResource,
                pUnkOuter: ?*IUnknown,
                pwszURL: ?[*:0]const u16,
                dwBindURLFlags: u32,
                rguid: ?*const Guid,
                riid: ?*const Guid,
                pAuthenticate: ?*IAuthenticate,
                pImplSession: ?*DBIMPLICITSESSION,
                pdwBindStatus: ?*u32,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindResource,
                pUnkOuter: ?*IUnknown,
                pwszURL: ?[*:0]const u16,
                dwBindURLFlags: u32,
                rguid: ?*const Guid,
                riid: ?*const Guid,
                pAuthenticate: ?*IAuthenticate,
                pImplSession: ?*DBIMPLICITSESSION,
                pdwBindStatus: ?*u32,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindResource_Bind(self: *const T, pUnkOuter: ?*IUnknown, pwszURL: ?[*:0]const u16, dwBindURLFlags: u32, rguid: ?*const Guid, riid: ?*const Guid, pAuthenticate: ?*IAuthenticate, pImplSession: ?*DBIMPLICITSESSION, pdwBindStatus: ?*u32, ppUnk: ?*?*IUnknown) HRESULT {
                return @as(*const IBindResource.VTable, @ptrCast(self.vtable)).Bind(@as(*const IBindResource, @ptrCast(self)), pUnkOuter, pwszURL, dwBindURLFlags, rguid, riid, pAuthenticate, pImplSession, pdwBindStatus, ppUnk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBCOPYFLAGSENUM = enum(i32) {
    ASYNC = 256,
    REPLACE_EXISTING = 512,
    ALLOW_EMULATION = 1024,
    NON_RECURSIVE = 2048,
    ATOMIC = 4096,
};
pub const DBCOPY_ASYNC = DBCOPYFLAGSENUM.ASYNC;
pub const DBCOPY_REPLACE_EXISTING = DBCOPYFLAGSENUM.REPLACE_EXISTING;
pub const DBCOPY_ALLOW_EMULATION = DBCOPYFLAGSENUM.ALLOW_EMULATION;
pub const DBCOPY_NON_RECURSIVE = DBCOPYFLAGSENUM.NON_RECURSIVE;
pub const DBCOPY_ATOMIC = DBCOPYFLAGSENUM.ATOMIC;

pub const DBMOVEFLAGSENUM = enum(i32) {
    REPLACE_EXISTING = 1,
    ASYNC = 256,
    DONT_UPDATE_LINKS = 512,
    ALLOW_EMULATION = 1024,
    ATOMIC = 4096,
};
pub const DBMOVE_REPLACE_EXISTING = DBMOVEFLAGSENUM.REPLACE_EXISTING;
pub const DBMOVE_ASYNC = DBMOVEFLAGSENUM.ASYNC;
pub const DBMOVE_DONT_UPDATE_LINKS = DBMOVEFLAGSENUM.DONT_UPDATE_LINKS;
pub const DBMOVE_ALLOW_EMULATION = DBMOVEFLAGSENUM.ALLOW_EMULATION;
pub const DBMOVE_ATOMIC = DBMOVEFLAGSENUM.ATOMIC;

pub const DBDELETEFLAGSENUM = enum(i32) {
    SYNC = 256,
    TOMIC = 4096,
};
pub const DBDELETE_ASYNC = DBDELETEFLAGSENUM.SYNC;
pub const DBDELETE_ATOMIC = DBDELETEFLAGSENUM.TOMIC;

const IID_IScopedOperations_Value = Guid.initString("0c733ab0-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IScopedOperations = &IID_IScopedOperations_Value;
pub const IScopedOperations = extern struct {
    pub const VTable = extern struct {
        base: IBindResource.VTable,
        Copy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScopedOperations,
                cRows: usize,
                rgpwszSourceURLs: ?[*]?PWSTR,
                rgpwszDestURLs: [*]?PWSTR,
                dwCopyFlags: u32,
                pAuthenticate: ?*IAuthenticate,
                rgdwStatus: [*]u32,
                rgpwszNewURLs: ?[*]?PWSTR,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScopedOperations,
                cRows: usize,
                rgpwszSourceURLs: ?[*]?PWSTR,
                rgpwszDestURLs: [*]?PWSTR,
                dwCopyFlags: u32,
                pAuthenticate: ?*IAuthenticate,
                rgdwStatus: [*]u32,
                rgpwszNewURLs: ?[*]?PWSTR,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScopedOperations,
                cRows: usize,
                rgpwszSourceURLs: ?[*]?PWSTR,
                rgpwszDestURLs: [*]?PWSTR,
                dwMoveFlags: u32,
                pAuthenticate: ?*IAuthenticate,
                rgdwStatus: [*]u32,
                rgpwszNewURLs: ?[*]?PWSTR,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScopedOperations,
                cRows: usize,
                rgpwszSourceURLs: ?[*]?PWSTR,
                rgpwszDestURLs: [*]?PWSTR,
                dwMoveFlags: u32,
                pAuthenticate: ?*IAuthenticate,
                rgdwStatus: [*]u32,
                rgpwszNewURLs: ?[*]?PWSTR,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScopedOperations,
                cRows: usize,
                rgpwszURLs: [*]?PWSTR,
                dwDeleteFlags: u32,
                rgdwStatus: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScopedOperations,
                cRows: usize,
                rgpwszURLs: [*]?PWSTR,
                dwDeleteFlags: u32,
                rgdwStatus: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScopedOperations,
                pUnkOuter: ?*IUnknown,
                pTableID: ?*DBID,
                pIndexID: ?*DBID,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: [*]DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScopedOperations,
                pUnkOuter: ?*IUnknown,
                pTableID: ?*DBID,
                pIndexID: ?*DBID,
                riid: ?*const Guid,
                cPropertySets: u32,
                rgPropertySets: [*]DBPROPSET,
                ppRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBindResource.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScopedOperations_Copy(self: *const T, cRows: usize, rgpwszSourceURLs: ?[*]?PWSTR, rgpwszDestURLs: [*]?PWSTR, dwCopyFlags: u32, pAuthenticate: ?*IAuthenticate, rgdwStatus: [*]u32, rgpwszNewURLs: ?[*]?PWSTR, ppStringsBuffer: ?*?*u16) HRESULT {
                return @as(*const IScopedOperations.VTable, @ptrCast(self.vtable)).Copy(@as(*const IScopedOperations, @ptrCast(self)), cRows, rgpwszSourceURLs, rgpwszDestURLs, dwCopyFlags, pAuthenticate, rgdwStatus, rgpwszNewURLs, ppStringsBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScopedOperations_Move(self: *const T, cRows: usize, rgpwszSourceURLs: ?[*]?PWSTR, rgpwszDestURLs: [*]?PWSTR, dwMoveFlags: u32, pAuthenticate: ?*IAuthenticate, rgdwStatus: [*]u32, rgpwszNewURLs: ?[*]?PWSTR, ppStringsBuffer: ?*?*u16) HRESULT {
                return @as(*const IScopedOperations.VTable, @ptrCast(self.vtable)).Move(@as(*const IScopedOperations, @ptrCast(self)), cRows, rgpwszSourceURLs, rgpwszDestURLs, dwMoveFlags, pAuthenticate, rgdwStatus, rgpwszNewURLs, ppStringsBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScopedOperations_Delete(self: *const T, cRows: usize, rgpwszURLs: [*]?PWSTR, dwDeleteFlags: u32, rgdwStatus: [*]u32) HRESULT {
                return @as(*const IScopedOperations.VTable, @ptrCast(self.vtable)).Delete(@as(*const IScopedOperations, @ptrCast(self)), cRows, rgpwszURLs, dwDeleteFlags, rgdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScopedOperations_OpenRowset(self: *const T, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, pIndexID: ?*DBID, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: [*]DBPROPSET, ppRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IScopedOperations.VTable, @ptrCast(self.vtable)).OpenRowset(@as(*const IScopedOperations, @ptrCast(self)), pUnkOuter, pTableID, pIndexID, riid, cPropertySets, rgPropertySets, ppRowset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateRow_Value = Guid.initString("0c733ab2-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICreateRow = &IID_ICreateRow_Value;
pub const ICreateRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateRow,
                pUnkOuter: ?*IUnknown,
                pwszURL: ?[*:0]const u16,
                dwBindURLFlags: u32,
                rguid: ?*const Guid,
                riid: ?*const Guid,
                pAuthenticate: ?*IAuthenticate,
                pImplSession: ?*DBIMPLICITSESSION,
                pdwBindStatus: ?*u32,
                ppwszNewURL: ?*?PWSTR,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateRow,
                pUnkOuter: ?*IUnknown,
                pwszURL: ?[*:0]const u16,
                dwBindURLFlags: u32,
                rguid: ?*const Guid,
                riid: ?*const Guid,
                pAuthenticate: ?*IAuthenticate,
                pImplSession: ?*DBIMPLICITSESSION,
                pdwBindStatus: ?*u32,
                ppwszNewURL: ?*?PWSTR,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateRow_CreateRow(self: *const T, pUnkOuter: ?*IUnknown, pwszURL: ?[*:0]const u16, dwBindURLFlags: u32, rguid: ?*const Guid, riid: ?*const Guid, pAuthenticate: ?*IAuthenticate, pImplSession: ?*DBIMPLICITSESSION, pdwBindStatus: ?*u32, ppwszNewURL: ?*?PWSTR, ppUnk: ?*?*IUnknown) HRESULT {
                return @as(*const ICreateRow.VTable, @ptrCast(self.vtable)).CreateRow(@as(*const ICreateRow, @ptrCast(self)), pUnkOuter, pwszURL, dwBindURLFlags, rguid, riid, pAuthenticate, pImplSession, pdwBindStatus, ppwszNewURL, ppUnk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBBinderProperties_Value = Guid.initString("0c733ab3-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBBinderProperties = &IID_IDBBinderProperties_Value;
pub const IDBBinderProperties = extern struct {
    pub const VTable = extern struct {
        base: IDBProperties.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBBinderProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBBinderProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDBProperties.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBBinderProperties_Reset(self: *const T) HRESULT {
                return @as(*const IDBBinderProperties.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDBBinderProperties, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnsInfo2_Value = Guid.initString("0c733ab8-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IColumnsInfo2 = &IID_IColumnsInfo2_Value;
pub const IColumnsInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IColumnsInfo.VTable,
        GetRestrictedColumnInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnsInfo2,
                cColumnIDMasks: usize,
                rgColumnIDMasks: [*]const DBID,
                dwFlags: u32,
                pcColumns: ?*usize,
                prgColumnIDs: ?*?*DBID,
                prgColumnInfo: ?*?*DBCOLUMNINFO,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnsInfo2,
                cColumnIDMasks: usize,
                rgColumnIDMasks: [*]const DBID,
                dwFlags: u32,
                pcColumns: ?*usize,
                prgColumnIDs: ?*?*DBID,
                prgColumnInfo: ?*?*DBCOLUMNINFO,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IColumnsInfo.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnsInfo2_GetRestrictedColumnInfo(self: *const T, cColumnIDMasks: usize, rgColumnIDMasks: [*]const DBID, dwFlags: u32, pcColumns: ?*usize, prgColumnIDs: ?*?*DBID, prgColumnInfo: ?*?*DBCOLUMNINFO, ppStringsBuffer: ?*?*u16) HRESULT {
                return @as(*const IColumnsInfo2.VTable, @ptrCast(self.vtable)).GetRestrictedColumnInfo(@as(*const IColumnsInfo2, @ptrCast(self)), cColumnIDMasks, rgColumnIDMasks, dwFlags, pcColumns, prgColumnIDs, prgColumnInfo, ppStringsBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRegisterProvider_Value = Guid.initString("0c733ab9-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRegisterProvider = &IID_IRegisterProvider_Value;
pub const IRegisterProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetURLMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRegisterProvider,
                pwszURL: ?[*:0]const u16,
                dwReserved: usize,
                pclsidProvider: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRegisterProvider,
                pwszURL: ?[*:0]const u16,
                dwReserved: usize,
                pclsidProvider: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetURLMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRegisterProvider,
                pwszURL: ?[*:0]const u16,
                dwReserved: usize,
                rclsidProvider: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRegisterProvider,
                pwszURL: ?[*:0]const u16,
                dwReserved: usize,
                rclsidProvider: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRegisterProvider,
                pwszURL: ?[*:0]const u16,
                dwReserved: usize,
                rclsidProvider: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRegisterProvider,
                pwszURL: ?[*:0]const u16,
                dwReserved: usize,
                rclsidProvider: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRegisterProvider_GetURLMapping(self: *const T, pwszURL: ?[*:0]const u16, dwReserved: usize, pclsidProvider: ?*Guid) HRESULT {
                return @as(*const IRegisterProvider.VTable, @ptrCast(self.vtable)).GetURLMapping(@as(*const IRegisterProvider, @ptrCast(self)), pwszURL, dwReserved, pclsidProvider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRegisterProvider_SetURLMapping(self: *const T, pwszURL: ?[*:0]const u16, dwReserved: usize, rclsidProvider: ?*const Guid) HRESULT {
                return @as(*const IRegisterProvider.VTable, @ptrCast(self.vtable)).SetURLMapping(@as(*const IRegisterProvider, @ptrCast(self)), pwszURL, dwReserved, rclsidProvider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRegisterProvider_UnregisterProvider(self: *const T, pwszURL: ?[*:0]const u16, dwReserved: usize, rclsidProvider: ?*const Guid) HRESULT {
                return @as(*const IRegisterProvider.VTable, @ptrCast(self.vtable)).UnregisterProvider(@as(*const IRegisterProvider, @ptrCast(self)), pwszURL, dwReserved, rclsidProvider);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetSession_Value = Guid.initString("0c733aba-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetSession = &IID_IGetSession_Value;
pub const IGetSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGetSession,
                riid: ?*const Guid,
                ppSession: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGetSession,
                riid: ?*const Guid,
                ppSession: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGetSession_GetSession(self: *const T, riid: ?*const Guid, ppSession: ?*?*IUnknown) HRESULT {
                return @as(*const IGetSession.VTable, @ptrCast(self.vtable)).GetSession(@as(*const IGetSession, @ptrCast(self)), riid, ppSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetSourceRow_Value = Guid.initString("0c733abb-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetSourceRow = &IID_IGetSourceRow_Value;
pub const IGetSourceRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGetSourceRow,
                riid: ?*const Guid,
                ppRow: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGetSourceRow,
                riid: ?*const Guid,
                ppRow: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGetSourceRow_GetSourceRow(self: *const T, riid: ?*const Guid, ppRow: ?*?*IUnknown) HRESULT {
                return @as(*const IGetSourceRow.VTable, @ptrCast(self.vtable)).GetSourceRow(@as(*const IGetSourceRow, @ptrCast(self)), riid, ppRow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetCurrentIndex_Value = Guid.initString("0c733abd-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetCurrentIndex = &IID_IRowsetCurrentIndex_Value;
pub const IRowsetCurrentIndex = extern struct {
    pub const VTable = extern struct {
        base: IRowsetIndex.VTable,
        GetIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetCurrentIndex,
                ppIndexID: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetCurrentIndex,
                ppIndexID: ?*?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetCurrentIndex,
                pIndexID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetCurrentIndex,
                pIndexID: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowsetIndex.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetCurrentIndex_GetIndex(self: *const T, ppIndexID: ?*?*DBID) HRESULT {
                return @as(*const IRowsetCurrentIndex.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const IRowsetCurrentIndex, @ptrCast(self)), ppIndexID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetCurrentIndex_SetIndex(self: *const T, pIndexID: ?*DBID) HRESULT {
                return @as(*const IRowsetCurrentIndex.VTable, @ptrCast(self.vtable)).SetIndex(@as(*const IRowsetCurrentIndex, @ptrCast(self)), pIndexID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandStream_Value = Guid.initString("0c733abf-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandStream = &IID_ICommandStream_Value;
pub const ICommandStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCommandStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandStream,
                piid: ?*Guid,
                pguidDialect: ?*Guid,
                ppCommandStream: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandStream,
                piid: ?*Guid,
                pguidDialect: ?*Guid,
                ppCommandStream: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommandStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandStream,
                riid: ?*const Guid,
                rguidDialect: ?*const Guid,
                pCommandStream: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandStream,
                riid: ?*const Guid,
                rguidDialect: ?*const Guid,
                pCommandStream: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandStream_GetCommandStream(self: *const T, piid: ?*Guid, pguidDialect: ?*Guid, ppCommandStream: ?*?*IUnknown) HRESULT {
                return @as(*const ICommandStream.VTable, @ptrCast(self.vtable)).GetCommandStream(@as(*const ICommandStream, @ptrCast(self)), piid, pguidDialect, ppCommandStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandStream_SetCommandStream(self: *const T, riid: ?*const Guid, rguidDialect: ?*const Guid, pCommandStream: ?*IUnknown) HRESULT {
                return @as(*const ICommandStream.VTable, @ptrCast(self.vtable)).SetCommandStream(@as(*const ICommandStream, @ptrCast(self)), riid, rguidDialect, pCommandStream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetBookmark_Value = Guid.initString("0c733ac2-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetBookmark = &IID_IRowsetBookmark_Value;
pub const IRowsetBookmark = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PositionOnBookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetBookmark,
                hChapter: usize,
                cbBookmark: usize,
                // TODO: what to do with BytesParamIndex 1?
                pBookmark: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetBookmark,
                hChapter: usize,
                cbBookmark: usize,
                // TODO: what to do with BytesParamIndex 1?
                pBookmark: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetBookmark_PositionOnBookmark(self: *const T, hChapter: usize, cbBookmark: usize, pBookmark: ?*const u8) HRESULT {
                return @as(*const IRowsetBookmark.VTable, @ptrCast(self.vtable)).PositionOnBookmark(@as(*const IRowsetBookmark, @ptrCast(self)), hChapter, cbBookmark, pBookmark);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_QueryParser_Value = Guid.initString("b72f8fd8-0fab-4dd9-bdbf-245a6ce1485b");
pub const CLSID_QueryParser = &CLSID_QueryParser_Value;

const CLSID_NegationCondition_Value = Guid.initString("8de9c74c-605a-4acd-bee3-2b222aa2d23d");
pub const CLSID_NegationCondition = &CLSID_NegationCondition_Value;

const CLSID_CompoundCondition_Value = Guid.initString("116f8d13-101e-4fa5-84d4-ff8279381935");
pub const CLSID_CompoundCondition = &CLSID_CompoundCondition_Value;

const CLSID_LeafCondition_Value = Guid.initString("52f15c89-5a17-48e1-bbcd-46a3f89c7cc2");
pub const CLSID_LeafCondition = &CLSID_LeafCondition_Value;

const CLSID_ConditionFactory_Value = Guid.initString("e03e85b0-7be3-4000-ba98-6c13de9fa486");
pub const CLSID_ConditionFactory = &CLSID_ConditionFactory_Value;

const CLSID_Interval_Value = Guid.initString("d957171f-4bf9-4de2-bcd5-c70a7ca55836");
pub const CLSID_Interval = &CLSID_Interval_Value;

const CLSID_QueryParserManager_Value = Guid.initString("5088b39a-29b4-4d9d-8245-4ee289222f66");
pub const CLSID_QueryParserManager = &CLSID_QueryParserManager_Value;

pub const STRUCTURED_QUERY_SYNTAX = enum(i32) {
    NO_SYNTAX = 0,
    ADVANCED_QUERY_SYNTAX = 1,
    NATURAL_QUERY_SYNTAX = 2,
};
pub const SQS_NO_SYNTAX = STRUCTURED_QUERY_SYNTAX.NO_SYNTAX;
pub const SQS_ADVANCED_QUERY_SYNTAX = STRUCTURED_QUERY_SYNTAX.ADVANCED_QUERY_SYNTAX;
pub const SQS_NATURAL_QUERY_SYNTAX = STRUCTURED_QUERY_SYNTAX.NATURAL_QUERY_SYNTAX;

pub const STRUCTURED_QUERY_SINGLE_OPTION = enum(i32) {
    SCHEMA = 0,
    LOCALE_WORD_BREAKING = 1,
    WORD_BREAKER = 2,
    NATURAL_SYNTAX = 3,
    AUTOMATIC_WILDCARD = 4,
    TRACE_LEVEL = 5,
    LANGUAGE_KEYWORDS = 6,
    SYNTAX = 7,
    TIME_ZONE = 8,
    IMPLICIT_CONNECTOR = 9,
    CONNECTOR_CASE = 10,
};
pub const SQSO_SCHEMA = STRUCTURED_QUERY_SINGLE_OPTION.SCHEMA;
pub const SQSO_LOCALE_WORD_BREAKING = STRUCTURED_QUERY_SINGLE_OPTION.LOCALE_WORD_BREAKING;
pub const SQSO_WORD_BREAKER = STRUCTURED_QUERY_SINGLE_OPTION.WORD_BREAKER;
pub const SQSO_NATURAL_SYNTAX = STRUCTURED_QUERY_SINGLE_OPTION.NATURAL_SYNTAX;
pub const SQSO_AUTOMATIC_WILDCARD = STRUCTURED_QUERY_SINGLE_OPTION.AUTOMATIC_WILDCARD;
pub const SQSO_TRACE_LEVEL = STRUCTURED_QUERY_SINGLE_OPTION.TRACE_LEVEL;
pub const SQSO_LANGUAGE_KEYWORDS = STRUCTURED_QUERY_SINGLE_OPTION.LANGUAGE_KEYWORDS;
pub const SQSO_SYNTAX = STRUCTURED_QUERY_SINGLE_OPTION.SYNTAX;
pub const SQSO_TIME_ZONE = STRUCTURED_QUERY_SINGLE_OPTION.TIME_ZONE;
pub const SQSO_IMPLICIT_CONNECTOR = STRUCTURED_QUERY_SINGLE_OPTION.IMPLICIT_CONNECTOR;
pub const SQSO_CONNECTOR_CASE = STRUCTURED_QUERY_SINGLE_OPTION.CONNECTOR_CASE;

pub const STRUCTURED_QUERY_MULTIOPTION = enum(i32) {
    VIRTUAL_PROPERTY = 0,
    DEFAULT_PROPERTY = 1,
    GENERATOR_FOR_TYPE = 2,
    MAP_PROPERTY = 3,
};
pub const SQMO_VIRTUAL_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.VIRTUAL_PROPERTY;
pub const SQMO_DEFAULT_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.DEFAULT_PROPERTY;
pub const SQMO_GENERATOR_FOR_TYPE = STRUCTURED_QUERY_MULTIOPTION.GENERATOR_FOR_TYPE;
pub const SQMO_MAP_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.MAP_PROPERTY;

pub const STRUCTURED_QUERY_PARSE_ERROR = enum(i32) {
    NONE = 0,
    EXTRA_OPENING_PARENTHESIS = 1,
    EXTRA_CLOSING_PARENTHESIS = 2,
    IGNORED_MODIFIER = 3,
    IGNORED_CONNECTOR = 4,
    IGNORED_KEYWORD = 5,
    UNHANDLED = 6,
};
pub const SQPE_NONE = STRUCTURED_QUERY_PARSE_ERROR.NONE;
pub const SQPE_EXTRA_OPENING_PARENTHESIS = STRUCTURED_QUERY_PARSE_ERROR.EXTRA_OPENING_PARENTHESIS;
pub const SQPE_EXTRA_CLOSING_PARENTHESIS = STRUCTURED_QUERY_PARSE_ERROR.EXTRA_CLOSING_PARENTHESIS;
pub const SQPE_IGNORED_MODIFIER = STRUCTURED_QUERY_PARSE_ERROR.IGNORED_MODIFIER;
pub const SQPE_IGNORED_CONNECTOR = STRUCTURED_QUERY_PARSE_ERROR.IGNORED_CONNECTOR;
pub const SQPE_IGNORED_KEYWORD = STRUCTURED_QUERY_PARSE_ERROR.IGNORED_KEYWORD;
pub const SQPE_UNHANDLED = STRUCTURED_QUERY_PARSE_ERROR.UNHANDLED;

pub const STRUCTURED_QUERY_RESOLVE_OPTION = enum(u32) {
    DEFAULT = 0,
    DONT_RESOLVE_DATETIME = 1,
    ALWAYS_ONE_INTERVAL = 2,
    DONT_SIMPLIFY_CONDITION_TREES = 4,
    DONT_MAP_RELATIONS = 8,
    DONT_RESOLVE_RANGES = 16,
    DONT_REMOVE_UNRESTRICTED_KEYWORDS = 32,
    DONT_SPLIT_WORDS = 64,
    IGNORE_PHRASE_ORDER = 128,
    ADD_VALUE_TYPE_FOR_PLAIN_VALUES = 256,
    ADD_ROBUST_ITEM_NAME = 512,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        DONT_RESOLVE_DATETIME: u1 = 0,
        ALWAYS_ONE_INTERVAL: u1 = 0,
        DONT_SIMPLIFY_CONDITION_TREES: u1 = 0,
        DONT_MAP_RELATIONS: u1 = 0,
        DONT_RESOLVE_RANGES: u1 = 0,
        DONT_REMOVE_UNRESTRICTED_KEYWORDS: u1 = 0,
        DONT_SPLIT_WORDS: u1 = 0,
        IGNORE_PHRASE_ORDER: u1 = 0,
        ADD_VALUE_TYPE_FOR_PLAIN_VALUES: u1 = 0,
        ADD_ROBUST_ITEM_NAME: u1 = 0,
    }) STRUCTURED_QUERY_RESOLVE_OPTION {
        return @as(STRUCTURED_QUERY_RESOLVE_OPTION, @enumFromInt((if (o.DEFAULT == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DEFAULT) else 0) | (if (o.DONT_RESOLVE_DATETIME == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_RESOLVE_DATETIME) else 0) | (if (o.ALWAYS_ONE_INTERVAL == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.ALWAYS_ONE_INTERVAL) else 0) | (if (o.DONT_SIMPLIFY_CONDITION_TREES == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_SIMPLIFY_CONDITION_TREES) else 0) | (if (o.DONT_MAP_RELATIONS == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_MAP_RELATIONS) else 0) | (if (o.DONT_RESOLVE_RANGES == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_RESOLVE_RANGES) else 0) | (if (o.DONT_REMOVE_UNRESTRICTED_KEYWORDS == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_REMOVE_UNRESTRICTED_KEYWORDS) else 0) | (if (o.DONT_SPLIT_WORDS == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_SPLIT_WORDS) else 0) | (if (o.IGNORE_PHRASE_ORDER == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.IGNORE_PHRASE_ORDER) else 0) | (if (o.ADD_VALUE_TYPE_FOR_PLAIN_VALUES == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.ADD_VALUE_TYPE_FOR_PLAIN_VALUES) else 0) | (if (o.ADD_ROBUST_ITEM_NAME == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.ADD_ROBUST_ITEM_NAME) else 0)));
    }
};
pub const SQRO_DEFAULT = STRUCTURED_QUERY_RESOLVE_OPTION.DEFAULT;
pub const SQRO_DONT_RESOLVE_DATETIME = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_RESOLVE_DATETIME;
pub const SQRO_ALWAYS_ONE_INTERVAL = STRUCTURED_QUERY_RESOLVE_OPTION.ALWAYS_ONE_INTERVAL;
pub const SQRO_DONT_SIMPLIFY_CONDITION_TREES = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_SIMPLIFY_CONDITION_TREES;
pub const SQRO_DONT_MAP_RELATIONS = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_MAP_RELATIONS;
pub const SQRO_DONT_RESOLVE_RANGES = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_RESOLVE_RANGES;
pub const SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_REMOVE_UNRESTRICTED_KEYWORDS;
pub const SQRO_DONT_SPLIT_WORDS = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_SPLIT_WORDS;
pub const SQRO_IGNORE_PHRASE_ORDER = STRUCTURED_QUERY_RESOLVE_OPTION.IGNORE_PHRASE_ORDER;
pub const SQRO_ADD_VALUE_TYPE_FOR_PLAIN_VALUES = STRUCTURED_QUERY_RESOLVE_OPTION.ADD_VALUE_TYPE_FOR_PLAIN_VALUES;
pub const SQRO_ADD_ROBUST_ITEM_NAME = STRUCTURED_QUERY_RESOLVE_OPTION.ADD_ROBUST_ITEM_NAME;

pub const CASE_REQUIREMENT = enum(i32) {
    ANY = 0,
    UPPER_IF_AQS = 1,
};
pub const CASE_REQUIREMENT_ANY = CASE_REQUIREMENT.ANY;
pub const CASE_REQUIREMENT_UPPER_IF_AQS = CASE_REQUIREMENT.UPPER_IF_AQS;

pub const INTERVAL_LIMIT_KIND = enum(i32) {
    EXPLICIT_INCLUDED = 0,
    EXPLICIT_EXCLUDED = 1,
    NEGATIVE_INFINITY = 2,
    POSITIVE_INFINITY = 3,
};
pub const ILK_EXPLICIT_INCLUDED = INTERVAL_LIMIT_KIND.EXPLICIT_INCLUDED;
pub const ILK_EXPLICIT_EXCLUDED = INTERVAL_LIMIT_KIND.EXPLICIT_EXCLUDED;
pub const ILK_NEGATIVE_INFINITY = INTERVAL_LIMIT_KIND.NEGATIVE_INFINITY;
pub const ILK_POSITIVE_INFINITY = INTERVAL_LIMIT_KIND.POSITIVE_INFINITY;

pub const QUERY_PARSER_MANAGER_OPTION = enum(i32) {
    SCHEMA_BINARY_NAME = 0,
    PRELOCALIZED_SCHEMA_BINARY_PATH = 1,
    UNLOCALIZED_SCHEMA_BINARY_PATH = 2,
    LOCALIZED_SCHEMA_BINARY_PATH = 3,
    APPEND_LCID_TO_LOCALIZED_PATH = 4,
    LOCALIZER_SUPPORT = 5,
};
pub const QPMO_SCHEMA_BINARY_NAME = QUERY_PARSER_MANAGER_OPTION.SCHEMA_BINARY_NAME;
pub const QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.PRELOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.UNLOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_LOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.LOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_APPEND_LCID_TO_LOCALIZED_PATH = QUERY_PARSER_MANAGER_OPTION.APPEND_LCID_TO_LOCALIZED_PATH;
pub const QPMO_LOCALIZER_SUPPORT = QUERY_PARSER_MANAGER_OPTION.LOCALIZER_SUPPORT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryParser_Value = Guid.initString("2ebdee67-3505-43f8-9946-ea44abc8e5b0");
pub const IID_IQueryParser = &IID_IQueryParser_Value;
pub const IQueryParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Parse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParser,
                pszInputString: ?[*:0]const u16,
                pCustomProperties: ?*IEnumUnknown,
                ppSolution: ?*?*IQuerySolution,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParser,
                pszInputString: ?[*:0]const u16,
                pCustomProperties: ?*IEnumUnknown,
                ppSolution: ?*?*IQuerySolution,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParser,
                option: STRUCTURED_QUERY_SINGLE_OPTION,
                pOptionValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParser,
                option: STRUCTURED_QUERY_SINGLE_OPTION,
                pOptionValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParser,
                option: STRUCTURED_QUERY_SINGLE_OPTION,
                pOptionValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParser,
                option: STRUCTURED_QUERY_SINGLE_OPTION,
                pOptionValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMultiOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParser,
                option: STRUCTURED_QUERY_MULTIOPTION,
                pszOptionKey: ?[*:0]const u16,
                pOptionValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParser,
                option: STRUCTURED_QUERY_MULTIOPTION,
                pszOptionKey: ?[*:0]const u16,
                pOptionValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSchemaProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParser,
                ppSchemaProvider: ?*?*ISchemaProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParser,
                ppSchemaProvider: ?*?*ISchemaProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestateToString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParser,
                pCondition: ?*ICondition,
                fUseEnglish: BOOL,
                ppszQueryString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParser,
                pCondition: ?*ICondition,
                fUseEnglish: BOOL,
                ppszQueryString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParsePropertyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParser,
                pszPropertyName: ?[*:0]const u16,
                pszInputString: ?[*:0]const u16,
                ppSolution: ?*?*IQuerySolution,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParser,
                pszPropertyName: ?[*:0]const u16,
                pszInputString: ?[*:0]const u16,
                ppSolution: ?*?*IQuerySolution,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestatePropertyValueToString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParser,
                pCondition: ?*ICondition,
                fUseEnglish: BOOL,
                ppszPropertyName: ?*?PWSTR,
                ppszQueryString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParser,
                pCondition: ?*ICondition,
                fUseEnglish: BOOL,
                ppszPropertyName: ?*?PWSTR,
                ppszQueryString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParser_Parse(self: *const T, pszInputString: ?[*:0]const u16, pCustomProperties: ?*IEnumUnknown, ppSolution: ?*?*IQuerySolution) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).Parse(@as(*const IQueryParser, @ptrCast(self)), pszInputString, pCustomProperties, ppSolution);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParser_SetOption(self: *const T, option: STRUCTURED_QUERY_SINGLE_OPTION, pOptionValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).SetOption(@as(*const IQueryParser, @ptrCast(self)), option, pOptionValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParser_GetOption(self: *const T, option: STRUCTURED_QUERY_SINGLE_OPTION, pOptionValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).GetOption(@as(*const IQueryParser, @ptrCast(self)), option, pOptionValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParser_SetMultiOption(self: *const T, option: STRUCTURED_QUERY_MULTIOPTION, pszOptionKey: ?[*:0]const u16, pOptionValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).SetMultiOption(@as(*const IQueryParser, @ptrCast(self)), option, pszOptionKey, pOptionValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParser_GetSchemaProvider(self: *const T, ppSchemaProvider: ?*?*ISchemaProvider) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).GetSchemaProvider(@as(*const IQueryParser, @ptrCast(self)), ppSchemaProvider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParser_RestateToString(self: *const T, pCondition: ?*ICondition, fUseEnglish: BOOL, ppszQueryString: ?*?PWSTR) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).RestateToString(@as(*const IQueryParser, @ptrCast(self)), pCondition, fUseEnglish, ppszQueryString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParser_ParsePropertyValue(self: *const T, pszPropertyName: ?[*:0]const u16, pszInputString: ?[*:0]const u16, ppSolution: ?*?*IQuerySolution) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).ParsePropertyValue(@as(*const IQueryParser, @ptrCast(self)), pszPropertyName, pszInputString, ppSolution);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParser_RestatePropertyValueToString(self: *const T, pCondition: ?*ICondition, fUseEnglish: BOOL, ppszPropertyName: ?*?PWSTR, ppszQueryString: ?*?PWSTR) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).RestatePropertyValueToString(@as(*const IQueryParser, @ptrCast(self)), pCondition, fUseEnglish, ppszPropertyName, ppszQueryString);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConditionFactory_Value = Guid.initString("a5efe073-b16f-474f-9f3e-9f8b497a3e08");
pub const IID_IConditionFactory = &IID_IConditionFactory_Value;
pub const IConditionFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MakeNot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory,
                pcSub: ?*ICondition,
                fSimplify: BOOL,
                ppcResult: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory,
                pcSub: ?*ICondition,
                fSimplify: BOOL,
                ppcResult: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MakeAndOr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory,
                ct: CONDITION_TYPE,
                peuSubs: ?*IEnumUnknown,
                fSimplify: BOOL,
                ppcResult: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory,
                ct: CONDITION_TYPE,
                peuSubs: ?*IEnumUnknown,
                fSimplify: BOOL,
                ppcResult: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MakeLeaf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory,
                pszPropertyName: ?[*:0]const u16,
                cop: CONDITION_OPERATION,
                pszValueType: ?[*:0]const u16,
                ppropvar: ?*const PROPVARIANT,
                pPropertyNameTerm: ?*IRichChunk,
                pOperationTerm: ?*IRichChunk,
                pValueTerm: ?*IRichChunk,
                fExpand: BOOL,
                ppcResult: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory,
                pszPropertyName: ?[*:0]const u16,
                cop: CONDITION_OPERATION,
                pszValueType: ?[*:0]const u16,
                ppropvar: ?*const PROPVARIANT,
                pPropertyNameTerm: ?*IRichChunk,
                pOperationTerm: ?*IRichChunk,
                pValueTerm: ?*IRichChunk,
                fExpand: BOOL,
                ppcResult: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resolve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory,
                pc: ?*ICondition,
                sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
                pstReferenceTime: ?*const SYSTEMTIME,
                ppcResolved: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory,
                pc: ?*ICondition,
                sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
                pstReferenceTime: ?*const SYSTEMTIME,
                ppcResolved: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory_MakeNot(self: *const T, pcSub: ?*ICondition, fSimplify: BOOL, ppcResult: ?*?*ICondition) HRESULT {
                return @as(*const IConditionFactory.VTable, @ptrCast(self.vtable)).MakeNot(@as(*const IConditionFactory, @ptrCast(self)), pcSub, fSimplify, ppcResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory_MakeAndOr(self: *const T, ct: CONDITION_TYPE, peuSubs: ?*IEnumUnknown, fSimplify: BOOL, ppcResult: ?*?*ICondition) HRESULT {
                return @as(*const IConditionFactory.VTable, @ptrCast(self.vtable)).MakeAndOr(@as(*const IConditionFactory, @ptrCast(self)), ct, peuSubs, fSimplify, ppcResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory_MakeLeaf(self: *const T, pszPropertyName: ?[*:0]const u16, cop: CONDITION_OPERATION, pszValueType: ?[*:0]const u16, ppropvar: ?*const PROPVARIANT, pPropertyNameTerm: ?*IRichChunk, pOperationTerm: ?*IRichChunk, pValueTerm: ?*IRichChunk, fExpand: BOOL, ppcResult: ?*?*ICondition) HRESULT {
                return @as(*const IConditionFactory.VTable, @ptrCast(self.vtable)).MakeLeaf(@as(*const IConditionFactory, @ptrCast(self)), pszPropertyName, cop, pszValueType, ppropvar, pPropertyNameTerm, pOperationTerm, pValueTerm, fExpand, ppcResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory_Resolve(self: *const T, pc: ?*ICondition, sqro: STRUCTURED_QUERY_RESOLVE_OPTION, pstReferenceTime: ?*const SYSTEMTIME, ppcResolved: ?*?*ICondition) HRESULT {
                return @as(*const IConditionFactory.VTable, @ptrCast(self.vtable)).Resolve(@as(*const IConditionFactory, @ptrCast(self)), pc, sqro, pstReferenceTime, ppcResolved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQuerySolution_Value = Guid.initString("d6ebc66b-8921-4193-afdd-a1789fb7ff57");
pub const IID_IQuerySolution = &IID_IQuerySolution_Value;
pub const IQuerySolution = extern struct {
    pub const VTable = extern struct {
        base: IConditionFactory.VTable,
        GetQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQuerySolution,
                ppQueryNode: ?*?*ICondition,
                ppMainType: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQuerySolution,
                ppQueryNode: ?*?*ICondition,
                ppMainType: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQuerySolution,
                riid: ?*const Guid,
                ppParseErrors: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQuerySolution,
                riid: ?*const Guid,
                ppParseErrors: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLexicalData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQuerySolution,
                ppszInputString: ?*?PWSTR,
                ppTokens: ?*?*ITokenCollection,
                plcid: ?*u32,
                ppWordBreaker: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQuerySolution,
                ppszInputString: ?*?PWSTR,
                ppTokens: ?*?*ITokenCollection,
                plcid: ?*u32,
                ppWordBreaker: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IConditionFactory.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQuerySolution_GetQuery(self: *const T, ppQueryNode: ?*?*ICondition, ppMainType: ?*?*IEntity) HRESULT {
                return @as(*const IQuerySolution.VTable, @ptrCast(self.vtable)).GetQuery(@as(*const IQuerySolution, @ptrCast(self)), ppQueryNode, ppMainType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQuerySolution_GetErrors(self: *const T, riid: ?*const Guid, ppParseErrors: ?*?*anyopaque) HRESULT {
                return @as(*const IQuerySolution.VTable, @ptrCast(self.vtable)).GetErrors(@as(*const IQuerySolution, @ptrCast(self)), riid, ppParseErrors);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQuerySolution_GetLexicalData(self: *const T, ppszInputString: ?*?PWSTR, ppTokens: ?*?*ITokenCollection, plcid: ?*u32, ppWordBreaker: ?*?*IUnknown) HRESULT {
                return @as(*const IQuerySolution.VTable, @ptrCast(self.vtable)).GetLexicalData(@as(*const IQuerySolution, @ptrCast(self)), ppszInputString, ppTokens, plcid, ppWordBreaker);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CONDITION_CREATION_OPTIONS = enum(u32) {
    DEFAULT = 0,
    // NONE = 0, this enum value conflicts with DEFAULT
    SIMPLIFY = 1,
    VECTOR_AND = 2,
    VECTOR_OR = 4,
    VECTOR_LEAF = 8,
    USE_CONTENT_LOCALE = 16,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        SIMPLIFY: u1 = 0,
        VECTOR_AND: u1 = 0,
        VECTOR_OR: u1 = 0,
        VECTOR_LEAF: u1 = 0,
        USE_CONTENT_LOCALE: u1 = 0,
    }) CONDITION_CREATION_OPTIONS {
        return @as(CONDITION_CREATION_OPTIONS, @enumFromInt((if (o.DEFAULT == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.DEFAULT) else 0) | (if (o.SIMPLIFY == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.SIMPLIFY) else 0) | (if (o.VECTOR_AND == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.VECTOR_AND) else 0) | (if (o.VECTOR_OR == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.VECTOR_OR) else 0) | (if (o.VECTOR_LEAF == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.VECTOR_LEAF) else 0) | (if (o.USE_CONTENT_LOCALE == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.USE_CONTENT_LOCALE) else 0)));
    }
};
pub const CONDITION_CREATION_DEFAULT = CONDITION_CREATION_OPTIONS.DEFAULT;
pub const CONDITION_CREATION_NONE = CONDITION_CREATION_OPTIONS.DEFAULT;
pub const CONDITION_CREATION_SIMPLIFY = CONDITION_CREATION_OPTIONS.SIMPLIFY;
pub const CONDITION_CREATION_VECTOR_AND = CONDITION_CREATION_OPTIONS.VECTOR_AND;
pub const CONDITION_CREATION_VECTOR_OR = CONDITION_CREATION_OPTIONS.VECTOR_OR;
pub const CONDITION_CREATION_VECTOR_LEAF = CONDITION_CREATION_OPTIONS.VECTOR_LEAF;
pub const CONDITION_CREATION_USE_CONTENT_LOCALE = CONDITION_CREATION_OPTIONS.USE_CONTENT_LOCALE;

// TODO: this type is limited to platform 'windows6.1'
const IID_IConditionFactory2_Value = Guid.initString("71d222e1-432f-429e-8c13-b6dafde5077a");
pub const IID_IConditionFactory2 = &IID_IConditionFactory2_Value;
pub const IConditionFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IConditionFactory.VTable,
        CreateTrueFalse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory2,
                fVal: BOOL,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory2,
                fVal: BOOL,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNegation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory2,
                pcSub: ?*ICondition,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory2,
                pcSub: ?*ICondition,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCompoundFromObjectArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory2,
                ct: CONDITION_TYPE,
                poaSubs: ?*IObjectArray,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory2,
                ct: CONDITION_TYPE,
                poaSubs: ?*IObjectArray,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCompoundFromArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory2,
                ct: CONDITION_TYPE,
                ppcondSubs: [*]?*ICondition,
                cSubs: u32,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory2,
                ct: CONDITION_TYPE,
                ppcondSubs: [*]?*ICondition,
                cSubs: u32,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStringLeaf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory2,
                propkey: ?*const PROPERTYKEY,
                cop: CONDITION_OPERATION,
                pszValue: ?[*:0]const u16,
                pszLocaleName: ?[*:0]const u16,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory2,
                propkey: ?*const PROPERTYKEY,
                cop: CONDITION_OPERATION,
                pszValue: ?[*:0]const u16,
                pszLocaleName: ?[*:0]const u16,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateIntegerLeaf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory2,
                propkey: ?*const PROPERTYKEY,
                cop: CONDITION_OPERATION,
                lValue: i32,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory2,
                propkey: ?*const PROPERTYKEY,
                cop: CONDITION_OPERATION,
                lValue: i32,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBooleanLeaf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory2,
                propkey: ?*const PROPERTYKEY,
                cop: CONDITION_OPERATION,
                fValue: BOOL,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory2,
                propkey: ?*const PROPERTYKEY,
                cop: CONDITION_OPERATION,
                fValue: BOOL,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLeaf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory2,
                propkey: ?*const PROPERTYKEY,
                cop: CONDITION_OPERATION,
                propvar: ?*const PROPVARIANT,
                pszSemanticType: ?[*:0]const u16,
                pszLocaleName: ?[*:0]const u16,
                pPropertyNameTerm: ?*IRichChunk,
                pOperationTerm: ?*IRichChunk,
                pValueTerm: ?*IRichChunk,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory2,
                propkey: ?*const PROPERTYKEY,
                cop: CONDITION_OPERATION,
                propvar: ?*const PROPVARIANT,
                pszSemanticType: ?[*:0]const u16,
                pszLocaleName: ?[*:0]const u16,
                pPropertyNameTerm: ?*IRichChunk,
                pOperationTerm: ?*IRichChunk,
                pValueTerm: ?*IRichChunk,
                cco: CONDITION_CREATION_OPTIONS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResolveCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionFactory2,
                pc: ?*ICondition,
                sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
                pstReferenceTime: ?*const SYSTEMTIME,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionFactory2,
                pc: ?*ICondition,
                sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
                pstReferenceTime: ?*const SYSTEMTIME,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IConditionFactory.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory2_CreateTrueFalse(self: *const T, fVal: BOOL, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateTrueFalse(@as(*const IConditionFactory2, @ptrCast(self)), fVal, cco, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory2_CreateNegation(self: *const T, pcSub: ?*ICondition, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateNegation(@as(*const IConditionFactory2, @ptrCast(self)), pcSub, cco, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory2_CreateCompoundFromObjectArray(self: *const T, ct: CONDITION_TYPE, poaSubs: ?*IObjectArray, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateCompoundFromObjectArray(@as(*const IConditionFactory2, @ptrCast(self)), ct, poaSubs, cco, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory2_CreateCompoundFromArray(self: *const T, ct: CONDITION_TYPE, ppcondSubs: [*]?*ICondition, cSubs: u32, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateCompoundFromArray(@as(*const IConditionFactory2, @ptrCast(self)), ct, ppcondSubs, cSubs, cco, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory2_CreateStringLeaf(self: *const T, propkey: ?*const PROPERTYKEY, cop: CONDITION_OPERATION, pszValue: ?[*:0]const u16, pszLocaleName: ?[*:0]const u16, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateStringLeaf(@as(*const IConditionFactory2, @ptrCast(self)), propkey, cop, pszValue, pszLocaleName, cco, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory2_CreateIntegerLeaf(self: *const T, propkey: ?*const PROPERTYKEY, cop: CONDITION_OPERATION, lValue: i32, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateIntegerLeaf(@as(*const IConditionFactory2, @ptrCast(self)), propkey, cop, lValue, cco, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory2_CreateBooleanLeaf(self: *const T, propkey: ?*const PROPERTYKEY, cop: CONDITION_OPERATION, fValue: BOOL, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateBooleanLeaf(@as(*const IConditionFactory2, @ptrCast(self)), propkey, cop, fValue, cco, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory2_CreateLeaf(self: *const T, propkey: ?*const PROPERTYKEY, cop: CONDITION_OPERATION, propvar: ?*const PROPVARIANT, pszSemanticType: ?[*:0]const u16, pszLocaleName: ?[*:0]const u16, pPropertyNameTerm: ?*IRichChunk, pOperationTerm: ?*IRichChunk, pValueTerm: ?*IRichChunk, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateLeaf(@as(*const IConditionFactory2, @ptrCast(self)), propkey, cop, propvar, pszSemanticType, pszLocaleName, pPropertyNameTerm, pOperationTerm, pValueTerm, cco, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionFactory2_ResolveCondition(self: *const T, pc: ?*ICondition, sqro: STRUCTURED_QUERY_RESOLVE_OPTION, pstReferenceTime: ?*const SYSTEMTIME, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).ResolveCondition(@as(*const IConditionFactory2, @ptrCast(self)), pc, sqro, pstReferenceTime, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConditionGenerator_Value = Guid.initString("92d2cc58-4386-45a3-b98c-7e0ce64a4117");
pub const IID_IConditionGenerator = &IID_IConditionGenerator_Value;
pub const IConditionGenerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionGenerator,
                pSchemaProvider: ?*ISchemaProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionGenerator,
                pSchemaProvider: ?*ISchemaProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RecognizeNamedEntities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionGenerator,
                pszInputString: ?[*:0]const u16,
                lcidUserLocale: u32,
                pTokenCollection: ?*ITokenCollection,
                pNamedEntities: ?*INamedEntityCollector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionGenerator,
                pszInputString: ?[*:0]const u16,
                lcidUserLocale: u32,
                pTokenCollection: ?*ITokenCollection,
                pNamedEntities: ?*INamedEntityCollector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateForLeaf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionGenerator,
                pConditionFactory: ?*IConditionFactory,
                pszPropertyName: ?[*:0]const u16,
                cop: CONDITION_OPERATION,
                pszValueType: ?[*:0]const u16,
                pszValue: ?[*:0]const u16,
                pszValue2: ?[*:0]const u16,
                pPropertyNameTerm: ?*IRichChunk,
                pOperationTerm: ?*IRichChunk,
                pValueTerm: ?*IRichChunk,
                automaticWildcard: BOOL,
                pNoStringQuery: ?*BOOL,
                ppQueryExpression: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionGenerator,
                pConditionFactory: ?*IConditionFactory,
                pszPropertyName: ?[*:0]const u16,
                cop: CONDITION_OPERATION,
                pszValueType: ?[*:0]const u16,
                pszValue: ?[*:0]const u16,
                pszValue2: ?[*:0]const u16,
                pPropertyNameTerm: ?*IRichChunk,
                pOperationTerm: ?*IRichChunk,
                pValueTerm: ?*IRichChunk,
                automaticWildcard: BOOL,
                pNoStringQuery: ?*BOOL,
                ppQueryExpression: ?*?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefaultPhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConditionGenerator,
                pszValueType: ?[*:0]const u16,
                ppropvar: ?*const PROPVARIANT,
                fUseEnglish: BOOL,
                ppszPhrase: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConditionGenerator,
                pszValueType: ?[*:0]const u16,
                ppropvar: ?*const PROPVARIANT,
                fUseEnglish: BOOL,
                ppszPhrase: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionGenerator_Initialize(self: *const T, pSchemaProvider: ?*ISchemaProvider) HRESULT {
                return @as(*const IConditionGenerator.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IConditionGenerator, @ptrCast(self)), pSchemaProvider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionGenerator_RecognizeNamedEntities(self: *const T, pszInputString: ?[*:0]const u16, lcidUserLocale: u32, pTokenCollection: ?*ITokenCollection, pNamedEntities: ?*INamedEntityCollector) HRESULT {
                return @as(*const IConditionGenerator.VTable, @ptrCast(self.vtable)).RecognizeNamedEntities(@as(*const IConditionGenerator, @ptrCast(self)), pszInputString, lcidUserLocale, pTokenCollection, pNamedEntities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionGenerator_GenerateForLeaf(self: *const T, pConditionFactory: ?*IConditionFactory, pszPropertyName: ?[*:0]const u16, cop: CONDITION_OPERATION, pszValueType: ?[*:0]const u16, pszValue: ?[*:0]const u16, pszValue2: ?[*:0]const u16, pPropertyNameTerm: ?*IRichChunk, pOperationTerm: ?*IRichChunk, pValueTerm: ?*IRichChunk, automaticWildcard: BOOL, pNoStringQuery: ?*BOOL, ppQueryExpression: ?*?*ICondition) HRESULT {
                return @as(*const IConditionGenerator.VTable, @ptrCast(self.vtable)).GenerateForLeaf(@as(*const IConditionGenerator, @ptrCast(self)), pConditionFactory, pszPropertyName, cop, pszValueType, pszValue, pszValue2, pPropertyNameTerm, pOperationTerm, pValueTerm, automaticWildcard, pNoStringQuery, ppQueryExpression);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConditionGenerator_DefaultPhrase(self: *const T, pszValueType: ?[*:0]const u16, ppropvar: ?*const PROPVARIANT, fUseEnglish: BOOL, ppszPhrase: ?*?PWSTR) HRESULT {
                return @as(*const IConditionGenerator.VTable, @ptrCast(self.vtable)).DefaultPhrase(@as(*const IConditionGenerator, @ptrCast(self)), pszValueType, ppropvar, fUseEnglish, ppszPhrase);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInterval_Value = Guid.initString("6bf0a714-3c18-430b-8b5d-83b1c234d3db");
pub const IID_IInterval = &IID_IInterval_Value;
pub const IInterval = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLimits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInterval,
                pilkLower: ?*INTERVAL_LIMIT_KIND,
                ppropvarLower: ?*PROPVARIANT,
                pilkUpper: ?*INTERVAL_LIMIT_KIND,
                ppropvarUpper: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInterval,
                pilkLower: ?*INTERVAL_LIMIT_KIND,
                ppropvarLower: ?*PROPVARIANT,
                pilkUpper: ?*INTERVAL_LIMIT_KIND,
                ppropvarUpper: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInterval_GetLimits(self: *const T, pilkLower: ?*INTERVAL_LIMIT_KIND, ppropvarLower: ?*PROPVARIANT, pilkUpper: ?*INTERVAL_LIMIT_KIND, ppropvarUpper: ?*PROPVARIANT) HRESULT {
                return @as(*const IInterval.VTable, @ptrCast(self.vtable)).GetLimits(@as(*const IInterval, @ptrCast(self)), pilkLower, ppropvarLower, pilkUpper, ppropvarUpper);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMetaData_Value = Guid.initString("780102b0-c43b-4876-bc7b-5e9ba5c88794");
pub const IID_IMetaData = &IID_IMetaData_Value;
pub const IMetaData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMetaData,
                ppszKey: ?*?PWSTR,
                ppszValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMetaData,
                ppszKey: ?*?PWSTR,
                ppszValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMetaData_GetData(self: *const T, ppszKey: ?*?PWSTR, ppszValue: ?*?PWSTR) HRESULT {
                return @as(*const IMetaData.VTable, @ptrCast(self.vtable)).GetData(@as(*const IMetaData, @ptrCast(self)), ppszKey, ppszValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEntity_Value = Guid.initString("24264891-e80b-4fd3-b7ce-4ff2fae8931f");
pub const IID_IEntity = &IID_IEntity_Value;
pub const IEntity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Name: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEntity,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEntity,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Base: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEntity,
                pBaseEntity: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEntity,
                pBaseEntity: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Relationships: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEntity,
                riid: ?*const Guid,
                pRelationships: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEntity,
                riid: ?*const Guid,
                pRelationships: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRelationship: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEntity,
                pszRelationName: ?[*:0]const u16,
                pRelationship: ?*?*IRelationship,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEntity,
                pszRelationName: ?[*:0]const u16,
                pRelationship: ?*?*IRelationship,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MetaData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEntity,
                riid: ?*const Guid,
                pMetaData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEntity,
                riid: ?*const Guid,
                pMetaData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NamedEntities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEntity,
                riid: ?*const Guid,
                pNamedEntities: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEntity,
                riid: ?*const Guid,
                pNamedEntities: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNamedEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEntity,
                pszValue: ?[*:0]const u16,
                ppNamedEntity: ?*?*INamedEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEntity,
                pszValue: ?[*:0]const u16,
                ppNamedEntity: ?*?*INamedEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefaultPhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEntity,
                ppszPhrase: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEntity,
                ppszPhrase: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEntity_Name(self: *const T, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).Name(@as(*const IEntity, @ptrCast(self)), ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEntity_Base(self: *const T, pBaseEntity: ?*?*IEntity) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).Base(@as(*const IEntity, @ptrCast(self)), pBaseEntity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEntity_Relationships(self: *const T, riid: ?*const Guid, pRelationships: ?*?*anyopaque) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).Relationships(@as(*const IEntity, @ptrCast(self)), riid, pRelationships);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEntity_GetRelationship(self: *const T, pszRelationName: ?[*:0]const u16, pRelationship: ?*?*IRelationship) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).GetRelationship(@as(*const IEntity, @ptrCast(self)), pszRelationName, pRelationship);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEntity_MetaData(self: *const T, riid: ?*const Guid, pMetaData: ?*?*anyopaque) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).MetaData(@as(*const IEntity, @ptrCast(self)), riid, pMetaData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEntity_NamedEntities(self: *const T, riid: ?*const Guid, pNamedEntities: ?*?*anyopaque) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).NamedEntities(@as(*const IEntity, @ptrCast(self)), riid, pNamedEntities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEntity_GetNamedEntity(self: *const T, pszValue: ?[*:0]const u16, ppNamedEntity: ?*?*INamedEntity) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).GetNamedEntity(@as(*const IEntity, @ptrCast(self)), pszValue, ppNamedEntity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEntity_DefaultPhrase(self: *const T, ppszPhrase: ?*?PWSTR) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).DefaultPhrase(@as(*const IEntity, @ptrCast(self)), ppszPhrase);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRelationship_Value = Guid.initString("2769280b-5108-498c-9c7f-a51239b63147");
pub const IID_IRelationship = &IID_IRelationship_Value;
pub const IRelationship = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Name: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRelationship,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRelationship,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsReal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRelationship,
                pIsReal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRelationship,
                pIsReal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Destination: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRelationship,
                pDestinationEntity: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRelationship,
                pDestinationEntity: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MetaData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRelationship,
                riid: ?*const Guid,
                pMetaData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRelationship,
                riid: ?*const Guid,
                pMetaData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefaultPhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRelationship,
                ppszPhrase: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRelationship,
                ppszPhrase: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRelationship_Name(self: *const T, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).Name(@as(*const IRelationship, @ptrCast(self)), ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRelationship_IsReal(self: *const T, pIsReal: ?*BOOL) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).IsReal(@as(*const IRelationship, @ptrCast(self)), pIsReal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRelationship_Destination(self: *const T, pDestinationEntity: ?*?*IEntity) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).Destination(@as(*const IRelationship, @ptrCast(self)), pDestinationEntity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRelationship_MetaData(self: *const T, riid: ?*const Guid, pMetaData: ?*?*anyopaque) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).MetaData(@as(*const IRelationship, @ptrCast(self)), riid, pMetaData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRelationship_DefaultPhrase(self: *const T, ppszPhrase: ?*?PWSTR) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).DefaultPhrase(@as(*const IRelationship, @ptrCast(self)), ppszPhrase);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamedEntity_Value = Guid.initString("abdbd0b1-7d54-49fb-ab5c-bff4130004cd");
pub const IID_INamedEntity = &IID_INamedEntity_Value;
pub const INamedEntity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamedEntity,
                ppszValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamedEntity,
                ppszValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefaultPhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamedEntity,
                ppszPhrase: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamedEntity,
                ppszPhrase: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamedEntity_GetValue(self: *const T, ppszValue: ?*?PWSTR) HRESULT {
                return @as(*const INamedEntity.VTable, @ptrCast(self.vtable)).GetValue(@as(*const INamedEntity, @ptrCast(self)), ppszValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamedEntity_DefaultPhrase(self: *const T, ppszPhrase: ?*?PWSTR) HRESULT {
                return @as(*const INamedEntity.VTable, @ptrCast(self.vtable)).DefaultPhrase(@as(*const INamedEntity, @ptrCast(self)), ppszPhrase);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISchemaProvider_Value = Guid.initString("8cf89bcb-394c-49b2-ae28-a59dd4ed7f68");
pub const IID_ISchemaProvider = &IID_ISchemaProvider_Value;
pub const ISchemaProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Entities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaProvider,
                riid: ?*const Guid,
                pEntities: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaProvider,
                riid: ?*const Guid,
                pEntities: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RootEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaProvider,
                pRootEntity: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaProvider,
                pRootEntity: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaProvider,
                pszEntityName: ?[*:0]const u16,
                pEntity: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaProvider,
                pszEntityName: ?[*:0]const u16,
                pEntity: ?*?*IEntity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MetaData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaProvider,
                riid: ?*const Guid,
                pMetaData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaProvider,
                riid: ?*const Guid,
                pMetaData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Localize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaProvider,
                lcid: u32,
                pSchemaLocalizerSupport: ?*ISchemaLocalizerSupport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaProvider,
                lcid: u32,
                pSchemaLocalizerSupport: ?*ISchemaLocalizerSupport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveBinary: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaProvider,
                pszSchemaBinaryPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaProvider,
                pszSchemaBinaryPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LookupAuthoredNamedEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaProvider,
                pEntity: ?*IEntity,
                pszInputString: ?[*:0]const u16,
                pTokenCollection: ?*ITokenCollection,
                cTokensBegin: u32,
                pcTokensLength: ?*u32,
                ppszValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaProvider,
                pEntity: ?*IEntity,
                pszInputString: ?[*:0]const u16,
                pTokenCollection: ?*ITokenCollection,
                cTokensBegin: u32,
                pcTokensLength: ?*u32,
                ppszValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaProvider_Entities(self: *const T, riid: ?*const Guid, pEntities: ?*?*anyopaque) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).Entities(@as(*const ISchemaProvider, @ptrCast(self)), riid, pEntities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaProvider_RootEntity(self: *const T, pRootEntity: ?*?*IEntity) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).RootEntity(@as(*const ISchemaProvider, @ptrCast(self)), pRootEntity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaProvider_GetEntity(self: *const T, pszEntityName: ?[*:0]const u16, pEntity: ?*?*IEntity) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).GetEntity(@as(*const ISchemaProvider, @ptrCast(self)), pszEntityName, pEntity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaProvider_MetaData(self: *const T, riid: ?*const Guid, pMetaData: ?*?*anyopaque) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).MetaData(@as(*const ISchemaProvider, @ptrCast(self)), riid, pMetaData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaProvider_Localize(self: *const T, lcid: u32, pSchemaLocalizerSupport: ?*ISchemaLocalizerSupport) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).Localize(@as(*const ISchemaProvider, @ptrCast(self)), lcid, pSchemaLocalizerSupport);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaProvider_SaveBinary(self: *const T, pszSchemaBinaryPath: ?[*:0]const u16) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).SaveBinary(@as(*const ISchemaProvider, @ptrCast(self)), pszSchemaBinaryPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaProvider_LookupAuthoredNamedEntity(self: *const T, pEntity: ?*IEntity, pszInputString: ?[*:0]const u16, pTokenCollection: ?*ITokenCollection, cTokensBegin: u32, pcTokensLength: ?*u32, ppszValue: ?*?PWSTR) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).LookupAuthoredNamedEntity(@as(*const ISchemaProvider, @ptrCast(self)), pEntity, pszInputString, pTokenCollection, cTokensBegin, pcTokensLength, ppszValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITokenCollection_Value = Guid.initString("22d8b4f2-f577-4adb-a335-c2ae88416fab");
pub const IID_ITokenCollection = &IID_ITokenCollection_Value;
pub const ITokenCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NumberOfTokens: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITokenCollection,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITokenCollection,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITokenCollection,
                i: u32,
                pBegin: ?*u32,
                pLength: ?*u32,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITokenCollection,
                i: u32,
                pBegin: ?*u32,
                pLength: ?*u32,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITokenCollection_NumberOfTokens(self: *const T, pCount: ?*u32) HRESULT {
                return @as(*const ITokenCollection.VTable, @ptrCast(self.vtable)).NumberOfTokens(@as(*const ITokenCollection, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITokenCollection_GetToken(self: *const T, i: u32, pBegin: ?*u32, pLength: ?*u32, ppsz: ?*?PWSTR) HRESULT {
                return @as(*const ITokenCollection.VTable, @ptrCast(self.vtable)).GetToken(@as(*const ITokenCollection, @ptrCast(self)), i, pBegin, pLength, ppsz);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NAMED_ENTITY_CERTAINTY = enum(i32) {
    LOW = 0,
    MEDIUM = 1,
    HIGH = 2,
};
pub const NEC_LOW = NAMED_ENTITY_CERTAINTY.LOW;
pub const NEC_MEDIUM = NAMED_ENTITY_CERTAINTY.MEDIUM;
pub const NEC_HIGH = NAMED_ENTITY_CERTAINTY.HIGH;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamedEntityCollector_Value = Guid.initString("af2440f6-8afc-47d0-9a7f-396a0acfb43d");
pub const IID_INamedEntityCollector = &IID_INamedEntityCollector_Value;
pub const INamedEntityCollector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamedEntityCollector,
                beginSpan: u32,
                endSpan: u32,
                beginActual: u32,
                endActual: u32,
                pType: ?*IEntity,
                pszValue: ?[*:0]const u16,
                certainty: NAMED_ENTITY_CERTAINTY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamedEntityCollector,
                beginSpan: u32,
                endSpan: u32,
                beginActual: u32,
                endActual: u32,
                pType: ?*IEntity,
                pszValue: ?[*:0]const u16,
                certainty: NAMED_ENTITY_CERTAINTY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamedEntityCollector_Add(self: *const T, beginSpan: u32, endSpan: u32, beginActual: u32, endActual: u32, pType: ?*IEntity, pszValue: ?[*:0]const u16, certainty: NAMED_ENTITY_CERTAINTY) HRESULT {
                return @as(*const INamedEntityCollector.VTable, @ptrCast(self.vtable)).Add(@as(*const INamedEntityCollector, @ptrCast(self)), beginSpan, endSpan, beginActual, endActual, pType, pszValue, certainty);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISchemaLocalizerSupport_Value = Guid.initString("ca3fdca2-bfbe-4eed-90d7-0caef0a1bda1");
pub const IID_ISchemaLocalizerSupport = &IID_ISchemaLocalizerSupport_Value;
pub const ISchemaLocalizerSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Localize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaLocalizerSupport,
                pszGlobalString: ?[*:0]const u16,
                ppszLocalString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaLocalizerSupport,
                pszGlobalString: ?[*:0]const u16,
                ppszLocalString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaLocalizerSupport_Localize(self: *const T, pszGlobalString: ?[*:0]const u16, ppszLocalString: ?*?PWSTR) HRESULT {
                return @as(*const ISchemaLocalizerSupport.VTable, @ptrCast(self.vtable)).Localize(@as(*const ISchemaLocalizerSupport, @ptrCast(self)), pszGlobalString, ppszLocalString);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryParserManager_Value = Guid.initString("a879e3c4-af77-44fb-8f37-ebd1487cf920");
pub const IID_IQueryParserManager = &IID_IQueryParserManager_Value;
pub const IQueryParserManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateLoadedParser: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParserManager,
                pszCatalog: ?[*:0]const u16,
                langidForKeywords: u16,
                riid: ?*const Guid,
                ppQueryParser: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParserManager,
                pszCatalog: ?[*:0]const u16,
                langidForKeywords: u16,
                riid: ?*const Guid,
                ppQueryParser: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParserManager,
                fUnderstandNQS: BOOL,
                fAutoWildCard: BOOL,
                pQueryParser: ?*IQueryParser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParserManager,
                fUnderstandNQS: BOOL,
                fAutoWildCard: BOOL,
                pQueryParser: ?*IQueryParser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryParserManager,
                option: QUERY_PARSER_MANAGER_OPTION,
                pOptionValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryParserManager,
                option: QUERY_PARSER_MANAGER_OPTION,
                pOptionValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParserManager_CreateLoadedParser(self: *const T, pszCatalog: ?[*:0]const u16, langidForKeywords: u16, riid: ?*const Guid, ppQueryParser: ?*?*anyopaque) HRESULT {
                return @as(*const IQueryParserManager.VTable, @ptrCast(self.vtable)).CreateLoadedParser(@as(*const IQueryParserManager, @ptrCast(self)), pszCatalog, langidForKeywords, riid, ppQueryParser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParserManager_InitializeOptions(self: *const T, fUnderstandNQS: BOOL, fAutoWildCard: BOOL, pQueryParser: ?*IQueryParser) HRESULT {
                return @as(*const IQueryParserManager.VTable, @ptrCast(self.vtable)).InitializeOptions(@as(*const IQueryParserManager, @ptrCast(self)), fUnderstandNQS, fAutoWildCard, pQueryParser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryParserManager_SetOption(self: *const T, option: QUERY_PARSER_MANAGER_OPTION, pOptionValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IQueryParserManager.VTable, @ptrCast(self.vtable)).SetOption(@as(*const IQueryParserManager, @ptrCast(self)), option, pOptionValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const HITRANGE = extern struct {
    iPosition: u32,
    cLength: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUrlAccessor_Value = Guid.initString("0b63e318-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IUrlAccessor = &IID_IUrlAccessor_Value;
pub const IUrlAccessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRequestParameter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                pSpec: ?*PROPSPEC,
                pVar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                pSpec: ?*PROPSPEC,
                pVar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                wszDocFormat: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                wszDocFormat: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCLSID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                pClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                pClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                wszHost: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                wszHost: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                pllSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                pllSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastModified: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                pftLastModified: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                pftLastModified: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                wszFileName: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                wszFileName: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecurityDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                pSD: [*:0]u8,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                pSD: [*:0]u8,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRedirectedURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                wszRedirectedURL: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                wszRedirectedURL: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecurityProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                pSPClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                pSPClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                ppStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                ppStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor,
                ppFilter: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor,
                ppFilter: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_AddRequestParameter(self: *const T, pSpec: ?*PROPSPEC, pVar: ?*PROPVARIANT) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).AddRequestParameter(@as(*const IUrlAccessor, @ptrCast(self)), pSpec, pVar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_GetDocFormat(self: *const T, wszDocFormat: [*:0]u16, dwSize: u32, pdwLength: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetDocFormat(@as(*const IUrlAccessor, @ptrCast(self)), wszDocFormat, dwSize, pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_GetCLSID(self: *const T, pClsid: ?*Guid) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetCLSID(@as(*const IUrlAccessor, @ptrCast(self)), pClsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_GetHost(self: *const T, wszHost: [*:0]u16, dwSize: u32, pdwLength: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetHost(@as(*const IUrlAccessor, @ptrCast(self)), wszHost, dwSize, pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_IsDirectory(self: *const T) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).IsDirectory(@as(*const IUrlAccessor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_GetSize(self: *const T, pllSize: ?*u64) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IUrlAccessor, @ptrCast(self)), pllSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_GetLastModified(self: *const T, pftLastModified: ?*FILETIME) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetLastModified(@as(*const IUrlAccessor, @ptrCast(self)), pftLastModified);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_GetFileName(self: *const T, wszFileName: [*:0]u16, dwSize: u32, pdwLength: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IUrlAccessor, @ptrCast(self)), wszFileName, dwSize, pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_GetSecurityDescriptor(self: *const T, pSD: [*:0]u8, dwSize: u32, pdwLength: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetSecurityDescriptor(@as(*const IUrlAccessor, @ptrCast(self)), pSD, dwSize, pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_GetRedirectedURL(self: *const T, wszRedirectedURL: [*:0]u16, dwSize: u32, pdwLength: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetRedirectedURL(@as(*const IUrlAccessor, @ptrCast(self)), wszRedirectedURL, dwSize, pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_GetSecurityProvider(self: *const T, pSPClsid: ?*Guid) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetSecurityProvider(@as(*const IUrlAccessor, @ptrCast(self)), pSPClsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_BindToStream(self: *const T, ppStream: ?*?*IStream) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).BindToStream(@as(*const IUrlAccessor, @ptrCast(self)), ppStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor_BindToFilter(self: *const T, ppFilter: ?*?*IFilter) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).BindToFilter(@as(*const IUrlAccessor, @ptrCast(self)), ppFilter);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUrlAccessor2_Value = Guid.initString("c7310734-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_IUrlAccessor2 = &IID_IUrlAccessor2_Value;
pub const IUrlAccessor2 = extern struct {
    pub const VTable = extern struct {
        base: IUrlAccessor.VTable,
        GetDisplayUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor2,
                wszDocUrl: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor2,
                wszDocUrl: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor2,
                wszCodePage: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor2,
                wszCodePage: [*:0]u16,
                dwSize: u32,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUrlAccessor.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor2_GetDisplayUrl(self: *const T, wszDocUrl: [*:0]u16, dwSize: u32, pdwLength: ?*u32) HRESULT {
                return @as(*const IUrlAccessor2.VTable, @ptrCast(self.vtable)).GetDisplayUrl(@as(*const IUrlAccessor2, @ptrCast(self)), wszDocUrl, dwSize, pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor2_IsDocument(self: *const T) HRESULT {
                return @as(*const IUrlAccessor2.VTable, @ptrCast(self.vtable)).IsDocument(@as(*const IUrlAccessor2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor2_GetCodePage(self: *const T, wszCodePage: [*:0]u16, dwSize: u32, pdwLength: ?*u32) HRESULT {
                return @as(*const IUrlAccessor2.VTable, @ptrCast(self.vtable)).GetCodePage(@as(*const IUrlAccessor2, @ptrCast(self)), wszCodePage, dwSize, pdwLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUrlAccessor3_Value = Guid.initString("6fbc7005-0455-4874-b8ff-7439450241a3");
pub const IID_IUrlAccessor3 = &IID_IUrlAccessor3_Value;
pub const IUrlAccessor3 = extern struct {
    pub const VTable = extern struct {
        base: IUrlAccessor2.VTable,
        GetImpersonationSidBlobs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor3,
                pcwszURL: ?[*:0]const u16,
                pcSidCount: ?*u32,
                ppSidBlobs: ?*?*BLOB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor3,
                pcwszURL: ?[*:0]const u16,
                pcSidCount: ?*u32,
                ppSidBlobs: ?*?*BLOB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUrlAccessor2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor3_GetImpersonationSidBlobs(self: *const T, pcwszURL: ?[*:0]const u16, pcSidCount: ?*u32, ppSidBlobs: ?*?*BLOB) HRESULT {
                return @as(*const IUrlAccessor3.VTable, @ptrCast(self.vtable)).GetImpersonationSidBlobs(@as(*const IUrlAccessor3, @ptrCast(self)), pcwszURL, pcSidCount, ppSidBlobs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUrlAccessor4_Value = Guid.initString("5cc51041-c8d2-41d7-bca3-9e9e286297dc");
pub const IID_IUrlAccessor4 = &IID_IUrlAccessor4_Value;
pub const IUrlAccessor4 = extern struct {
    pub const VTable = extern struct {
        base: IUrlAccessor3.VTable,
        ShouldIndexItemContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor4,
                pfIndexContent: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor4,
                pfIndexContent: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShouldIndexProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlAccessor4,
                key: ?*const PROPERTYKEY,
                pfIndexProperty: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlAccessor4,
                key: ?*const PROPERTYKEY,
                pfIndexProperty: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUrlAccessor3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor4_ShouldIndexItemContent(self: *const T, pfIndexContent: ?*BOOL) HRESULT {
                return @as(*const IUrlAccessor4.VTable, @ptrCast(self.vtable)).ShouldIndexItemContent(@as(*const IUrlAccessor4, @ptrCast(self)), pfIndexContent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlAccessor4_ShouldIndexProperty(self: *const T, key: ?*const PROPERTYKEY, pfIndexProperty: ?*BOOL) HRESULT {
                return @as(*const IUrlAccessor4.VTable, @ptrCast(self.vtable)).ShouldIndexProperty(@as(*const IUrlAccessor4, @ptrCast(self)), key, pfIndexProperty);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IOpLockStatus_Value = Guid.initString("c731065d-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_IOpLockStatus = &IID_IOpLockStatus_Value;
pub const IOpLockStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsOplockValid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOpLockStatus,
                pfIsOplockValid: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOpLockStatus,
                pfIsOplockValid: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsOplockBroken: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOpLockStatus,
                pfIsOplockBroken: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOpLockStatus,
                pfIsOplockBroken: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOplockEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOpLockStatus,
                phOplockEv: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOpLockStatus,
                phOplockEv: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOpLockStatus_IsOplockValid(self: *const T, pfIsOplockValid: ?*BOOL) HRESULT {
                return @as(*const IOpLockStatus.VTable, @ptrCast(self.vtable)).IsOplockValid(@as(*const IOpLockStatus, @ptrCast(self)), pfIsOplockValid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOpLockStatus_IsOplockBroken(self: *const T, pfIsOplockBroken: ?*BOOL) HRESULT {
                return @as(*const IOpLockStatus.VTable, @ptrCast(self.vtable)).IsOplockBroken(@as(*const IOpLockStatus, @ptrCast(self)), pfIsOplockBroken);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOpLockStatus_GetOplockEventHandle(self: *const T, phOplockEv: ?*?HANDLE) HRESULT {
                return @as(*const IOpLockStatus.VTable, @ptrCast(self.vtable)).GetOplockEventHandle(@as(*const IOpLockStatus, @ptrCast(self)), phOplockEv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchProtocolThreadContext_Value = Guid.initString("c73106e1-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_ISearchProtocolThreadContext = &IID_ISearchProtocolThreadContext_Value;
pub const ISearchProtocolThreadContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadInit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchProtocolThreadContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchProtocolThreadContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ThreadShutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchProtocolThreadContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchProtocolThreadContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ThreadIdle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchProtocolThreadContext,
                dwTimeElaspedSinceLastCallInMS: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchProtocolThreadContext,
                dwTimeElaspedSinceLastCallInMS: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchProtocolThreadContext_ThreadInit(self: *const T) HRESULT {
                return @as(*const ISearchProtocolThreadContext.VTable, @ptrCast(self.vtable)).ThreadInit(@as(*const ISearchProtocolThreadContext, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchProtocolThreadContext_ThreadShutdown(self: *const T) HRESULT {
                return @as(*const ISearchProtocolThreadContext.VTable, @ptrCast(self.vtable)).ThreadShutdown(@as(*const ISearchProtocolThreadContext, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchProtocolThreadContext_ThreadIdle(self: *const T, dwTimeElaspedSinceLastCallInMS: u32) HRESULT {
                return @as(*const ISearchProtocolThreadContext.VTable, @ptrCast(self.vtable)).ThreadIdle(@as(*const ISearchProtocolThreadContext, @ptrCast(self)), dwTimeElaspedSinceLastCallInMS);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TIMEOUT_INFO = extern struct {
    dwSize: u32,
    dwConnectTimeout: u32,
    dwDataTimeout: u32,
};

pub const PROXY_ACCESS = enum(i32) {
    PRECONFIG = 0,
    DIRECT = 1,
    PROXY = 2,
};
pub const PROXY_ACCESS_PRECONFIG = PROXY_ACCESS.PRECONFIG;
pub const PROXY_ACCESS_DIRECT = PROXY_ACCESS.DIRECT;
pub const PROXY_ACCESS_PROXY = PROXY_ACCESS.PROXY;

pub const PROXY_INFO = extern struct {
    dwSize: u32,
    pcwszUserAgent: ?[*:0]const u16,
    paUseProxy: PROXY_ACCESS,
    fLocalBypass: BOOL,
    dwPortNumber: u32,
    pcwszProxyName: ?[*:0]const u16,
    pcwszBypassList: ?[*:0]const u16,
};

pub const AUTH_TYPE = enum(i32) {
    ANONYMOUS = 0,
    NTLM = 1,
    BASIC = 2,
};
pub const eAUTH_TYPE_ANONYMOUS = AUTH_TYPE.ANONYMOUS;
pub const eAUTH_TYPE_NTLM = AUTH_TYPE.NTLM;
pub const eAUTH_TYPE_BASIC = AUTH_TYPE.BASIC;

pub const AUTHENTICATION_INFO = extern struct {
    dwSize: u32,
    atAuthenticationType: AUTH_TYPE,
    pcwszUser: ?[*:0]const u16,
    pcwszPassword: ?[*:0]const u16,
};

pub const INCREMENTAL_ACCESS_INFO = extern struct {
    dwSize: u32,
    ftLastModifiedTime: FILETIME,
};

pub const ITEM_INFO = extern struct {
    dwSize: u32,
    pcwszFromEMail: ?[*:0]const u16,
    pcwszApplicationName: ?[*:0]const u16,
    pcwszCatalogName: ?[*:0]const u16,
    pcwszContentClass: ?[*:0]const u16,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchProtocol_Value = Guid.initString("c73106ba-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_ISearchProtocol = &IID_ISearchProtocol_Value;
pub const ISearchProtocol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchProtocol,
                pTimeoutInfo: ?*TIMEOUT_INFO,
                pProtocolHandlerSite: ?*IProtocolHandlerSite,
                pProxyInfo: ?*PROXY_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchProtocol,
                pTimeoutInfo: ?*TIMEOUT_INFO,
                pProtocolHandlerSite: ?*IProtocolHandlerSite,
                pProxyInfo: ?*PROXY_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAccessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchProtocol,
                pcwszURL: ?[*:0]const u16,
                pAuthenticationInfo: ?*AUTHENTICATION_INFO,
                pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO,
                pItemInfo: ?*ITEM_INFO,
                ppAccessor: ?*?*IUrlAccessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchProtocol,
                pcwszURL: ?[*:0]const u16,
                pAuthenticationInfo: ?*AUTHENTICATION_INFO,
                pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO,
                pItemInfo: ?*ITEM_INFO,
                ppAccessor: ?*?*IUrlAccessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseAccessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchProtocol,
                pAccessor: ?*IUrlAccessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchProtocol,
                pAccessor: ?*IUrlAccessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShutDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchProtocol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchProtocol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchProtocol_Init(self: *const T, pTimeoutInfo: ?*TIMEOUT_INFO, pProtocolHandlerSite: ?*IProtocolHandlerSite, pProxyInfo: ?*PROXY_INFO) HRESULT {
                return @as(*const ISearchProtocol.VTable, @ptrCast(self.vtable)).Init(@as(*const ISearchProtocol, @ptrCast(self)), pTimeoutInfo, pProtocolHandlerSite, pProxyInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchProtocol_CreateAccessor(self: *const T, pcwszURL: ?[*:0]const u16, pAuthenticationInfo: ?*AUTHENTICATION_INFO, pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO, pItemInfo: ?*ITEM_INFO, ppAccessor: ?*?*IUrlAccessor) HRESULT {
                return @as(*const ISearchProtocol.VTable, @ptrCast(self.vtable)).CreateAccessor(@as(*const ISearchProtocol, @ptrCast(self)), pcwszURL, pAuthenticationInfo, pIncrementalAccessInfo, pItemInfo, ppAccessor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchProtocol_CloseAccessor(self: *const T, pAccessor: ?*IUrlAccessor) HRESULT {
                return @as(*const ISearchProtocol.VTable, @ptrCast(self.vtable)).CloseAccessor(@as(*const ISearchProtocol, @ptrCast(self)), pAccessor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchProtocol_ShutDown(self: *const T) HRESULT {
                return @as(*const ISearchProtocol.VTable, @ptrCast(self.vtable)).ShutDown(@as(*const ISearchProtocol, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchProtocol2_Value = Guid.initString("7789f0b2-b5b2-4722-8b65-5dbd150697a9");
pub const IID_ISearchProtocol2 = &IID_ISearchProtocol2_Value;
pub const ISearchProtocol2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchProtocol.VTable,
        CreateAccessorEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchProtocol2,
                pcwszURL: ?[*:0]const u16,
                pAuthenticationInfo: ?*AUTHENTICATION_INFO,
                pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO,
                pItemInfo: ?*ITEM_INFO,
                pUserData: ?*const BLOB,
                ppAccessor: ?*?*IUrlAccessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchProtocol2,
                pcwszURL: ?[*:0]const u16,
                pAuthenticationInfo: ?*AUTHENTICATION_INFO,
                pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO,
                pItemInfo: ?*ITEM_INFO,
                pUserData: ?*const BLOB,
                ppAccessor: ?*?*IUrlAccessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISearchProtocol.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchProtocol2_CreateAccessorEx(self: *const T, pcwszURL: ?[*:0]const u16, pAuthenticationInfo: ?*AUTHENTICATION_INFO, pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO, pItemInfo: ?*ITEM_INFO, pUserData: ?*const BLOB, ppAccessor: ?*?*IUrlAccessor) HRESULT {
                return @as(*const ISearchProtocol2.VTable, @ptrCast(self.vtable)).CreateAccessorEx(@as(*const ISearchProtocol2, @ptrCast(self)), pcwszURL, pAuthenticationInfo, pIncrementalAccessInfo, pItemInfo, pUserData, ppAccessor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IProtocolHandlerSite_Value = Guid.initString("0b63e385-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IProtocolHandlerSite = &IID_IProtocolHandlerSite_Value;
pub const IProtocolHandlerSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProtocolHandlerSite,
                pclsidObj: ?*Guid,
                pcwszContentType: ?[*:0]const u16,
                pcwszExtension: ?[*:0]const u16,
                ppFilter: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProtocolHandlerSite,
                pclsidObj: ?*Guid,
                pcwszContentType: ?[*:0]const u16,
                pcwszExtension: ?[*:0]const u16,
                ppFilter: ?*?*IFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProtocolHandlerSite_GetFilter(self: *const T, pclsidObj: ?*Guid, pcwszContentType: ?[*:0]const u16, pcwszExtension: ?[*:0]const u16, ppFilter: ?*?*IFilter) HRESULT {
                return @as(*const IProtocolHandlerSite.VTable, @ptrCast(self.vtable)).GetFilter(@as(*const IProtocolHandlerSite, @ptrCast(self)), pclsidObj, pcwszContentType, pcwszExtension, ppFilter);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchRoot_Value = Guid.initString("04c18ccf-1f57-4cbd-88cc-3900f5195ce3");
pub const IID_ISearchRoot = &IID_ISearchRoot_Value;
pub const ISearchRoot = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Schedule: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pszTaskArg: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pszTaskArg: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Schedule: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                ppszTaskArg: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                ppszTaskArg: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                ppszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                ppszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsHierarchical: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                fIsHierarchical: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                fIsHierarchical: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsHierarchical: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pfIsHierarchical: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pfIsHierarchical: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProvidesNotifications: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                fProvidesNotifications: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                fProvidesNotifications: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProvidesNotifications: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pfProvidesNotifications: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pfProvidesNotifications: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseNotificationsOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                fUseNotificationsOnly: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                fUseNotificationsOnly: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseNotificationsOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pfUseNotificationsOnly: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pfUseNotificationsOnly: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnumerationDepth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                dwDepth: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                dwDepth: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumerationDepth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pdwDepth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pdwDepth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HostDepth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                dwDepth: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                dwDepth: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HostDepth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pdwDepth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pdwDepth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FollowDirectories: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                fFollowDirectories: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                fFollowDirectories: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FollowDirectories: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pfFollowDirectories: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pfFollowDirectories: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AuthenticationType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                authType: AUTH_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                authType: AUTH_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthenticationType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pAuthType: ?*AUTH_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pAuthType: ?*AUTH_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_User: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pszUser: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pszUser: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_User: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                ppszUser: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                ppszUser: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Password: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                pszPassword: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                pszPassword: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Password: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchRoot,
                ppszPassword: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchRoot,
                ppszPassword: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_Schedule(self: *const T, pszTaskArg: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_Schedule(@as(*const ISearchRoot, @ptrCast(self)), pszTaskArg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_Schedule(self: *const T, ppszTaskArg: ?*?PWSTR) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_Schedule(@as(*const ISearchRoot, @ptrCast(self)), ppszTaskArg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_RootURL(self: *const T, pszURL: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_RootURL(@as(*const ISearchRoot, @ptrCast(self)), pszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_RootURL(self: *const T, ppszURL: ?*?PWSTR) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_RootURL(@as(*const ISearchRoot, @ptrCast(self)), ppszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_IsHierarchical(self: *const T, fIsHierarchical: BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_IsHierarchical(@as(*const ISearchRoot, @ptrCast(self)), fIsHierarchical);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_IsHierarchical(self: *const T, pfIsHierarchical: ?*BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_IsHierarchical(@as(*const ISearchRoot, @ptrCast(self)), pfIsHierarchical);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_ProvidesNotifications(self: *const T, fProvidesNotifications: BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_ProvidesNotifications(@as(*const ISearchRoot, @ptrCast(self)), fProvidesNotifications);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_ProvidesNotifications(self: *const T, pfProvidesNotifications: ?*BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_ProvidesNotifications(@as(*const ISearchRoot, @ptrCast(self)), pfProvidesNotifications);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_UseNotificationsOnly(self: *const T, fUseNotificationsOnly: BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_UseNotificationsOnly(@as(*const ISearchRoot, @ptrCast(self)), fUseNotificationsOnly);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_UseNotificationsOnly(self: *const T, pfUseNotificationsOnly: ?*BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_UseNotificationsOnly(@as(*const ISearchRoot, @ptrCast(self)), pfUseNotificationsOnly);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_EnumerationDepth(self: *const T, dwDepth: u32) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_EnumerationDepth(@as(*const ISearchRoot, @ptrCast(self)), dwDepth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_EnumerationDepth(self: *const T, pdwDepth: ?*u32) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_EnumerationDepth(@as(*const ISearchRoot, @ptrCast(self)), pdwDepth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_HostDepth(self: *const T, dwDepth: u32) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_HostDepth(@as(*const ISearchRoot, @ptrCast(self)), dwDepth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_HostDepth(self: *const T, pdwDepth: ?*u32) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_HostDepth(@as(*const ISearchRoot, @ptrCast(self)), pdwDepth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_FollowDirectories(self: *const T, fFollowDirectories: BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_FollowDirectories(@as(*const ISearchRoot, @ptrCast(self)), fFollowDirectories);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_FollowDirectories(self: *const T, pfFollowDirectories: ?*BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_FollowDirectories(@as(*const ISearchRoot, @ptrCast(self)), pfFollowDirectories);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_AuthenticationType(self: *const T, authType: AUTH_TYPE) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_AuthenticationType(@as(*const ISearchRoot, @ptrCast(self)), authType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_AuthenticationType(self: *const T, pAuthType: ?*AUTH_TYPE) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_AuthenticationType(@as(*const ISearchRoot, @ptrCast(self)), pAuthType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_User(self: *const T, pszUser: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_User(@as(*const ISearchRoot, @ptrCast(self)), pszUser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_User(self: *const T, ppszUser: ?*?PWSTR) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_User(@as(*const ISearchRoot, @ptrCast(self)), ppszUser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_put_Password(self: *const T, pszPassword: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_Password(@as(*const ISearchRoot, @ptrCast(self)), pszPassword);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchRoot_get_Password(self: *const T, ppszPassword: ?*?PWSTR) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_Password(@as(*const ISearchRoot, @ptrCast(self)), ppszPassword);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumSearchRoots_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef52");
pub const IID_IEnumSearchRoots = &IID_IEnumSearchRoots_Value;
pub const IEnumSearchRoots = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSearchRoots,
                celt: u32,
                rgelt: [*]?*ISearchRoot,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSearchRoots,
                celt: u32,
                rgelt: [*]?*ISearchRoot,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSearchRoots,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSearchRoots,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSearchRoots,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSearchRoots,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSearchRoots,
                ppenum: ?*?*IEnumSearchRoots,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSearchRoots,
                ppenum: ?*?*IEnumSearchRoots,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSearchRoots_Next(self: *const T, celt: u32, rgelt: [*]?*ISearchRoot, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumSearchRoots.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSearchRoots, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSearchRoots_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumSearchRoots.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSearchRoots, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSearchRoots_Reset(self: *const T) HRESULT {
                return @as(*const IEnumSearchRoots.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSearchRoots, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSearchRoots_Clone(self: *const T, ppenum: ?*?*IEnumSearchRoots) HRESULT {
                return @as(*const IEnumSearchRoots.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSearchRoots, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FOLLOW_FLAGS = enum(i32) {
    INDEXCOMPLEXURLS = 1,
    SUPPRESSINDEXING = 2,
};
pub const FF_INDEXCOMPLEXURLS = FOLLOW_FLAGS.INDEXCOMPLEXURLS;
pub const FF_SUPPRESSINDEXING = FOLLOW_FLAGS.SUPPRESSINDEXING;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchScopeRule_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef53");
pub const IID_ISearchScopeRule = &IID_ISearchScopeRule_Value;
pub const ISearchScopeRule = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PatternOrURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchScopeRule,
                ppszPatternOrURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchScopeRule,
                ppszPatternOrURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsIncluded: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchScopeRule,
                pfIsIncluded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchScopeRule,
                pfIsIncluded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDefault: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchScopeRule,
                pfIsDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchScopeRule,
                pfIsDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FollowFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchScopeRule,
                pFollowFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchScopeRule,
                pFollowFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchScopeRule_get_PatternOrURL(self: *const T, ppszPatternOrURL: ?*?PWSTR) HRESULT {
                return @as(*const ISearchScopeRule.VTable, @ptrCast(self.vtable)).get_PatternOrURL(@as(*const ISearchScopeRule, @ptrCast(self)), ppszPatternOrURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchScopeRule_get_IsIncluded(self: *const T, pfIsIncluded: ?*BOOL) HRESULT {
                return @as(*const ISearchScopeRule.VTable, @ptrCast(self.vtable)).get_IsIncluded(@as(*const ISearchScopeRule, @ptrCast(self)), pfIsIncluded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchScopeRule_get_IsDefault(self: *const T, pfIsDefault: ?*BOOL) HRESULT {
                return @as(*const ISearchScopeRule.VTable, @ptrCast(self.vtable)).get_IsDefault(@as(*const ISearchScopeRule, @ptrCast(self)), pfIsDefault);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchScopeRule_get_FollowFlags(self: *const T, pFollowFlags: ?*u32) HRESULT {
                return @as(*const ISearchScopeRule.VTable, @ptrCast(self.vtable)).get_FollowFlags(@as(*const ISearchScopeRule, @ptrCast(self)), pFollowFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumSearchScopeRules_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef54");
pub const IID_IEnumSearchScopeRules = &IID_IEnumSearchScopeRules_Value;
pub const IEnumSearchScopeRules = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSearchScopeRules,
                celt: u32,
                pprgelt: [*]?*ISearchScopeRule,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSearchScopeRules,
                celt: u32,
                pprgelt: [*]?*ISearchScopeRule,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSearchScopeRules,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSearchScopeRules,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSearchScopeRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSearchScopeRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSearchScopeRules,
                ppenum: ?*?*IEnumSearchScopeRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSearchScopeRules,
                ppenum: ?*?*IEnumSearchScopeRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSearchScopeRules_Next(self: *const T, celt: u32, pprgelt: [*]?*ISearchScopeRule, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumSearchScopeRules.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSearchScopeRules, @ptrCast(self)), celt, pprgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSearchScopeRules_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumSearchScopeRules.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSearchScopeRules, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSearchScopeRules_Reset(self: *const T) HRESULT {
                return @as(*const IEnumSearchScopeRules.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSearchScopeRules, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSearchScopeRules_Clone(self: *const T, ppenum: ?*?*IEnumSearchScopeRules) HRESULT {
                return @as(*const IEnumSearchScopeRules.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSearchScopeRules, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CLUSION_REASON = enum(i32) {
    UNKNOWNSCOPE = 0,
    DEFAULT = 1,
    USER = 2,
    GROUPPOLICY = 3,
};
pub const CLUSIONREASON_UNKNOWNSCOPE = CLUSION_REASON.UNKNOWNSCOPE;
pub const CLUSIONREASON_DEFAULT = CLUSION_REASON.DEFAULT;
pub const CLUSIONREASON_USER = CLUSION_REASON.USER;
pub const CLUSIONREASON_GROUPPOLICY = CLUSION_REASON.GROUPPOLICY;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCrawlScopeManager_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef55");
pub const IID_ISearchCrawlScopeManager = &IID_ISearchCrawlScopeManager_Value;
pub const ISearchCrawlScopeManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDefaultScopeRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                fInclude: BOOL,
                fFollowFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                fInclude: BOOL,
                fFollowFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pSearchRoot: ?*ISearchRoot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pSearchRoot: ?*ISearchRoot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateRoots: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                ppSearchRoots: ?*?*IEnumSearchRoots,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                ppSearchRoots: ?*?*IEnumSearchRoots,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddHierarchicalScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                fInclude: BOOL,
                fDefault: BOOL,
                fOverrideChildren: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                fInclude: BOOL,
                fDefault: BOOL,
                fOverrideChildren: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddUserScopeRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                fInclude: BOOL,
                fOverrideChildren: BOOL,
                fFollowFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                fInclude: BOOL,
                fOverrideChildren: BOOL,
                fFollowFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveScopeRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszRule: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszRule: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateScopeRules: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                ppSearchScopeRules: ?*?*IEnumSearchScopeRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                ppSearchScopeRules: ?*?*IEnumSearchScopeRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasParentScopeRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                pfHasParentRule: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                pfHasParentRule: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasChildScopeRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                pfHasChildRule: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                pfHasChildRule: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IncludedInCrawlScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                pfIsIncluded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                pfIsIncluded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IncludedInCrawlScopeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                pfIsIncluded: ?*BOOL,
                pReason: ?*CLUSION_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                pfIsIncluded: ?*BOOL,
                pReason: ?*CLUSION_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevertToDefaultScopes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentScopeVersionId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                plScopeId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
                plScopeId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveDefaultScopeRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_AddDefaultScopeRule(self: *const T, pszURL: ?[*:0]const u16, fInclude: BOOL, fFollowFlags: u32) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).AddDefaultScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL, fInclude, fFollowFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_AddRoot(self: *const T, pSearchRoot: ?*ISearchRoot) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).AddRoot(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pSearchRoot);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_RemoveRoot(self: *const T, pszURL: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).RemoveRoot(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_EnumerateRoots(self: *const T, ppSearchRoots: ?*?*IEnumSearchRoots) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).EnumerateRoots(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), ppSearchRoots);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_AddHierarchicalScope(self: *const T, pszURL: ?[*:0]const u16, fInclude: BOOL, fDefault: BOOL, fOverrideChildren: BOOL) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).AddHierarchicalScope(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL, fInclude, fDefault, fOverrideChildren);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_AddUserScopeRule(self: *const T, pszURL: ?[*:0]const u16, fInclude: BOOL, fOverrideChildren: BOOL, fFollowFlags: u32) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).AddUserScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL, fInclude, fOverrideChildren, fFollowFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_RemoveScopeRule(self: *const T, pszRule: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).RemoveScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszRule);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_EnumerateScopeRules(self: *const T, ppSearchScopeRules: ?*?*IEnumSearchScopeRules) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).EnumerateScopeRules(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), ppSearchScopeRules);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_HasParentScopeRule(self: *const T, pszURL: ?[*:0]const u16, pfHasParentRule: ?*BOOL) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).HasParentScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL, pfHasParentRule);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_HasChildScopeRule(self: *const T, pszURL: ?[*:0]const u16, pfHasChildRule: ?*BOOL) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).HasChildScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL, pfHasChildRule);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_IncludedInCrawlScope(self: *const T, pszURL: ?[*:0]const u16, pfIsIncluded: ?*BOOL) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).IncludedInCrawlScope(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL, pfIsIncluded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_IncludedInCrawlScopeEx(self: *const T, pszURL: ?[*:0]const u16, pfIsIncluded: ?*BOOL, pReason: ?*CLUSION_REASON) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).IncludedInCrawlScopeEx(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL, pfIsIncluded, pReason);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_RevertToDefaultScopes(self: *const T) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).RevertToDefaultScopes(@as(*const ISearchCrawlScopeManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_SaveAll(self: *const T) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).SaveAll(@as(*const ISearchCrawlScopeManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_GetParentScopeVersionId(self: *const T, pszURL: ?[*:0]const u16, plScopeId: ?*i32) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).GetParentScopeVersionId(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL, plScopeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager_RemoveDefaultScopeRule(self: *const T, pszURL: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).RemoveDefaultScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pszURL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISearchCrawlScopeManager2_Value = Guid.initString("6292f7ad-4e19-4717-a534-8fc22bcd5ccd");
pub const IID_ISearchCrawlScopeManager2 = &IID_ISearchCrawlScopeManager2_Value;
pub const ISearchCrawlScopeManager2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchCrawlScopeManager.VTable,
        GetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCrawlScopeManager2,
                plVersion: ?*?*i32,
                phFileMapping: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCrawlScopeManager2,
                plVersion: ?*?*i32,
                phFileMapping: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISearchCrawlScopeManager.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCrawlScopeManager2_GetVersion(self: *const T, plVersion: ?*?*i32, phFileMapping: ?*?HANDLE) HRESULT {
                return @as(*const ISearchCrawlScopeManager2.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const ISearchCrawlScopeManager2, @ptrCast(self)), plVersion, phFileMapping);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_KIND_OF_CHANGE = enum(i32) {
    ADD = 0,
    DELETE = 1,
    MODIFY = 2,
    MOVE_RENAME = 3,
    SEMANTICS_DIRECTORY = 262144,
    SEMANTICS_SHALLOW = 524288,
    SEMANTICS_UPDATE_SECURITY = 4194304,
};
pub const SEARCH_CHANGE_ADD = SEARCH_KIND_OF_CHANGE.ADD;
pub const SEARCH_CHANGE_DELETE = SEARCH_KIND_OF_CHANGE.DELETE;
pub const SEARCH_CHANGE_MODIFY = SEARCH_KIND_OF_CHANGE.MODIFY;
pub const SEARCH_CHANGE_MOVE_RENAME = SEARCH_KIND_OF_CHANGE.MOVE_RENAME;
pub const SEARCH_CHANGE_SEMANTICS_DIRECTORY = SEARCH_KIND_OF_CHANGE.SEMANTICS_DIRECTORY;
pub const SEARCH_CHANGE_SEMANTICS_SHALLOW = SEARCH_KIND_OF_CHANGE.SEMANTICS_SHALLOW;
pub const SEARCH_CHANGE_SEMANTICS_UPDATE_SECURITY = SEARCH_KIND_OF_CHANGE.SEMANTICS_UPDATE_SECURITY;

pub const SEARCH_NOTIFICATION_PRIORITY = enum(i32) {
    NORMAL_PRIORITY = 0,
    HIGH_PRIORITY = 1,
};
pub const SEARCH_NORMAL_PRIORITY = SEARCH_NOTIFICATION_PRIORITY.NORMAL_PRIORITY;
pub const SEARCH_HIGH_PRIORITY = SEARCH_NOTIFICATION_PRIORITY.HIGH_PRIORITY;

pub const SEARCH_ITEM_CHANGE = extern struct {
    Change: SEARCH_KIND_OF_CHANGE,
    Priority: SEARCH_NOTIFICATION_PRIORITY,
    pUserData: ?*BLOB,
    lpwszURL: ?PWSTR,
    lpwszOldURL: ?PWSTR,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchItemsChangedSink_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef58");
pub const IID_ISearchItemsChangedSink = &IID_ISearchItemsChangedSink_Value;
pub const ISearchItemsChangedSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartedMonitoringScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchItemsChangedSink,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchItemsChangedSink,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StoppedMonitoringScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchItemsChangedSink,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchItemsChangedSink,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnItemsChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchItemsChangedSink,
                dwNumberOfChanges: u32,
                rgDataChangeEntries: [*]SEARCH_ITEM_CHANGE,
                rgdwDocIds: [*]u32,
                rghrCompletionCodes: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchItemsChangedSink,
                dwNumberOfChanges: u32,
                rgDataChangeEntries: [*]SEARCH_ITEM_CHANGE,
                rgdwDocIds: [*]u32,
                rghrCompletionCodes: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchItemsChangedSink_StartedMonitoringScope(self: *const T, pszURL: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchItemsChangedSink.VTable, @ptrCast(self.vtable)).StartedMonitoringScope(@as(*const ISearchItemsChangedSink, @ptrCast(self)), pszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchItemsChangedSink_StoppedMonitoringScope(self: *const T, pszURL: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchItemsChangedSink.VTable, @ptrCast(self.vtable)).StoppedMonitoringScope(@as(*const ISearchItemsChangedSink, @ptrCast(self)), pszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchItemsChangedSink_OnItemsChanged(self: *const T, dwNumberOfChanges: u32, rgDataChangeEntries: [*]SEARCH_ITEM_CHANGE, rgdwDocIds: [*]u32, rghrCompletionCodes: [*]HRESULT) HRESULT {
                return @as(*const ISearchItemsChangedSink.VTable, @ptrCast(self.vtable)).OnItemsChanged(@as(*const ISearchItemsChangedSink, @ptrCast(self)), dwNumberOfChanges, rgDataChangeEntries, rgdwDocIds, rghrCompletionCodes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_ITEM_PERSISTENT_CHANGE = extern struct {
    Change: SEARCH_KIND_OF_CHANGE,
    URL: ?PWSTR,
    OldURL: ?PWSTR,
    Priority: SEARCH_NOTIFICATION_PRIORITY,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchPersistentItemsChangedSink_Value = Guid.initString("a2ffdf9b-4758-4f84-b729-df81a1a0612f");
pub const IID_ISearchPersistentItemsChangedSink = &IID_ISearchPersistentItemsChangedSink_Value;
pub const ISearchPersistentItemsChangedSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartedMonitoringScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchPersistentItemsChangedSink,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchPersistentItemsChangedSink,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StoppedMonitoringScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchPersistentItemsChangedSink,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchPersistentItemsChangedSink,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnItemsChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchPersistentItemsChangedSink,
                dwNumberOfChanges: u32,
                DataChangeEntries: [*]SEARCH_ITEM_PERSISTENT_CHANGE,
                hrCompletionCodes: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchPersistentItemsChangedSink,
                dwNumberOfChanges: u32,
                DataChangeEntries: [*]SEARCH_ITEM_PERSISTENT_CHANGE,
                hrCompletionCodes: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchPersistentItemsChangedSink_StartedMonitoringScope(self: *const T, pszURL: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchPersistentItemsChangedSink.VTable, @ptrCast(self.vtable)).StartedMonitoringScope(@as(*const ISearchPersistentItemsChangedSink, @ptrCast(self)), pszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchPersistentItemsChangedSink_StoppedMonitoringScope(self: *const T, pszURL: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchPersistentItemsChangedSink.VTable, @ptrCast(self.vtable)).StoppedMonitoringScope(@as(*const ISearchPersistentItemsChangedSink, @ptrCast(self)), pszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchPersistentItemsChangedSink_OnItemsChanged(self: *const T, dwNumberOfChanges: u32, DataChangeEntries: [*]SEARCH_ITEM_PERSISTENT_CHANGE, hrCompletionCodes: [*]HRESULT) HRESULT {
                return @as(*const ISearchPersistentItemsChangedSink.VTable, @ptrCast(self.vtable)).OnItemsChanged(@as(*const ISearchPersistentItemsChangedSink, @ptrCast(self)), dwNumberOfChanges, DataChangeEntries, hrCompletionCodes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchViewChangedSink_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef65");
pub const IID_ISearchViewChangedSink = &IID_ISearchViewChangedSink_Value;
pub const ISearchViewChangedSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchViewChangedSink,
                pdwDocID: ?*i32,
                pChange: ?*SEARCH_ITEM_CHANGE,
                pfInView: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchViewChangedSink,
                pdwDocID: ?*i32,
                pChange: ?*SEARCH_ITEM_CHANGE,
                pfInView: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchViewChangedSink_OnChange(self: *const T, pdwDocID: ?*i32, pChange: ?*SEARCH_ITEM_CHANGE, pfInView: ?*BOOL) HRESULT {
                return @as(*const ISearchViewChangedSink.VTable, @ptrCast(self.vtable)).OnChange(@as(*const ISearchViewChangedSink, @ptrCast(self)), pdwDocID, pChange, pfInView);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_INDEXING_PHASE = enum(i32) {
    GATHERER = 0,
    QUERYABLE = 1,
    PERSISTED = 2,
};
pub const SEARCH_INDEXING_PHASE_GATHERER = SEARCH_INDEXING_PHASE.GATHERER;
pub const SEARCH_INDEXING_PHASE_QUERYABLE = SEARCH_INDEXING_PHASE.QUERYABLE;
pub const SEARCH_INDEXING_PHASE_PERSISTED = SEARCH_INDEXING_PHASE.PERSISTED;

pub const SEARCH_ITEM_INDEXING_STATUS = extern struct {
    dwDocID: u32,
    hrIndexingStatus: HRESULT,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchNotifyInlineSite_Value = Guid.initString("b5702e61-e75c-4b64-82a1-6cb4f832fccf");
pub const IID_ISearchNotifyInlineSite = &IID_ISearchNotifyInlineSite_Value;
pub const ISearchNotifyInlineSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnItemIndexedStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchNotifyInlineSite,
                sipStatus: SEARCH_INDEXING_PHASE,
                dwNumEntries: u32,
                rgItemStatusEntries: [*]SEARCH_ITEM_INDEXING_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchNotifyInlineSite,
                sipStatus: SEARCH_INDEXING_PHASE,
                dwNumEntries: u32,
                rgItemStatusEntries: [*]SEARCH_ITEM_INDEXING_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCatalogStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchNotifyInlineSite,
                guidCatalogResetSignature: ?*const Guid,
                guidCheckPointSignature: ?*const Guid,
                dwLastCheckPointNumber: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchNotifyInlineSite,
                guidCatalogResetSignature: ?*const Guid,
                guidCheckPointSignature: ?*const Guid,
                dwLastCheckPointNumber: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchNotifyInlineSite_OnItemIndexedStatusChange(self: *const T, sipStatus: SEARCH_INDEXING_PHASE, dwNumEntries: u32, rgItemStatusEntries: [*]SEARCH_ITEM_INDEXING_STATUS) HRESULT {
                return @as(*const ISearchNotifyInlineSite.VTable, @ptrCast(self.vtable)).OnItemIndexedStatusChange(@as(*const ISearchNotifyInlineSite, @ptrCast(self)), sipStatus, dwNumEntries, rgItemStatusEntries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchNotifyInlineSite_OnCatalogStatusChange(self: *const T, guidCatalogResetSignature: ?*const Guid, guidCheckPointSignature: ?*const Guid, dwLastCheckPointNumber: u32) HRESULT {
                return @as(*const ISearchNotifyInlineSite.VTable, @ptrCast(self.vtable)).OnCatalogStatusChange(@as(*const ISearchNotifyInlineSite, @ptrCast(self)), guidCatalogResetSignature, guidCheckPointSignature, dwLastCheckPointNumber);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CatalogStatus = enum(i32) {
    IDLE = 0,
    PAUSED = 1,
    RECOVERING = 2,
    FULL_CRAWL = 3,
    INCREMENTAL_CRAWL = 4,
    PROCESSING_NOTIFICATIONS = 5,
    SHUTTING_DOWN = 6,
};
pub const CATALOG_STATUS_IDLE = CatalogStatus.IDLE;
pub const CATALOG_STATUS_PAUSED = CatalogStatus.PAUSED;
pub const CATALOG_STATUS_RECOVERING = CatalogStatus.RECOVERING;
pub const CATALOG_STATUS_FULL_CRAWL = CatalogStatus.FULL_CRAWL;
pub const CATALOG_STATUS_INCREMENTAL_CRAWL = CatalogStatus.INCREMENTAL_CRAWL;
pub const CATALOG_STATUS_PROCESSING_NOTIFICATIONS = CatalogStatus.PROCESSING_NOTIFICATIONS;
pub const CATALOG_STATUS_SHUTTING_DOWN = CatalogStatus.SHUTTING_DOWN;

pub const CatalogPausedReason = enum(i32) {
    NONE = 0,
    HIGH_IO = 1,
    HIGH_CPU = 2,
    HIGH_NTF_RATE = 3,
    LOW_BATTERY = 4,
    LOW_MEMORY = 5,
    LOW_DISK = 6,
    DELAYED_RECOVERY = 7,
    USER_ACTIVE = 8,
    EXTERNAL = 9,
    UPGRADING = 10,
};
pub const CATALOG_PAUSED_REASON_NONE = CatalogPausedReason.NONE;
pub const CATALOG_PAUSED_REASON_HIGH_IO = CatalogPausedReason.HIGH_IO;
pub const CATALOG_PAUSED_REASON_HIGH_CPU = CatalogPausedReason.HIGH_CPU;
pub const CATALOG_PAUSED_REASON_HIGH_NTF_RATE = CatalogPausedReason.HIGH_NTF_RATE;
pub const CATALOG_PAUSED_REASON_LOW_BATTERY = CatalogPausedReason.LOW_BATTERY;
pub const CATALOG_PAUSED_REASON_LOW_MEMORY = CatalogPausedReason.LOW_MEMORY;
pub const CATALOG_PAUSED_REASON_LOW_DISK = CatalogPausedReason.LOW_DISK;
pub const CATALOG_PAUSED_REASON_DELAYED_RECOVERY = CatalogPausedReason.DELAYED_RECOVERY;
pub const CATALOG_PAUSED_REASON_USER_ACTIVE = CatalogPausedReason.USER_ACTIVE;
pub const CATALOG_PAUSED_REASON_EXTERNAL = CatalogPausedReason.EXTERNAL;
pub const CATALOG_PAUSED_REASON_UPGRADING = CatalogPausedReason.UPGRADING;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCatalogManager_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef50");
pub const IID_ISearchCatalogManager = &IID_ISearchCatalogManager_Value;
pub const ISearchCatalogManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchCatalogManager,
                pszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pszName: ?[*:0]const u16,
                ppValue: ?*?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pszName: ?[*:0]const u16,
                ppValue: ?*?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParameter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pszName: ?[*:0]const u16,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pszName: ?[*:0]const u16,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCatalogStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pStatus: ?*CatalogStatus,
                pPausedReason: ?*CatalogPausedReason,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pStatus: ?*CatalogStatus,
                pPausedReason: ?*CatalogPausedReason,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reindex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReindexMatchingURLs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pszPattern: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pszPattern: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReindexSearchRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pszRootURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pszRootURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                dwConnectTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchCatalogManager,
                dwConnectTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pdwConnectTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchCatalogManager,
                pdwConnectTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DataTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                dwDataTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchCatalogManager,
                dwDataTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pdwDataTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchCatalogManager,
                pdwDataTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NumberOfItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NumberOfItemsToIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                plIncrementalCount: ?*i32,
                plNotificationQueue: ?*i32,
                plHighPriorityQueue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                plIncrementalCount: ?*i32,
                plNotificationQueue: ?*i32,
                plHighPriorityQueue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        URLBeingIndexed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetURLIndexingState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pszURL: ?[*:0]const u16,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pszURL: ?[*:0]const u16,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPersistentItemsChangedSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                ppISearchPersistentItemsChangedSink: ?*?*ISearchPersistentItemsChangedSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                ppISearchPersistentItemsChangedSink: ?*?*ISearchPersistentItemsChangedSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterViewForNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pszView: ?[*:0]const u16,
                pViewChangedSink: ?*ISearchViewChangedSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pszView: ?[*:0]const u16,
                pViewChangedSink: ?*ISearchViewChangedSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemsChangedSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pISearchNotifyInlineSite: ?*ISearchNotifyInlineSite,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
                pGUIDCatalogResetSignature: ?*Guid,
                pGUIDCheckPointSignature: ?*Guid,
                pdwLastCheckPointNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pISearchNotifyInlineSite: ?*ISearchNotifyInlineSite,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
                pGUIDCatalogResetSignature: ?*Guid,
                pGUIDCheckPointSignature: ?*Guid,
                pdwLastCheckPointNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterViewForNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExtensionClusion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pszExtension: ?[*:0]const u16,
                fExclude: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                pszExtension: ?[*:0]const u16,
                fExclude: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateExcludedExtensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                ppExtensions: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                ppExtensions: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQueryHelper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                ppSearchQueryHelper: ?*?*ISearchQueryHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                ppSearchQueryHelper: ?*?*ISearchQueryHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiacriticSensitivity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                fDiacriticSensitive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchCatalogManager,
                fDiacriticSensitive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiacriticSensitivity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                pfDiacriticSensitive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchCatalogManager,
                pfDiacriticSensitive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCrawlScopeManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager,
                ppCrawlScopeManager: ?*?*ISearchCrawlScopeManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager,
                ppCrawlScopeManager: ?*?*ISearchCrawlScopeManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_get_Name(self: *const T, pszName: ?*?PWSTR) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ISearchCatalogManager, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_GetParameter(self: *const T, pszName: ?[*:0]const u16, ppValue: ?*?*PROPVARIANT) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetParameter(@as(*const ISearchCatalogManager, @ptrCast(self)), pszName, ppValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_SetParameter(self: *const T, pszName: ?[*:0]const u16, pValue: ?*PROPVARIANT) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).SetParameter(@as(*const ISearchCatalogManager, @ptrCast(self)), pszName, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_GetCatalogStatus(self: *const T, pStatus: ?*CatalogStatus, pPausedReason: ?*CatalogPausedReason) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetCatalogStatus(@as(*const ISearchCatalogManager, @ptrCast(self)), pStatus, pPausedReason);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_Reset(self: *const T) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISearchCatalogManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_Reindex(self: *const T) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).Reindex(@as(*const ISearchCatalogManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_ReindexMatchingURLs(self: *const T, pszPattern: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).ReindexMatchingURLs(@as(*const ISearchCatalogManager, @ptrCast(self)), pszPattern);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_ReindexSearchRoot(self: *const T, pszRootURL: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).ReindexSearchRoot(@as(*const ISearchCatalogManager, @ptrCast(self)), pszRootURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_put_ConnectTimeout(self: *const T, dwConnectTimeout: u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).put_ConnectTimeout(@as(*const ISearchCatalogManager, @ptrCast(self)), dwConnectTimeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_get_ConnectTimeout(self: *const T, pdwConnectTimeout: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).get_ConnectTimeout(@as(*const ISearchCatalogManager, @ptrCast(self)), pdwConnectTimeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_put_DataTimeout(self: *const T, dwDataTimeout: u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).put_DataTimeout(@as(*const ISearchCatalogManager, @ptrCast(self)), dwDataTimeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_get_DataTimeout(self: *const T, pdwDataTimeout: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).get_DataTimeout(@as(*const ISearchCatalogManager, @ptrCast(self)), pdwDataTimeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_NumberOfItems(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).NumberOfItems(@as(*const ISearchCatalogManager, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_NumberOfItemsToIndex(self: *const T, plIncrementalCount: ?*i32, plNotificationQueue: ?*i32, plHighPriorityQueue: ?*i32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).NumberOfItemsToIndex(@as(*const ISearchCatalogManager, @ptrCast(self)), plIncrementalCount, plNotificationQueue, plHighPriorityQueue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_URLBeingIndexed(self: *const T, pszUrl: ?*?PWSTR) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).URLBeingIndexed(@as(*const ISearchCatalogManager, @ptrCast(self)), pszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_GetURLIndexingState(self: *const T, pszURL: ?[*:0]const u16, pdwState: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetURLIndexingState(@as(*const ISearchCatalogManager, @ptrCast(self)), pszURL, pdwState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_GetPersistentItemsChangedSink(self: *const T, ppISearchPersistentItemsChangedSink: ?*?*ISearchPersistentItemsChangedSink) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetPersistentItemsChangedSink(@as(*const ISearchCatalogManager, @ptrCast(self)), ppISearchPersistentItemsChangedSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_RegisterViewForNotification(self: *const T, pszView: ?[*:0]const u16, pViewChangedSink: ?*ISearchViewChangedSink, pdwCookie: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).RegisterViewForNotification(@as(*const ISearchCatalogManager, @ptrCast(self)), pszView, pViewChangedSink, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_GetItemsChangedSink(self: *const T, pISearchNotifyInlineSite: ?*ISearchNotifyInlineSite, riid: ?*const Guid, ppv: ?*?*anyopaque, pGUIDCatalogResetSignature: ?*Guid, pGUIDCheckPointSignature: ?*Guid, pdwLastCheckPointNumber: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetItemsChangedSink(@as(*const ISearchCatalogManager, @ptrCast(self)), pISearchNotifyInlineSite, riid, ppv, pGUIDCatalogResetSignature, pGUIDCheckPointSignature, pdwLastCheckPointNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_UnregisterViewForNotification(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).UnregisterViewForNotification(@as(*const ISearchCatalogManager, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_SetExtensionClusion(self: *const T, pszExtension: ?[*:0]const u16, fExclude: BOOL) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).SetExtensionClusion(@as(*const ISearchCatalogManager, @ptrCast(self)), pszExtension, fExclude);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_EnumerateExcludedExtensions(self: *const T, ppExtensions: ?*?*IEnumString) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).EnumerateExcludedExtensions(@as(*const ISearchCatalogManager, @ptrCast(self)), ppExtensions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_GetQueryHelper(self: *const T, ppSearchQueryHelper: ?*?*ISearchQueryHelper) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetQueryHelper(@as(*const ISearchCatalogManager, @ptrCast(self)), ppSearchQueryHelper);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_put_DiacriticSensitivity(self: *const T, fDiacriticSensitive: BOOL) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).put_DiacriticSensitivity(@as(*const ISearchCatalogManager, @ptrCast(self)), fDiacriticSensitive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_get_DiacriticSensitivity(self: *const T, pfDiacriticSensitive: ?*BOOL) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).get_DiacriticSensitivity(@as(*const ISearchCatalogManager, @ptrCast(self)), pfDiacriticSensitive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager_GetCrawlScopeManager(self: *const T, ppCrawlScopeManager: ?*?*ISearchCrawlScopeManager) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetCrawlScopeManager(@as(*const ISearchCatalogManager, @ptrCast(self)), ppCrawlScopeManager);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PRIORITIZE_FLAGS = enum(i32) {
    RETRYFAILEDITEMS = 1,
    IGNOREFAILURECOUNT = 2,
};
pub const PRIORITIZE_FLAG_RETRYFAILEDITEMS = PRIORITIZE_FLAGS.RETRYFAILEDITEMS;
pub const PRIORITIZE_FLAG_IGNOREFAILURECOUNT = PRIORITIZE_FLAGS.IGNOREFAILURECOUNT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCatalogManager2_Value = Guid.initString("7ac3286d-4d1d-4817-84fc-c1c85e3af0d9");
pub const IID_ISearchCatalogManager2 = &IID_ISearchCatalogManager2_Value;
pub const ISearchCatalogManager2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchCatalogManager.VTable,
        PrioritizeMatchingURLs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchCatalogManager2,
                pszPattern: ?[*:0]const u16,
                dwPrioritizeFlags: PRIORITIZE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchCatalogManager2,
                pszPattern: ?[*:0]const u16,
                dwPrioritizeFlags: PRIORITIZE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISearchCatalogManager.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchCatalogManager2_PrioritizeMatchingURLs(self: *const T, pszPattern: ?[*:0]const u16, dwPrioritizeFlags: PRIORITIZE_FLAGS) HRESULT {
                return @as(*const ISearchCatalogManager2.VTable, @ptrCast(self.vtable)).PrioritizeMatchingURLs(@as(*const ISearchCatalogManager2, @ptrCast(self)), pszPattern, dwPrioritizeFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_TERM_EXPANSION = enum(i32) {
    NO_EXPANSION = 0,
    PREFIX_ALL = 1,
    STEM_ALL = 2,
};
pub const SEARCH_TERM_NO_EXPANSION = SEARCH_TERM_EXPANSION.NO_EXPANSION;
pub const SEARCH_TERM_PREFIX_ALL = SEARCH_TERM_EXPANSION.PREFIX_ALL;
pub const SEARCH_TERM_STEM_ALL = SEARCH_TERM_EXPANSION.STEM_ALL;

pub const SEARCH_QUERY_SYNTAX = enum(i32) {
    NO_QUERY_SYNTAX = 0,
    ADVANCED_QUERY_SYNTAX = 1,
    NATURAL_QUERY_SYNTAX = 2,
};
pub const SEARCH_NO_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.NO_QUERY_SYNTAX;
pub const SEARCH_ADVANCED_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.ADVANCED_QUERY_SYNTAX;
pub const SEARCH_NATURAL_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.NATURAL_QUERY_SYNTAX;

pub const SEARCH_COLUMN_PROPERTIES = extern struct {
    Value: PROPVARIANT,
    lcid: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchQueryHelper_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef63");
pub const IID_ISearchQueryHelper = &IID_ISearchQueryHelper_Value;
pub const ISearchQueryHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                pszConnectionString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                pszConnectionString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryContentLocale: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryContentLocale: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryKeywordLocale: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryKeywordLocale: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryTermExpansion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                expandTerms: SEARCH_TERM_EXPANSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                expandTerms: SEARCH_TERM_EXPANSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryTermExpansion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                pExpandTerms: ?*SEARCH_TERM_EXPANSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                pExpandTerms: ?*SEARCH_TERM_EXPANSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuerySyntax: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                querySyntax: SEARCH_QUERY_SYNTAX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                querySyntax: SEARCH_QUERY_SYNTAX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuerySyntax: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                pQuerySyntax: ?*SEARCH_QUERY_SYNTAX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                pQuerySyntax: ?*SEARCH_QUERY_SYNTAX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryContentProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                pszContentProperties: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                pszContentProperties: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryContentProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                ppszContentProperties: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                ppszContentProperties: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuerySelectColumns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                pszSelectColumns: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                pszSelectColumns: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuerySelectColumns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                ppszSelectColumns: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                ppszSelectColumns: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryWhereRestrictions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                pszRestrictions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                pszRestrictions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryWhereRestrictions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                ppszRestrictions: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                ppszRestrictions: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuerySorting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                pszSorting: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                pszSorting: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuerySorting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                ppszSorting: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                ppszSorting: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateSQLFromUserQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                pszQuery: ?[*:0]const u16,
                ppszSQL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchQueryHelper,
                pszQuery: ?[*:0]const u16,
                ppszSQL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                itemID: i32,
                dwNumberOfColumns: u32,
                pColumns: [*]PROPERTYKEY,
                pValues: [*]SEARCH_COLUMN_PROPERTIES,
                pftGatherModifiedTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchQueryHelper,
                itemID: i32,
                dwNumberOfColumns: u32,
                pColumns: [*]PROPERTYKEY,
                pValues: [*]SEARCH_COLUMN_PROPERTIES,
                pftGatherModifiedTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryMaxResults: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                cMaxResults: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                cMaxResults: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryMaxResults: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchQueryHelper,
                pcMaxResults: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchQueryHelper,
                pcMaxResults: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_ConnectionString(self: *const T, pszConnectionString: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_ConnectionString(@as(*const ISearchQueryHelper, @ptrCast(self)), pszConnectionString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_put_QueryContentLocale(self: *const T, lcid: u32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryContentLocale(@as(*const ISearchQueryHelper, @ptrCast(self)), lcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_QueryContentLocale(self: *const T, plcid: ?*u32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryContentLocale(@as(*const ISearchQueryHelper, @ptrCast(self)), plcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_put_QueryKeywordLocale(self: *const T, lcid: u32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryKeywordLocale(@as(*const ISearchQueryHelper, @ptrCast(self)), lcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_QueryKeywordLocale(self: *const T, plcid: ?*u32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryKeywordLocale(@as(*const ISearchQueryHelper, @ptrCast(self)), plcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_put_QueryTermExpansion(self: *const T, expandTerms: SEARCH_TERM_EXPANSION) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryTermExpansion(@as(*const ISearchQueryHelper, @ptrCast(self)), expandTerms);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_QueryTermExpansion(self: *const T, pExpandTerms: ?*SEARCH_TERM_EXPANSION) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryTermExpansion(@as(*const ISearchQueryHelper, @ptrCast(self)), pExpandTerms);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_put_QuerySyntax(self: *const T, querySyntax: SEARCH_QUERY_SYNTAX) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QuerySyntax(@as(*const ISearchQueryHelper, @ptrCast(self)), querySyntax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_QuerySyntax(self: *const T, pQuerySyntax: ?*SEARCH_QUERY_SYNTAX) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QuerySyntax(@as(*const ISearchQueryHelper, @ptrCast(self)), pQuerySyntax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_put_QueryContentProperties(self: *const T, pszContentProperties: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryContentProperties(@as(*const ISearchQueryHelper, @ptrCast(self)), pszContentProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_QueryContentProperties(self: *const T, ppszContentProperties: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryContentProperties(@as(*const ISearchQueryHelper, @ptrCast(self)), ppszContentProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_put_QuerySelectColumns(self: *const T, pszSelectColumns: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QuerySelectColumns(@as(*const ISearchQueryHelper, @ptrCast(self)), pszSelectColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_QuerySelectColumns(self: *const T, ppszSelectColumns: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QuerySelectColumns(@as(*const ISearchQueryHelper, @ptrCast(self)), ppszSelectColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_put_QueryWhereRestrictions(self: *const T, pszRestrictions: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryWhereRestrictions(@as(*const ISearchQueryHelper, @ptrCast(self)), pszRestrictions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_QueryWhereRestrictions(self: *const T, ppszRestrictions: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryWhereRestrictions(@as(*const ISearchQueryHelper, @ptrCast(self)), ppszRestrictions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_put_QuerySorting(self: *const T, pszSorting: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QuerySorting(@as(*const ISearchQueryHelper, @ptrCast(self)), pszSorting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_QuerySorting(self: *const T, ppszSorting: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QuerySorting(@as(*const ISearchQueryHelper, @ptrCast(self)), ppszSorting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_GenerateSQLFromUserQuery(self: *const T, pszQuery: ?[*:0]const u16, ppszSQL: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).GenerateSQLFromUserQuery(@as(*const ISearchQueryHelper, @ptrCast(self)), pszQuery, ppszSQL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_WriteProperties(self: *const T, itemID: i32, dwNumberOfColumns: u32, pColumns: [*]PROPERTYKEY, pValues: [*]SEARCH_COLUMN_PROPERTIES, pftGatherModifiedTime: ?*FILETIME) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).WriteProperties(@as(*const ISearchQueryHelper, @ptrCast(self)), itemID, dwNumberOfColumns, pColumns, pValues, pftGatherModifiedTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_put_QueryMaxResults(self: *const T, cMaxResults: i32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryMaxResults(@as(*const ISearchQueryHelper, @ptrCast(self)), cMaxResults);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHelper_get_QueryMaxResults(self: *const T, pcMaxResults: ?*i32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryMaxResults(@as(*const ISearchQueryHelper, @ptrCast(self)), pcMaxResults);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PRIORITY_LEVEL = enum(i32) {
    FOREGROUND = 0,
    HIGH = 1,
    LOW = 2,
    DEFAULT = 3,
};
pub const PRIORITY_LEVEL_FOREGROUND = PRIORITY_LEVEL.FOREGROUND;
pub const PRIORITY_LEVEL_HIGH = PRIORITY_LEVEL.HIGH;
pub const PRIORITY_LEVEL_LOW = PRIORITY_LEVEL.LOW;
pub const PRIORITY_LEVEL_DEFAULT = PRIORITY_LEVEL.DEFAULT;

// TODO: this type is limited to platform 'windows6.1'
const IID_IRowsetPrioritization_Value = Guid.initString("42811652-079d-481b-87a2-09a69ecc5f44");
pub const IID_IRowsetPrioritization = &IID_IRowsetPrioritization_Value;
pub const IRowsetPrioritization = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetScopePriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetPrioritization,
                priority: PRIORITY_LEVEL,
                scopeStatisticsEventFrequency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetPrioritization,
                priority: PRIORITY_LEVEL,
                scopeStatisticsEventFrequency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopePriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetPrioritization,
                priority: ?*PRIORITY_LEVEL,
                scopeStatisticsEventFrequency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetPrioritization,
                priority: ?*PRIORITY_LEVEL,
                scopeStatisticsEventFrequency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetPrioritization,
                indexedDocumentCount: ?*u32,
                oustandingAddCount: ?*u32,
                oustandingModifyCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetPrioritization,
                indexedDocumentCount: ?*u32,
                oustandingAddCount: ?*u32,
                oustandingModifyCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetPrioritization_SetScopePriority(self: *const T, priority: PRIORITY_LEVEL, scopeStatisticsEventFrequency: u32) HRESULT {
                return @as(*const IRowsetPrioritization.VTable, @ptrCast(self.vtable)).SetScopePriority(@as(*const IRowsetPrioritization, @ptrCast(self)), priority, scopeStatisticsEventFrequency);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetPrioritization_GetScopePriority(self: *const T, priority: ?*PRIORITY_LEVEL, scopeStatisticsEventFrequency: ?*u32) HRESULT {
                return @as(*const IRowsetPrioritization.VTable, @ptrCast(self.vtable)).GetScopePriority(@as(*const IRowsetPrioritization, @ptrCast(self)), priority, scopeStatisticsEventFrequency);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetPrioritization_GetScopeStatistics(self: *const T, indexedDocumentCount: ?*u32, oustandingAddCount: ?*u32, oustandingModifyCount: ?*u32) HRESULT {
                return @as(*const IRowsetPrioritization.VTable, @ptrCast(self.vtable)).GetScopeStatistics(@as(*const IRowsetPrioritization, @ptrCast(self)), indexedDocumentCount, oustandingAddCount, oustandingModifyCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ROWSETEVENT_ITEMSTATE = enum(i32) {
    NOTINROWSET = 0,
    INROWSET = 1,
    UNKNOWN = 2,
};
pub const ROWSETEVENT_ITEMSTATE_NOTINROWSET = ROWSETEVENT_ITEMSTATE.NOTINROWSET;
pub const ROWSETEVENT_ITEMSTATE_INROWSET = ROWSETEVENT_ITEMSTATE.INROWSET;
pub const ROWSETEVENT_ITEMSTATE_UNKNOWN = ROWSETEVENT_ITEMSTATE.UNKNOWN;

pub const ROWSETEVENT_TYPE = enum(i32) {
    DATAEXPIRED = 0,
    FOREGROUNDLOST = 1,
    SCOPESTATISTICS = 2,
};
pub const ROWSETEVENT_TYPE_DATAEXPIRED = ROWSETEVENT_TYPE.DATAEXPIRED;
pub const ROWSETEVENT_TYPE_FOREGROUNDLOST = ROWSETEVENT_TYPE.FOREGROUNDLOST;
pub const ROWSETEVENT_TYPE_SCOPESTATISTICS = ROWSETEVENT_TYPE.SCOPESTATISTICS;

// TODO: this type is limited to platform 'windows6.1'
const IID_IRowsetEvents_Value = Guid.initString("1551aea5-5d66-4b11-86f5-d5634cb211b9");
pub const IID_IRowsetEvents = &IID_IRowsetEvents_Value;
pub const IRowsetEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNewItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetEvents,
                itemID: ?*const PROPVARIANT,
                newItemState: ROWSETEVENT_ITEMSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetEvents,
                itemID: ?*const PROPVARIANT,
                newItemState: ROWSETEVENT_ITEMSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnChangedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetEvents,
                itemID: ?*const PROPVARIANT,
                rowsetItemState: ROWSETEVENT_ITEMSTATE,
                changedItemState: ROWSETEVENT_ITEMSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetEvents,
                itemID: ?*const PROPVARIANT,
                rowsetItemState: ROWSETEVENT_ITEMSTATE,
                changedItemState: ROWSETEVENT_ITEMSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDeletedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetEvents,
                itemID: ?*const PROPVARIANT,
                deletedItemState: ROWSETEVENT_ITEMSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetEvents,
                itemID: ?*const PROPVARIANT,
                deletedItemState: ROWSETEVENT_ITEMSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnRowsetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetEvents,
                eventType: ROWSETEVENT_TYPE,
                eventData: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetEvents,
                eventType: ROWSETEVENT_TYPE,
                eventData: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetEvents_OnNewItem(self: *const T, itemID: ?*const PROPVARIANT, newItemState: ROWSETEVENT_ITEMSTATE) HRESULT {
                return @as(*const IRowsetEvents.VTable, @ptrCast(self.vtable)).OnNewItem(@as(*const IRowsetEvents, @ptrCast(self)), itemID, newItemState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetEvents_OnChangedItem(self: *const T, itemID: ?*const PROPVARIANT, rowsetItemState: ROWSETEVENT_ITEMSTATE, changedItemState: ROWSETEVENT_ITEMSTATE) HRESULT {
                return @as(*const IRowsetEvents.VTable, @ptrCast(self.vtable)).OnChangedItem(@as(*const IRowsetEvents, @ptrCast(self)), itemID, rowsetItemState, changedItemState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetEvents_OnDeletedItem(self: *const T, itemID: ?*const PROPVARIANT, deletedItemState: ROWSETEVENT_ITEMSTATE) HRESULT {
                return @as(*const IRowsetEvents.VTable, @ptrCast(self.vtable)).OnDeletedItem(@as(*const IRowsetEvents, @ptrCast(self)), itemID, deletedItemState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetEvents_OnRowsetEvent(self: *const T, eventType: ROWSETEVENT_TYPE, eventData: ?*const PROPVARIANT) HRESULT {
                return @as(*const IRowsetEvents.VTable, @ptrCast(self.vtable)).OnRowsetEvent(@as(*const IRowsetEvents, @ptrCast(self)), eventType, eventData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchManager_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef69");
pub const IID_ISearchManager = &IID_ISearchManager_Value;
pub const ISearchManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIndexerVersionStr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchManager,
                ppszVersionString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchManager,
                ppszVersionString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexerVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchManager,
                pdwMajor: ?*u32,
                pdwMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchManager,
                pdwMajor: ?*u32,
                pdwMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchManager,
                pszName: ?[*:0]const u16,
                ppValue: ?*?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchManager,
                pszName: ?[*:0]const u16,
                ppValue: ?*?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParameter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchManager,
                pszName: ?[*:0]const u16,
                pValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchManager,
                pszName: ?[*:0]const u16,
                pValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProxyName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchManager,
                ppszProxyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchManager,
                ppszProxyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BypassList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchManager,
                ppszBypassList: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchManager,
                ppszBypassList: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProxy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchManager,
                sUseProxy: PROXY_ACCESS,
                fLocalByPassProxy: BOOL,
                dwPortNumber: u32,
                pszProxyName: ?[*:0]const u16,
                pszByPassList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchManager,
                sUseProxy: PROXY_ACCESS,
                fLocalByPassProxy: BOOL,
                dwPortNumber: u32,
                pszProxyName: ?[*:0]const u16,
                pszByPassList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCatalog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchManager,
                pszCatalog: ?[*:0]const u16,
                ppCatalogManager: ?*?*ISearchCatalogManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchManager,
                pszCatalog: ?[*:0]const u16,
                ppCatalogManager: ?*?*ISearchCatalogManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAgent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchManager,
                ppszUserAgent: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchManager,
                ppszUserAgent: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserAgent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchManager,
                pszUserAgent: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchManager,
                pszUserAgent: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseProxy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchManager,
                pUseProxy: ?*PROXY_ACCESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchManager,
                pUseProxy: ?*PROXY_ACCESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalBypass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchManager,
                pfLocalBypass: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchManager,
                pfLocalBypass: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PortNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ISearchManager,
                pdwPortNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ISearchManager,
                pdwPortNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_GetIndexerVersionStr(self: *const T, ppszVersionString: ?*?PWSTR) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).GetIndexerVersionStr(@as(*const ISearchManager, @ptrCast(self)), ppszVersionString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_GetIndexerVersion(self: *const T, pdwMajor: ?*u32, pdwMinor: ?*u32) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).GetIndexerVersion(@as(*const ISearchManager, @ptrCast(self)), pdwMajor, pdwMinor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_GetParameter(self: *const T, pszName: ?[*:0]const u16, ppValue: ?*?*PROPVARIANT) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).GetParameter(@as(*const ISearchManager, @ptrCast(self)), pszName, ppValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_SetParameter(self: *const T, pszName: ?[*:0]const u16, pValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).SetParameter(@as(*const ISearchManager, @ptrCast(self)), pszName, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_get_ProxyName(self: *const T, ppszProxyName: ?*?PWSTR) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_ProxyName(@as(*const ISearchManager, @ptrCast(self)), ppszProxyName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_get_BypassList(self: *const T, ppszBypassList: ?*?PWSTR) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_BypassList(@as(*const ISearchManager, @ptrCast(self)), ppszBypassList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_SetProxy(self: *const T, sUseProxy: PROXY_ACCESS, fLocalByPassProxy: BOOL, dwPortNumber: u32, pszProxyName: ?[*:0]const u16, pszByPassList: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).SetProxy(@as(*const ISearchManager, @ptrCast(self)), sUseProxy, fLocalByPassProxy, dwPortNumber, pszProxyName, pszByPassList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_GetCatalog(self: *const T, pszCatalog: ?[*:0]const u16, ppCatalogManager: ?*?*ISearchCatalogManager) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).GetCatalog(@as(*const ISearchManager, @ptrCast(self)), pszCatalog, ppCatalogManager);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_get_UserAgent(self: *const T, ppszUserAgent: ?*?PWSTR) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_UserAgent(@as(*const ISearchManager, @ptrCast(self)), ppszUserAgent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_put_UserAgent(self: *const T, pszUserAgent: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).put_UserAgent(@as(*const ISearchManager, @ptrCast(self)), pszUserAgent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_get_UseProxy(self: *const T, pUseProxy: ?*PROXY_ACCESS) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_UseProxy(@as(*const ISearchManager, @ptrCast(self)), pUseProxy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_get_LocalBypass(self: *const T, pfLocalBypass: ?*BOOL) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_LocalBypass(@as(*const ISearchManager, @ptrCast(self)), pfLocalBypass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager_get_PortNumber(self: *const T, pdwPortNumber: ?*u32) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_PortNumber(@as(*const ISearchManager, @ptrCast(self)), pdwPortNumber);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISearchManager2_Value = Guid.initString("dbab3f73-db19-4a79-bfc0-a61a93886ddf");
pub const IID_ISearchManager2 = &IID_ISearchManager2_Value;
pub const ISearchManager2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchManager.VTable,
        CreateCatalog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchManager2,
                pszCatalog: ?[*:0]const u16,
                ppCatalogManager: ?*?*ISearchCatalogManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchManager2,
                pszCatalog: ?[*:0]const u16,
                ppCatalogManager: ?*?*ISearchCatalogManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteCatalog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchManager2,
                pszCatalog: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchManager2,
                pszCatalog: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISearchManager.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager2_CreateCatalog(self: *const T, pszCatalog: ?[*:0]const u16, ppCatalogManager: ?*?*ISearchCatalogManager) HRESULT {
                return @as(*const ISearchManager2.VTable, @ptrCast(self.vtable)).CreateCatalog(@as(*const ISearchManager2, @ptrCast(self)), pszCatalog, ppCatalogManager);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchManager2_DeleteCatalog(self: *const T, pszCatalog: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchManager2.VTable, @ptrCast(self.vtable)).DeleteCatalog(@as(*const ISearchManager2, @ptrCast(self)), pszCatalog);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CSearchLanguageSupport_Value = Guid.initString("6a68cc80-4337-4dbc-bd27-fbfb1053820b");
pub const CLSID_CSearchLanguageSupport = &CLSID_CSearchLanguageSupport_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchLanguageSupport_Value = Guid.initString("24c3cbaa-ebc1-491a-9ef1-9f6d8deb1b8f");
pub const IID_ISearchLanguageSupport = &IID_ISearchLanguageSupport_Value;
pub const ISearchLanguageSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDiacriticSensitivity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchLanguageSupport,
                fDiacriticSensitive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchLanguageSupport,
                fDiacriticSensitive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDiacriticSensitivity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchLanguageSupport,
                pfDiacriticSensitive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchLanguageSupport,
                pfDiacriticSensitive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadWordBreaker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchLanguageSupport,
                lcid: u32,
                riid: ?*const Guid,
                ppWordBreaker: ?*?*anyopaque,
                pLcidUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchLanguageSupport,
                lcid: u32,
                riid: ?*const Guid,
                ppWordBreaker: ?*?*anyopaque,
                pLcidUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadStemmer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchLanguageSupport,
                lcid: u32,
                riid: ?*const Guid,
                ppStemmer: ?*?*anyopaque,
                pLcidUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchLanguageSupport,
                lcid: u32,
                riid: ?*const Guid,
                ppStemmer: ?*?*anyopaque,
                pLcidUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPrefixNormalized: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchLanguageSupport,
                pwcsQueryToken: [*:0]const u16,
                cwcQueryToken: u32,
                pwcsDocumentToken: [*:0]const u16,
                cwcDocumentToken: u32,
                pulPrefixLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchLanguageSupport,
                pwcsQueryToken: [*:0]const u16,
                cwcQueryToken: u32,
                pwcsDocumentToken: [*:0]const u16,
                cwcDocumentToken: u32,
                pulPrefixLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchLanguageSupport_SetDiacriticSensitivity(self: *const T, fDiacriticSensitive: BOOL) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).SetDiacriticSensitivity(@as(*const ISearchLanguageSupport, @ptrCast(self)), fDiacriticSensitive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchLanguageSupport_GetDiacriticSensitivity(self: *const T, pfDiacriticSensitive: ?*BOOL) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).GetDiacriticSensitivity(@as(*const ISearchLanguageSupport, @ptrCast(self)), pfDiacriticSensitive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchLanguageSupport_LoadWordBreaker(self: *const T, lcid: u32, riid: ?*const Guid, ppWordBreaker: ?*?*anyopaque, pLcidUsed: ?*u32) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).LoadWordBreaker(@as(*const ISearchLanguageSupport, @ptrCast(self)), lcid, riid, ppWordBreaker, pLcidUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchLanguageSupport_LoadStemmer(self: *const T, lcid: u32, riid: ?*const Guid, ppStemmer: ?*?*anyopaque, pLcidUsed: ?*u32) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).LoadStemmer(@as(*const ISearchLanguageSupport, @ptrCast(self)), lcid, riid, ppStemmer, pLcidUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchLanguageSupport_IsPrefixNormalized(self: *const T, pwcsQueryToken: [*:0]const u16, cwcQueryToken: u32, pwcsDocumentToken: [*:0]const u16, cwcDocumentToken: u32, pulPrefixLength: ?*u32) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).IsPrefixNormalized(@as(*const ISearchLanguageSupport, @ptrCast(self)), pwcsQueryToken, cwcQueryToken, pwcsDocumentToken, cwcDocumentToken, pulPrefixLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SubscriptionMgr_Value = Guid.initString("abbe31d0-6dae-11d0-beca-00c04fd940be");
pub const CLSID_SubscriptionMgr = &CLSID_SubscriptionMgr_Value;

pub const ITEMPROP = extern struct {
    variantValue: VARIANT,
    pwszName: ?PWSTR,
};

const IID_IEnumItemProperties_Value = Guid.initString("f72c8d96-6dbd-11d1-a1e8-00c04fc2fbe1");
pub const IID_IEnumItemProperties = &IID_IEnumItemProperties_Value;
pub const IEnumItemProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumItemProperties,
                celt: u32,
                rgelt: [*]ITEMPROP,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumItemProperties,
                celt: u32,
                rgelt: [*]ITEMPROP,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumItemProperties,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumItemProperties,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumItemProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumItemProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumItemProperties,
                ppenum: ?*?*IEnumItemProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumItemProperties,
                ppenum: ?*?*IEnumItemProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumItemProperties,
                pnCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumItemProperties,
                pnCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumItemProperties_Next(self: *const T, celt: u32, rgelt: [*]ITEMPROP, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumItemProperties, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumItemProperties_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumItemProperties, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumItemProperties_Reset(self: *const T) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumItemProperties, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumItemProperties_Clone(self: *const T, ppenum: ?*?*IEnumItemProperties) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumItemProperties, @ptrCast(self)), ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumItemProperties_GetCount(self: *const T, pnCount: ?*u32) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IEnumItemProperties, @ptrCast(self)), pnCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SUBSCRIPTIONITEMINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwPriority: u32,
    ScheduleGroup: Guid,
    clsidAgent: Guid,
};

const IID_ISubscriptionItem_Value = Guid.initString("a97559f8-6c4a-11d1-a1e8-00c04fc2fbe1");
pub const IID_ISubscriptionItem = &IID_ISubscriptionItem_Value;
pub const ISubscriptionItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionItem,
                pCookie: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionItem,
                pCookie: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubscriptionItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionItem,
                pSubscriptionItemInfo: ?*SUBSCRIPTIONITEMINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionItem,
                pSubscriptionItemInfo: ?*SUBSCRIPTIONITEMINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSubscriptionItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionItem,
                pSubscriptionItemInfo: ?*const SUBSCRIPTIONITEMINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionItem,
                pSubscriptionItemInfo: ?*const SUBSCRIPTIONITEMINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionItem,
                nCount: u32,
                rgwszName: [*]const ?[*:0]const u16,
                rgValue: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionItem,
                nCount: u32,
                rgwszName: [*]const ?[*:0]const u16,
                rgValue: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionItem,
                nCount: u32,
                rgwszName: [*]const ?[*:0]const u16,
                rgValue: [*]const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionItem,
                nCount: u32,
                rgwszName: [*]const ?[*:0]const u16,
                rgValue: [*]const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionItem,
                ppEnumItemProperties: ?*?*IEnumItemProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionItem,
                ppEnumItemProperties: ?*?*IEnumItemProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionItem_GetCookie(self: *const T, pCookie: ?*Guid) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).GetCookie(@as(*const ISubscriptionItem, @ptrCast(self)), pCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionItem_GetSubscriptionItemInfo(self: *const T, pSubscriptionItemInfo: ?*SUBSCRIPTIONITEMINFO) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).GetSubscriptionItemInfo(@as(*const ISubscriptionItem, @ptrCast(self)), pSubscriptionItemInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionItem_SetSubscriptionItemInfo(self: *const T, pSubscriptionItemInfo: ?*const SUBSCRIPTIONITEMINFO) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).SetSubscriptionItemInfo(@as(*const ISubscriptionItem, @ptrCast(self)), pSubscriptionItemInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionItem_ReadProperties(self: *const T, nCount: u32, rgwszName: [*]const ?[*:0]const u16, rgValue: [*]VARIANT) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).ReadProperties(@as(*const ISubscriptionItem, @ptrCast(self)), nCount, rgwszName, rgValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionItem_WriteProperties(self: *const T, nCount: u32, rgwszName: [*]const ?[*:0]const u16, rgValue: [*]const VARIANT) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).WriteProperties(@as(*const ISubscriptionItem, @ptrCast(self)), nCount, rgwszName, rgValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionItem_EnumProperties(self: *const T, ppEnumItemProperties: ?*?*IEnumItemProperties) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).EnumProperties(@as(*const ISubscriptionItem, @ptrCast(self)), ppEnumItemProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionItem_NotifyChanged(self: *const T) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).NotifyChanged(@as(*const ISubscriptionItem, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSubscription_Value = Guid.initString("f72c8d97-6dbd-11d1-a1e8-00c04fc2fbe1");
pub const IID_IEnumSubscription = &IID_IEnumSubscription_Value;
pub const IEnumSubscription = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSubscription,
                celt: u32,
                rgelt: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSubscription,
                celt: u32,
                rgelt: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSubscription,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSubscription,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSubscription,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSubscription,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSubscription,
                ppenum: ?*?*IEnumSubscription,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSubscription,
                ppenum: ?*?*IEnumSubscription,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSubscription,
                pnCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSubscription,
                pnCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSubscription_Next(self: *const T, celt: u32, rgelt: [*]Guid, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSubscription, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSubscription_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSubscription, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSubscription_Reset(self: *const T) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSubscription, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSubscription_Clone(self: *const T, ppenum: ?*?*IEnumSubscription) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSubscription, @ptrCast(self)), ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSubscription_GetCount(self: *const T, pnCount: ?*u32) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IEnumSubscription, @ptrCast(self)), pnCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SUBSCRIPTIONTYPE = enum(i32) {
    URL = 0,
    CHANNEL = 1,
    DESKTOPURL = 2,
    EXTERNAL = 3,
    DESKTOPCHANNEL = 4,
};
pub const SUBSTYPE_URL = SUBSCRIPTIONTYPE.URL;
pub const SUBSTYPE_CHANNEL = SUBSCRIPTIONTYPE.CHANNEL;
pub const SUBSTYPE_DESKTOPURL = SUBSCRIPTIONTYPE.DESKTOPURL;
pub const SUBSTYPE_EXTERNAL = SUBSCRIPTIONTYPE.EXTERNAL;
pub const SUBSTYPE_DESKTOPCHANNEL = SUBSCRIPTIONTYPE.DESKTOPCHANNEL;

pub const SUBSCRIPTIONINFOFLAGS = enum(i32) {
    SCHEDULE = 1,
    RECURSE = 2,
    WEBCRAWL = 4,
    MAILNOT = 8,
    MAXSIZEKB = 16,
    USER = 32,
    PASSWORD = 64,
    TASKFLAGS = 256,
    GLEAM = 512,
    CHANGESONLY = 1024,
    CHANNELFLAGS = 2048,
    FRIENDLYNAME = 8192,
    NEEDPASSWORD = 16384,
    TYPE = 32768,
};
pub const SUBSINFO_SCHEDULE = SUBSCRIPTIONINFOFLAGS.SCHEDULE;
pub const SUBSINFO_RECURSE = SUBSCRIPTIONINFOFLAGS.RECURSE;
pub const SUBSINFO_WEBCRAWL = SUBSCRIPTIONINFOFLAGS.WEBCRAWL;
pub const SUBSINFO_MAILNOT = SUBSCRIPTIONINFOFLAGS.MAILNOT;
pub const SUBSINFO_MAXSIZEKB = SUBSCRIPTIONINFOFLAGS.MAXSIZEKB;
pub const SUBSINFO_USER = SUBSCRIPTIONINFOFLAGS.USER;
pub const SUBSINFO_PASSWORD = SUBSCRIPTIONINFOFLAGS.PASSWORD;
pub const SUBSINFO_TASKFLAGS = SUBSCRIPTIONINFOFLAGS.TASKFLAGS;
pub const SUBSINFO_GLEAM = SUBSCRIPTIONINFOFLAGS.GLEAM;
pub const SUBSINFO_CHANGESONLY = SUBSCRIPTIONINFOFLAGS.CHANGESONLY;
pub const SUBSINFO_CHANNELFLAGS = SUBSCRIPTIONINFOFLAGS.CHANNELFLAGS;
pub const SUBSINFO_FRIENDLYNAME = SUBSCRIPTIONINFOFLAGS.FRIENDLYNAME;
pub const SUBSINFO_NEEDPASSWORD = SUBSCRIPTIONINFOFLAGS.NEEDPASSWORD;
pub const SUBSINFO_TYPE = SUBSCRIPTIONINFOFLAGS.TYPE;

pub const CREATESUBSCRIPTIONFLAGS = enum(i32) {
    ADDTOFAVORITES = 1,
    FROMFAVORITES = 2,
    NOUI = 4,
    NOSAVE = 8,
    SOFTWAREUPDATE = 16,
};
pub const CREATESUBS_ADDTOFAVORITES = CREATESUBSCRIPTIONFLAGS.ADDTOFAVORITES;
pub const CREATESUBS_FROMFAVORITES = CREATESUBSCRIPTIONFLAGS.FROMFAVORITES;
pub const CREATESUBS_NOUI = CREATESUBSCRIPTIONFLAGS.NOUI;
pub const CREATESUBS_NOSAVE = CREATESUBSCRIPTIONFLAGS.NOSAVE;
pub const CREATESUBS_SOFTWAREUPDATE = CREATESUBSCRIPTIONFLAGS.SOFTWAREUPDATE;

pub const SUBSCRIPTIONSCHEDULE = enum(i32) {
    AUTO = 0,
    DAILY = 1,
    WEEKLY = 2,
    CUSTOM = 3,
    MANUAL = 4,
};
pub const SUBSSCHED_AUTO = SUBSCRIPTIONSCHEDULE.AUTO;
pub const SUBSSCHED_DAILY = SUBSCRIPTIONSCHEDULE.DAILY;
pub const SUBSSCHED_WEEKLY = SUBSCRIPTIONSCHEDULE.WEEKLY;
pub const SUBSSCHED_CUSTOM = SUBSCRIPTIONSCHEDULE.CUSTOM;
pub const SUBSSCHED_MANUAL = SUBSCRIPTIONSCHEDULE.MANUAL;

pub const SUBSCRIPTIONINFO = extern struct {
    cbSize: u32,
    fUpdateFlags: u32,
    schedule: SUBSCRIPTIONSCHEDULE,
    customGroupCookie: Guid,
    pTrigger: ?*anyopaque,
    dwRecurseLevels: u32,
    fWebcrawlerFlags: u32,
    bMailNotification: BOOL,
    bGleam: BOOL,
    bChangesOnly: BOOL,
    bNeedPassword: BOOL,
    fChannelFlags: u32,
    bstrUserName: ?BSTR,
    bstrPassword: ?BSTR,
    bstrFriendlyName: ?BSTR,
    dwMaxSizeKB: u32,
    subType: SUBSCRIPTIONTYPE,
    fTaskFlags: u32,
    dwReserved: u32,
};

const IID_ISubscriptionMgr_Value = Guid.initString("085fb2c0-0df8-11d1-8f4b-00a0c905413f");
pub const IID_ISubscriptionMgr = &IID_ISubscriptionMgr_Value;
pub const ISubscriptionMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteSubscription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateSubscription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSubscribed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
                pfSubscribed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
                pfSubscribed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubscriptionInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
                pInfo: ?*SUBSCRIPTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
                pInfo: ?*SUBSCRIPTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr,
                subType: SUBSCRIPTIONTYPE,
                pInfo: ?*SUBSCRIPTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr,
                subType: SUBSCRIPTIONTYPE,
                pInfo: ?*SUBSCRIPTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowSubscriptionProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr,
                pwszURL: ?[*:0]const u16,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSubscription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr,
                hwnd: ?HWND,
                pwszURL: ?[*:0]const u16,
                pwszFriendlyName: ?[*:0]const u16,
                dwFlags: u32,
                subsType: SUBSCRIPTIONTYPE,
                pInfo: ?*SUBSCRIPTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr,
                hwnd: ?HWND,
                pwszURL: ?[*:0]const u16,
                pwszFriendlyName: ?[*:0]const u16,
                dwFlags: u32,
                subsType: SUBSCRIPTIONTYPE,
                pInfo: ?*SUBSCRIPTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr_DeleteSubscription(self: *const T, pwszURL: ?[*:0]const u16, hwnd: ?HWND) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).DeleteSubscription(@as(*const ISubscriptionMgr, @ptrCast(self)), pwszURL, hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr_UpdateSubscription(self: *const T, pwszURL: ?[*:0]const u16) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).UpdateSubscription(@as(*const ISubscriptionMgr, @ptrCast(self)), pwszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr_UpdateAll(self: *const T) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).UpdateAll(@as(*const ISubscriptionMgr, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr_IsSubscribed(self: *const T, pwszURL: ?[*:0]const u16, pfSubscribed: ?*BOOL) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).IsSubscribed(@as(*const ISubscriptionMgr, @ptrCast(self)), pwszURL, pfSubscribed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr_GetSubscriptionInfo(self: *const T, pwszURL: ?[*:0]const u16, pInfo: ?*SUBSCRIPTIONINFO) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).GetSubscriptionInfo(@as(*const ISubscriptionMgr, @ptrCast(self)), pwszURL, pInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr_GetDefaultInfo(self: *const T, subType: SUBSCRIPTIONTYPE, pInfo: ?*SUBSCRIPTIONINFO) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).GetDefaultInfo(@as(*const ISubscriptionMgr, @ptrCast(self)), subType, pInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr_ShowSubscriptionProperties(self: *const T, pwszURL: ?[*:0]const u16, hwnd: ?HWND) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).ShowSubscriptionProperties(@as(*const ISubscriptionMgr, @ptrCast(self)), pwszURL, hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr_CreateSubscription(self: *const T, hwnd: ?HWND, pwszURL: ?[*:0]const u16, pwszFriendlyName: ?[*:0]const u16, dwFlags: u32, subsType: SUBSCRIPTIONTYPE, pInfo: ?*SUBSCRIPTIONINFO) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).CreateSubscription(@as(*const ISubscriptionMgr, @ptrCast(self)), hwnd, pwszURL, pwszFriendlyName, dwFlags, subsType, pInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISubscriptionMgr2_Value = Guid.initString("614bc270-aedf-11d1-a1f9-00c04fc2fbe1");
pub const IID_ISubscriptionMgr2 = &IID_ISubscriptionMgr2_Value;
pub const ISubscriptionMgr2 = extern struct {
    pub const VTable = extern struct {
        base: ISubscriptionMgr.VTable,
        GetItemFromURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr2,
                pwszURL: ?[*:0]const u16,
                ppSubscriptionItem: ?*?*ISubscriptionItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr2,
                pwszURL: ?[*:0]const u16,
                ppSubscriptionItem: ?*?*ISubscriptionItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemFromCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr2,
                pSubscriptionCookie: ?*const Guid,
                ppSubscriptionItem: ?*?*ISubscriptionItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr2,
                pSubscriptionCookie: ?*const Guid,
                ppSubscriptionItem: ?*?*ISubscriptionItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubscriptionRunState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr2,
                dwNumCookies: u32,
                pCookies: [*]const Guid,
                pdwRunState: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr2,
                dwNumCookies: u32,
                pCookies: [*]const Guid,
                pdwRunState: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumSubscriptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr2,
                dwFlags: u32,
                ppEnumSubscriptions: ?*?*IEnumSubscription,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr2,
                dwFlags: u32,
                ppEnumSubscriptions: ?*?*IEnumSubscription,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr2,
                dwFlags: u32,
                dwNumCookies: u32,
                pCookies: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr2,
                dwFlags: u32,
                dwNumCookies: u32,
                pCookies: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbortItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr2,
                dwNumCookies: u32,
                pCookies: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr2,
                dwNumCookies: u32,
                pCookies: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbortAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISubscriptionMgr2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISubscriptionMgr2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISubscriptionMgr.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr2_GetItemFromURL(self: *const T, pwszURL: ?[*:0]const u16, ppSubscriptionItem: ?*?*ISubscriptionItem) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).GetItemFromURL(@as(*const ISubscriptionMgr2, @ptrCast(self)), pwszURL, ppSubscriptionItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr2_GetItemFromCookie(self: *const T, pSubscriptionCookie: ?*const Guid, ppSubscriptionItem: ?*?*ISubscriptionItem) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).GetItemFromCookie(@as(*const ISubscriptionMgr2, @ptrCast(self)), pSubscriptionCookie, ppSubscriptionItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr2_GetSubscriptionRunState(self: *const T, dwNumCookies: u32, pCookies: [*]const Guid, pdwRunState: [*]u32) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).GetSubscriptionRunState(@as(*const ISubscriptionMgr2, @ptrCast(self)), dwNumCookies, pCookies, pdwRunState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr2_EnumSubscriptions(self: *const T, dwFlags: u32, ppEnumSubscriptions: ?*?*IEnumSubscription) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).EnumSubscriptions(@as(*const ISubscriptionMgr2, @ptrCast(self)), dwFlags, ppEnumSubscriptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr2_UpdateItems(self: *const T, dwFlags: u32, dwNumCookies: u32, pCookies: [*]const Guid) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).UpdateItems(@as(*const ISubscriptionMgr2, @ptrCast(self)), dwFlags, dwNumCookies, pCookies);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr2_AbortItems(self: *const T, dwNumCookies: u32, pCookies: [*]const Guid) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).AbortItems(@as(*const ISubscriptionMgr2, @ptrCast(self)), dwNumCookies, pCookies);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISubscriptionMgr2_AbortAll(self: *const T) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).AbortAll(@as(*const ISubscriptionMgr2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DELIVERY_AGENT_FLAGS = enum(i32) {
    NO_BROADCAST = 4,
    NO_RESTRICTIONS = 8,
    SILENT_DIAL = 16,
};
pub const DELIVERY_AGENT_FLAG_NO_BROADCAST = DELIVERY_AGENT_FLAGS.NO_BROADCAST;
pub const DELIVERY_AGENT_FLAG_NO_RESTRICTIONS = DELIVERY_AGENT_FLAGS.NO_RESTRICTIONS;
pub const DELIVERY_AGENT_FLAG_SILENT_DIAL = DELIVERY_AGENT_FLAGS.SILENT_DIAL;

pub const WEBCRAWL_RECURSEFLAGS = enum(i32) {
    DONT_MAKE_STICKY = 1,
    GET_IMAGES = 2,
    GET_VIDEOS = 4,
    GET_BGSOUNDS = 8,
    GET_CONTROLS = 16,
    LINKS_ELSEWHERE = 32,
    IGNORE_ROBOTSTXT = 128,
    ONLY_LINKS_TO_HTML = 256,
};
pub const WEBCRAWL_DONT_MAKE_STICKY = WEBCRAWL_RECURSEFLAGS.DONT_MAKE_STICKY;
pub const WEBCRAWL_GET_IMAGES = WEBCRAWL_RECURSEFLAGS.GET_IMAGES;
pub const WEBCRAWL_GET_VIDEOS = WEBCRAWL_RECURSEFLAGS.GET_VIDEOS;
pub const WEBCRAWL_GET_BGSOUNDS = WEBCRAWL_RECURSEFLAGS.GET_BGSOUNDS;
pub const WEBCRAWL_GET_CONTROLS = WEBCRAWL_RECURSEFLAGS.GET_CONTROLS;
pub const WEBCRAWL_LINKS_ELSEWHERE = WEBCRAWL_RECURSEFLAGS.LINKS_ELSEWHERE;
pub const WEBCRAWL_IGNORE_ROBOTSTXT = WEBCRAWL_RECURSEFLAGS.IGNORE_ROBOTSTXT;
pub const WEBCRAWL_ONLY_LINKS_TO_HTML = WEBCRAWL_RECURSEFLAGS.ONLY_LINKS_TO_HTML;

pub const CHANNEL_AGENT_FLAGS = enum(i32) {
    DYNAMIC_SCHEDULE = 1,
    PRECACHE_SOME = 2,
    PRECACHE_ALL = 4,
    PRECACHE_SCRNSAVER = 8,
};
pub const CHANNEL_AGENT_DYNAMIC_SCHEDULE = CHANNEL_AGENT_FLAGS.DYNAMIC_SCHEDULE;
pub const CHANNEL_AGENT_PRECACHE_SOME = CHANNEL_AGENT_FLAGS.PRECACHE_SOME;
pub const CHANNEL_AGENT_PRECACHE_ALL = CHANNEL_AGENT_FLAGS.PRECACHE_ALL;
pub const CHANNEL_AGENT_PRECACHE_SCRNSAVER = CHANNEL_AGENT_FLAGS.PRECACHE_SCRNSAVER;

pub const DBDATACONVERTENUM = enum(i32) {
    DEFAULT = 0,
    SETDATABEHAVIOR = 1,
    LENGTHFROMNTS = 2,
    DSTISFIXEDLENGTH = 4,
    DECIMALSCALE = 8,
};
pub const DBDATACONVERT_DEFAULT = DBDATACONVERTENUM.DEFAULT;
pub const DBDATACONVERT_SETDATABEHAVIOR = DBDATACONVERTENUM.SETDATABEHAVIOR;
pub const DBDATACONVERT_LENGTHFROMNTS = DBDATACONVERTENUM.LENGTHFROMNTS;
pub const DBDATACONVERT_DSTISFIXEDLENGTH = DBDATACONVERTENUM.DSTISFIXEDLENGTH;
pub const DBDATACONVERT_DECIMALSCALE = DBDATACONVERTENUM.DECIMALSCALE;

const IID_IDataConvert_Value = Guid.initString("0c733a8d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDataConvert = &IID_IDataConvert_Value;
pub const IDataConvert = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DataConvert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataConvert,
                wSrcType: u16,
                wDstType: u16,
                cbSrcLength: usize,
                pcbDstLength: ?*usize,
                // TODO: what to do with BytesParamIndex 2?
                pSrc: ?*anyopaque,
                pDst: ?*anyopaque,
                cbDstMaxLength: usize,
                dbsSrcStatus: u32,
                pdbsStatus: ?*u32,
                bPrecision: u8,
                bScale: u8,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataConvert,
                wSrcType: u16,
                wDstType: u16,
                cbSrcLength: usize,
                pcbDstLength: ?*usize,
                // TODO: what to do with BytesParamIndex 2?
                pSrc: ?*anyopaque,
                pDst: ?*anyopaque,
                cbDstMaxLength: usize,
                dbsSrcStatus: u32,
                pdbsStatus: ?*u32,
                bPrecision: u8,
                bScale: u8,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanConvert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataConvert,
                wSrcType: u16,
                wDstType: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataConvert,
                wSrcType: u16,
                wDstType: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataConvert,
                wSrcType: u16,
                wDstType: u16,
                pcbSrcLength: ?*usize,
                pcbDstLength: ?*usize,
                // TODO: what to do with BytesParamIndex 2?
                pSrc: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataConvert,
                wSrcType: u16,
                wDstType: u16,
                pcbSrcLength: ?*usize,
                pcbDstLength: ?*usize,
                // TODO: what to do with BytesParamIndex 2?
                pSrc: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataConvert_DataConvert(self: *const T, wSrcType: u16, wDstType: u16, cbSrcLength: usize, pcbDstLength: ?*usize, pSrc: ?*anyopaque, pDst: ?*anyopaque, cbDstMaxLength: usize, dbsSrcStatus: u32, pdbsStatus: ?*u32, bPrecision: u8, bScale: u8, dwFlags: u32) HRESULT {
                return @as(*const IDataConvert.VTable, @ptrCast(self.vtable)).DataConvert(@as(*const IDataConvert, @ptrCast(self)), wSrcType, wDstType, cbSrcLength, pcbDstLength, pSrc, pDst, cbDstMaxLength, dbsSrcStatus, pdbsStatus, bPrecision, bScale, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataConvert_CanConvert(self: *const T, wSrcType: u16, wDstType: u16) HRESULT {
                return @as(*const IDataConvert.VTable, @ptrCast(self.vtable)).CanConvert(@as(*const IDataConvert, @ptrCast(self)), wSrcType, wDstType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataConvert_GetConversionSize(self: *const T, wSrcType: u16, wDstType: u16, pcbSrcLength: ?*usize, pcbDstLength: ?*usize, pSrc: ?*anyopaque) HRESULT {
                return @as(*const IDataConvert.VTable, @ptrCast(self.vtable)).GetConversionSize(@as(*const IDataConvert, @ptrCast(self)), wSrcType, wDstType, pcbSrcLength, pcbDstLength, pSrc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DCINFOTYPEENUM = enum(i32) {
    N = 1,
};
pub const DCINFOTYPE_VERSION = DCINFOTYPEENUM.N;

pub const DCINFO = extern struct {
    eInfoType: u32,
    vData: VARIANT,
};

const IID_IDCInfo_Value = Guid.initString("0c733a9c-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDCInfo = &IID_IDCInfo_Value;
pub const IDCInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDCInfo,
                cInfo: u32,
                rgeInfoType: [*]u32,
                prgInfo: [*]?*DCINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDCInfo,
                cInfo: u32,
                rgeInfoType: [*]u32,
                prgInfo: [*]?*DCINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDCInfo,
                cInfo: u32,
                rgInfo: [*]DCINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDCInfo,
                cInfo: u32,
                rgInfo: [*]DCINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDCInfo_GetInfo(self: *const T, cInfo: u32, rgeInfoType: [*]u32, prgInfo: [*]?*DCINFO) HRESULT {
                return @as(*const IDCInfo.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IDCInfo, @ptrCast(self)), cInfo, rgeInfoType, prgInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDCInfo_SetInfo(self: *const T, cInfo: u32, rgInfo: [*]DCINFO) HRESULT {
                return @as(*const IDCInfo.VTable, @ptrCast(self.vtable)).SetInfo(@as(*const IDCInfo, @ptrCast(self)), cInfo, rgInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSDAORA_Value = Guid.initString("e8cc4cbe-fdff-11d0-b865-00a0c9081c1d");
pub const CLSID_MSDAORA = &CLSID_MSDAORA_Value;

const CLSID_MSDAORA_ERROR_Value = Guid.initString("e8cc4cbf-fdff-11d0-b865-00a0c9081c1d");
pub const CLSID_MSDAORA_ERROR = &CLSID_MSDAORA_ERROR_Value;

const CLSID_MSDAORA8_Value = Guid.initString("7f06a373-dd6a-43db-b4e0-1fc121e5e62b");
pub const CLSID_MSDAORA8 = &CLSID_MSDAORA8_Value;

const CLSID_MSDAORA8_ERROR_Value = Guid.initString("7f06a374-dd6a-43db-b4e0-1fc121e5e62b");
pub const CLSID_MSDAORA8_ERROR = &CLSID_MSDAORA8_ERROR_Value;

const IID_DataSourceListener_Value = Guid.initString("7c0ffab2-cd84-11d0-949a-00a0c91110ed");
pub const IID_DataSourceListener = &IID_DataSourceListener_Value;
pub const DataSourceListener = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        dataMemberChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const DataSourceListener,
                bstrDM: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const DataSourceListener,
                bstrDM: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        dataMemberAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const DataSourceListener,
                bstrDM: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const DataSourceListener,
                bstrDM: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        dataMemberRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const DataSourceListener,
                bstrDM: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const DataSourceListener,
                bstrDM: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DataSourceListener_dataMemberChanged(self: *const T, bstrDM: ?*u16) HRESULT {
                return @as(*const DataSourceListener.VTable, @ptrCast(self.vtable)).dataMemberChanged(@as(*const DataSourceListener, @ptrCast(self)), bstrDM);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DataSourceListener_dataMemberAdded(self: *const T, bstrDM: ?*u16) HRESULT {
                return @as(*const DataSourceListener.VTable, @ptrCast(self.vtable)).dataMemberAdded(@as(*const DataSourceListener, @ptrCast(self)), bstrDM);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DataSourceListener_dataMemberRemoved(self: *const T, bstrDM: ?*u16) HRESULT {
                return @as(*const DataSourceListener.VTable, @ptrCast(self.vtable)).dataMemberRemoved(@as(*const DataSourceListener, @ptrCast(self)), bstrDM);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DataSource_Value = Guid.initString("7c0ffab3-cd84-11d0-949a-00a0c91110ed");
pub const IID_DataSource = &IID_DataSource_Value;
pub const DataSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getDataMember: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const DataSource,
                bstrDM: ?*u16,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const DataSource,
                bstrDM: ?*u16,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getDataMemberName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const DataSource,
                lIndex: i32,
                pbstrDM: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const DataSource,
                lIndex: i32,
                pbstrDM: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getDataMemberCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const DataSource,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const DataSource,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        addDataSourceListener: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const DataSource,
                pDSL: ?*DataSourceListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const DataSource,
                pDSL: ?*DataSourceListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeDataSourceListener: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const DataSource,
                pDSL: ?*DataSourceListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const DataSource,
                pDSL: ?*DataSourceListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DataSource_getDataMember(self: *const T, bstrDM: ?*u16, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).getDataMember(@as(*const DataSource, @ptrCast(self)), bstrDM, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DataSource_getDataMemberName(self: *const T, lIndex: i32, pbstrDM: ?*?*u16) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).getDataMemberName(@as(*const DataSource, @ptrCast(self)), lIndex, pbstrDM);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DataSource_getDataMemberCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).getDataMemberCount(@as(*const DataSource, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DataSource_addDataSourceListener(self: *const T, pDSL: ?*DataSourceListener) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).addDataSourceListener(@as(*const DataSource, @ptrCast(self)), pDSL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DataSource_removeDataSourceListener(self: *const T, pDSL: ?*DataSourceListener) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).removeDataSourceListener(@as(*const DataSource, @ptrCast(self)), pDSL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OSPFORMAT = enum(i32) {
    RAW = 0,
    // DEFAULT = 0, this enum value conflicts with RAW
    FORMATTED = 1,
    HTML = 2,
};
pub const OSPFORMAT_RAW = OSPFORMAT.RAW;
pub const OSPFORMAT_DEFAULT = OSPFORMAT.RAW;
pub const OSPFORMAT_FORMATTED = OSPFORMAT.FORMATTED;
pub const OSPFORMAT_HTML = OSPFORMAT.HTML;

pub const OSPRW = enum(i32) {
    DEFAULT = 1,
    READONLY = 0,
    // READWRITE = 1, this enum value conflicts with DEFAULT
    MIXED = 2,
};
pub const OSPRW_DEFAULT = OSPRW.DEFAULT;
pub const OSPRW_READONLY = OSPRW.READONLY;
pub const OSPRW_READWRITE = OSPRW.DEFAULT;
pub const OSPRW_MIXED = OSPRW.MIXED;

pub const OSPFIND = enum(i32) {
    DEFAULT = 0,
    UP = 1,
    CASESENSITIVE = 2,
    UPCASESENSITIVE = 3,
};
pub const OSPFIND_DEFAULT = OSPFIND.DEFAULT;
pub const OSPFIND_UP = OSPFIND.UP;
pub const OSPFIND_CASESENSITIVE = OSPFIND.CASESENSITIVE;
pub const OSPFIND_UPCASESENSITIVE = OSPFIND.UPCASESENSITIVE;

pub const OSPCOMP = enum(i32) {
    EQ = 1,
    // DEFAULT = 1, this enum value conflicts with EQ
    LT = 2,
    LE = 3,
    GE = 4,
    GT = 5,
    NE = 6,
};
pub const OSPCOMP_EQ = OSPCOMP.EQ;
pub const OSPCOMP_DEFAULT = OSPCOMP.EQ;
pub const OSPCOMP_LT = OSPCOMP.LT;
pub const OSPCOMP_LE = OSPCOMP.LE;
pub const OSPCOMP_GE = OSPCOMP.GE;
pub const OSPCOMP_GT = OSPCOMP.GT;
pub const OSPCOMP_NE = OSPCOMP.NE;

pub const OSPXFER = enum(i32) {
    COMPLETE = 0,
    ABORT = 1,
    ERROR = 2,
};
pub const OSPXFER_COMPLETE = OSPXFER.COMPLETE;
pub const OSPXFER_ABORT = OSPXFER.ABORT;
pub const OSPXFER_ERROR = OSPXFER.ERROR;

const IID_OLEDBSimpleProviderListener_Value = Guid.initString("e0e270c1-c0be-11d0-8fe4-00a0c90a6341");
pub const IID_OLEDBSimpleProviderListener = &IID_OLEDBSimpleProviderListener_Value;
pub const OLEDBSimpleProviderListener = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        aboutToChangeCell: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                iColumn: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                iColumn: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        cellChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                iColumn: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                iColumn: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        aboutToDeleteRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        deletedRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        aboutToInsertRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        insertedRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        rowsAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProviderListener,
                iRow: isize,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        transferComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProviderListener,
                xfer: OSPXFER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProviderListener,
                xfer: OSPXFER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProviderListener_aboutToChangeCell(self: *const T, iRow: isize, iColumn: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).aboutToChangeCell(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), iRow, iColumn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProviderListener_cellChanged(self: *const T, iRow: isize, iColumn: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).cellChanged(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), iRow, iColumn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProviderListener_aboutToDeleteRows(self: *const T, iRow: isize, cRows: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).aboutToDeleteRows(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), iRow, cRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProviderListener_deletedRows(self: *const T, iRow: isize, cRows: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).deletedRows(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), iRow, cRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProviderListener_aboutToInsertRows(self: *const T, iRow: isize, cRows: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).aboutToInsertRows(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), iRow, cRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProviderListener_insertedRows(self: *const T, iRow: isize, cRows: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).insertedRows(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), iRow, cRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProviderListener_rowsAvailable(self: *const T, iRow: isize, cRows: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).rowsAvailable(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), iRow, cRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProviderListener_transferComplete(self: *const T, xfer: OSPXFER) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).transferComplete(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), xfer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_OLEDBSimpleProvider_Value = Guid.initString("e0e270c0-c0be-11d0-8fe4-00a0c90a6341");
pub const IID_OLEDBSimpleProvider = &IID_OLEDBSimpleProvider_Value;
pub const OLEDBSimpleProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getRowCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                pcRows: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                pcRows: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getColumnCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                pcColumns: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                pcColumns: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRWStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                iColumn: isize,
                prwStatus: ?*OSPRW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                iColumn: isize,
                prwStatus: ?*OSPRW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getVariant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                iColumn: isize,
                format: OSPFORMAT,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                iColumn: isize,
                format: OSPFORMAT,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setVariant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                iColumn: isize,
                format: OSPFORMAT,
                Var: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                iColumn: isize,
                format: OSPFORMAT,
                Var: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getLocale: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                pbstrLocale: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                pbstrLocale: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        deleteRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                cRows: isize,
                pcRowsDeleted: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                cRows: isize,
                pcRowsDeleted: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        insertRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                cRows: isize,
                pcRowsInserted: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                iRow: isize,
                cRows: isize,
                pcRowsInserted: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        find: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                iRowStart: isize,
                iColumn: isize,
                val: VARIANT,
                findFlags: OSPFIND,
                compType: OSPCOMP,
                piRowFound: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                iRowStart: isize,
                iColumn: isize,
                val: VARIANT,
                findFlags: OSPFIND,
                compType: OSPCOMP,
                piRowFound: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        addOLEDBSimpleProviderListener: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                pospIListener: ?*OLEDBSimpleProviderListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                pospIListener: ?*OLEDBSimpleProviderListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeOLEDBSimpleProviderListener: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                pospIListener: ?*OLEDBSimpleProviderListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                pospIListener: ?*OLEDBSimpleProviderListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                pbAsynch: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                pbAsynch: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getEstimatedRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
                piRows: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
                piRows: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        stopTransfer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const OLEDBSimpleProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const OLEDBSimpleProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_getRowCount(self: *const T, pcRows: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getRowCount(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pcRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_getColumnCount(self: *const T, pcColumns: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getColumnCount(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pcColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_getRWStatus(self: *const T, iRow: isize, iColumn: isize, prwStatus: ?*OSPRW) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getRWStatus(@as(*const OLEDBSimpleProvider, @ptrCast(self)), iRow, iColumn, prwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_getVariant(self: *const T, iRow: isize, iColumn: isize, format: OSPFORMAT, pVar: ?*VARIANT) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getVariant(@as(*const OLEDBSimpleProvider, @ptrCast(self)), iRow, iColumn, format, pVar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_setVariant(self: *const T, iRow: isize, iColumn: isize, format: OSPFORMAT, Var: VARIANT) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).setVariant(@as(*const OLEDBSimpleProvider, @ptrCast(self)), iRow, iColumn, format, Var);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_getLocale(self: *const T, pbstrLocale: ?*?BSTR) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getLocale(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pbstrLocale);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_deleteRows(self: *const T, iRow: isize, cRows: isize, pcRowsDeleted: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).deleteRows(@as(*const OLEDBSimpleProvider, @ptrCast(self)), iRow, cRows, pcRowsDeleted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_insertRows(self: *const T, iRow: isize, cRows: isize, pcRowsInserted: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).insertRows(@as(*const OLEDBSimpleProvider, @ptrCast(self)), iRow, cRows, pcRowsInserted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_find(self: *const T, iRowStart: isize, iColumn: isize, val: VARIANT, findFlags: OSPFIND, compType: OSPCOMP, piRowFound: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).find(@as(*const OLEDBSimpleProvider, @ptrCast(self)), iRowStart, iColumn, val, findFlags, compType, piRowFound);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_addOLEDBSimpleProviderListener(self: *const T, pospIListener: ?*OLEDBSimpleProviderListener) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).addOLEDBSimpleProviderListener(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pospIListener);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_removeOLEDBSimpleProviderListener(self: *const T, pospIListener: ?*OLEDBSimpleProviderListener) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).removeOLEDBSimpleProviderListener(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pospIListener);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_isAsync(self: *const T, pbAsynch: ?*BOOL) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).isAsync(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pbAsynch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_getEstimatedRows(self: *const T, piRows: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getEstimatedRows(@as(*const OLEDBSimpleProvider, @ptrCast(self)), piRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn OLEDBSimpleProvider_stopTransfer(self: *const T) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).stopTransfer(@as(*const OLEDBSimpleProvider, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DataSourceObject_Value = Guid.initString("0ae9a4e4-18d4-11d1-b3b3-00aa00c1a924");
pub const IID_DataSourceObject = &IID_DataSourceObject_Value;
pub const DataSourceObject = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DataLinks_Value = Guid.initString("2206cdb2-19c1-11d1-89e0-00c04fd7a829");
pub const CLSID_DataLinks = &CLSID_DataLinks_Value;

const CLSID_MSDAINITIALIZE_Value = Guid.initString("2206cdb0-19c1-11d1-89e0-00c04fd7a829");
pub const CLSID_MSDAINITIALIZE = &CLSID_MSDAINITIALIZE_Value;

const CLSID_PDPO_Value = Guid.initString("ccb4ec60-b9dc-11d1-ac80-00a0c9034873");
pub const CLSID_PDPO = &CLSID_PDPO_Value;

const CLSID_RootBinder_Value = Guid.initString("ff151822-b0bf-11d1-a80d-000000000000");
pub const CLSID_RootBinder = &CLSID_RootBinder_Value;

pub const EBindInfoOptions = enum(i32) {
    R = 1,
};
pub const BIO_BINDER = EBindInfoOptions.R;

const IID_IService_Value = Guid.initString("06210e88-01f5-11d1-b512-0080c781c384");
pub const IID_IService = &IID_IService_Value;
pub const IService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvokeService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IService,
                pUnkInner: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IService,
                pUnkInner: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IService_InvokeService(self: *const T, pUnkInner: ?*IUnknown) HRESULT {
                return @as(*const IService.VTable, @ptrCast(self.vtable)).InvokeService(@as(*const IService, @ptrCast(self)), pUnkInner);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBPROMPTOPTIONSENUM = enum(i32) {
    NONE = 0,
    WIZARDSHEET = 1,
    PROPERTYSHEET = 2,
    BROWSEONLY = 8,
    DISABLE_PROVIDER_SELECTION = 16,
    DISABLESAVEPASSWORD = 32,
};
pub const DBPROMPTOPTIONS_NONE = DBPROMPTOPTIONSENUM.NONE;
pub const DBPROMPTOPTIONS_WIZARDSHEET = DBPROMPTOPTIONSENUM.WIZARDSHEET;
pub const DBPROMPTOPTIONS_PROPERTYSHEET = DBPROMPTOPTIONSENUM.PROPERTYSHEET;
pub const DBPROMPTOPTIONS_BROWSEONLY = DBPROMPTOPTIONSENUM.BROWSEONLY;
pub const DBPROMPTOPTIONS_DISABLE_PROVIDER_SELECTION = DBPROMPTOPTIONSENUM.DISABLE_PROVIDER_SELECTION;
pub const DBPROMPTOPTIONS_DISABLESAVEPASSWORD = DBPROMPTOPTIONSENUM.DISABLESAVEPASSWORD;

const IID_IDBPromptInitialize_Value = Guid.initString("2206ccb0-19c1-11d1-89e0-00c04fd7a829");
pub const IID_IDBPromptInitialize = &IID_IDBPromptInitialize_Value;
pub const IDBPromptInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PromptDataSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBPromptInitialize,
                pUnkOuter: ?*IUnknown,
                hWndParent: ?HWND,
                dwPromptOptions: u32,
                cSourceTypeFilter: u32,
                rgSourceTypeFilter: ?[*]u32,
                pwszszzProviderFilter: ?[*:0]const u16,
                riid: ?*const Guid,
                ppDataSource: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBPromptInitialize,
                pUnkOuter: ?*IUnknown,
                hWndParent: ?HWND,
                dwPromptOptions: u32,
                cSourceTypeFilter: u32,
                rgSourceTypeFilter: ?[*]u32,
                pwszszzProviderFilter: ?[*:0]const u16,
                riid: ?*const Guid,
                ppDataSource: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PromptFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBPromptInitialize,
                hWndParent: ?HWND,
                dwPromptOptions: u32,
                pwszInitialDirectory: ?[*:0]const u16,
                pwszInitialFile: ?[*:0]const u16,
                ppwszSelectedFile: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBPromptInitialize,
                hWndParent: ?HWND,
                dwPromptOptions: u32,
                pwszInitialDirectory: ?[*:0]const u16,
                pwszInitialFile: ?[*:0]const u16,
                ppwszSelectedFile: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBPromptInitialize_PromptDataSource(self: *const T, pUnkOuter: ?*IUnknown, hWndParent: ?HWND, dwPromptOptions: u32, cSourceTypeFilter: u32, rgSourceTypeFilter: ?[*]u32, pwszszzProviderFilter: ?[*:0]const u16, riid: ?*const Guid, ppDataSource: ?*?*IUnknown) HRESULT {
                return @as(*const IDBPromptInitialize.VTable, @ptrCast(self.vtable)).PromptDataSource(@as(*const IDBPromptInitialize, @ptrCast(self)), pUnkOuter, hWndParent, dwPromptOptions, cSourceTypeFilter, rgSourceTypeFilter, pwszszzProviderFilter, riid, ppDataSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBPromptInitialize_PromptFileName(self: *const T, hWndParent: ?HWND, dwPromptOptions: u32, pwszInitialDirectory: ?[*:0]const u16, pwszInitialFile: ?[*:0]const u16, ppwszSelectedFile: ?*?PWSTR) HRESULT {
                return @as(*const IDBPromptInitialize.VTable, @ptrCast(self.vtable)).PromptFileName(@as(*const IDBPromptInitialize, @ptrCast(self)), hWndParent, dwPromptOptions, pwszInitialDirectory, pwszInitialFile, ppwszSelectedFile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataInitialize_Value = Guid.initString("2206ccb1-19c1-11d1-89e0-00c04fd7a829");
pub const IID_IDataInitialize = &IID_IDataInitialize_Value;
pub const IDataInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataInitialize,
                pUnkOuter: ?*IUnknown,
                dwClsCtx: u32,
                pwszInitializationString: ?[*:0]const u16,
                riid: ?*const Guid,
                ppDataSource: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataInitialize,
                pUnkOuter: ?*IUnknown,
                dwClsCtx: u32,
                pwszInitializationString: ?[*:0]const u16,
                riid: ?*const Guid,
                ppDataSource: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInitializationString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataInitialize,
                pDataSource: ?*IUnknown,
                fIncludePassword: u8,
                ppwszInitString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataInitialize,
                pDataSource: ?*IUnknown,
                fIncludePassword: u8,
                ppwszInitString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDBInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataInitialize,
                clsidProvider: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsCtx: u32,
                pwszReserved: ?PWSTR,
                riid: ?*const Guid,
                ppDataSource: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataInitialize,
                clsidProvider: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsCtx: u32,
                pwszReserved: ?PWSTR,
                riid: ?*const Guid,
                ppDataSource: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDBInstanceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataInitialize,
                clsidProvider: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsCtx: u32,
                pwszReserved: ?PWSTR,
                pServerInfo: ?*COSERVERINFO,
                cmq: u32,
                rgmqResults: [*]MULTI_QI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataInitialize,
                clsidProvider: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsCtx: u32,
                pwszReserved: ?PWSTR,
                pServerInfo: ?*COSERVERINFO,
                cmq: u32,
                rgmqResults: [*]MULTI_QI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadStringFromStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataInitialize,
                pwszFileName: ?[*:0]const u16,
                ppwszInitializationString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataInitialize,
                pwszFileName: ?[*:0]const u16,
                ppwszInitializationString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteStringToStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataInitialize,
                pwszFileName: ?[*:0]const u16,
                pwszInitializationString: ?[*:0]const u16,
                dwCreationDisposition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataInitialize,
                pwszFileName: ?[*:0]const u16,
                pwszInitializationString: ?[*:0]const u16,
                dwCreationDisposition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataInitialize_GetDataSource(self: *const T, pUnkOuter: ?*IUnknown, dwClsCtx: u32, pwszInitializationString: ?[*:0]const u16, riid: ?*const Guid, ppDataSource: ?*?*IUnknown) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).GetDataSource(@as(*const IDataInitialize, @ptrCast(self)), pUnkOuter, dwClsCtx, pwszInitializationString, riid, ppDataSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataInitialize_GetInitializationString(self: *const T, pDataSource: ?*IUnknown, fIncludePassword: u8, ppwszInitString: ?*?PWSTR) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).GetInitializationString(@as(*const IDataInitialize, @ptrCast(self)), pDataSource, fIncludePassword, ppwszInitString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataInitialize_CreateDBInstance(self: *const T, clsidProvider: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsCtx: u32, pwszReserved: ?PWSTR, riid: ?*const Guid, ppDataSource: ?*?*IUnknown) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).CreateDBInstance(@as(*const IDataInitialize, @ptrCast(self)), clsidProvider, pUnkOuter, dwClsCtx, pwszReserved, riid, ppDataSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataInitialize_CreateDBInstanceEx(self: *const T, clsidProvider: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsCtx: u32, pwszReserved: ?PWSTR, pServerInfo: ?*COSERVERINFO, cmq: u32, rgmqResults: [*]MULTI_QI) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).CreateDBInstanceEx(@as(*const IDataInitialize, @ptrCast(self)), clsidProvider, pUnkOuter, dwClsCtx, pwszReserved, pServerInfo, cmq, rgmqResults);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataInitialize_LoadStringFromStorage(self: *const T, pwszFileName: ?[*:0]const u16, ppwszInitializationString: ?*?PWSTR) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).LoadStringFromStorage(@as(*const IDataInitialize, @ptrCast(self)), pwszFileName, ppwszInitializationString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataInitialize_WriteStringToStorage(self: *const T, pwszFileName: ?[*:0]const u16, pwszInitializationString: ?[*:0]const u16, dwCreationDisposition: u32) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).WriteStringToStorage(@as(*const IDataInitialize, @ptrCast(self)), pwszFileName, pwszInitializationString, dwCreationDisposition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataSourceLocator_Value = Guid.initString("2206ccb2-19c1-11d1-89e0-00c04fd7a829");
pub const IID_IDataSourceLocator = &IID_IDataSourceLocator_Value;
pub const IDataSourceLocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hWnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDataSourceLocator,
                phwndParent: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDataSourceLocator,
                phwndParent: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hWnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDataSourceLocator,
                hwndParent: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDataSourceLocator,
                hwndParent: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PromptNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataSourceLocator,
                ppADOConnection: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataSourceLocator,
                ppADOConnection: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PromptEdit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataSourceLocator,
                ppADOConnection: ?*?*IDispatch,
                pbSuccess: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataSourceLocator,
                ppADOConnection: ?*?*IDispatch,
                pbSuccess: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataSourceLocator_get_hWnd(self: *const T, phwndParent: ?*i64) HRESULT {
                return @as(*const IDataSourceLocator.VTable, @ptrCast(self.vtable)).get_hWnd(@as(*const IDataSourceLocator, @ptrCast(self)), phwndParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataSourceLocator_put_hWnd(self: *const T, hwndParent: i64) HRESULT {
                return @as(*const IDataSourceLocator.VTable, @ptrCast(self.vtable)).put_hWnd(@as(*const IDataSourceLocator, @ptrCast(self)), hwndParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataSourceLocator_PromptNew(self: *const T, ppADOConnection: ?*?*IDispatch) HRESULT {
                return @as(*const IDataSourceLocator.VTable, @ptrCast(self.vtable)).PromptNew(@as(*const IDataSourceLocator, @ptrCast(self)), ppADOConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataSourceLocator_PromptEdit(self: *const T, ppADOConnection: ?*?*IDispatch, pbSuccess: ?*i16) HRESULT {
                return @as(*const IDataSourceLocator.VTable, @ptrCast(self.vtable)).PromptEdit(@as(*const IDataSourceLocator, @ptrCast(self)), ppADOConnection, pbSuccess);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const KAGREQDIAGFLAGSENUM = enum(i32) {
    HEADER = 1,
    RECORD = 2,
};
pub const KAGREQDIAGFLAGS_HEADER = KAGREQDIAGFLAGSENUM.HEADER;
pub const KAGREQDIAGFLAGS_RECORD = KAGREQDIAGFLAGSENUM.RECORD;

const IID_IRowsetChangeExtInfo_Value = Guid.initString("0c733a8f-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetChangeExtInfo = &IID_IRowsetChangeExtInfo_Value;
pub const IRowsetChangeExtInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOriginalRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetChangeExtInfo,
                hReserved: usize,
                hRow: usize,
                phRowOriginal: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetChangeExtInfo,
                hReserved: usize,
                hRow: usize,
                phRowOriginal: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPendingColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetChangeExtInfo,
                hReserved: usize,
                hRow: usize,
                cColumnOrdinals: u32,
                rgiOrdinals: ?*const u32,
                rgColumnStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetChangeExtInfo,
                hReserved: usize,
                hRow: usize,
                cColumnOrdinals: u32,
                rgiOrdinals: ?*const u32,
                rgColumnStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetChangeExtInfo_GetOriginalRow(self: *const T, hReserved: usize, hRow: usize, phRowOriginal: ?*usize) HRESULT {
                return @as(*const IRowsetChangeExtInfo.VTable, @ptrCast(self.vtable)).GetOriginalRow(@as(*const IRowsetChangeExtInfo, @ptrCast(self)), hReserved, hRow, phRowOriginal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetChangeExtInfo_GetPendingColumns(self: *const T, hReserved: usize, hRow: usize, cColumnOrdinals: u32, rgiOrdinals: ?*const u32, rgColumnStatus: ?*u32) HRESULT {
                return @as(*const IRowsetChangeExtInfo.VTable, @ptrCast(self.vtable)).GetPendingColumns(@as(*const IRowsetChangeExtInfo, @ptrCast(self)), hReserved, hRow, cColumnOrdinals, rgiOrdinals, rgColumnStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const KAGREQDIAG = extern struct {
    ulDiagFlags: u32,
    vt: u16,
    sDiagField: i16,
};

pub const KAGGETDIAG = extern struct {
    ulSize: u32,
    vDiagInfo: VARIANT,
    sDiagField: i16,
};

const IID_ISQLRequestDiagFields_Value = Guid.initString("228972f0-b5ff-11d0-8a80-00c04fd611cd");
pub const IID_ISQLRequestDiagFields = &IID_ISQLRequestDiagFields_Value;
pub const ISQLRequestDiagFields = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestDiagFields: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISQLRequestDiagFields,
                cDiagFields: u32,
                rgDiagFields: [*]KAGREQDIAG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISQLRequestDiagFields,
                cDiagFields: u32,
                rgDiagFields: [*]KAGREQDIAG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISQLRequestDiagFields_RequestDiagFields(self: *const T, cDiagFields: u32, rgDiagFields: [*]KAGREQDIAG) HRESULT {
                return @as(*const ISQLRequestDiagFields.VTable, @ptrCast(self.vtable)).RequestDiagFields(@as(*const ISQLRequestDiagFields, @ptrCast(self)), cDiagFields, rgDiagFields);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISQLGetDiagField_Value = Guid.initString("228972f1-b5ff-11d0-8a80-00c04fd611cd");
pub const IID_ISQLGetDiagField = &IID_ISQLGetDiagField_Value;
pub const ISQLGetDiagField = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDiagField: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISQLGetDiagField,
                pDiagInfo: ?*KAGGETDIAG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISQLGetDiagField,
                pDiagInfo: ?*KAGGETDIAG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISQLGetDiagField_GetDiagField(self: *const T, pDiagInfo: ?*KAGGETDIAG) HRESULT {
                return @as(*const ISQLGetDiagField.VTable, @ptrCast(self.vtable)).GetDiagField(@as(*const ISQLGetDiagField, @ptrCast(self)), pDiagInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MSDSDBINITPROPENUM = enum(i32) {
    R = 2,
};
pub const DBPROP_MSDS_DBINIT_DATAPROVIDER = MSDSDBINITPROPENUM.R;

pub const MSDSSESSIONPROPENUM = enum(i32) {
    S = 2,
};
pub const DBPROP_MSDS_SESS_UNIQUENAMES = MSDSSESSIONPROPENUM.S;

pub const DATE_STRUCT = extern struct {
    year: i16,
    month: u16,
    day: u16,
};

pub const TIME_STRUCT = extern struct {
    hour: u16,
    minute: u16,
    second: u16,
};

pub const TIMESTAMP_STRUCT = extern struct {
    year: i16,
    month: u16,
    day: u16,
    hour: u16,
    minute: u16,
    second: u16,
    fraction: u32,
};

pub const SQLINTERVAL = enum(i32) {
    YEAR = 1,
    MONTH = 2,
    DAY = 3,
    HOUR = 4,
    MINUTE = 5,
    SECOND = 6,
    YEAR_TO_MONTH = 7,
    DAY_TO_HOUR = 8,
    DAY_TO_MINUTE = 9,
    DAY_TO_SECOND = 10,
    HOUR_TO_MINUTE = 11,
    HOUR_TO_SECOND = 12,
    MINUTE_TO_SECOND = 13,
};
pub const SQL_IS_YEAR = SQLINTERVAL.YEAR;
pub const SQL_IS_MONTH = SQLINTERVAL.MONTH;
pub const SQL_IS_DAY = SQLINTERVAL.DAY;
pub const SQL_IS_HOUR = SQLINTERVAL.HOUR;
pub const SQL_IS_MINUTE = SQLINTERVAL.MINUTE;
pub const SQL_IS_SECOND = SQLINTERVAL.SECOND;
pub const SQL_IS_YEAR_TO_MONTH = SQLINTERVAL.YEAR_TO_MONTH;
pub const SQL_IS_DAY_TO_HOUR = SQLINTERVAL.DAY_TO_HOUR;
pub const SQL_IS_DAY_TO_MINUTE = SQLINTERVAL.DAY_TO_MINUTE;
pub const SQL_IS_DAY_TO_SECOND = SQLINTERVAL.DAY_TO_SECOND;
pub const SQL_IS_HOUR_TO_MINUTE = SQLINTERVAL.HOUR_TO_MINUTE;
pub const SQL_IS_HOUR_TO_SECOND = SQLINTERVAL.HOUR_TO_SECOND;
pub const SQL_IS_MINUTE_TO_SECOND = SQLINTERVAL.MINUTE_TO_SECOND;

pub const tagSQL_YEAR_MONTH = extern struct {
    year: u32,
    month: u32,
};

pub const tagSQL_DAY_SECOND = extern struct {
    day: u32,
    hour: u32,
    minute: u32,
    second: u32,
    fraction: u32,
};

pub const SQL_INTERVAL_STRUCT = extern struct {
    interval_type: SQLINTERVAL,
    interval_sign: i16,
    intval: extern union {
        year_month: tagSQL_YEAR_MONTH,
        day_second: tagSQL_DAY_SECOND,
    },
};

pub const SQL_NUMERIC_STRUCT = extern struct {
    precision: u8,
    scale: i8,
    sign: u8,
    val: [16]u8,
};

pub const dbvarychar = extern struct {
    len: i16,
    str: [8001]i8,
};

pub const dbvarybin = extern struct {
    len: i16,
    array: [8001]u8,
};

pub const dbmoney = extern struct {
    mnyhigh: i32,
    mnylow: u32,
};

pub const dbdatetime = extern struct {
    dtdays: i32,
    dttime: u32,
};

pub const dbdatetime4 = extern struct {
    numdays: u16,
    nummins: u16,
};

pub const sqlperf = extern struct {
    TimerResolution: u32,
    SQLidu: u32,
    SQLiduRows: u32,
    SQLSelects: u32,
    SQLSelectRows: u32,
    Transactions: u32,
    SQLPrepares: u32,
    ExecDirects: u32,
    SQLExecutes: u32,
    CursorOpens: u32,
    CursorSize: u32,
    CursorUsed: u32,
    PercentCursorUsed: f64,
    AvgFetchTime: f64,
    AvgCursorSize: f64,
    AvgCursorUsed: f64,
    SQLFetchTime: u32,
    SQLFetchCount: u32,
    CurrentStmtCount: u32,
    MaxOpenStmt: u32,
    SumOpenStmt: u32,
    CurrentConnectionCount: u32,
    MaxConnectionsOpened: u32,
    SumConnectionsOpened: u32,
    SumConnectiontime: u32,
    AvgTimeOpened: f64,
    ServerRndTrips: u32,
    BuffersSent: u32,
    BuffersRec: u32,
    BytesSent: u32,
    BytesRec: u32,
    msExecutionTime: u32,
    msNetWorkServerTime: u32,
};

pub const DBPROPENUM25_DEPRECATED = enum(i32) {
    CommandCost = 141,
    CommandTree = 142,
    CommandValidate = 143,
    DBSchemaCommand = 144,
    ProvideMoniker = 125,
    Query = 146,
    ReadData = 147,
    RowsetAsynch = 148,
    RowsetCopyRows = 149,
    RowsetKeys = 151,
    RowsetNewRowAfter = 152,
    RowsetNextRowset = 153,
    RowsetWatchAll = 155,
    RowsetWatchNotify = 156,
    RowsetWatchRegion = 157,
    RowsetWithParameters = 158,
};
pub const DBPROP_ICommandCost = DBPROPENUM25_DEPRECATED.CommandCost;
pub const DBPROP_ICommandTree = DBPROPENUM25_DEPRECATED.CommandTree;
pub const DBPROP_ICommandValidate = DBPROPENUM25_DEPRECATED.CommandValidate;
pub const DBPROP_IDBSchemaCommand = DBPROPENUM25_DEPRECATED.DBSchemaCommand;
pub const DBPROP_IProvideMoniker = DBPROPENUM25_DEPRECATED.ProvideMoniker;
pub const DBPROP_IQuery = DBPROPENUM25_DEPRECATED.Query;
pub const DBPROP_IReadData = DBPROPENUM25_DEPRECATED.ReadData;
pub const DBPROP_IRowsetAsynch = DBPROPENUM25_DEPRECATED.RowsetAsynch;
pub const DBPROP_IRowsetCopyRows = DBPROPENUM25_DEPRECATED.RowsetCopyRows;
pub const DBPROP_IRowsetKeys = DBPROPENUM25_DEPRECATED.RowsetKeys;
pub const DBPROP_IRowsetNewRowAfter = DBPROPENUM25_DEPRECATED.RowsetNewRowAfter;
pub const DBPROP_IRowsetNextRowset = DBPROPENUM25_DEPRECATED.RowsetNextRowset;
pub const DBPROP_IRowsetWatchAll = DBPROPENUM25_DEPRECATED.RowsetWatchAll;
pub const DBPROP_IRowsetWatchNotify = DBPROPENUM25_DEPRECATED.RowsetWatchNotify;
pub const DBPROP_IRowsetWatchRegion = DBPROPENUM25_DEPRECATED.RowsetWatchRegion;
pub const DBPROP_IRowsetWithParameters = DBPROPENUM25_DEPRECATED.RowsetWithParameters;

pub const DBREASONENUM25 = enum(i32) {
    ROWSADDED = 19,
    POPULATIONCOMPLETE = 20,
    POPULATIONSTOPPED = 21,
};
pub const DBREASON_ROWSET_ROWSADDED = DBREASONENUM25.ROWSADDED;
pub const DBREASON_ROWSET_POPULATIONCOMPLETE = DBREASONENUM25.POPULATIONCOMPLETE;
pub const DBREASON_ROWSET_POPULATIONSTOPPED = DBREASONENUM25.POPULATIONSTOPPED;

const IID_IRowsetNextRowset_Value = Guid.initString("0c733a72-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetNextRowset = &IID_IRowsetNextRowset_Value;
pub const IRowsetNextRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextRowset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetNextRowset,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppNextRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetNextRowset,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppNextRowset: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetNextRowset_GetNextRowset(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppNextRowset: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetNextRowset.VTable, @ptrCast(self.vtable)).GetNextRowset(@as(*const IRowsetNextRowset, @ptrCast(self)), pUnkOuter, riid, ppNextRowset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetNewRowAfter_Value = Guid.initString("0c733a71-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetNewRowAfter = &IID_IRowsetNewRowAfter_Value;
pub const IRowsetNewRowAfter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNewDataAfter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetNewRowAfter,
                hChapter: usize,
                cbbmPrevious: u32,
                pbmPrevious: ?*const u8,
                hAccessor: usize,
                pData: ?*u8,
                phRow: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetNewRowAfter,
                hChapter: usize,
                cbbmPrevious: u32,
                pbmPrevious: ?*const u8,
                hAccessor: usize,
                pData: ?*u8,
                phRow: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetNewRowAfter_SetNewDataAfter(self: *const T, hChapter: usize, cbbmPrevious: u32, pbmPrevious: ?*const u8, hAccessor: usize, pData: ?*u8, phRow: ?*usize) HRESULT {
                return @as(*const IRowsetNewRowAfter.VTable, @ptrCast(self.vtable)).SetNewDataAfter(@as(*const IRowsetNewRowAfter, @ptrCast(self)), hChapter, cbbmPrevious, pbmPrevious, hAccessor, pData, phRow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetWithParameters_Value = Guid.initString("0c733a6e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWithParameters = &IID_IRowsetWithParameters_Value;
pub const IRowsetWithParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParameterInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWithParameters,
                pcParams: ?*usize,
                prgParamInfo: ?*?*DBPARAMINFO,
                ppNamesBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWithParameters,
                pcParams: ?*usize,
                prgParamInfo: ?*?*DBPARAMINFO,
                ppNamesBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Requery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWithParameters,
                pParams: ?*DBPARAMS,
                pulErrorParam: ?*u32,
                phReserved: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWithParameters,
                pParams: ?*DBPARAMS,
                pulErrorParam: ?*u32,
                phReserved: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWithParameters_GetParameterInfo(self: *const T, pcParams: ?*usize, prgParamInfo: ?*?*DBPARAMINFO, ppNamesBuffer: ?*?*u16) HRESULT {
                return @as(*const IRowsetWithParameters.VTable, @ptrCast(self.vtable)).GetParameterInfo(@as(*const IRowsetWithParameters, @ptrCast(self)), pcParams, prgParamInfo, ppNamesBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWithParameters_Requery(self: *const T, pParams: ?*DBPARAMS, pulErrorParam: ?*u32, phReserved: ?*usize) HRESULT {
                return @as(*const IRowsetWithParameters.VTable, @ptrCast(self.vtable)).Requery(@as(*const IRowsetWithParameters, @ptrCast(self)), pParams, pulErrorParam, phReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetAsynch_Value = Guid.initString("0c733a0f-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetAsynch = &IID_IRowsetAsynch_Value;
pub const IRowsetAsynch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RatioFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetAsynch,
                pulDenominator: ?*usize,
                pulNumerator: ?*usize,
                pcRows: ?*usize,
                pfNewRows: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetAsynch,
                pulDenominator: ?*usize,
                pulNumerator: ?*usize,
                pcRows: ?*usize,
                pfNewRows: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetAsynch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetAsynch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetAsynch_RatioFinished(self: *const T, pulDenominator: ?*usize, pulNumerator: ?*usize, pcRows: ?*usize, pfNewRows: ?*BOOL) HRESULT {
                return @as(*const IRowsetAsynch.VTable, @ptrCast(self.vtable)).RatioFinished(@as(*const IRowsetAsynch, @ptrCast(self)), pulDenominator, pulNumerator, pcRows, pfNewRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetAsynch_Stop(self: *const T) HRESULT {
                return @as(*const IRowsetAsynch.VTable, @ptrCast(self.vtable)).Stop(@as(*const IRowsetAsynch, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetKeys_Value = Guid.initString("0c733a12-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetKeys = &IID_IRowsetKeys_Value;
pub const IRowsetKeys = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ListKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetKeys,
                pcColumns: ?*usize,
                prgColumns: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetKeys,
                pcColumns: ?*usize,
                prgColumns: ?*?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetKeys_ListKeys(self: *const T, pcColumns: ?*usize, prgColumns: ?*?*usize) HRESULT {
                return @as(*const IRowsetKeys.VTable, @ptrCast(self.vtable)).ListKeys(@as(*const IRowsetKeys, @ptrCast(self)), pcColumns, prgColumns);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetWatchAll_Value = Guid.initString("0c733a73-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWatchAll = &IID_IRowsetWatchAll_Value;
pub const IRowsetWatchAll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Acknowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchAll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchAll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchAll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchAll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopWatching: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchAll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchAll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchAll_Acknowledge(self: *const T) HRESULT {
                return @as(*const IRowsetWatchAll.VTable, @ptrCast(self.vtable)).Acknowledge(@as(*const IRowsetWatchAll, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchAll_Start(self: *const T) HRESULT {
                return @as(*const IRowsetWatchAll.VTable, @ptrCast(self.vtable)).Start(@as(*const IRowsetWatchAll, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchAll_StopWatching(self: *const T) HRESULT {
                return @as(*const IRowsetWatchAll.VTable, @ptrCast(self.vtable)).StopWatching(@as(*const IRowsetWatchAll, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBWATCHNOTIFYENUM = enum(i32) {
    ROWSCHANGED = 1,
    QUERYDONE = 2,
    QUERYREEXECUTED = 3,
};
pub const DBWATCHNOTIFY_ROWSCHANGED = DBWATCHNOTIFYENUM.ROWSCHANGED;
pub const DBWATCHNOTIFY_QUERYDONE = DBWATCHNOTIFYENUM.QUERYDONE;
pub const DBWATCHNOTIFY_QUERYREEXECUTED = DBWATCHNOTIFYENUM.QUERYREEXECUTED;

const IID_IRowsetWatchNotify_Value = Guid.initString("0c733a44-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWatchNotify = &IID_IRowsetWatchNotify_Value;
pub const IRowsetWatchNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchNotify,
                pRowset: ?*IRowset,
                eChangeReason: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchNotify,
                pRowset: ?*IRowset,
                eChangeReason: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchNotify_OnChange(self: *const T, pRowset: ?*IRowset, eChangeReason: u32) HRESULT {
                return @as(*const IRowsetWatchNotify.VTable, @ptrCast(self.vtable)).OnChange(@as(*const IRowsetWatchNotify, @ptrCast(self)), pRowset, eChangeReason);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBWATCHMODEENUM = enum(i32) {
    ALL = 1,
    EXTEND = 2,
    MOVE = 4,
    COUNT = 8,
};
pub const DBWATCHMODE_ALL = DBWATCHMODEENUM.ALL;
pub const DBWATCHMODE_EXTEND = DBWATCHMODEENUM.EXTEND;
pub const DBWATCHMODE_MOVE = DBWATCHMODEENUM.MOVE;
pub const DBWATCHMODE_COUNT = DBWATCHMODEENUM.COUNT;

pub const DBROWCHANGEKINDENUM = enum(i32) {
    INSERT = 0,
    DELETE = 1,
    UPDATE = 2,
    COUNT = 3,
};
pub const DBROWCHANGEKIND_INSERT = DBROWCHANGEKINDENUM.INSERT;
pub const DBROWCHANGEKIND_DELETE = DBROWCHANGEKINDENUM.DELETE;
pub const DBROWCHANGEKIND_UPDATE = DBROWCHANGEKINDENUM.UPDATE;
pub const DBROWCHANGEKIND_COUNT = DBROWCHANGEKINDENUM.COUNT;

const IID_IRowsetWatchRegion_Value = Guid.initString("0c733a45-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWatchRegion = &IID_IRowsetWatchRegion_Value;
pub const IRowsetWatchRegion = extern struct {
    pub const VTable = extern struct {
        base: IRowsetWatchAll.VTable,
        CreateWatchRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchRegion,
                dwWatchMode: u32,
                phRegion: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchRegion,
                dwWatchMode: u32,
                phRegion: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeWatchMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchRegion,
                hRegion: usize,
                dwWatchMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchRegion,
                hRegion: usize,
                dwWatchMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteWatchRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchRegion,
                hRegion: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchRegion,
                hRegion: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWatchRegionInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchRegion,
                hRegion: usize,
                pdwWatchMode: ?*u32,
                phChapter: ?*usize,
                pcbBookmark: ?*usize,
                ppBookmark: ?*?*u8,
                pcRows: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchRegion,
                hRegion: usize,
                pdwWatchMode: ?*u32,
                phChapter: ?*usize,
                pcbBookmark: ?*usize,
                ppBookmark: ?*?*u8,
                pcRows: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchRegion,
                pcChangesObtained: ?*usize,
                prgChanges: ?*?*tagDBROWWATCHRANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchRegion,
                pcChangesObtained: ?*usize,
                prgChanges: ?*?*tagDBROWWATCHRANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShrinkWatchRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetWatchRegion,
                hRegion: usize,
                hChapter: usize,
                cbBookmark: usize,
                pBookmark: ?*u8,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetWatchRegion,
                hRegion: usize,
                hChapter: usize,
                cbBookmark: usize,
                pBookmark: ?*u8,
                cRows: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowsetWatchAll.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchRegion_CreateWatchRegion(self: *const T, dwWatchMode: u32, phRegion: ?*usize) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).CreateWatchRegion(@as(*const IRowsetWatchRegion, @ptrCast(self)), dwWatchMode, phRegion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchRegion_ChangeWatchMode(self: *const T, hRegion: usize, dwWatchMode: u32) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).ChangeWatchMode(@as(*const IRowsetWatchRegion, @ptrCast(self)), hRegion, dwWatchMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchRegion_DeleteWatchRegion(self: *const T, hRegion: usize) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).DeleteWatchRegion(@as(*const IRowsetWatchRegion, @ptrCast(self)), hRegion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchRegion_GetWatchRegionInfo(self: *const T, hRegion: usize, pdwWatchMode: ?*u32, phChapter: ?*usize, pcbBookmark: ?*usize, ppBookmark: ?*?*u8, pcRows: ?*isize) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).GetWatchRegionInfo(@as(*const IRowsetWatchRegion, @ptrCast(self)), hRegion, pdwWatchMode, phChapter, pcbBookmark, ppBookmark, pcRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchRegion_Refresh(self: *const T, pcChangesObtained: ?*usize, prgChanges: ?*?*tagDBROWWATCHRANGE) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IRowsetWatchRegion, @ptrCast(self)), pcChangesObtained, prgChanges);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetWatchRegion_ShrinkWatchRegion(self: *const T, hRegion: usize, hChapter: usize, cbBookmark: usize, pBookmark: ?*u8, cRows: isize) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).ShrinkWatchRegion(@as(*const IRowsetWatchRegion, @ptrCast(self)), hRegion, hChapter, cbBookmark, pBookmark, cRows);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetCopyRows_Value = Guid.initString("0c733a6b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetCopyRows = &IID_IRowsetCopyRows_Value;
pub const IRowsetCopyRows = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CloseSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetCopyRows,
                hSourceID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetCopyRows,
                hSourceID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyByHROWS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetCopyRows,
                hSourceID: u16,
                hReserved: usize,
                cRows: isize,
                rghRows: ?*const usize,
                bFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetCopyRows,
                hSourceID: u16,
                hReserved: usize,
                cRows: isize,
                rghRows: ?*const usize,
                bFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetCopyRows,
                hSourceID: u16,
                hReserved: usize,
                cRows: isize,
                bFlags: u32,
                pcRowsCopied: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetCopyRows,
                hSourceID: u16,
                hReserved: usize,
                cRows: isize,
                bFlags: u32,
                pcRowsCopied: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetCopyRows,
                pRowsetSource: ?*IRowset,
                cColIds: usize,
                rgSourceColumns: ?*const isize,
                rgTargetColumns: ?*const isize,
                phSourceID: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetCopyRows,
                pRowsetSource: ?*IRowset,
                cColIds: usize,
                rgSourceColumns: ?*const isize,
                rgTargetColumns: ?*const isize,
                phSourceID: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetCopyRows_CloseSource(self: *const T, hSourceID: u16) HRESULT {
                return @as(*const IRowsetCopyRows.VTable, @ptrCast(self.vtable)).CloseSource(@as(*const IRowsetCopyRows, @ptrCast(self)), hSourceID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetCopyRows_CopyByHROWS(self: *const T, hSourceID: u16, hReserved: usize, cRows: isize, rghRows: ?*const usize, bFlags: u32) HRESULT {
                return @as(*const IRowsetCopyRows.VTable, @ptrCast(self.vtable)).CopyByHROWS(@as(*const IRowsetCopyRows, @ptrCast(self)), hSourceID, hReserved, cRows, rghRows, bFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetCopyRows_CopyRows(self: *const T, hSourceID: u16, hReserved: usize, cRows: isize, bFlags: u32, pcRowsCopied: ?*usize) HRESULT {
                return @as(*const IRowsetCopyRows.VTable, @ptrCast(self.vtable)).CopyRows(@as(*const IRowsetCopyRows, @ptrCast(self)), hSourceID, hReserved, cRows, bFlags, pcRowsCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetCopyRows_DefineSource(self: *const T, pRowsetSource: ?*IRowset, cColIds: usize, rgSourceColumns: ?*const isize, rgTargetColumns: ?*const isize, phSourceID: ?*u16) HRESULT {
                return @as(*const IRowsetCopyRows.VTable, @ptrCast(self.vtable)).DefineSource(@as(*const IRowsetCopyRows, @ptrCast(self)), pRowsetSource, cColIds, rgSourceColumns, rgTargetColumns, phSourceID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IReadData_Value = Guid.initString("0c733a6a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IReadData = &IID_IReadData_Value;
pub const IReadData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IReadData,
                hChapter: usize,
                cbBookmark: usize,
                pBookmark: ?*const u8,
                lRowsOffset: isize,
                hAccessor: usize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                ppFixedData: ?*?*u8,
                pcbVariableTotal: ?*usize,
                ppVariableData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IReadData,
                hChapter: usize,
                cbBookmark: usize,
                pBookmark: ?*const u8,
                lRowsOffset: isize,
                hAccessor: usize,
                cRows: isize,
                pcRowsObtained: ?*usize,
                ppFixedData: ?*?*u8,
                pcbVariableTotal: ?*usize,
                ppVariableData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IReadData,
                hChapter: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IReadData,
                hChapter: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IReadData_ReadData(self: *const T, hChapter: usize, cbBookmark: usize, pBookmark: ?*const u8, lRowsOffset: isize, hAccessor: usize, cRows: isize, pcRowsObtained: ?*usize, ppFixedData: ?*?*u8, pcbVariableTotal: ?*usize, ppVariableData: ?*?*u8) HRESULT {
                return @as(*const IReadData.VTable, @ptrCast(self.vtable)).ReadData(@as(*const IReadData, @ptrCast(self)), hChapter, cbBookmark, pBookmark, lRowsOffset, hAccessor, cRows, pcRowsObtained, ppFixedData, pcbVariableTotal, ppVariableData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IReadData_ReleaseChapter(self: *const T, hChapter: usize) HRESULT {
                return @as(*const IReadData.VTable, @ptrCast(self.vtable)).ReleaseChapter(@as(*const IReadData, @ptrCast(self)), hChapter);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBRESOURCEKINDENUM = enum(i32) {
    INVALID = 0,
    TOTAL = 1,
    CPU = 2,
    MEMORY = 3,
    DISK = 4,
    NETWORK = 5,
    RESPONSE = 6,
    ROWS = 7,
    OTHER = 8,
};
pub const DBRESOURCE_INVALID = DBRESOURCEKINDENUM.INVALID;
pub const DBRESOURCE_TOTAL = DBRESOURCEKINDENUM.TOTAL;
pub const DBRESOURCE_CPU = DBRESOURCEKINDENUM.CPU;
pub const DBRESOURCE_MEMORY = DBRESOURCEKINDENUM.MEMORY;
pub const DBRESOURCE_DISK = DBRESOURCEKINDENUM.DISK;
pub const DBRESOURCE_NETWORK = DBRESOURCEKINDENUM.NETWORK;
pub const DBRESOURCE_RESPONSE = DBRESOURCEKINDENUM.RESPONSE;
pub const DBRESOURCE_ROWS = DBRESOURCEKINDENUM.ROWS;
pub const DBRESOURCE_OTHER = DBRESOURCEKINDENUM.OTHER;

pub const DBCOSTUNITENUM = enum(i32) {
    INVALID = 0,
    WEIGHT = 1,
    PERCENT = 2,
    MAXIMUM = 4,
    MINIMUM = 8,
    MICRO_SECOND = 16,
    MILLI_SECOND = 32,
    SECOND = 64,
    MINUTE = 128,
    HOUR = 256,
    BYTE = 512,
    KILO_BYTE = 1024,
    MEGA_BYTE = 2048,
    GIGA_BYTE = 4096,
    NUM_MSGS = 8192,
    NUM_LOCKS = 16384,
    NUM_ROWS = 32768,
    OTHER = 65536,
};
pub const DBUNIT_INVALID = DBCOSTUNITENUM.INVALID;
pub const DBUNIT_WEIGHT = DBCOSTUNITENUM.WEIGHT;
pub const DBUNIT_PERCENT = DBCOSTUNITENUM.PERCENT;
pub const DBUNIT_MAXIMUM = DBCOSTUNITENUM.MAXIMUM;
pub const DBUNIT_MINIMUM = DBCOSTUNITENUM.MINIMUM;
pub const DBUNIT_MICRO_SECOND = DBCOSTUNITENUM.MICRO_SECOND;
pub const DBUNIT_MILLI_SECOND = DBCOSTUNITENUM.MILLI_SECOND;
pub const DBUNIT_SECOND = DBCOSTUNITENUM.SECOND;
pub const DBUNIT_MINUTE = DBCOSTUNITENUM.MINUTE;
pub const DBUNIT_HOUR = DBCOSTUNITENUM.HOUR;
pub const DBUNIT_BYTE = DBCOSTUNITENUM.BYTE;
pub const DBUNIT_KILO_BYTE = DBCOSTUNITENUM.KILO_BYTE;
pub const DBUNIT_MEGA_BYTE = DBCOSTUNITENUM.MEGA_BYTE;
pub const DBUNIT_GIGA_BYTE = DBCOSTUNITENUM.GIGA_BYTE;
pub const DBUNIT_NUM_MSGS = DBCOSTUNITENUM.NUM_MSGS;
pub const DBUNIT_NUM_LOCKS = DBCOSTUNITENUM.NUM_LOCKS;
pub const DBUNIT_NUM_ROWS = DBCOSTUNITENUM.NUM_ROWS;
pub const DBUNIT_OTHER = DBCOSTUNITENUM.OTHER;

pub const DBEXECLIMITSENUM = enum(i32) {
    ABORT = 1,
    STOP = 2,
    SUSPEND = 3,
};
pub const DBEXECLIMITS_ABORT = DBEXECLIMITSENUM.ABORT;
pub const DBEXECLIMITS_STOP = DBEXECLIMITSENUM.STOP;
pub const DBEXECLIMITS_SUSPEND = DBEXECLIMITSENUM.SUSPEND;

const IID_ICommandCost_Value = Guid.initString("0c733a4e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandCost = &IID_ICommandCost_Value;
pub const ICommandCost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAccumulatedCost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                pcCostLimits: ?*u32,
                prgCostLimits: ?*?*DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                pcCostLimits: ?*u32,
                prgCostLimits: ?*?*DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCostEstimate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                pcCostEstimates: ?*u32,
                prgCostEstimates: ?*DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                pcCostEstimates: ?*u32,
                prgCostEstimates: ?*DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCostGoals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                pcCostGoals: ?*u32,
                prgCostGoals: ?*DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                pcCostGoals: ?*u32,
                prgCostGoals: ?*DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCostLimits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                pcCostLimits: ?*u32,
                prgCostLimits: ?*DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                pcCostLimits: ?*u32,
                prgCostLimits: ?*DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCostGoals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                cCostGoals: u32,
                rgCostGoals: ?*const DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                cCostGoals: u32,
                rgCostGoals: ?*const DBCOST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCostLimits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                cCostLimits: u32,
                prgCostLimits: ?*DBCOST,
                dwExecutionFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandCost,
                pwszRowsetName: ?[*:0]const u16,
                cCostLimits: u32,
                prgCostLimits: ?*DBCOST,
                dwExecutionFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandCost_GetAccumulatedCost(self: *const T, pwszRowsetName: ?[*:0]const u16, pcCostLimits: ?*u32, prgCostLimits: ?*?*DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).GetAccumulatedCost(@as(*const ICommandCost, @ptrCast(self)), pwszRowsetName, pcCostLimits, prgCostLimits);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandCost_GetCostEstimate(self: *const T, pwszRowsetName: ?[*:0]const u16, pcCostEstimates: ?*u32, prgCostEstimates: ?*DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).GetCostEstimate(@as(*const ICommandCost, @ptrCast(self)), pwszRowsetName, pcCostEstimates, prgCostEstimates);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandCost_GetCostGoals(self: *const T, pwszRowsetName: ?[*:0]const u16, pcCostGoals: ?*u32, prgCostGoals: ?*DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).GetCostGoals(@as(*const ICommandCost, @ptrCast(self)), pwszRowsetName, pcCostGoals, prgCostGoals);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandCost_GetCostLimits(self: *const T, pwszRowsetName: ?[*:0]const u16, pcCostLimits: ?*u32, prgCostLimits: ?*DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).GetCostLimits(@as(*const ICommandCost, @ptrCast(self)), pwszRowsetName, pcCostLimits, prgCostLimits);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandCost_SetCostGoals(self: *const T, pwszRowsetName: ?[*:0]const u16, cCostGoals: u32, rgCostGoals: ?*const DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).SetCostGoals(@as(*const ICommandCost, @ptrCast(self)), pwszRowsetName, cCostGoals, rgCostGoals);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandCost_SetCostLimits(self: *const T, pwszRowsetName: ?[*:0]const u16, cCostLimits: u32, prgCostLimits: ?*DBCOST, dwExecutionFlags: u32) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).SetCostLimits(@as(*const ICommandCost, @ptrCast(self)), pwszRowsetName, cCostLimits, prgCostLimits, dwExecutionFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandValidate_Value = Guid.initString("0c733a18-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandValidate = &IID_ICommandValidate_Value;
pub const ICommandValidate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateCompletely: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandValidate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandValidate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ValidateSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommandValidate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommandValidate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandValidate_ValidateCompletely(self: *const T) HRESULT {
                return @as(*const ICommandValidate.VTable, @ptrCast(self.vtable)).ValidateCompletely(@as(*const ICommandValidate, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommandValidate_ValidateSyntax(self: *const T) HRESULT {
                return @as(*const ICommandValidate.VTable, @ptrCast(self.vtable)).ValidateSyntax(@as(*const ICommandValidate, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableRename_Value = Guid.initString("0c733a77-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableRename = &IID_ITableRename_Value;
pub const ITableRename = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenameColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableRename,
                pTableId: ?*DBID,
                pOldColumnId: ?*DBID,
                pNewColumnId: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableRename,
                pTableId: ?*DBID,
                pOldColumnId: ?*DBID,
                pNewColumnId: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenameTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableRename,
                pOldTableId: ?*DBID,
                pOldIndexId: ?*DBID,
                pNewTableId: ?*DBID,
                pNewIndexId: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableRename,
                pOldTableId: ?*DBID,
                pOldIndexId: ?*DBID,
                pNewTableId: ?*DBID,
                pNewIndexId: ?*DBID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableRename_RenameColumn(self: *const T, pTableId: ?*DBID, pOldColumnId: ?*DBID, pNewColumnId: ?*DBID) HRESULT {
                return @as(*const ITableRename.VTable, @ptrCast(self.vtable)).RenameColumn(@as(*const ITableRename, @ptrCast(self)), pTableId, pOldColumnId, pNewColumnId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableRename_RenameTable(self: *const T, pOldTableId: ?*DBID, pOldIndexId: ?*DBID, pNewTableId: ?*DBID, pNewIndexId: ?*DBID) HRESULT {
                return @as(*const ITableRename.VTable, @ptrCast(self.vtable)).RenameTable(@as(*const ITableRename, @ptrCast(self)), pOldTableId, pOldIndexId, pNewTableId, pNewIndexId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBSchemaCommand_Value = Guid.initString("0c733a50-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBSchemaCommand = &IID_IDBSchemaCommand_Value;
pub const IDBSchemaCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBSchemaCommand,
                pUnkOuter: ?*IUnknown,
                rguidSchema: ?*const Guid,
                ppCommand: ?*?*ICommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBSchemaCommand,
                pUnkOuter: ?*IUnknown,
                rguidSchema: ?*const Guid,
                ppCommand: ?*?*ICommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSchemas: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDBSchemaCommand,
                pcSchemas: ?*u32,
                prgSchemas: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDBSchemaCommand,
                pcSchemas: ?*u32,
                prgSchemas: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBSchemaCommand_GetCommand(self: *const T, pUnkOuter: ?*IUnknown, rguidSchema: ?*const Guid, ppCommand: ?*?*ICommand) HRESULT {
                return @as(*const IDBSchemaCommand.VTable, @ptrCast(self.vtable)).GetCommand(@as(*const IDBSchemaCommand, @ptrCast(self)), pUnkOuter, rguidSchema, ppCommand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDBSchemaCommand_GetSchemas(self: *const T, pcSchemas: ?*u32, prgSchemas: ?*?*Guid) HRESULT {
                return @as(*const IDBSchemaCommand.VTable, @ptrCast(self.vtable)).GetSchemas(@as(*const IDBSchemaCommand, @ptrCast(self)), pcSchemas, prgSchemas);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IProvideMoniker_Value = Guid.initString("0c733a4d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IProvideMoniker = &IID_IProvideMoniker_Value;
pub const IProvideMoniker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProvideMoniker,
                ppIMoniker: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProvideMoniker,
                ppIMoniker: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProvideMoniker_GetMoniker(self: *const T, ppIMoniker: ?*?*IMoniker) HRESULT {
                return @as(*const IProvideMoniker.VTable, @ptrCast(self.vtable)).GetMoniker(@as(*const IProvideMoniker, @ptrCast(self)), ppIMoniker);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NOTRESTRICTION = extern struct {
    pRes: ?*RESTRICTION,
};

pub const NODERESTRICTION = extern struct {
    cRes: u32,
    paRes: ?*?*RESTRICTION,
    reserved: u32,
};

pub const VECTORRESTRICTION = extern struct {
    Node: NODERESTRICTION,
    RankMethod: u32,
};

pub const CONTENTRESTRICTION = extern struct {
    prop: FULLPROPSPEC,
    pwcsPhrase: ?PWSTR,
    lcid: u32,
    ulGenerateMethod: u32,
};

pub const NATLANGUAGERESTRICTION = extern struct {
    prop: FULLPROPSPEC,
    pwcsPhrase: ?PWSTR,
    lcid: u32,
};

pub const PROPERTYRESTRICTION = extern struct {
    rel: u32,
    prop: FULLPROPSPEC,
    prval: PROPVARIANT,
};

pub const RESTRICTION = extern struct {
    pub const _URes = extern union {
        ar: NODERESTRICTION,
        orRestriction: NODERESTRICTION,
        pxr: NODERESTRICTION,
        vr: VECTORRESTRICTION,
        nr: NOTRESTRICTION,
        cr: CONTENTRESTRICTION,
        nlr: NATLANGUAGERESTRICTION,
        pr: PROPERTYRESTRICTION,
    };
    rt: u32,
    weight: u32,
    res: _URes,
};

pub const COLUMNSET = extern struct {
    cCol: u32,
    aCol: ?*FULLPROPSPEC,
};

pub const SORTKEY = extern struct {
    propColumn: FULLPROPSPEC,
    dwOrder: u32,
    locale: u32,
};

pub const SORTSET = extern struct {
    cCol: u32,
    aCol: ?*SORTKEY,
};

pub const BUCKETCATEGORIZE = extern struct {
    cBuckets: u32,
    Distribution: u32,
};

pub const RANGECATEGORIZE = extern struct {
    cRange: u32,
    aRangeBegin: ?*PROPVARIANT,
};

pub const CATEGORIZATION = extern struct {
    ulCatType: u32,
    Anonymous: extern union {
        cClusters: u32,
        bucket: BUCKETCATEGORIZE,
        range: RANGECATEGORIZE,
    },
    csColumns: COLUMNSET,
};

pub const CATEGORIZATIONSET = extern struct {
    cCat: u32,
    aCat: ?*CATEGORIZATION,
};

const IID_ISearchQueryHits_Value = Guid.initString("ed8ce7e0-106c-11ce-84e2-00aa004b9986");
pub const IID_ISearchQueryHits = &IID_ISearchQueryHits_Value;
pub const ISearchQueryHits = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchQueryHits,
                pflt: ?*IFilter,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn (
                self: *const ISearchQueryHits,
                pflt: ?*IFilter,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        NextHitMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchQueryHits,
                pcMnk: ?*u32,
                papMnk: ?*?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn (
                self: *const ISearchQueryHits,
                pcMnk: ?*u32,
                papMnk: ?*?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        NextHitOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchQueryHits,
                pcRegion: ?*u32,
                paRegion: ?*?*FILTERREGION,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn (
                self: *const ISearchQueryHits,
                pcRegion: ?*u32,
                paRegion: ?*?*FILTERREGION,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHits_Init(self: *const T, pflt: ?*IFilter, ulFlags: u32) i32 {
                return @as(*const ISearchQueryHits.VTable, @ptrCast(self.vtable)).Init(@as(*const ISearchQueryHits, @ptrCast(self)), pflt, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHits_NextHitMoniker(self: *const T, pcMnk: ?*u32, papMnk: ?*?*?*IMoniker) i32 {
                return @as(*const ISearchQueryHits.VTable, @ptrCast(self.vtable)).NextHitMoniker(@as(*const ISearchQueryHits, @ptrCast(self)), pcMnk, papMnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchQueryHits_NextHitOffset(self: *const T, pcRegion: ?*u32, paRegion: ?*?*FILTERREGION) i32 {
                return @as(*const ISearchQueryHits.VTable, @ptrCast(self.vtable)).NextHitOffset(@as(*const ISearchQueryHits, @ptrCast(self)), pcRegion, paRegion);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetQueryStatus_Value = Guid.initString("a7ac77ed-f8d7-11ce-a798-0020f8008024");
pub const IID_IRowsetQueryStatus = &IID_IRowsetQueryStatus_Value;
pub const IRowsetQueryStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetQueryStatus,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetQueryStatus,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatusEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetQueryStatus,
                pdwStatus: ?*u32,
                pcFilteredDocuments: ?*u32,
                pcDocumentsToFilter: ?*u32,
                pdwRatioFinishedDenominator: ?*usize,
                pdwRatioFinishedNumerator: ?*usize,
                cbBmk: usize,
                pBmk: ?*const u8,
                piRowBmk: ?*usize,
                pcRowsTotal: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetQueryStatus,
                pdwStatus: ?*u32,
                pcFilteredDocuments: ?*u32,
                pcDocumentsToFilter: ?*u32,
                pdwRatioFinishedDenominator: ?*usize,
                pdwRatioFinishedNumerator: ?*usize,
                cbBmk: usize,
                pBmk: ?*const u8,
                piRowBmk: ?*usize,
                pcRowsTotal: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetQueryStatus_GetStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IRowsetQueryStatus.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IRowsetQueryStatus, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetQueryStatus_GetStatusEx(self: *const T, pdwStatus: ?*u32, pcFilteredDocuments: ?*u32, pcDocumentsToFilter: ?*u32, pdwRatioFinishedDenominator: ?*usize, pdwRatioFinishedNumerator: ?*usize, cbBmk: usize, pBmk: ?*const u8, piRowBmk: ?*usize, pcRowsTotal: ?*usize) HRESULT {
                return @as(*const IRowsetQueryStatus.VTable, @ptrCast(self.vtable)).GetStatusEx(@as(*const IRowsetQueryStatus, @ptrCast(self)), pdwStatus, pcFilteredDocuments, pcDocumentsToFilter, pdwRatioFinishedDenominator, pdwRatioFinishedNumerator, cbBmk, pBmk, piRowBmk, pcRowsTotal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ODBC_VS_ARGS = extern struct {
    pguidEvent: ?*const Guid,
    dwFlags: u32,
    Anonymous1: extern union {
        wszArg: ?PWSTR,
        szArg: ?PSTR,
    },
    Anonymous2: extern union {
        wszCorrelation: ?PWSTR,
        szCorrelation: ?PSTR,
    },
    RetCode: i16,
};

pub const SQLVARENUM = enum(i32) {
    EMPTY = 0,
    NULL = 1,
    UI1 = 17,
    I2 = 2,
    I4 = 3,
    I8 = 20,
    R4 = 4,
    R8 = 5,
    MONEY = 6,
    SMALLMONEY = 200,
    WSTRING = 201,
    WVARSTRING = 202,
    STRING = 203,
    VARSTRING = 204,
    BIT = 11,
    GUID = 72,
    NUMERIC = 131,
    DECIMAL = 205,
    DATETIME = 135,
    SMALLDATETIME = 206,
    BINARY = 207,
    VARBINARY = 208,
    UNKNOWN = 209,
};
pub const VT_SS_EMPTY = SQLVARENUM.EMPTY;
pub const VT_SS_NULL = SQLVARENUM.NULL;
pub const VT_SS_UI1 = SQLVARENUM.UI1;
pub const VT_SS_I2 = SQLVARENUM.I2;
pub const VT_SS_I4 = SQLVARENUM.I4;
pub const VT_SS_I8 = SQLVARENUM.I8;
pub const VT_SS_R4 = SQLVARENUM.R4;
pub const VT_SS_R8 = SQLVARENUM.R8;
pub const VT_SS_MONEY = SQLVARENUM.MONEY;
pub const VT_SS_SMALLMONEY = SQLVARENUM.SMALLMONEY;
pub const VT_SS_WSTRING = SQLVARENUM.WSTRING;
pub const VT_SS_WVARSTRING = SQLVARENUM.WVARSTRING;
pub const VT_SS_STRING = SQLVARENUM.STRING;
pub const VT_SS_VARSTRING = SQLVARENUM.VARSTRING;
pub const VT_SS_BIT = SQLVARENUM.BIT;
pub const VT_SS_GUID = SQLVARENUM.GUID;
pub const VT_SS_NUMERIC = SQLVARENUM.NUMERIC;
pub const VT_SS_DECIMAL = SQLVARENUM.DECIMAL;
pub const VT_SS_DATETIME = SQLVARENUM.DATETIME;
pub const VT_SS_SMALLDATETIME = SQLVARENUM.SMALLDATETIME;
pub const VT_SS_BINARY = SQLVARENUM.BINARY;
pub const VT_SS_VARBINARY = SQLVARENUM.VARBINARY;
pub const VT_SS_UNKNOWN = SQLVARENUM.UNKNOWN;

pub const SSVARIANT = extern struct {
    vt: u16,
    dwReserved1: u32,
    dwReserved2: u32,
    Anonymous: extern union {
        pub const _UnknownType = extern struct {
            dwActualLength: u32,
            rgMetadata: [16]u8,
            pUnknownData: ?*u8,
        };
        pub const _CharVal = extern struct {
            sActualLength: i16,
            sMaxLength: i16,
            pchCharVal: ?PSTR,
            rgbReserved: [5]u8,
            dwReserved: u32,
            pwchReserved: ?PWSTR,
        };
        pub const _BinaryVal = extern struct {
            sActualLength: i16,
            sMaxLength: i16,
            prgbBinaryVal: ?*u8,
            dwReserved: u32,
        };
        pub const _BLOBType = extern struct {
            dbobj: DBOBJECT,
            pUnk: ?*IUnknown,
        };
        pub const _NCharVal = extern struct {
            sActualLength: i16,
            sMaxLength: i16,
            pwchNCharVal: ?PWSTR,
            rgbReserved: [5]u8,
            dwReserved: u32,
            pwchReserved: ?PWSTR,
        };
        bTinyIntVal: u8,
        sShortIntVal: i16,
        lIntVal: i32,
        llBigIntVal: i64,
        fltRealVal: f32,
        dblFloatVal: f64,
        cyMoneyVal: CY,
        NCharVal: _NCharVal,
        CharVal: _CharVal,
        fBitVal: i16,
        rgbGuidVal: [16]u8,
        numNumericVal: DB_NUMERIC,
        BinaryVal: _BinaryVal,
        tsDateTimeVal: DBTIMESTAMP,
        UnknownType: _UnknownType,
        BLOBType: _BLOBType,
    },
};

const IID_IUMSInitialize_Value = Guid.initString("5cf4ca14-ef21-11d0-97e7-00c04fc2ad98");
pub const IID_IUMSInitialize = &IID_IUMSInitialize_Value;
pub const IUMSInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUMSInitialize,
                pUMS: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUMSInitialize,
                pUMS: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUMSInitialize_Initialize(self: *const T, pUMS: ?*anyopaque) HRESULT {
                return @as(*const IUMSInitialize.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IUMSInitialize, @ptrCast(self)), pUMS);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IUMS = extern struct {
    pub const VTable = extern struct {
        SqlUmsSuspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUMS,
                ticks: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IUMS,
                ticks: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SqlUmsYield: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUMS,
                ticks: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IUMS,
                ticks: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SqlUmsSwitchPremptive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUMS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IUMS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SqlUmsSwitchNonPremptive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUMS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IUMS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SqlUmsFIsPremptive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUMS,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IUMS,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUMS_SqlUmsSuspend(self: *const T, ticks: u32) void {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsSuspend(@as(*const IUMS, @ptrCast(self)), ticks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUMS_SqlUmsYield(self: *const T, ticks: u32) void {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsYield(@as(*const IUMS, @ptrCast(self)), ticks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUMS_SqlUmsSwitchPremptive(self: *const T) void {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsSwitchPremptive(@as(*const IUMS, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUMS_SqlUmsSwitchNonPremptive(self: *const T) void {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsSwitchNonPremptive(@as(*const IUMS, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUMS_SqlUmsFIsPremptive(self: *const T) BOOL {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsFIsPremptive(@as(*const IUMS, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const tagSSErrorInfo = extern struct {
    pwszMessage: ?PWSTR,
    pwszServer: ?PWSTR,
    pwszProcedure: ?PWSTR,
    lNative: i32,
    bState: u8,
    bClass: u8,
    wLineNumber: u16,
};

const IID_ISQLServerErrorInfo_Value = Guid.initString("5cf4ca12-ef21-11d0-97e7-00c04fc2ad98");
pub const IID_ISQLServerErrorInfo = &IID_ISQLServerErrorInfo_Value;
pub const ISQLServerErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISQLServerErrorInfo,
                ppErrorInfo: ?*?*tagSSErrorInfo,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISQLServerErrorInfo,
                ppErrorInfo: ?*?*tagSSErrorInfo,
                ppStringsBuffer: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISQLServerErrorInfo_GetErrorInfo(self: *const T, ppErrorInfo: ?*?*tagSSErrorInfo, ppStringsBuffer: ?*?*u16) HRESULT {
                return @as(*const ISQLServerErrorInfo.VTable, @ptrCast(self.vtable)).GetErrorInfo(@as(*const ISQLServerErrorInfo, @ptrCast(self)), ppErrorInfo, ppStringsBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetFastLoad_Value = Guid.initString("5cf4ca13-ef21-11d0-97e7-00c04fc2ad98");
pub const IID_IRowsetFastLoad = &IID_IRowsetFastLoad_Value;
pub const IRowsetFastLoad = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetFastLoad,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetFastLoad,
                hAccessor: usize,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRowsetFastLoad,
                fDone: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRowsetFastLoad,
                fDone: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetFastLoad_InsertRow(self: *const T, hAccessor: usize, pData: ?*anyopaque) HRESULT {
                return @as(*const IRowsetFastLoad.VTable, @ptrCast(self.vtable)).InsertRow(@as(*const IRowsetFastLoad, @ptrCast(self)), hAccessor, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRowsetFastLoad_Commit(self: *const T, fDone: BOOL) HRESULT {
                return @as(*const IRowsetFastLoad.VTable, @ptrCast(self.vtable)).Commit(@as(*const IRowsetFastLoad, @ptrCast(self)), fDone);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LOCKMODEENUM = enum(i32) {
    INVALID = 0,
    EXCLUSIVE = 1,
    SHARED = 2,
};
pub const LOCKMODE_INVALID = LOCKMODEENUM.INVALID;
pub const LOCKMODE_EXCLUSIVE = LOCKMODEENUM.EXCLUSIVE;
pub const LOCKMODE_SHARED = LOCKMODEENUM.SHARED;

const IID_ISchemaLock_Value = Guid.initString("4c2389fb-2511-11d4-b258-00c04f7971ce");
pub const IID_ISchemaLock = &IID_ISchemaLock_Value;
pub const ISchemaLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSchemaLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaLock,
                pTableID: ?*DBID,
                lmMode: u32,
                phLockHandle: ?*?HANDLE,
                pTableVersion: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaLock,
                pTableID: ?*DBID,
                lmMode: u32,
                phLockHandle: ?*?HANDLE,
                pTableVersion: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseSchemaLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISchemaLock,
                hLockHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISchemaLock,
                hLockHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaLock_GetSchemaLock(self: *const T, pTableID: ?*DBID, lmMode: u32, phLockHandle: ?*?HANDLE, pTableVersion: ?*u64) HRESULT {
                return @as(*const ISchemaLock.VTable, @ptrCast(self.vtable)).GetSchemaLock(@as(*const ISchemaLock, @ptrCast(self)), pTableID, lmMode, phLockHandle, pTableVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISchemaLock_ReleaseSchemaLock(self: *const T, hLockHandle: ?HANDLE) HRESULT {
                return @as(*const ISchemaLock.VTable, @ptrCast(self.vtable)).ReleaseSchemaLock(@as(*const ISchemaLock, @ptrCast(self)), hLockHandle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SQL_ASYNC_NOTIFICATION_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pContext: ?*anyopaque,
        fLast: BOOL,
    ) callconv(@import("std").os.windows.WINAPI) i16,
    else => *const fn (
        pContext: ?*anyopaque,
        fLast: BOOL,
    ) callconv(@import("std").os.windows.WINAPI) i16,
};

pub const DBVECTOR = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        size: usize,
        ptr: ?*anyopaque,
    },
    .X86 => extern struct {
        size: usize align(2),
        ptr: ?*anyopaque align(2),
    },
};
pub const DBTIMESTAMP = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        year: i16,
        month: u16,
        day: u16,
        hour: u16,
        minute: u16,
        second: u16,
        fraction: u32,
    },
    .X86 => extern struct {
        year: i16 align(2),
        month: u16 align(2),
        day: u16 align(2),
        hour: u16 align(2),
        minute: u16 align(2),
        second: u16 align(2),
        fraction: u32 align(2),
    },
};
pub const SEC_OBJECT_ELEMENT = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        guidObjectType: Guid,
        ObjectID: DBID,
    },
    .X86 => extern struct {
        guidObjectType: Guid align(2),
        ObjectID: DBID align(2),
    },
};
pub const SEC_OBJECT = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cObjects: u32,
        prgObjects: ?*SEC_OBJECT_ELEMENT,
    },
    .X86 => extern struct {
        cObjects: u32 align(2),
        prgObjects: ?*SEC_OBJECT_ELEMENT align(2),
    },
};
pub const DBIMPLICITSESSION = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pUnkOuter: ?*IUnknown,
        piid: ?*Guid,
        pSession: ?*IUnknown,
    },
    .X86 => extern struct {
        pUnkOuter: ?*IUnknown align(2),
        piid: ?*Guid align(2),
        pSession: ?*IUnknown align(2),
    },
};
pub const DBOBJECT = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwFlags: u32,
        iid: Guid,
    },
    .X86 => extern struct {
        dwFlags: u32 align(2),
        iid: Guid align(2),
    },
};
pub const DBBINDEXT = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pExtension: ?*u8,
        ulExtension: usize,
    },
    .X86 => extern struct {
        pExtension: ?*u8 align(2),
        ulExtension: usize align(2),
    },
};
pub const DBBINDING = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        iOrdinal: usize,
        obValue: usize,
        obLength: usize,
        obStatus: usize,
        pTypeInfo: ?*ITypeInfo,
        pObject: ?*DBOBJECT,
        pBindExt: ?*DBBINDEXT,
        dwPart: u32,
        dwMemOwner: u32,
        eParamIO: u32,
        cbMaxLen: usize,
        dwFlags: u32,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        iOrdinal: usize align(2),
        obValue: usize align(2),
        obLength: usize align(2),
        obStatus: usize align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        pObject: ?*DBOBJECT align(2),
        pBindExt: ?*DBBINDEXT align(2),
        dwPart: u32 align(2),
        dwMemOwner: u32 align(2),
        eParamIO: u32 align(2),
        cbMaxLen: usize align(2),
        dwFlags: u32 align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBFAILUREINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hRow: usize,
        iColumn: usize,
        failure: HRESULT,
    },
    .X86 => extern struct {
        hRow: usize align(2),
        iColumn: usize align(2),
        failure: HRESULT align(2),
    },
};
pub const DBCOLUMNINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszName: ?PWSTR,
        pTypeInfo: ?*ITypeInfo,
        iOrdinal: usize,
        dwFlags: u32,
        ulColumnSize: usize,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
        columnid: DBID,
    },
    .X86 => extern struct {
        pwszName: ?PWSTR align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        iOrdinal: usize align(2),
        dwFlags: u32 align(2),
        ulColumnSize: usize align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
        columnid: DBID align(2),
    },
};
pub const DBPARAMS = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pData: ?*anyopaque,
        cParamSets: usize,
        hAccessor: usize,
    },
    .X86 => extern struct {
        pData: ?*anyopaque align(2),
        cParamSets: usize align(2),
        hAccessor: usize align(2),
    },
};
pub const DBPARAMINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwFlags: u32,
        iOrdinal: usize,
        pwszName: ?PWSTR,
        pTypeInfo: ?*ITypeInfo,
        ulParamSize: usize,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        dwFlags: u32 align(2),
        iOrdinal: usize align(2),
        pwszName: ?PWSTR align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        ulParamSize: usize align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBPROPIDSET = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rgPropertyIDs: ?*u32,
        cPropertyIDs: u32,
        guidPropertySet: Guid,
    },
    .X86 => extern struct {
        rgPropertyIDs: ?*u32 align(2),
        cPropertyIDs: u32 align(2),
        guidPropertySet: Guid align(2),
    },
};
pub const DBPROPINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszDescription: ?PWSTR,
        dwPropertyID: u32,
        dwFlags: u32,
        vtType: u16,
        vValues: VARIANT,
    },
    .X86 => extern struct {
        pwszDescription: ?PWSTR align(2),
        dwPropertyID: u32 align(2),
        dwFlags: u32 align(2),
        vtType: u16 align(2),
        vValues: VARIANT align(2),
    },
};
pub const DBPROPINFOSET = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rgPropertyInfos: ?*DBPROPINFO,
        cPropertyInfos: u32,
        guidPropertySet: Guid,
    },
    .X86 => extern struct {
        rgPropertyInfos: ?*DBPROPINFO align(2),
        cPropertyInfos: u32 align(2),
        guidPropertySet: Guid align(2),
    },
};
pub const DBPROP = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwPropertyID: u32,
        dwOptions: u32,
        dwStatus: u32,
        colid: DBID,
        vValue: VARIANT,
    },
    .X86 => extern struct {
        dwPropertyID: u32 align(2),
        dwOptions: u32 align(2),
        dwStatus: u32 align(2),
        colid: DBID align(2),
        vValue: VARIANT align(2),
    },
};
pub const DBPROPSET = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rgProperties: ?*DBPROP,
        cProperties: u32,
        guidPropertySet: Guid,
    },
    .X86 => extern struct {
        rgProperties: ?*DBPROP align(2),
        cProperties: u32 align(2),
        guidPropertySet: Guid align(2),
    },
};
pub const DBINDEXCOLUMNDESC = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pColumnID: ?*DBID,
        eIndexColOrder: u32,
    },
    .X86 => extern struct {
        pColumnID: ?*DBID align(2),
        eIndexColOrder: u32 align(2),
    },
};
pub const DBCOLUMNDESC = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszTypeName: ?PWSTR,
        pTypeInfo: ?*ITypeInfo,
        rgPropertySets: ?*DBPROPSET,
        pclsid: ?*Guid,
        cPropertySets: u32,
        ulColumnSize: usize,
        dbcid: DBID,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        pwszTypeName: ?PWSTR align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        rgPropertySets: ?*DBPROPSET align(2),
        pclsid: ?*Guid align(2),
        cPropertySets: u32 align(2),
        ulColumnSize: usize align(2),
        dbcid: DBID align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBCOLUMNACCESS = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pData: ?*anyopaque,
        columnid: DBID,
        cbDataLen: usize,
        dwStatus: u32,
        cbMaxLen: usize,
        dwReserved: usize,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        pData: ?*anyopaque align(2),
        columnid: DBID align(2),
        cbDataLen: usize align(2),
        dwStatus: u32 align(2),
        cbMaxLen: usize align(2),
        dwReserved: usize align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBCONSTRAINTDESC = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pConstraintID: ?*DBID,
        ConstraintType: u32,
        cColumns: usize,
        rgColumnList: ?*DBID,
        pReferencedTableID: ?*DBID,
        cForeignKeyColumns: usize,
        rgForeignKeyColumnList: ?*DBID,
        pwszConstraintText: ?PWSTR,
        UpdateRule: u32,
        DeleteRule: u32,
        MatchType: u32,
        Deferrability: u32,
        cReserved: usize,
        rgReserved: ?*DBPROPSET,
    },
    .X86 => extern struct {
        pConstraintID: ?*DBID align(2),
        ConstraintType: u32 align(2),
        cColumns: usize align(2),
        rgColumnList: ?*DBID align(2),
        pReferencedTableID: ?*DBID align(2),
        cForeignKeyColumns: usize align(2),
        rgForeignKeyColumnList: ?*DBID align(2),
        pwszConstraintText: ?PWSTR align(2),
        UpdateRule: u32 align(2),
        DeleteRule: u32 align(2),
        MatchType: u32 align(2),
        Deferrability: u32 align(2),
        cReserved: usize align(2),
        rgReserved: ?*DBPROPSET align(2),
    },
};
pub const MDAXISINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: usize,
        iAxis: usize,
        cDimensions: usize,
        cCoordinates: usize,
        rgcColumns: ?*usize,
        rgpwszDimensionNames: ?*?PWSTR,
    },
    .X86 => extern struct {
        cbSize: usize align(2),
        iAxis: usize align(2),
        cDimensions: usize align(2),
        cCoordinates: usize align(2),
        rgcColumns: ?*usize align(2),
        rgpwszDimensionNames: ?*?PWSTR align(2),
    },
};
pub const RMTPACK = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pISeqStream: ?*ISequentialStream,
        cbData: u32,
        cBSTR: u32,
        rgBSTR: ?*?BSTR,
        cVARIANT: u32,
        rgVARIANT: ?*VARIANT,
        cIDISPATCH: u32,
        rgIDISPATCH: ?*?*IDispatch,
        cIUNKNOWN: u32,
        rgIUNKNOWN: ?*?*IUnknown,
        cPROPVARIANT: u32,
        rgPROPVARIANT: ?*PROPVARIANT,
        cArray: u32,
        rgArray: ?*VARIANT,
    },
    .X86 => extern struct {
        pISeqStream: ?*ISequentialStream align(2),
        cbData: u32 align(2),
        cBSTR: u32 align(2),
        rgBSTR: ?*?BSTR align(2),
        cVARIANT: u32 align(2),
        rgVARIANT: ?*VARIANT align(2),
        cIDISPATCH: u32 align(2),
        rgIDISPATCH: ?*?*IDispatch align(2),
        cIUNKNOWN: u32 align(2),
        rgIUNKNOWN: ?*?*IUnknown align(2),
        cPROPVARIANT: u32 align(2),
        rgPROPVARIANT: ?*PROPVARIANT align(2),
        cArray: u32 align(2),
        rgArray: ?*VARIANT align(2),
    },
};
pub const DBPARAMBINDINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszDataSourceType: ?PWSTR,
        pwszName: ?PWSTR,
        ulParamSize: usize,
        dwFlags: u32,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        pwszDataSourceType: ?PWSTR align(2),
        pwszName: ?PWSTR align(2),
        ulParamSize: usize align(2),
        dwFlags: u32 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBLITERALINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszLiteralValue: ?PWSTR,
        pwszInvalidChars: ?PWSTR,
        pwszInvalidStartingChars: ?PWSTR,
        lt: u32,
        fSupported: BOOL,
        cchMaxLen: u32,
    },
    .X86 => extern struct {
        pwszLiteralValue: ?PWSTR align(2),
        pwszInvalidChars: ?PWSTR align(2),
        pwszInvalidStartingChars: ?PWSTR align(2),
        lt: u32 align(2),
        fSupported: BOOL align(2),
        cchMaxLen: u32 align(2),
    },
};
pub const ERRORINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hrError: HRESULT,
        dwMinor: u32,
        clsid: Guid,
        iid: Guid,
        dispid: i32,
    },
    .X86 => extern struct {
        hrError: HRESULT align(2),
        dwMinor: u32 align(2),
        clsid: Guid align(2),
        iid: Guid align(2),
        dispid: i32 align(2),
    },
};
pub const tagDBROWWATCHRANGE = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hRegion: usize,
        eChangeKind: u32,
        hRow: usize,
        iRow: usize,
    },
    .X86 => extern struct {
        hRegion: usize align(2),
        eChangeKind: u32 align(2),
        hRow: usize align(2),
        iRow: usize align(2),
    },
};
pub const DBCOST = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        eKind: u32,
        dwUnits: u32,
        lValue: i32,
    },
    .X86 => extern struct {
        eKind: u32 align(2),
        dwUnits: u32 align(2),
        lValue: i32 align(2),
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (211)
//--------------------------------------------------------------------------------
pub extern "odbc32" fn SQLAllocConnect(
    EnvironmentHandle: ?*anyopaque,
    ConnectionHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLAllocEnv(
    EnvironmentHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLAllocHandle(
    HandleType: i16,
    InputHandle: ?*anyopaque,
    OutputHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLAllocStmt(
    ConnectionHandle: ?*anyopaque,
    StatementHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLBindCol(
            StatementHandle: ?*anyopaque,
            ColumnNumber: u16,
            TargetType: i16,
            TargetValue: ?*anyopaque,
            BufferLength: i64,
            StrLen_or_Ind: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLBindParam(
            StatementHandle: ?*anyopaque,
            ParameterNumber: u16,
            ValueType: i16,
            ParameterType: i16,
            LengthPrecision: u64,
            ParameterScale: i16,
            ParameterValue: ?*anyopaque,
            StrLen_or_Ind: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLCancel(
    StatementHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCancelHandle(
    HandleType: i16,
    InputHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCloseCursor(
    StatementHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttribute(
            StatementHandle: ?*anyopaque,
            ColumnNumber: u16,
            FieldIdentifier: u16,
            // TODO: what to do with BytesParamIndex 4?
            CharacterAttribute: ?*anyopaque,
            BufferLength: i16,
            StringLength: ?*i16,
            NumericAttribute: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLColumns(
    StatementHandle: ?*anyopaque,
    CatalogName: ?[*:0]u8,
    NameLength1: i16,
    SchemaName: ?[*:0]u8,
    NameLength2: i16,
    TableName: ?[*:0]u8,
    NameLength3: i16,
    ColumnName: ?[*:0]u8,
    NameLength4: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCompleteAsync(
    HandleType: i16,
    Handle: ?*anyopaque,
    AsyncRetCodePtr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLConnect(
    ConnectionHandle: ?*anyopaque,
    ServerName: [*:0]u8,
    NameLength1: i16,
    UserName: [*:0]u8,
    NameLength2: i16,
    Authentication: [*:0]u8,
    NameLength3: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCopyDesc(
    SourceDescHandle: ?*anyopaque,
    TargetDescHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDataSources(
    EnvironmentHandle: ?*anyopaque,
    Direction: u16,
    ServerName: ?[*:0]u8,
    BufferLength1: i16,
    NameLength1Ptr: ?*i16,
    Description: ?[*:0]u8,
    BufferLength2: i16,
    NameLength2Ptr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLDescribeCol(
            StatementHandle: ?*anyopaque,
            ColumnNumber: u16,
            ColumnName: ?[*:0]u8,
            BufferLength: i16,
            NameLength: ?*i16,
            DataType: ?*i16,
            ColumnSize: ?*u64,
            DecimalDigits: ?*i16,
            Nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLDisconnect(
    ConnectionHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLEndTran(
    HandleType: i16,
    Handle: ?*anyopaque,
    CompletionType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLError(
    EnvironmentHandle: ?*anyopaque,
    ConnectionHandle: ?*anyopaque,
    StatementHandle: ?*anyopaque,
    Sqlstate: *[6]u8,
    NativeError: ?*i32,
    MessageText: ?[*:0]u8,
    BufferLength: i16,
    TextLength: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecDirect(
    StatementHandle: ?*anyopaque,
    StatementText: ?[*:0]u8,
    TextLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecute(
    StatementHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFetch(
    StatementHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLFetchScroll(
            StatementHandle: ?*anyopaque,
            FetchOrientation: i16,
            FetchOffset: i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLFreeConnect(
    ConnectionHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFreeEnv(
    EnvironmentHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFreeHandle(
    HandleType: i16,
    Handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFreeStmt(
    StatementHandle: ?*anyopaque,
    Option: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectAttr(
    ConnectionHandle: ?*anyopaque,
    Attribute: i32,
    Value: ?*anyopaque,
    BufferLength: i32,
    StringLengthPtr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectOption(
    ConnectionHandle: ?*anyopaque,
    Option: u16,
    Value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetCursorName(
    StatementHandle: ?*anyopaque,
    CursorName: ?[*:0]u8,
    BufferLength: i16,
    NameLengthPtr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLGetData(
            StatementHandle: ?*anyopaque,
            ColumnNumber: u16,
            TargetType: i16,
            TargetValue: ?*anyopaque,
            BufferLength: i64,
            StrLen_or_IndPtr: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLGetDescField(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    FieldIdentifier: i16,
    Value: ?*anyopaque,
    BufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLGetDescRec(
            DescriptorHandle: ?*anyopaque,
            RecNumber: i16,
            Name: ?[*:0]u8,
            BufferLength: i16,
            StringLengthPtr: ?*i16,
            TypePtr: ?*i16,
            SubTypePtr: ?*i16,
            LengthPtr: ?*i64,
            PrecisionPtr: ?*i16,
            ScalePtr: ?*i16,
            NullablePtr: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLGetDiagField(
    HandleType: i16,
    Handle: ?*anyopaque,
    RecNumber: i16,
    DiagIdentifier: i16,
    DiagInfo: ?*anyopaque,
    BufferLength: i16,
    StringLength: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDiagRec(
    HandleType: i16,
    Handle: ?*anyopaque,
    RecNumber: i16,
    Sqlstate: ?*[6]u8,
    NativeError: ?*i32,
    MessageText: ?[*:0]u8,
    BufferLength: i16,
    TextLength: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetEnvAttr(
    EnvironmentHandle: ?*anyopaque,
    Attribute: i32,
    Value: ?*anyopaque,
    BufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetFunctions(
    ConnectionHandle: ?*anyopaque,
    FunctionId: u16,
    Supported: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetInfo(
    ConnectionHandle: ?*anyopaque,
    InfoType: u16,
    // TODO: what to do with BytesParamIndex 3?
    InfoValue: ?*anyopaque,
    BufferLength: i16,
    StringLengthPtr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtAttr(
    StatementHandle: ?*anyopaque,
    Attribute: i32,
    Value: ?*anyopaque,
    BufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtOption(
    StatementHandle: ?*anyopaque,
    Option: u16,
    Value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetTypeInfo(
    StatementHandle: ?*anyopaque,
    DataType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNumResultCols(
    StatementHandle: ?*anyopaque,
    ColumnCount: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLParamData(
    StatementHandle: ?*anyopaque,
    Value: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrepare(
    StatementHandle: ?*anyopaque,
    StatementText: [*:0]u8,
    TextLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLPutData(
            StatementHandle: ?*anyopaque,
            Data: ?*anyopaque,
            StrLen_or_Ind: i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLRowCount(
            StatementHandle: ?*anyopaque,
            RowCount: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSetConnectAttr(
    ConnectionHandle: ?*anyopaque,
    Attribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    Value: ?*anyopaque,
    StringLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetConnectOption(
            ConnectionHandle: ?*anyopaque,
            Option: u16,
            Value: u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSetCursorName(
    StatementHandle: ?*anyopaque,
    CursorName: [*:0]u8,
    NameLength: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetDescField(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    FieldIdentifier: i16,
    Value: ?*anyopaque,
    BufferLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetDescRec(
            DescriptorHandle: ?*anyopaque,
            RecNumber: i16,
            Type: i16,
            SubType: i16,
            Length: i64,
            Precision: i16,
            Scale: i16,
            // TODO: what to do with BytesParamIndex 4?
            Data: ?*anyopaque,
            StringLength: ?*i64,
            Indicator: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSetEnvAttr(
    EnvironmentHandle: ?*anyopaque,
    Attribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    Value: ?*anyopaque,
    StringLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetParam(
            StatementHandle: ?*anyopaque,
            ParameterNumber: u16,
            ValueType: i16,
            ParameterType: i16,
            LengthPrecision: u64,
            ParameterScale: i16,
            ParameterValue: ?*anyopaque,
            StrLen_or_Ind: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSetStmtAttr(
    StatementHandle: ?*anyopaque,
    Attribute: i32,
    Value: ?*anyopaque,
    StringLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetStmtOption(
            StatementHandle: ?*anyopaque,
            Option: u16,
            Value: u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSpecialColumns(
    StatementHandle: ?*anyopaque,
    IdentifierType: u16,
    CatalogName: ?[*:0]u8,
    NameLength1: i16,
    SchemaName: ?[*:0]u8,
    NameLength2: i16,
    TableName: ?[*:0]u8,
    NameLength3: i16,
    Scope: u16,
    Nullable: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLStatistics(
    StatementHandle: ?*anyopaque,
    CatalogName: ?[*:0]u8,
    NameLength1: i16,
    SchemaName: ?[*:0]u8,
    NameLength2: i16,
    TableName: ?[*:0]u8,
    NameLength3: i16,
    Unique: u16,
    Reserved: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTables(
    StatementHandle: ?*anyopaque,
    CatalogName: ?[*:0]u8,
    NameLength1: i16,
    SchemaName: ?[*:0]u8,
    NameLength2: i16,
    TableName: ?[*:0]u8,
    NameLength3: i16,
    TableType: ?[*:0]u8,
    NameLength4: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTransact(
    EnvironmentHandle: ?*anyopaque,
    ConnectionHandle: ?*anyopaque,
    CompletionType: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_batch(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "odbcbcp" fn bcp_bind(
    param0: ?*anyopaque,
    param1: ?*u8,
    param2: i32,
    param3: i32,
    param4: ?*u8,
    param5: i32,
    param6: i32,
    param7: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_colfmt(
    param0: ?*anyopaque,
    param1: i32,
    param2: u8,
    param3: i32,
    param4: i32,
    param5: ?*u8,
    param6: i32,
    param7: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_collen(
    param0: ?*anyopaque,
    param1: i32,
    param2: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_colptr(
    param0: ?*anyopaque,
    param1: ?*u8,
    param2: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_columns(
    param0: ?*anyopaque,
    param1: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_control(
    param0: ?*anyopaque,
    param1: i32,
    param2: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_done(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "odbcbcp" fn bcp_exec(
    param0: ?*anyopaque,
    param1: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_getcolfmt(
    param0: ?*anyopaque,
    param1: i32,
    param2: i32,
    param3: ?*anyopaque,
    param4: i32,
    param5: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_initA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
    param3: ?[*:0]const u8,
    param4: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_initW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: ?[*:0]const u16,
    param4: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_moretext(
    param0: ?*anyopaque,
    param1: i32,
    param2: ?*u8,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_readfmtA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_readfmtW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_sendrow(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_setcolfmt(
    param0: ?*anyopaque,
    param1: i32,
    param2: i32,
    param3: ?*anyopaque,
    param4: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_writefmtA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_writefmtW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn dbprtypeA(
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "odbcbcp" fn dbprtypeW(
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "odbcbcp" fn SQLLinkedServers(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLLinkedCatalogsA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
    param2: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLLinkedCatalogsW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
    param2: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLInitEnumServers(
    pwchServerName: ?PWSTR,
    pwchInstanceName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "odbcbcp" fn SQLGetNextEnumeration(
    hEnumHandle: ?HANDLE,
    prgEnumData: ?*u8,
    piEnumLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLCloseEnumServers(
    hEnumHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriverConnect(
    hdbc: ?*anyopaque,
    hwnd: isize,
    szConnStrIn: [*:0]u8,
    cchConnStrIn: i16,
    szConnStrOut: ?[*:0]u8,
    cchConnStrOutMax: i16,
    pcchConnStrOut: ?*i16,
    fDriverCompletion: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBrowseConnect(
    hdbc: ?*anyopaque,
    szConnStrIn: [*:0]u8,
    cchConnStrIn: i16,
    szConnStrOut: ?[*:0]u8,
    cchConnStrOutMax: i16,
    pcchConnStrOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBulkOperations(
    StatementHandle: ?*anyopaque,
    Operation: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributes(
            hstmt: ?*anyopaque,
            icol: u16,
            fDescType: u16,
            rgbDesc: ?*anyopaque,
            cbDescMax: i16,
            pcbDesc: ?*i16,
            pfDesc: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLColumnPrivileges(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szTableName: ?[*:0]u8,
    cchTableName: i16,
    szColumnName: ?[*:0]u8,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLDescribeParam(
            hstmt: ?*anyopaque,
            ipar: u16,
            pfSqlType: ?*i16,
            pcbParamDef: ?*u64,
            pibScale: ?*i16,
            pfNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLExtendedFetch(
            hstmt: ?*anyopaque,
            fFetchType: u16,
            irow: i64,
            pcrow: ?*u64,
            rgfRowStatus: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLForeignKeys(
    hstmt: ?*anyopaque,
    szPkCatalogName: ?[*:0]u8,
    cchPkCatalogName: i16,
    szPkSchemaName: ?[*:0]u8,
    cchPkSchemaName: i16,
    szPkTableName: ?[*:0]u8,
    cchPkTableName: i16,
    szFkCatalogName: ?[*:0]u8,
    cchFkCatalogName: i16,
    szFkSchemaName: ?[*:0]u8,
    cchFkSchemaName: i16,
    szFkTableName: ?[*:0]u8,
    cchFkTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLMoreResults(
    hstmt: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNativeSql(
    hdbc: ?*anyopaque,
    szSqlStrIn: [*:0]u8,
    cchSqlStrIn: i32,
    szSqlStr: ?[*:0]u8,
    cchSqlStrMax: i32,
    pcbSqlStr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNumParams(
    hstmt: ?*anyopaque,
    pcpar: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLParamOptions(
            hstmt: ?*anyopaque,
            crow: u64,
            pirow: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLPrimaryKeys(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szTableName: ?[*:0]u8,
    cchTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedureColumns(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szProcName: ?[*:0]u8,
    cchProcName: i16,
    szColumnName: ?[*:0]u8,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedures(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szProcName: ?[*:0]u8,
    cchProcName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetPos(
            hstmt: ?*anyopaque,
            irow: u64,
            fOption: u16,
            fLock: u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLTablePrivileges(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szTableName: ?[*:0]u8,
    cchTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDrivers(
    henv: ?*anyopaque,
    fDirection: u16,
    szDriverDesc: ?[*:0]u8,
    cchDriverDescMax: i16,
    pcchDriverDesc: ?*i16,
    szDriverAttributes: ?[*:0]u8,
    cchDrvrAttrMax: i16,
    pcchDrvrAttr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLBindParameter(
            hstmt: ?*anyopaque,
            ipar: u16,
            fParamType: i16,
            fCType: i16,
            fSqlType: i16,
            cbColDef: u64,
            ibScale: i16,
            rgbValue: ?*anyopaque,
            cbValueMax: i64,
            pcbValue: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLAllocHandleStd(
    fHandleType: i16,
    hInput: ?*anyopaque,
    phOutput: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetScrollOptions(
            hstmt: ?*anyopaque,
            fConcurrency: u16,
            crowKeyset: i64,
            crowRowset: u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn ODBCSetTryWaitValue(
    dwValue: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "odbc32" fn ODBCGetTryWaitValue() callconv(@import("std").os.windows.WINAPI) u32;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributeW(
            hstmt: ?*anyopaque,
            iCol: u16,
            iField: u16,
            // TODO: what to do with BytesParamIndex 4?
            pCharAttr: ?*anyopaque,
            cbDescMax: i16,
            pcbCharAttr: ?*i16,
            pNumAttr: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributesW(
            hstmt: ?*anyopaque,
            icol: u16,
            fDescType: u16,
            // TODO: what to do with BytesParamIndex 4?
            rgbDesc: ?*anyopaque,
            cbDescMax: i16,
            pcbDesc: ?*i16,
            pfDesc: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLConnectW(
    hdbc: ?*anyopaque,
    szDSN: [*:0]u16,
    cchDSN: i16,
    szUID: [*:0]u16,
    cchUID: i16,
    szAuthStr: [*:0]u16,
    cchAuthStr: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLDescribeColW(
            hstmt: ?*anyopaque,
            icol: u16,
            szColName: ?[*:0]u16,
            cchColNameMax: i16,
            pcchColName: ?*i16,
            pfSqlType: ?*i16,
            pcbColDef: ?*u64,
            pibScale: ?*i16,
            pfNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLErrorW(
    henv: ?*anyopaque,
    hdbc: ?*anyopaque,
    hstmt: ?*anyopaque,
    wszSqlState: *[6]u16,
    pfNativeError: ?*i32,
    wszErrorMsg: ?[*:0]u16,
    cchErrorMsgMax: i16,
    pcchErrorMsg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecDirectW(
    hstmt: ?*anyopaque,
    szSqlStr: ?[*:0]u16,
    TextLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectAttrW(
    hdbc: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
    pcbValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetCursorNameW(
    hstmt: ?*anyopaque,
    szCursor: ?[*:0]u16,
    cchCursorMax: i16,
    pcchCursor: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetDescFieldW(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    FieldIdentifier: i16,
    Value: ?*anyopaque,
    BufferLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDescFieldW(
    hdesc: ?*anyopaque,
    iRecord: i16,
    iField: i16,
    rgbValue: ?*anyopaque,
    cbBufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLGetDescRecW(
            hdesc: ?*anyopaque,
            iRecord: i16,
            szName: ?[*:0]u16,
            cchNameMax: i16,
            pcchName: ?*i16,
            pfType: ?*i16,
            pfSubType: ?*i16,
            pLength: ?*i64,
            pPrecision: ?*i16,
            pScale: ?*i16,
            pNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLGetDiagFieldW(
    fHandleType: i16,
    handle: ?*anyopaque,
    iRecord: i16,
    fDiagField: i16,
    rgbDiagInfo: ?*anyopaque,
    cbBufferLength: i16,
    pcbStringLength: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDiagRecW(
    fHandleType: i16,
    handle: ?*anyopaque,
    iRecord: i16,
    szSqlState: ?*[6]u16,
    pfNativeError: ?*i32,
    szErrorMsg: ?[*:0]u16,
    cchErrorMsgMax: i16,
    pcchErrorMsg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrepareW(
    hstmt: ?*anyopaque,
    szSqlStr: [*:0]u16,
    cchSqlStr: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetConnectAttrW(
    hdbc: ?*anyopaque,
    fAttribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    rgbValue: ?*anyopaque,
    cbValue: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetCursorNameW(
    hstmt: ?*anyopaque,
    szCursor: [*:0]u16,
    cchCursor: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnsW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    szColumnName: ?[*:0]u16,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectOptionW(
    hdbc: ?*anyopaque,
    fOption: u16,
    pvParam: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetInfoW(
    hdbc: ?*anyopaque,
    fInfoType: u16,
    // TODO: what to do with BytesParamIndex 3?
    rgbInfoValue: ?*anyopaque,
    cbInfoValueMax: i16,
    pcbInfoValue: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetTypeInfoW(
    StatementHandle: ?*anyopaque,
    DataType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetConnectOptionW(
            hdbc: ?*anyopaque,
            fOption: u16,
            vParam: u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSpecialColumnsW(
    hstmt: ?*anyopaque,
    fColType: u16,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    fScope: u16,
    fNullable: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLStatisticsW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    fUnique: u16,
    fAccuracy: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablesW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    szTableType: ?[*:0]u16,
    cchTableType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDataSourcesW(
    henv: ?*anyopaque,
    fDirection: u16,
    szDSN: ?[*:0]u16,
    cchDSNMax: i16,
    pcchDSN: ?*i16,
    wszDescription: ?[*:0]u16,
    cchDescriptionMax: i16,
    pcchDescription: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriverConnectW(
    hdbc: ?*anyopaque,
    hwnd: isize,
    szConnStrIn: [*:0]u16,
    cchConnStrIn: i16,
    szConnStrOut: ?[*:0]u16,
    cchConnStrOutMax: i16,
    pcchConnStrOut: ?*i16,
    fDriverCompletion: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBrowseConnectW(
    hdbc: ?*anyopaque,
    szConnStrIn: [*:0]u16,
    cchConnStrIn: i16,
    szConnStrOut: ?[*:0]u16,
    cchConnStrOutMax: i16,
    pcchConnStrOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnPrivilegesW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    szColumnName: ?[*:0]u16,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtAttrW(
    hstmt: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
    pcbValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetStmtAttrW(
    hstmt: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLForeignKeysW(
    hstmt: ?*anyopaque,
    szPkCatalogName: ?[*:0]u16,
    cchPkCatalogName: i16,
    szPkSchemaName: ?[*:0]u16,
    cchPkSchemaName: i16,
    szPkTableName: ?[*:0]u16,
    cchPkTableName: i16,
    szFkCatalogName: ?[*:0]u16,
    cchFkCatalogName: i16,
    szFkSchemaName: ?[*:0]u16,
    cchFkSchemaName: i16,
    szFkTableName: ?[*:0]u16,
    cchFkTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNativeSqlW(
    hdbc: ?*anyopaque,
    szSqlStrIn: [*:0]u16,
    cchSqlStrIn: i32,
    szSqlStr: ?[*:0]u16,
    cchSqlStrMax: i32,
    pcchSqlStr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrimaryKeysW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedureColumnsW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szProcName: ?[*:0]u16,
    cchProcName: i16,
    szColumnName: ?[*:0]u16,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProceduresW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szProcName: ?[*:0]u16,
    cchProcName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablePrivilegesW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriversW(
    henv: ?*anyopaque,
    fDirection: u16,
    szDriverDesc: ?[*:0]u16,
    cchDriverDescMax: i16,
    pcchDriverDesc: ?*i16,
    szDriverAttributes: ?[*:0]u16,
    cchDrvrAttrMax: i16,
    pcchDrvrAttr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributeA(
            hstmt: ?*anyopaque,
            iCol: i16,
            iField: i16,
            // TODO: what to do with BytesParamIndex 4?
            pCharAttr: ?*anyopaque,
            cbCharAttrMax: i16,
            pcbCharAttr: ?*i16,
            pNumAttr: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributesA(
            hstmt: ?*anyopaque,
            icol: u16,
            fDescType: u16,
            // TODO: what to do with BytesParamIndex 4?
            rgbDesc: ?*anyopaque,
            cbDescMax: i16,
            pcbDesc: ?*i16,
            pfDesc: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLConnectA(
    hdbc: ?*anyopaque,
    szDSN: [*:0]u8,
    cbDSN: i16,
    szUID: [*:0]u8,
    cbUID: i16,
    szAuthStr: [*:0]u8,
    cbAuthStr: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLDescribeColA(
            hstmt: ?*anyopaque,
            icol: u16,
            szColName: ?[*:0]u8,
            cbColNameMax: i16,
            pcbColName: ?*i16,
            pfSqlType: ?*i16,
            pcbColDef: ?*u64,
            pibScale: ?*i16,
            pfNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLErrorA(
    henv: ?*anyopaque,
    hdbc: ?*anyopaque,
    hstmt: ?*anyopaque,
    szSqlState: ?*u8,
    pfNativeError: ?*i32,
    szErrorMsg: ?[*:0]u8,
    cbErrorMsgMax: i16,
    pcbErrorMsg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecDirectA(
    hstmt: ?*anyopaque,
    szSqlStr: ?[*:0]u8,
    cbSqlStr: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectAttrA(
    hdbc: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
    pcbValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetCursorNameA(
    hstmt: ?*anyopaque,
    szCursor: ?[*:0]u8,
    cbCursorMax: i16,
    pcbCursor: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDescFieldA(
    hdesc: ?*anyopaque,
    iRecord: i16,
    iField: i16,
    rgbValue: ?*anyopaque,
    cbBufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLGetDescRecA(
            hdesc: ?*anyopaque,
            iRecord: i16,
            szName: ?[*:0]u8,
            cbNameMax: i16,
            pcbName: ?*i16,
            pfType: ?*i16,
            pfSubType: ?*i16,
            pLength: ?*i64,
            pPrecision: ?*i16,
            pScale: ?*i16,
            pNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLGetDiagFieldA(
    fHandleType: i16,
    handle: ?*anyopaque,
    iRecord: i16,
    fDiagField: i16,
    rgbDiagInfo: ?*anyopaque,
    cbDiagInfoMax: i16,
    pcbDiagInfo: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDiagRecA(
    fHandleType: i16,
    handle: ?*anyopaque,
    iRecord: i16,
    szSqlState: ?*[6]u8,
    pfNativeError: ?*i32,
    szErrorMsg: ?[*:0]u8,
    cbErrorMsgMax: i16,
    pcbErrorMsg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtAttrA(
    hstmt: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
    pcbValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetTypeInfoA(
    StatementHandle: ?*anyopaque,
    DataType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrepareA(
    hstmt: ?*anyopaque,
    szSqlStr: [*:0]u8,
    cbSqlStr: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetConnectAttrA(
    hdbc: ?*anyopaque,
    fAttribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    rgbValue: ?*anyopaque,
    cbValue: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetCursorNameA(
    hstmt: ?*anyopaque,
    szCursor: [*:0]u8,
    cbCursor: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnsA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    szColumnName: ?[*:0]u8,
    cbColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectOptionA(
    hdbc: ?*anyopaque,
    fOption: u16,
    pvParam: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetInfoA(
    hdbc: ?*anyopaque,
    fInfoType: u16,
    // TODO: what to do with BytesParamIndex 3?
    rgbInfoValue: ?*anyopaque,
    cbInfoValueMax: i16,
    pcbInfoValue: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetConnectOptionA(
            hdbc: ?*anyopaque,
            fOption: u16,
            vParam: u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSpecialColumnsA(
    hstmt: ?*anyopaque,
    fColType: u16,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    fScope: u16,
    fNullable: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLStatisticsA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    fUnique: u16,
    fAccuracy: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablesA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    szTableType: ?[*:0]u8,
    cbTableType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDataSourcesA(
    henv: ?*anyopaque,
    fDirection: u16,
    szDSN: ?[*:0]u8,
    cbDSNMax: i16,
    pcbDSN: ?*i16,
    szDescription: ?[*:0]u8,
    cbDescriptionMax: i16,
    pcbDescription: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriverConnectA(
    hdbc: ?*anyopaque,
    hwnd: isize,
    szConnStrIn: [*:0]u8,
    cbConnStrIn: i16,
    szConnStrOut: ?[*:0]u8,
    cbConnStrOutMax: i16,
    pcbConnStrOut: ?*i16,
    fDriverCompletion: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBrowseConnectA(
    hdbc: ?*anyopaque,
    szConnStrIn: [*:0]u8,
    cbConnStrIn: i16,
    szConnStrOut: ?[*:0]u8,
    cbConnStrOutMax: i16,
    pcbConnStrOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnPrivilegesA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    szColumnName: ?[*:0]u8,
    cbColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLForeignKeysA(
    hstmt: ?*anyopaque,
    szPkCatalogName: ?[*:0]u8,
    cbPkCatalogName: i16,
    szPkSchemaName: ?[*:0]u8,
    cbPkSchemaName: i16,
    szPkTableName: ?[*:0]u8,
    cbPkTableName: i16,
    szFkCatalogName: ?[*:0]u8,
    cbFkCatalogName: i16,
    szFkSchemaName: ?[*:0]u8,
    cbFkSchemaName: i16,
    szFkTableName: ?[*:0]u8,
    cbFkTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNativeSqlA(
    hdbc: ?*anyopaque,
    szSqlStrIn: [*:0]u8,
    cbSqlStrIn: i32,
    szSqlStr: ?[*:0]u8,
    cbSqlStrMax: i32,
    pcbSqlStr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrimaryKeysA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedureColumnsA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szProcName: ?[*:0]u8,
    cbProcName: i16,
    szColumnName: ?[*:0]u8,
    cbColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProceduresA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szProcName: ?[*:0]u8,
    cbProcName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablePrivilegesA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriversA(
    henv: ?*anyopaque,
    fDirection: u16,
    szDriverDesc: ?[*:0]u8,
    cbDriverDescMax: i16,
    pcbDriverDesc: ?*i16,
    szDriverAttributes: ?[*:0]u8,
    cbDrvrAttrMax: i16,
    pcbDrvrAttr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLBindCol(
            StatementHandle: ?*anyopaque,
            ColumnNumber: u16,
            TargetType: i16,
            TargetValue: ?*anyopaque,
            BufferLength: i32,
            StrLen_or_Ind: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLBindParam(
            StatementHandle: ?*anyopaque,
            ParameterNumber: u16,
            ValueType: i16,
            ParameterType: i16,
            LengthPrecision: u32,
            ParameterScale: i16,
            ParameterValue: ?*anyopaque,
            StrLen_or_Ind: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttribute(
            StatementHandle: ?*anyopaque,
            ColumnNumber: u16,
            FieldIdentifier: u16,
            // TODO: what to do with BytesParamIndex 4?
            CharacterAttribute: ?*anyopaque,
            BufferLength: i16,
            StringLength: ?*i16,
            NumericAttribute: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLDescribeCol(
            StatementHandle: ?*anyopaque,
            ColumnNumber: u16,
            ColumnName: ?[*:0]u8,
            BufferLength: i16,
            NameLength: ?*i16,
            DataType: ?*i16,
            ColumnSize: ?*u32,
            DecimalDigits: ?*i16,
            Nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLFetchScroll(
            StatementHandle: ?*anyopaque,
            FetchOrientation: i16,
            FetchOffset: i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLGetData(
            StatementHandle: ?*anyopaque,
            ColumnNumber: u16,
            TargetType: i16,
            TargetValue: ?*anyopaque,
            BufferLength: i32,
            StrLen_or_IndPtr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLGetDescRec(
            DescriptorHandle: ?*anyopaque,
            RecNumber: i16,
            Name: ?[*:0]u8,
            BufferLength: i16,
            StringLengthPtr: ?*i16,
            TypePtr: ?*i16,
            SubTypePtr: ?*i16,
            LengthPtr: ?*i32,
            PrecisionPtr: ?*i16,
            ScalePtr: ?*i16,
            NullablePtr: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLPutData(
            StatementHandle: ?*anyopaque,
            Data: ?*anyopaque,
            StrLen_or_Ind: i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLRowCount(
            StatementHandle: ?*anyopaque,
            RowCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetConnectOption(
            ConnectionHandle: ?*anyopaque,
            Option: u16,
            Value: u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetDescRec(
            DescriptorHandle: ?*anyopaque,
            RecNumber: i16,
            Type: i16,
            SubType: i16,
            Length: i32,
            Precision: i16,
            Scale: i16,
            // TODO: what to do with BytesParamIndex 4?
            Data: ?*anyopaque,
            StringLength: ?*i32,
            Indicator: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetParam(
            StatementHandle: ?*anyopaque,
            ParameterNumber: u16,
            ValueType: i16,
            ParameterType: i16,
            LengthPrecision: u32,
            ParameterScale: i16,
            ParameterValue: ?*anyopaque,
            StrLen_or_Ind: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetStmtOption(
            StatementHandle: ?*anyopaque,
            Option: u16,
            Value: u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributes(
            hstmt: ?*anyopaque,
            icol: u16,
            fDescType: u16,
            rgbDesc: ?*anyopaque,
            cbDescMax: i16,
            pcbDesc: ?*i16,
            pfDesc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLDescribeParam(
            hstmt: ?*anyopaque,
            ipar: u16,
            pfSqlType: ?*i16,
            pcbParamDef: ?*u32,
            pibScale: ?*i16,
            pfNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLExtendedFetch(
            hstmt: ?*anyopaque,
            fFetchType: u16,
            irow: i32,
            pcrow: ?*u32,
            rgfRowStatus: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLParamOptions(
            hstmt: ?*anyopaque,
            crow: u32,
            pirow: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetPos(
            hstmt: ?*anyopaque,
            irow: u16,
            fOption: u16,
            fLock: u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLBindParameter(
            hstmt: ?*anyopaque,
            ipar: u16,
            fParamType: i16,
            fCType: i16,
            fSqlType: i16,
            cbColDef: u32,
            ibScale: i16,
            rgbValue: ?*anyopaque,
            cbValueMax: i32,
            pcbValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetScrollOptions(
            hstmt: ?*anyopaque,
            fConcurrency: u16,
            crowKeyset: i32,
            crowRowset: u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributeW(
            hstmt: ?*anyopaque,
            iCol: u16,
            iField: u16,
            // TODO: what to do with BytesParamIndex 4?
            pCharAttr: ?*anyopaque,
            cbDescMax: i16,
            pcbCharAttr: ?*i16,
            pNumAttr: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributesW(
            hstmt: ?*anyopaque,
            icol: u16,
            fDescType: u16,
            // TODO: what to do with BytesParamIndex 4?
            rgbDesc: ?*anyopaque,
            cbDescMax: i16,
            pcbDesc: ?*i16,
            pfDesc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLDescribeColW(
            hstmt: ?*anyopaque,
            icol: u16,
            szColName: ?[*:0]u16,
            cchColNameMax: i16,
            pcchColName: ?*i16,
            pfSqlType: ?*i16,
            pcbColDef: ?*u32,
            pibScale: ?*i16,
            pfNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLGetDescRecW(
            hdesc: ?*anyopaque,
            iRecord: i16,
            szName: ?[*:0]u16,
            cchNameMax: i16,
            pcchName: ?*i16,
            pfType: ?*i16,
            pfSubType: ?*i16,
            pLength: ?*i32,
            pPrecision: ?*i16,
            pScale: ?*i16,
            pNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetConnectOptionW(
            hdbc: ?*anyopaque,
            fOption: u16,
            vParam: u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributeA(
            hstmt: ?*anyopaque,
            iCol: i16,
            iField: i16,
            // TODO: what to do with BytesParamIndex 4?
            pCharAttr: ?*anyopaque,
            cbCharAttrMax: i16,
            pcbCharAttr: ?*i16,
            pNumAttr: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributesA(
            hstmt: ?*anyopaque,
            icol: u16,
            fDescType: u16,
            // TODO: what to do with BytesParamIndex 4?
            rgbDesc: ?*anyopaque,
            cbDescMax: i16,
            pcbDesc: ?*i16,
            pfDesc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLDescribeColA(
            hstmt: ?*anyopaque,
            icol: u16,
            szColName: ?[*:0]u8,
            cbColNameMax: i16,
            pcbColName: ?*i16,
            pfSqlType: ?*i16,
            pcbColDef: ?*u32,
            pibScale: ?*i16,
            pfNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLGetDescRecA(
            hdesc: ?*anyopaque,
            iRecord: i16,
            szName: ?[*:0]u8,
            cbNameMax: i16,
            pcbName: ?*i16,
            pfType: ?*i16,
            pfSubType: ?*i16,
            pLength: ?*i32,
            pPrecision: ?*i16,
            pScale: ?*i16,
            pNullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetConnectOptionA(
            hdbc: ?*anyopaque,
            fOption: u16,
            vParam: u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (5)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const bcp_init = thismodule.bcp_initA;
        pub const bcp_readfmt = thismodule.bcp_readfmtA;
        pub const bcp_writefmt = thismodule.bcp_writefmtA;
        pub const dbprtype = thismodule.dbprtypeA;
        pub const SQLLinkedCatalogs = thismodule.SQLLinkedCatalogsA;
    },
    .wide => struct {
        pub const bcp_init = thismodule.bcp_initW;
        pub const bcp_readfmt = thismodule.bcp_readfmtW;
        pub const bcp_writefmt = thismodule.bcp_writefmtW;
        pub const dbprtype = thismodule.dbprtypeW;
        pub const SQLLinkedCatalogs = thismodule.SQLLinkedCatalogsW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const bcp_init = *opaque {};
        pub const bcp_readfmt = *opaque {};
        pub const bcp_writefmt = *opaque {};
        pub const dbprtype = *opaque {};
        pub const SQLLinkedCatalogs = *opaque {};
    } else struct {
        pub const bcp_init = @compileError("'bcp_init' requires that UNICODE be set to true or false in the root module");
        pub const bcp_readfmt = @compileError("'bcp_readfmt' requires that UNICODE be set to true or false in the root module");
        pub const bcp_writefmt = @compileError("'bcp_writefmt' requires that UNICODE be set to true or false in the root module");
        pub const dbprtype = @compileError("'dbprtype' requires that UNICODE be set to true or false in the root module");
        pub const SQLLinkedCatalogs = @compileError("'SQLLinkedCatalogs' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (44)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BLOB = @import("../system/com.zig").BLOB;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CONDITION_OPERATION = @import("../system/search/common.zig").CONDITION_OPERATION;
const CONDITION_TYPE = @import("../system/search/common.zig").CONDITION_TYPE;
const COSERVERINFO = @import("../system/com.zig").COSERVERINFO;
const CY = @import("../system/com.zig").CY;
const DBID = @import("../storage/index_server.zig").DBID;
const DISPPARAMS = @import("../system/com.zig").DISPPARAMS;
const EXPLICIT_ACCESS_W = @import("../security/authorization.zig").EXPLICIT_ACCESS_W;
const FILETIME = @import("../foundation.zig").FILETIME;
const FILTERREGION = @import("../storage/index_server.zig").FILTERREGION;
const FULLPROPSPEC = @import("../storage/index_server.zig").FULLPROPSPEC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IAuthenticate = @import("../system/com.zig").IAuthenticate;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumString = @import("../system/com.zig").IEnumString;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IErrorInfo = @import("../system/com.zig").IErrorInfo;
const IFilter = @import("../storage/index_server.zig").IFilter;
const IMoniker = @import("../system/com.zig").IMoniker;
const IObjectArray = @import("../ui/shell/common.zig").IObjectArray;
const IPersistStream = @import("../system/com.zig").IPersistStream;
const IPhraseSink = @import("../storage/index_server.zig").IPhraseSink;
const ISequentialStream = @import("../system/com.zig").ISequentialStream;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const ITransaction = @import("../system/distributed_transaction_coordinator.zig").ITransaction;
const ITransactionOptions = @import("../system/distributed_transaction_coordinator.zig").ITransactionOptions;
const ITypeInfo = @import("../system/com.zig").ITypeInfo;
const IUnknown = @import("../system/com.zig").IUnknown;
const MULTI_QI = @import("../system/com.zig").MULTI_QI;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPSPEC = @import("../system/com/structured_storage.zig").PROPSPEC;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const TRUSTEE_W = @import("../security/authorization.zig").TRUSTEE_W;
const VARIANT = @import("../system/com.zig").VARIANT;
const WORDREP_BREAK_TYPE = @import("../storage/index_server.zig").WORDREP_BREAK_TYPE;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "SQL_ASYNC_NOTIFICATION_CALLBACK")) {
        _ = SQL_ASYNC_NOTIFICATION_CALLBACK;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (1)
//--------------------------------------------------------------------------------
pub const common = @import("search/common.zig");
