//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (3393)
//--------------------------------------------------------------------------------
pub const SI_TEMPORARY = @as(u32, 2147483648);
pub const SUBSINFO_ALLFLAGS = @as(u32, 61311);
pub const RS_READY = @as(u32, 1);
pub const RS_SUSPENDED = @as(u32, 2);
pub const RS_UPDATING = @as(u32, 4);
pub const RS_SUSPENDONIDLE = @as(u32, 65536);
pub const RS_MAYBOTHERUSER = @as(u32, 131072);
pub const RS_COMPLETED = @as(u32, 2147483648);
pub const SUBSMGRUPDATE_MINIMIZE = @as(u32, 1);
pub const SUBSMGRUPDATE_MASK = @as(u32, 1);
pub const SUBSMGRENUM_TEMP = @as(u32, 1);
pub const SUBSMGRENUM_MASK = @as(u32, 1);
pub const INET_E_AGENT_MAX_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693248));
pub const INET_S_AGENT_PART_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 790401));
pub const INET_E_AGENT_CACHE_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693246));
pub const INET_E_AGENT_CONNECTION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693245));
pub const INET_E_SCHEDULED_UPDATES_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693244));
pub const INET_E_SCHEDULED_UPDATES_RESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693243));
pub const INET_E_SCHEDULED_UPDATE_INTERVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693242));
pub const INET_E_SCHEDULED_EXCLUDE_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693241));
pub const INET_E_AGENT_EXCEEDING_CACHE_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693232));
pub const INET_S_AGENT_INCREASED_CACHE_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 790416));
pub const OLEDBVER = @as(u32, 624);
pub const DB_NULL_HACCESSOR = @as(u32, 0);
pub const DB_INVALID_HACCESSOR = @as(u32, 0);
pub const DB_NULL_HROW = @as(u32, 0);
pub const DB_NULL_HCHAPTER = @as(u32, 0);
pub const DB_INVALID_HCHAPTER = @as(u32, 0);
pub const STD_BOOKMARKLENGTH = @as(u32, 1);
pub const DBPROPVAL_BMK_NUMERIC = @as(i32, 1);
pub const DBPROPVAL_BMK_KEY = @as(i32, 2);
pub const DBPROPVAL_CL_START = @as(i32, 1);
pub const DBPROPVAL_CL_END = @as(i32, 2);
pub const DBPROPVAL_CU_DML_STATEMENTS = @as(i32, 1);
pub const DBPROPVAL_CU_TABLE_DEFINITION = @as(i32, 2);
pub const DBPROPVAL_CU_INDEX_DEFINITION = @as(i32, 4);
pub const DBPROPVAL_CU_PRIVILEGE_DEFINITION = @as(i32, 8);
pub const DBPROPVAL_CD_NOTNULL = @as(i32, 1);
pub const DBPROPVAL_CB_NULL = @as(i32, 1);
pub const DBPROPVAL_CB_NON_NULL = @as(i32, 2);
pub const DBPROPVAL_FU_NOT_SUPPORTED = @as(i32, 1);
pub const DBPROPVAL_FU_COLUMN = @as(i32, 2);
pub const DBPROPVAL_FU_TABLE = @as(i32, 4);
pub const DBPROPVAL_FU_CATALOG = @as(i32, 8);
pub const DBPROPVAL_GB_NOT_SUPPORTED = @as(i32, 1);
pub const DBPROPVAL_GB_EQUALS_SELECT = @as(i32, 2);
pub const DBPROPVAL_GB_CONTAINS_SELECT = @as(i32, 4);
pub const DBPROPVAL_GB_NO_RELATION = @as(i32, 8);
pub const DBPROPVAL_HT_DIFFERENT_CATALOGS = @as(i32, 1);
pub const DBPROPVAL_HT_DIFFERENT_PROVIDERS = @as(i32, 2);
pub const DBPROPVAL_IC_UPPER = @as(i32, 1);
pub const DBPROPVAL_IC_LOWER = @as(i32, 2);
pub const DBPROPVAL_IC_SENSITIVE = @as(i32, 4);
pub const DBPROPVAL_IC_MIXED = @as(i32, 8);
pub const DBPROPVAL_LM_NONE = @as(i32, 1);
pub const DBPROPVAL_LM_READ = @as(i32, 2);
pub const DBPROPVAL_LM_INTENT = @as(i32, 4);
pub const DBPROPVAL_LM_RITE = @as(i32, 8);
pub const DBPROPVAL_NP_OKTODO = @as(i32, 1);
pub const DBPROPVAL_NP_ABOUTTODO = @as(i32, 2);
pub const DBPROPVAL_NP_SYNCHAFTER = @as(i32, 4);
pub const DBPROPVAL_NP_FAILEDTODO = @as(i32, 8);
pub const DBPROPVAL_NP_DIDEVENT = @as(i32, 16);
pub const DBPROPVAL_NC_END = @as(i32, 1);
pub const DBPROPVAL_NC_HIGH = @as(i32, 2);
pub const DBPROPVAL_NC_LOW = @as(i32, 4);
pub const DBPROPVAL_NC_START = @as(i32, 8);
pub const DBPROPVAL_OO_BLOB = @as(i32, 1);
pub const DBPROPVAL_OO_IPERSIST = @as(i32, 2);
pub const DBPROPVAL_CB_DELETE = @as(i32, 1);
pub const DBPROPVAL_CB_PRESERVE = @as(i32, 2);
pub const DBPROPVAL_SU_DML_STATEMENTS = @as(i32, 1);
pub const DBPROPVAL_SU_TABLE_DEFINITION = @as(i32, 2);
pub const DBPROPVAL_SU_INDEX_DEFINITION = @as(i32, 4);
pub const DBPROPVAL_SU_PRIVILEGE_DEFINITION = @as(i32, 8);
pub const DBPROPVAL_SQ_CORRELATEDSUBQUERIES = @as(i32, 1);
pub const DBPROPVAL_SQ_COMPARISON = @as(i32, 2);
pub const DBPROPVAL_SQ_EXISTS = @as(i32, 4);
pub const DBPROPVAL_SQ_IN = @as(i32, 8);
pub const DBPROPVAL_SQ_QUANTIFIED = @as(i32, 16);
pub const DBPROPVAL_SQ_TABLE = @as(i32, 32);
pub const DBPROPVAL_SS_ISEQUENTIALSTREAM = @as(i32, 1);
pub const DBPROPVAL_SS_ISTREAM = @as(i32, 2);
pub const DBPROPVAL_SS_ISTORAGE = @as(i32, 4);
pub const DBPROPVAL_SS_ILOCKBYTES = @as(i32, 8);
pub const DBPROPVAL_TI_CHAOS = @as(i32, 16);
pub const DBPROPVAL_TI_READUNCOMMITTED = @as(i32, 256);
pub const DBPROPVAL_TI_BROWSE = @as(i32, 256);
pub const DBPROPVAL_TI_CURSORSTABILITY = @as(i32, 4096);
pub const DBPROPVAL_TI_READCOMMITTED = @as(i32, 4096);
pub const DBPROPVAL_TI_REPEATABLEREAD = @as(i32, 65536);
pub const DBPROPVAL_TI_SERIALIZABLE = @as(i32, 1048576);
pub const DBPROPVAL_TI_ISOLATED = @as(i32, 1048576);
pub const DBPROPVAL_TR_COMMIT_DC = @as(i32, 1);
pub const DBPROPVAL_TR_COMMIT = @as(i32, 2);
pub const DBPROPVAL_TR_COMMIT_NO = @as(i32, 4);
pub const DBPROPVAL_TR_ABORT_DC = @as(i32, 8);
pub const DBPROPVAL_TR_ABORT = @as(i32, 16);
pub const DBPROPVAL_TR_ABORT_NO = @as(i32, 32);
pub const DBPROPVAL_TR_DONTCARE = @as(i32, 64);
pub const DBPROPVAL_TR_BOTH = @as(i32, 128);
pub const DBPROPVAL_TR_NONE = @as(i32, 256);
pub const DBPROPVAL_TR_OPTIMISTIC = @as(i32, 512);
pub const DBPROPVAL_RT_FREETHREAD = @as(i32, 1);
pub const DBPROPVAL_RT_APTMTTHREAD = @as(i32, 2);
pub const DBPROPVAL_RT_SINGLETHREAD = @as(i32, 4);
pub const DBPROPVAL_UP_CHANGE = @as(i32, 1);
pub const DBPROPVAL_UP_DELETE = @as(i32, 2);
pub const DBPROPVAL_UP_INSERT = @as(i32, 4);
pub const DBPROPVAL_SQL_NONE = @as(i32, 0);
pub const DBPROPVAL_SQL_ODBC_MINIMUM = @as(i32, 1);
pub const DBPROPVAL_SQL_ODBC_CORE = @as(i32, 2);
pub const DBPROPVAL_SQL_ODBC_EXTENDED = @as(i32, 4);
pub const DBPROPVAL_SQL_ANSI89_IEF = @as(i32, 8);
pub const DBPROPVAL_SQL_ANSI92_ENTRY = @as(i32, 16);
pub const DBPROPVAL_SQL_FIPS_TRANSITIONAL = @as(i32, 32);
pub const DBPROPVAL_SQL_ANSI92_INTERMEDIATE = @as(i32, 64);
pub const DBPROPVAL_SQL_ANSI92_FULL = @as(i32, 128);
pub const DBPROPVAL_SQL_ESCAPECLAUSES = @as(i32, 256);
pub const DBPROPVAL_IT_BTREE = @as(i32, 1);
pub const DBPROPVAL_IT_HASH = @as(i32, 2);
pub const DBPROPVAL_IT_CONTENT = @as(i32, 3);
pub const DBPROPVAL_IT_OTHER = @as(i32, 4);
pub const DBPROPVAL_IN_DISALLOWNULL = @as(i32, 1);
pub const DBPROPVAL_IN_IGNORENULL = @as(i32, 2);
pub const DBPROPVAL_IN_IGNOREANYNULL = @as(i32, 4);
pub const DBPROPVAL_TC_NONE = @as(i32, 0);
pub const DBPROPVAL_TC_DML = @as(i32, 1);
pub const DBPROPVAL_TC_DDL_COMMIT = @as(i32, 2);
pub const DBPROPVAL_TC_DDL_IGNORE = @as(i32, 4);
pub const DBPROPVAL_TC_ALL = @as(i32, 8);
pub const DBPROPVAL_OA_NOTSUPPORTED = @as(i32, 1);
pub const DBPROPVAL_OA_ATEXECUTE = @as(i32, 2);
pub const DBPROPVAL_OA_ATROWRELEASE = @as(i32, 4);
pub const DBPROPVAL_MR_NOTSUPPORTED = @as(i32, 0);
pub const DBPROPVAL_MR_SUPPORTED = @as(i32, 1);
pub const DBPROPVAL_MR_CONCURRENT = @as(i32, 2);
pub const DBPROPVAL_PT_GUID_NAME = @as(i32, 1);
pub const DBPROPVAL_PT_GUID_PROPID = @as(i32, 2);
pub const DBPROPVAL_PT_NAME = @as(i32, 4);
pub const DBPROPVAL_PT_GUID = @as(i32, 8);
pub const DBPROPVAL_PT_PROPID = @as(i32, 16);
pub const DBPROPVAL_PT_PGUID_NAME = @as(i32, 32);
pub const DBPROPVAL_PT_PGUID_PROPID = @as(i32, 64);
pub const DBPROPVAL_NT_SINGLEROW = @as(i32, 1);
pub const DBPROPVAL_NT_MULTIPLEROWS = @as(i32, 2);
pub const DBPROPVAL_ASYNCH_INITIALIZE = @as(i32, 1);
pub const DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION = @as(i32, 2);
pub const DBPROPVAL_ASYNCH_RANDOMPOPULATION = @as(i32, 4);
pub const DBPROPVAL_OP_EQUAL = @as(i32, 1);
pub const DBPROPVAL_OP_RELATIVE = @as(i32, 2);
pub const DBPROPVAL_OP_STRING = @as(i32, 4);
pub const DBPROPVAL_CO_EQUALITY = @as(i32, 1);
pub const DBPROPVAL_CO_STRING = @as(i32, 2);
pub const DBPROPVAL_CO_CASESENSITIVE = @as(i32, 4);
pub const DBPROPVAL_CO_CASEINSENSITIVE = @as(i32, 8);
pub const DBPROPVAL_CO_CONTAINS = @as(i32, 16);
pub const DBPROPVAL_CO_BEGINSWITH = @as(i32, 32);
pub const DBPROPVAL_ASYNCH_BACKGROUNDPOPULATION = @as(i32, 8);
pub const DBPROPVAL_ASYNCH_PREPOPULATE = @as(i32, 16);
pub const DBPROPVAL_ASYNCH_POPULATEONDEMAND = @as(i32, 32);
pub const DBPROPVAL_LM_SINGLEROW = @as(i32, 2);
pub const DBPROPVAL_SQL_SUBMINIMUM = @as(i32, 512);
pub const DBPROPVAL_DST_TDP = @as(i32, 1);
pub const DBPROPVAL_DST_MDP = @as(i32, 2);
pub const DBPROPVAL_DST_TDPANDMDP = @as(i32, 3);
pub const MDPROPVAL_AU_UNSUPPORTED = @as(i32, 0);
pub const MDPROPVAL_AU_UNCHANGED = @as(i32, 1);
pub const MDPROPVAL_AU_UNKNOWN = @as(i32, 2);
pub const MDPROPVAL_MF_WITH_CALCMEMBERS = @as(i32, 1);
pub const MDPROPVAL_MF_WITH_NAMEDSETS = @as(i32, 2);
pub const MDPROPVAL_MF_CREATE_CALCMEMBERS = @as(i32, 4);
pub const MDPROPVAL_MF_CREATE_NAMEDSETS = @as(i32, 8);
pub const MDPROPVAL_MF_SCOPE_SESSION = @as(i32, 16);
pub const MDPROPVAL_MF_SCOPE_GLOBAL = @as(i32, 32);
pub const MDPROPVAL_MMF_COUSIN = @as(i32, 1);
pub const MDPROPVAL_MMF_PARALLELPERIOD = @as(i32, 2);
pub const MDPROPVAL_MMF_OPENINGPERIOD = @as(i32, 4);
pub const MDPROPVAL_MMF_CLOSINGPERIOD = @as(i32, 8);
pub const MDPROPVAL_MNF_MEDIAN = @as(i32, 1);
pub const MDPROPVAL_MNF_VAR = @as(i32, 2);
pub const MDPROPVAL_MNF_STDDEV = @as(i32, 4);
pub const MDPROPVAL_MNF_RANK = @as(i32, 8);
pub const MDPROPVAL_MNF_AGGREGATE = @as(i32, 16);
pub const MDPROPVAL_MNF_COVARIANCE = @as(i32, 32);
pub const MDPROPVAL_MNF_CORRELATION = @as(i32, 64);
pub const MDPROPVAL_MNF_LINREGSLOPE = @as(i32, 128);
pub const MDPROPVAL_MNF_LINREGVARIANCE = @as(i32, 256);
pub const MDPROPVAL_MNF_LINREG2 = @as(i32, 512);
pub const MDPROPVAL_MNF_LINREGPOINT = @as(i32, 1024);
pub const MDPROPVAL_MNF_DRILLDOWNLEVEL = @as(i32, 2048);
pub const MDPROPVAL_MNF_DRILLDOWNMEMBERTOP = @as(i32, 4096);
pub const MDPROPVAL_MNF_DRILLDOWNMEMBERBOTTOM = @as(i32, 8192);
pub const MDPROPVAL_MNF_DRILLDOWNLEVELTOP = @as(i32, 16384);
pub const MDPROPVAL_MNF_DRILLDOWNLEVELBOTTOM = @as(i32, 32768);
pub const MDPROPVAL_MNF_DRILLUPMEMBER = @as(i32, 65536);
pub const MDPROPVAL_MNF_DRILLUPLEVEL = @as(i32, 131072);
pub const MDPROPVAL_MSF_TOPPERCENT = @as(i32, 1);
pub const MDPROPVAL_MSF_BOTTOMPERCENT = @as(i32, 2);
pub const MDPROPVAL_MSF_TOPSUM = @as(i32, 4);
pub const MDPROPVAL_MSF_BOTTOMSUM = @as(i32, 8);
pub const MDPROPVAL_MSF_PERIODSTODATE = @as(i32, 16);
pub const MDPROPVAL_MSF_LASTPERIODS = @as(i32, 32);
pub const MDPROPVAL_MSF_YTD = @as(i32, 64);
pub const MDPROPVAL_MSF_QTD = @as(i32, 128);
pub const MDPROPVAL_MSF_MTD = @as(i32, 256);
pub const MDPROPVAL_MSF_WTD = @as(i32, 512);
pub const MDPROPVAL_MSF_DRILLDOWNMEMBBER = @as(i32, 1024);
pub const MDPROPVAL_MSF_DRILLDOWNLEVEL = @as(i32, 2048);
pub const MDPROPVAL_MSF_DRILLDOWNMEMBERTOP = @as(i32, 4096);
pub const MDPROPVAL_MSF_DRILLDOWNMEMBERBOTTOM = @as(i32, 8192);
pub const MDPROPVAL_MSF_DRILLDOWNLEVELTOP = @as(i32, 16384);
pub const MDPROPVAL_MSF_DRILLDOWNLEVELBOTTOM = @as(i32, 32768);
pub const MDPROPVAL_MSF_DRILLUPMEMBER = @as(i32, 65536);
pub const MDPROPVAL_MSF_DRILLUPLEVEL = @as(i32, 131072);
pub const MDPROPVAL_MSF_TOGGLEDRILLSTATE = @as(i32, 262144);
pub const MDPROPVAL_MD_SELF = @as(i32, 1);
pub const MDPROPVAL_MD_BEFORE = @as(i32, 2);
pub const MDPROPVAL_MD_AFTER = @as(i32, 4);
pub const MDPROPVAL_MSC_LESSTHAN = @as(i32, 1);
pub const MDPROPVAL_MSC_GREATERTHAN = @as(i32, 2);
pub const MDPROPVAL_MSC_LESSTHANEQUAL = @as(i32, 4);
pub const MDPROPVAL_MSC_GREATERTHANEQUAL = @as(i32, 8);
pub const MDPROPVAL_MC_SINGLECASE = @as(i32, 1);
pub const MDPROPVAL_MC_SEARCHEDCASE = @as(i32, 2);
pub const MDPROPVAL_MOQ_OUTERREFERENCE = @as(i32, 1);
pub const MDPROPVAL_MOQ_DATASOURCE_CUBE = @as(i32, 1);
pub const MDPROPVAL_MOQ_CATALOG_CUBE = @as(i32, 2);
pub const MDPROPVAL_MOQ_SCHEMA_CUBE = @as(i32, 4);
pub const MDPROPVAL_MOQ_CUBE_DIM = @as(i32, 8);
pub const MDPROPVAL_MOQ_DIM_HIER = @as(i32, 16);
pub const MDPROPVAL_MOQ_DIMHIER_LEVEL = @as(i32, 32);
pub const MDPROPVAL_MOQ_LEVEL_MEMBER = @as(i32, 64);
pub const MDPROPVAL_MOQ_MEMBER_MEMBER = @as(i32, 128);
pub const MDPROPVAL_MOQ_DIMHIER_MEMBER = @as(i32, 256);
pub const MDPROPVAL_FS_FULL_SUPPORT = @as(i32, 1);
pub const MDPROPVAL_FS_GENERATED_COLUMN = @as(i32, 2);
pub const MDPROPVAL_FS_GENERATED_DIMENSION = @as(i32, 3);
pub const MDPROPVAL_FS_NO_SUPPORT = @as(i32, 4);
pub const MDPROPVAL_NL_NAMEDLEVELS = @as(i32, 1);
pub const MDPROPVAL_NL_NUMBEREDLEVELS = @as(i32, 2);
pub const MDPROPVAL_MJC_SINGLECUBE = @as(i32, 1);
pub const MDPROPVAL_MJC_MULTICUBES = @as(i32, 2);
pub const MDPROPVAL_MJC_IMPLICITCUBE = @as(i32, 4);
pub const MDPROPVAL_RR_NORANGEROWSET = @as(i32, 1);
pub const MDPROPVAL_RR_READONLY = @as(i32, 2);
pub const MDPROPVAL_RR_UPDATE = @as(i32, 4);
pub const MDPROPVAL_MS_MULTIPLETUPLES = @as(i32, 1);
pub const MDPROPVAL_MS_SINGLETUPLE = @as(i32, 2);
pub const MDPROPVAL_NME_ALLDIMENSIONS = @as(i32, 0);
pub const MDPROPVAL_NME_MEASURESONLY = @as(i32, 1);
pub const DBPROPVAL_AO_SEQUENTIAL = @as(i32, 0);
pub const DBPROPVAL_AO_SEQUENTIALSTORAGEOBJECTS = @as(i32, 1);
pub const DBPROPVAL_AO_RANDOM = @as(i32, 2);
pub const DBPROPVAL_BD_ROWSET = @as(i32, 0);
pub const DBPROPVAL_BD_INTRANSACTION = @as(i32, 1);
pub const DBPROPVAL_BD_XTRANSACTION = @as(i32, 2);
pub const DBPROPVAL_BD_REORGANIZATION = @as(i32, 3);
pub const BMK_DURABILITY_ROWSET = @as(i32, 0);
pub const BMK_DURABILITY_INTRANSACTION = @as(i32, 1);
pub const BMK_DURABILITY_XTRANSACTION = @as(i32, 2);
pub const BMK_DURABILITY_REORGANIZATION = @as(i32, 3);
pub const DBPROPVAL_BO_NOLOG = @as(i32, 0);
pub const DBPROPVAL_BO_NOINDEXUPDATE = @as(i32, 1);
pub const DBPROPVAL_BO_REFINTEGRITY = @as(i32, 2);
pub const DBPROPVAL_STGM_DIRECT = @as(u32, 65536);
pub const DBPROPVAL_STGM_TRANSACTED = @as(u32, 131072);
pub const DBPROPVAL_STGM_CONVERT = @as(u32, 262144);
pub const DBPROPVAL_STGM_FAILIFTHERE = @as(u32, 524288);
pub const DBPROPVAL_STGM_PRIORITY = @as(u32, 1048576);
pub const DBPROPVAL_STGM_DELETEONRELEASE = @as(u32, 2097152);
pub const DBPROPVAL_GB_COLLATE = @as(i32, 16);
pub const DBPROPVAL_CS_UNINITIALIZED = @as(i32, 0);
pub const DBPROPVAL_CS_INITIALIZED = @as(i32, 1);
pub const DBPROPVAL_CS_COMMUNICATIONFAILURE = @as(i32, 2);
pub const DBPROPVAL_RD_RESETALL = @as(i32, -1);
pub const DBPROPVAL_OS_RESOURCEPOOLING = @as(i32, 1);
pub const DBPROPVAL_OS_TXNENLISTMENT = @as(i32, 2);
pub const DBPROPVAL_OS_CLIENTCURSOR = @as(i32, 4);
pub const DBPROPVAL_OS_ENABLEALL = @as(i32, -1);
pub const DBPROPVAL_BI_CROSSROWSET = @as(i32, 1);
pub const MDPROPVAL_NL_SCHEMAONLY = @as(i32, 4);
pub const DBPROPVAL_OS_DISABLEALL = @as(i32, 0);
pub const DBPROPVAL_OO_ROWOBJECT = @as(i32, 4);
pub const DBPROPVAL_OO_SCOPED = @as(i32, 8);
pub const DBPROPVAL_OO_DIRECTBIND = @as(i32, 16);
pub const DBPROPVAL_DST_DOCSOURCE = @as(i32, 4);
pub const DBPROPVAL_GU_NOTSUPPORTED = @as(i32, 1);
pub const DBPROPVAL_GU_SUFFIX = @as(i32, 2);
pub const DB_BINDFLAGS_DELAYFETCHCOLUMNS = @as(i32, 1);
pub const DB_BINDFLAGS_DELAYFETCHSTREAM = @as(i32, 2);
pub const DB_BINDFLAGS_RECURSIVE = @as(i32, 4);
pub const DB_BINDFLAGS_OUTPUT = @as(i32, 8);
pub const DB_BINDFLAGS_COLLECTION = @as(i32, 16);
pub const DB_BINDFLAGS_OPENIFEXISTS = @as(i32, 32);
pub const DB_BINDFLAGS_OVERWRITE = @as(i32, 64);
pub const DB_BINDFLAGS_ISSTRUCTUREDDOCUMENT = @as(i32, 128);
pub const DBPROPVAL_ORS_TABLE = @as(i32, 0);
pub const DBPROPVAL_ORS_INDEX = @as(i32, 1);
pub const DBPROPVAL_ORS_INTEGRATEDINDEX = @as(i32, 2);
pub const DBPROPVAL_TC_DDL_LOCK = @as(i32, 16);
pub const DBPROPVAL_ORS_STOREDPROC = @as(i32, 4);
pub const DBPROPVAL_IN_ALLOWNULL = @as(i32, 0);
pub const DBPROPVAL_OO_SINGLETON = @as(i32, 32);
pub const DBPROPVAL_OS_AGR_AFTERSESSION = @as(i32, 8);
pub const DBPROPVAL_CM_TRANSACTIONS = @as(i32, 1);
pub const DBPROPVAL_TS_CARDINALITY = @as(i32, 1);
pub const DBPROPVAL_TS_HISTOGRAM = @as(i32, 2);
pub const DBPROPVAL_ORS_HISTOGRAM = @as(i32, 8);
pub const MDPROPVAL_VISUAL_MODE_DEFAULT = @as(i32, 0);
pub const MDPROPVAL_VISUAL_MODE_VISUAL = @as(i32, 1);
pub const MDPROPVAL_VISUAL_MODE_VISUAL_OFF = @as(i32, 2);
pub const DB_IMP_LEVEL_ANONYMOUS = @as(u32, 0);
pub const DB_IMP_LEVEL_IDENTIFY = @as(u32, 1);
pub const DB_IMP_LEVEL_IMPERSONATE = @as(u32, 2);
pub const DB_IMP_LEVEL_DELEGATE = @as(u32, 3);
pub const DBPROMPT_PROMPT = @as(u32, 1);
pub const DBPROMPT_COMPLETE = @as(u32, 2);
pub const DBPROMPT_COMPLETEREQUIRED = @as(u32, 3);
pub const DBPROMPT_NOPROMPT = @as(u32, 4);
pub const DB_PROT_LEVEL_NONE = @as(u32, 0);
pub const DB_PROT_LEVEL_CONNECT = @as(u32, 1);
pub const DB_PROT_LEVEL_CALL = @as(u32, 2);
pub const DB_PROT_LEVEL_PKT = @as(u32, 3);
pub const DB_PROT_LEVEL_PKT_INTEGRITY = @as(u32, 4);
pub const DB_PROT_LEVEL_PKT_PRIVACY = @as(u32, 5);
pub const DB_MODE_READ = @as(u32, 1);
pub const DB_MODE_WRITE = @as(u32, 2);
pub const DB_MODE_READWRITE = @as(u32, 3);
pub const DB_MODE_SHARE_DENY_READ = @as(u32, 4);
pub const DB_MODE_SHARE_DENY_WRITE = @as(u32, 8);
pub const DB_MODE_SHARE_EXCLUSIVE = @as(u32, 12);
pub const DB_MODE_SHARE_DENY_NONE = @as(u32, 16);
pub const DBCOMPUTEMODE_COMPUTED = @as(u32, 1);
pub const DBCOMPUTEMODE_DYNAMIC = @as(u32, 2);
pub const DBCOMPUTEMODE_NOTCOMPUTED = @as(u32, 3);
pub const DBPROPVAL_DF_INITIALLY_DEFERRED = @as(u32, 1);
pub const DBPROPVAL_DF_INITIALLY_IMMEDIATE = @as(u32, 2);
pub const DBPROPVAL_DF_NOT_DEFERRABLE = @as(u32, 3);
pub const DBPARAMTYPE_INPUT = @as(u32, 1);
pub const DBPARAMTYPE_INPUTOUTPUT = @as(u32, 2);
pub const DBPARAMTYPE_OUTPUT = @as(u32, 3);
pub const DBPARAMTYPE_RETURNVALUE = @as(u32, 4);
pub const DB_PT_UNKNOWN = @as(u32, 1);
pub const DB_PT_PROCEDURE = @as(u32, 2);
pub const DB_PT_FUNCTION = @as(u32, 3);
pub const DB_REMOTE = @as(u32, 1);
pub const DB_LOCAL_SHARED = @as(u32, 2);
pub const DB_LOCAL_EXCLUSIVE = @as(u32, 3);
pub const DB_COLLATION_ASC = @as(u32, 1);
pub const DB_COLLATION_DESC = @as(u32, 2);
pub const DB_UNSEARCHABLE = @as(u32, 1);
pub const DB_LIKE_ONLY = @as(u32, 2);
pub const DB_ALL_EXCEPT_LIKE = @as(u32, 3);
pub const DB_SEARCHABLE = @as(u32, 4);
pub const MDTREEOP_CHILDREN = @as(u32, 1);
pub const MDTREEOP_SIBLINGS = @as(u32, 2);
pub const MDTREEOP_PARENT = @as(u32, 4);
pub const MDTREEOP_SELF = @as(u32, 8);
pub const MDTREEOP_DESCENDANTS = @as(u32, 16);
pub const MDTREEOP_ANCESTORS = @as(u32, 32);
pub const MD_DIMTYPE_UNKNOWN = @as(u32, 0);
pub const MD_DIMTYPE_TIME = @as(u32, 1);
pub const MD_DIMTYPE_MEASURE = @as(u32, 2);
pub const MD_DIMTYPE_OTHER = @as(u32, 3);
pub const MDLEVEL_TYPE_UNKNOWN = @as(u32, 0);
pub const MDLEVEL_TYPE_REGULAR = @as(u32, 0);
pub const MDLEVEL_TYPE_ALL = @as(u32, 1);
pub const MDLEVEL_TYPE_CALCULATED = @as(u32, 2);
pub const MDLEVEL_TYPE_TIME = @as(u32, 4);
pub const MDLEVEL_TYPE_RESERVED1 = @as(u32, 8);
pub const MDLEVEL_TYPE_TIME_YEARS = @as(u32, 20);
pub const MDLEVEL_TYPE_TIME_HALF_YEAR = @as(u32, 36);
pub const MDLEVEL_TYPE_TIME_QUARTERS = @as(u32, 68);
pub const MDLEVEL_TYPE_TIME_MONTHS = @as(u32, 132);
pub const MDLEVEL_TYPE_TIME_WEEKS = @as(u32, 260);
pub const MDLEVEL_TYPE_TIME_DAYS = @as(u32, 516);
pub const MDLEVEL_TYPE_TIME_HOURS = @as(u32, 772);
pub const MDLEVEL_TYPE_TIME_MINUTES = @as(u32, 1028);
pub const MDLEVEL_TYPE_TIME_SECONDS = @as(u32, 2052);
pub const MDLEVEL_TYPE_TIME_UNDEFINED = @as(u32, 4100);
pub const MDMEASURE_AGGR_UNKNOWN = @as(u32, 0);
pub const MDMEASURE_AGGR_SUM = @as(u32, 1);
pub const MDMEASURE_AGGR_COUNT = @as(u32, 2);
pub const MDMEASURE_AGGR_MIN = @as(u32, 3);
pub const MDMEASURE_AGGR_MAX = @as(u32, 4);
pub const MDMEASURE_AGGR_AVG = @as(u32, 5);
pub const MDMEASURE_AGGR_VAR = @as(u32, 6);
pub const MDMEASURE_AGGR_STD = @as(u32, 7);
pub const MDMEASURE_AGGR_CALCULATED = @as(u32, 127);
pub const MDPROP_MEMBER = @as(u32, 1);
pub const MDPROP_CELL = @as(u32, 2);
pub const MDMEMBER_TYPE_UNKNOWN = @as(u32, 0);
pub const MDMEMBER_TYPE_REGULAR = @as(u32, 1);
pub const MDMEMBER_TYPE_ALL = @as(u32, 2);
pub const MDMEMBER_TYPE_MEASURE = @as(u32, 3);
pub const MDMEMBER_TYPE_FORMULA = @as(u32, 4);
pub const MDMEMBER_TYPE_RESERVE1 = @as(u32, 5);
pub const MDMEMBER_TYPE_RESERVE2 = @as(u32, 6);
pub const MDMEMBER_TYPE_RESERVE3 = @as(u32, 7);
pub const MDMEMBER_TYPE_RESERVE4 = @as(u32, 8);
pub const MDDISPINFO_DRILLED_DOWN = @as(u32, 65536);
pub const MDDISPINFO_PARENT_SAME_AS_PREV = @as(u32, 131072);
pub const DB_COUNTUNAVAILABLE = @as(i32, -1);
pub const MDFF_BOLD = @as(u32, 1);
pub const MDFF_ITALIC = @as(u32, 2);
pub const MDFF_UNDERLINE = @as(u32, 4);
pub const MDFF_STRIKEOUT = @as(u32, 8);
pub const MDAXIS_COLUMNS = @as(u32, 0);
pub const MDAXIS_ROWS = @as(u32, 1);
pub const MDAXIS_PAGES = @as(u32, 2);
pub const MDAXIS_SECTIONS = @as(u32, 3);
pub const MDAXIS_CHAPTERS = @as(u32, 4);
pub const MDAXIS_SLICERS = @as(u32, 4294967295);
pub const CRESTRICTIONS_DBSCHEMA_ASSERTIONS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_CATALOGS = @as(u32, 1);
pub const CRESTRICTIONS_DBSCHEMA_CHARACTER_SETS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_COLLATIONS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_COLUMNS = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_CHECK_CONSTRAINTS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_CONSTRAINT_COLUMN_USAGE = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_CONSTRAINT_TABLE_USAGE = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_KEY_COLUMN_USAGE = @as(u32, 7);
pub const CRESTRICTIONS_DBSCHEMA_REFERENTIAL_CONSTRAINTS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_TABLE_CONSTRAINTS = @as(u32, 7);
pub const CRESTRICTIONS_DBSCHEMA_COLUMN_DOMAIN_USAGE = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_INDEXES = @as(u32, 5);
pub const CRESTRICTIONS_DBSCHEMA_OBJECT_ACTIONS = @as(u32, 1);
pub const CRESTRICTIONS_DBSCHEMA_OBJECTS = @as(u32, 1);
pub const CRESTRICTIONS_DBSCHEMA_COLUMN_PRIVILEGES = @as(u32, 6);
pub const CRESTRICTIONS_DBSCHEMA_TABLE_PRIVILEGES = @as(u32, 5);
pub const CRESTRICTIONS_DBSCHEMA_USAGE_PRIVILEGES = @as(u32, 6);
pub const CRESTRICTIONS_DBSCHEMA_PROCEDURES = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_SCHEMATA = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_SQL_LANGUAGES = @as(u32, 0);
pub const CRESTRICTIONS_DBSCHEMA_STATISTICS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_TABLES = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_TRANSLATIONS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_PROVIDER_TYPES = @as(u32, 2);
pub const CRESTRICTIONS_DBSCHEMA_VIEWS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_VIEW_COLUMN_USAGE = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_VIEW_TABLE_USAGE = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_PROCEDURE_PARAMETERS = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_FOREIGN_KEYS = @as(u32, 6);
pub const CRESTRICTIONS_DBSCHEMA_PRIMARY_KEYS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_PROCEDURE_COLUMNS = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_TABLES_INFO = @as(u32, 4);
pub const CRESTRICTIONS_MDSCHEMA_CUBES = @as(u32, 3);
pub const CRESTRICTIONS_MDSCHEMA_DIMENSIONS = @as(u32, 5);
pub const CRESTRICTIONS_MDSCHEMA_HIERARCHIES = @as(u32, 6);
pub const CRESTRICTIONS_MDSCHEMA_LEVELS = @as(u32, 7);
pub const CRESTRICTIONS_MDSCHEMA_MEASURES = @as(u32, 5);
pub const CRESTRICTIONS_MDSCHEMA_PROPERTIES = @as(u32, 9);
pub const CRESTRICTIONS_MDSCHEMA_MEMBERS = @as(u32, 12);
pub const CRESTRICTIONS_DBSCHEMA_TRUSTEE = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_TABLE_STATISTICS = @as(u32, 7);
pub const CRESTRICTIONS_DBSCHEMA_CHECK_CONSTRAINTS_BY_TABLE = @as(u32, 6);
pub const CRESTRICTIONS_MDSCHEMA_FUNCTIONS = @as(u32, 4);
pub const CRESTRICTIONS_MDSCHEMA_ACTIONS = @as(u32, 8);
pub const CRESTRICTIONS_MDSCHEMA_COMMANDS = @as(u32, 5);
pub const CRESTRICTIONS_MDSCHEMA_SETS = @as(u32, 5);
pub const IDENTIFIER_SDK_MASK = @as(u32, 4026531840);
pub const IDENTIFIER_SDK_ERROR = @as(u32, 268435456);
pub const DBPROP_MSDAORA_DETERMINEKEYCOLUMNS = @as(u32, 1);
pub const DBPROP_MSDAORA8_DETERMINEKEYCOLUMNS = @as(u32, 2);
pub const PWPROP_OSPVALUE = @as(u32, 2);
pub const STGM_COLLECTION = @as(i32, 8192);
pub const STGM_OUTPUT = @as(i32, 32768);
pub const STGM_OPEN = @as(i32, -2147483648);
pub const STGM_RECURSIVE = @as(i32, 16777216);
pub const STGM_STRICTOPEN = @as(i32, 1073741824);
pub const KAGPROP_QUERYBASEDUPDATES = @as(u32, 2);
pub const KAGPROP_MARSHALLABLE = @as(u32, 3);
pub const KAGPROP_POSITIONONNEWROW = @as(u32, 4);
pub const KAGPROP_IRowsetChangeExtInfo = @as(u32, 5);
pub const KAGPROP_CURSOR = @as(u32, 6);
pub const KAGPROP_CONCURRENCY = @as(u32, 7);
pub const KAGPROP_BLOBSONFOCURSOR = @as(u32, 8);
pub const KAGPROP_INCLUDENONEXACT = @as(u32, 9);
pub const KAGPROP_FORCESSFIREHOSEMODE = @as(u32, 10);
pub const KAGPROP_FORCENOPARAMETERREBIND = @as(u32, 11);
pub const KAGPROP_FORCENOPREPARE = @as(u32, 12);
pub const KAGPROP_FORCENOREEXECUTE = @as(u32, 13);
pub const KAGPROP_ACCESSIBLEPROCEDURES = @as(u32, 2);
pub const KAGPROP_ACCESSIBLETABLES = @as(u32, 3);
pub const KAGPROP_ODBCSQLOPTIEF = @as(u32, 4);
pub const KAGPROP_OJCAPABILITY = @as(u32, 5);
pub const KAGPROP_PROCEDURES = @as(u32, 6);
pub const KAGPROP_DRIVERNAME = @as(u32, 7);
pub const KAGPROP_DRIVERVER = @as(u32, 8);
pub const KAGPROP_DRIVERODBCVER = @as(u32, 9);
pub const KAGPROP_LIKEESCAPECLAUSE = @as(u32, 10);
pub const KAGPROP_SPECIALCHARACTERS = @as(u32, 11);
pub const KAGPROP_MAXCOLUMNSINGROUPBY = @as(u32, 12);
pub const KAGPROP_MAXCOLUMNSININDEX = @as(u32, 13);
pub const KAGPROP_MAXCOLUMNSINORDERBY = @as(u32, 14);
pub const KAGPROP_MAXCOLUMNSINSELECT = @as(u32, 15);
pub const KAGPROP_MAXCOLUMNSINTABLE = @as(u32, 16);
pub const KAGPROP_NUMERICFUNCTIONS = @as(u32, 17);
pub const KAGPROP_ODBCSQLCONFORMANCE = @as(u32, 18);
pub const KAGPROP_OUTERJOINS = @as(u32, 19);
pub const KAGPROP_STRINGFUNCTIONS = @as(u32, 20);
pub const KAGPROP_SYSTEMFUNCTIONS = @as(u32, 21);
pub const KAGPROP_TIMEDATEFUNCTIONS = @as(u32, 22);
pub const KAGPROP_FILEUSAGE = @as(u32, 23);
pub const KAGPROP_ACTIVESTATEMENTS = @as(u32, 24);
pub const KAGPROP_AUTH_TRUSTEDCONNECTION = @as(u32, 2);
pub const KAGPROP_AUTH_SERVERINTEGRATED = @as(u32, 3);
pub const KAGPROPVAL_CONCUR_ROWVER = @as(u32, 1);
pub const KAGPROPVAL_CONCUR_VALUES = @as(u32, 2);
pub const KAGPROPVAL_CONCUR_LOCK = @as(u32, 4);
pub const KAGPROPVAL_CONCUR_READ_ONLY = @as(u32, 8);
pub const ODBCVER = @as(u32, 896);
pub const ODBC_ADD_DSN = @as(u32, 1);
pub const ODBC_CONFIG_DSN = @as(u32, 2);
pub const ODBC_REMOVE_DSN = @as(u32, 3);
pub const ODBC_ADD_SYS_DSN = @as(u32, 4);
pub const ODBC_CONFIG_SYS_DSN = @as(u32, 5);
pub const ODBC_REMOVE_SYS_DSN = @as(u32, 6);
pub const ODBC_REMOVE_DEFAULT_DSN = @as(u32, 7);
pub const ODBC_INSTALL_INQUIRY = @as(u32, 1);
pub const ODBC_INSTALL_COMPLETE = @as(u32, 2);
pub const ODBC_INSTALL_DRIVER = @as(u32, 1);
pub const ODBC_REMOVE_DRIVER = @as(u32, 2);
pub const ODBC_CONFIG_DRIVER = @as(u32, 3);
pub const ODBC_CONFIG_DRIVER_MAX = @as(u32, 100);
pub const ODBC_BOTH_DSN = @as(u32, 0);
pub const ODBC_USER_DSN = @as(u32, 1);
pub const ODBC_SYSTEM_DSN = @as(u32, 2);
pub const ODBC_ERROR_GENERAL_ERR = @as(u32, 1);
pub const ODBC_ERROR_INVALID_BUFF_LEN = @as(u32, 2);
pub const ODBC_ERROR_INVALID_HWND = @as(u32, 3);
pub const ODBC_ERROR_INVALID_STR = @as(u32, 4);
pub const ODBC_ERROR_INVALID_REQUEST_TYPE = @as(u32, 5);
pub const ODBC_ERROR_COMPONENT_NOT_FOUND = @as(u32, 6);
pub const ODBC_ERROR_INVALID_NAME = @as(u32, 7);
pub const ODBC_ERROR_INVALID_KEYWORD_VALUE = @as(u32, 8);
pub const ODBC_ERROR_INVALID_DSN = @as(u32, 9);
pub const ODBC_ERROR_INVALID_INF = @as(u32, 10);
pub const ODBC_ERROR_REQUEST_FAILED = @as(u32, 11);
pub const ODBC_ERROR_INVALID_PATH = @as(u32, 12);
pub const ODBC_ERROR_LOAD_LIB_FAILED = @as(u32, 13);
pub const ODBC_ERROR_INVALID_PARAM_SEQUENCE = @as(u32, 14);
pub const ODBC_ERROR_INVALID_LOG_FILE = @as(u32, 15);
pub const ODBC_ERROR_USER_CANCELED = @as(u32, 16);
pub const ODBC_ERROR_USAGE_UPDATE_FAILED = @as(u32, 17);
pub const ODBC_ERROR_CREATE_DSN_FAILED = @as(u32, 18);
pub const ODBC_ERROR_WRITING_SYSINFO_FAILED = @as(u32, 19);
pub const ODBC_ERROR_REMOVE_DSN_FAILED = @as(u32, 20);
pub const ODBC_ERROR_OUT_OF_MEM = @as(u32, 21);
pub const ODBC_ERROR_OUTPUT_STRING_TRUNCATED = @as(u32, 22);
pub const ODBC_ERROR_NOTRANINFO = @as(u32, 23);
pub const ODBC_ERROR_MAX = @as(u32, 23);
pub const SQL_MAX_SQLSERVERNAME = @as(u32, 128);
pub const SQL_COPT_SS_BASE = @as(u32, 1200);
pub const SQL_COPT_SS_REMOTE_PWD = @as(u32, 1201);
pub const SQL_COPT_SS_USE_PROC_FOR_PREP = @as(u32, 1202);
pub const SQL_COPT_SS_INTEGRATED_SECURITY = @as(u32, 1203);
pub const SQL_COPT_SS_PRESERVE_CURSORS = @as(u32, 1204);
pub const SQL_COPT_SS_USER_DATA = @as(u32, 1205);
pub const SQL_COPT_SS_FALLBACK_CONNECT = @as(u32, 1210);
pub const SQL_COPT_SS_PERF_DATA = @as(u32, 1211);
pub const SQL_COPT_SS_PERF_DATA_LOG = @as(u32, 1212);
pub const SQL_COPT_SS_PERF_QUERY_INTERVAL = @as(u32, 1213);
pub const SQL_COPT_SS_PERF_QUERY_LOG = @as(u32, 1214);
pub const SQL_COPT_SS_PERF_QUERY = @as(u32, 1215);
pub const SQL_COPT_SS_PERF_DATA_LOG_NOW = @as(u32, 1216);
pub const SQL_COPT_SS_QUOTED_IDENT = @as(u32, 1217);
pub const SQL_COPT_SS_ANSI_NPW = @as(u32, 1218);
pub const SQL_COPT_SS_BCP = @as(u32, 1219);
pub const SQL_COPT_SS_TRANSLATE = @as(u32, 1220);
pub const SQL_COPT_SS_ATTACHDBFILENAME = @as(u32, 1221);
pub const SQL_COPT_SS_CONCAT_NULL = @as(u32, 1222);
pub const SQL_COPT_SS_ENCRYPT = @as(u32, 1223);
pub const SQL_COPT_SS_MAX_USED = @as(u32, 1223);
pub const SQL_SOPT_SS_BASE = @as(u32, 1225);
pub const SQL_SOPT_SS_TEXTPTR_LOGGING = @as(u32, 1225);
pub const SQL_SOPT_SS_CURRENT_COMMAND = @as(u32, 1226);
pub const SQL_SOPT_SS_HIDDEN_COLUMNS = @as(u32, 1227);
pub const SQL_SOPT_SS_NOBROWSETABLE = @as(u32, 1228);
pub const SQL_SOPT_SS_REGIONALIZE = @as(u32, 1229);
pub const SQL_SOPT_SS_CURSOR_OPTIONS = @as(u32, 1230);
pub const SQL_SOPT_SS_NOCOUNT_STATUS = @as(u32, 1231);
pub const SQL_SOPT_SS_DEFER_PREPARE = @as(u32, 1232);
pub const SQL_SOPT_SS_MAX_USED = @as(u32, 1232);
pub const SQL_COPT_SS_BASE_EX = @as(u32, 1240);
pub const SQL_COPT_SS_BROWSE_CONNECT = @as(u32, 1241);
pub const SQL_COPT_SS_BROWSE_SERVER = @as(u32, 1242);
pub const SQL_COPT_SS_WARN_ON_CP_ERROR = @as(u32, 1243);
pub const SQL_COPT_SS_CONNECTION_DEAD = @as(u32, 1244);
pub const SQL_COPT_SS_BROWSE_CACHE_DATA = @as(u32, 1245);
pub const SQL_COPT_SS_RESET_CONNECTION = @as(u32, 1246);
pub const SQL_COPT_SS_EX_MAX_USED = @as(u32, 1246);
pub const SQL_UP_OFF = @as(i32, 0);
pub const SQL_UP_ON = @as(i32, 1);
pub const SQL_UP_ON_DROP = @as(i32, 2);
pub const SQL_UP_DEFAULT = @as(i32, 1);
pub const SQL_IS_OFF = @as(i32, 0);
pub const SQL_IS_ON = @as(i32, 1);
pub const SQL_IS_DEFAULT = @as(i32, 0);
pub const SQL_PC_OFF = @as(i32, 0);
pub const SQL_PC_ON = @as(i32, 1);
pub const SQL_PC_DEFAULT = @as(i32, 0);
pub const SQL_XL_OFF = @as(i32, 0);
pub const SQL_XL_ON = @as(i32, 1);
pub const SQL_XL_DEFAULT = @as(i32, 1);
pub const SQL_FB_OFF = @as(i32, 0);
pub const SQL_FB_ON = @as(i32, 1);
pub const SQL_FB_DEFAULT = @as(i32, 0);
pub const SQL_BCP_OFF = @as(i32, 0);
pub const SQL_BCP_ON = @as(i32, 1);
pub const SQL_BCP_DEFAULT = @as(i32, 0);
pub const SQL_QI_OFF = @as(i32, 0);
pub const SQL_QI_ON = @as(i32, 1);
pub const SQL_QI_DEFAULT = @as(i32, 1);
pub const SQL_AD_OFF = @as(i32, 0);
pub const SQL_AD_ON = @as(i32, 1);
pub const SQL_AD_DEFAULT = @as(i32, 1);
pub const SQL_CN_OFF = @as(i32, 0);
pub const SQL_CN_ON = @as(i32, 1);
pub const SQL_CN_DEFAULT = @as(i32, 1);
pub const SQL_TL_OFF = @as(i32, 0);
pub const SQL_TL_ON = @as(i32, 1);
pub const SQL_TL_DEFAULT = @as(i32, 1);
pub const SQL_HC_OFF = @as(i32, 0);
pub const SQL_HC_ON = @as(i32, 1);
pub const SQL_HC_DEFAULT = @as(i32, 0);
pub const SQL_NB_OFF = @as(i32, 0);
pub const SQL_NB_ON = @as(i32, 1);
pub const SQL_NB_DEFAULT = @as(i32, 0);
pub const SQL_RE_OFF = @as(i32, 0);
pub const SQL_RE_ON = @as(i32, 1);
pub const SQL_RE_DEFAULT = @as(i32, 0);
pub const SQL_CO_OFF = @as(i32, 0);
pub const SQL_CO_FFO = @as(i32, 1);
pub const SQL_CO_AF = @as(i32, 2);
pub const SQL_CO_FIREHOSE_AF = @as(i32, 4);
pub const SQL_CO_DEFAULT = @as(i32, 0);
pub const SQL_NC_OFF = @as(i32, 0);
pub const SQL_NC_ON = @as(i32, 1);
pub const SQL_DP_OFF = @as(i32, 0);
pub const SQL_DP_ON = @as(i32, 1);
pub const SQL_EN_OFF = @as(i32, 0);
pub const SQL_EN_ON = @as(i32, 1);
pub const SQL_MORE_INFO_NO = @as(i32, 0);
pub const SQL_MORE_INFO_YES = @as(i32, 1);
pub const SQL_CACHE_DATA_NO = @as(i32, 0);
pub const SQL_CACHE_DATA_YES = @as(i32, 1);
pub const SQL_RESET_YES = @as(i32, 1);
pub const SQL_WARN_NO = @as(i32, 0);
pub const SQL_WARN_YES = @as(i32, 1);
pub const SQL_CURSOR_FAST_FORWARD_ONLY = @as(u32, 8);
pub const SQL_CA_SS_BASE = @as(u32, 1200);
pub const SQL_CA_SS_COLUMN_SSTYPE = @as(u32, 1200);
pub const SQL_CA_SS_COLUMN_UTYPE = @as(u32, 1201);
pub const SQL_CA_SS_NUM_ORDERS = @as(u32, 1202);
pub const SQL_CA_SS_COLUMN_ORDER = @as(u32, 1203);
pub const SQL_CA_SS_COLUMN_VARYLEN = @as(u32, 1204);
pub const SQL_CA_SS_NUM_COMPUTES = @as(u32, 1205);
pub const SQL_CA_SS_COMPUTE_ID = @as(u32, 1206);
pub const SQL_CA_SS_COMPUTE_BYLIST = @as(u32, 1207);
pub const SQL_CA_SS_COLUMN_ID = @as(u32, 1208);
pub const SQL_CA_SS_COLUMN_OP = @as(u32, 1209);
pub const SQL_CA_SS_COLUMN_SIZE = @as(u32, 1210);
pub const SQL_CA_SS_COLUMN_HIDDEN = @as(u32, 1211);
pub const SQL_CA_SS_COLUMN_KEY = @as(u32, 1212);
pub const SQL_CA_SS_COLUMN_COLLATION = @as(u32, 1214);
pub const SQL_CA_SS_VARIANT_TYPE = @as(u32, 1215);
pub const SQL_CA_SS_VARIANT_SQL_TYPE = @as(u32, 1216);
pub const SQL_CA_SS_VARIANT_SERVER_TYPE = @as(u32, 1217);
pub const SQL_CA_SS_MAX_USED = @as(u32, 1218);
pub const SQLTEXT = @as(u32, 35);
pub const SQLVARBINARY = @as(u32, 37);
pub const SQLINTN = @as(u32, 38);
pub const SQLVARCHAR = @as(u32, 39);
pub const SQLBINARY = @as(u32, 45);
pub const SQLIMAGE = @as(u32, 34);
pub const SQLCHARACTER = @as(u32, 47);
pub const SQLINT1 = @as(u32, 48);
pub const SQLBIT = @as(u32, 50);
pub const SQLINT2 = @as(u32, 52);
pub const SQLINT4 = @as(u32, 56);
pub const SQLMONEY = @as(u32, 60);
pub const SQLDATETIME = @as(u32, 61);
pub const SQLFLT8 = @as(u32, 62);
pub const SQLFLTN = @as(u32, 109);
pub const SQLMONEYN = @as(u32, 110);
pub const SQLDATETIMN = @as(u32, 111);
pub const SQLFLT4 = @as(u32, 59);
pub const SQLMONEY4 = @as(u32, 122);
pub const SQLDATETIM4 = @as(u32, 58);
pub const SQLDECIMAL = @as(u32, 106);
pub const SQLNUMERIC = @as(u32, 108);
pub const SQLUNIQUEID = @as(u32, 36);
pub const SQLBIGCHAR = @as(u32, 175);
pub const SQLBIGVARCHAR = @as(u32, 167);
pub const SQLBIGBINARY = @as(u32, 173);
pub const SQLBIGVARBINARY = @as(u32, 165);
pub const SQLBITN = @as(u32, 104);
pub const SQLNCHAR = @as(u32, 239);
pub const SQLNVARCHAR = @as(u32, 231);
pub const SQLNTEXT = @as(u32, 99);
pub const SQLINT8 = @as(u32, 127);
pub const SQLVARIANT = @as(u32, 98);
pub const SQLudtBINARY = @as(u32, 3);
pub const SQLudtBIT = @as(u32, 16);
pub const SQLudtBITN = @as(u32, 0);
pub const SQLudtCHAR = @as(u32, 1);
pub const SQLudtDATETIM4 = @as(u32, 22);
pub const SQLudtDATETIME = @as(u32, 12);
pub const SQLudtDATETIMN = @as(u32, 15);
pub const SQLudtDECML = @as(u32, 24);
pub const SQLudtDECMLN = @as(u32, 26);
pub const SQLudtFLT4 = @as(u32, 23);
pub const SQLudtFLT8 = @as(u32, 8);
pub const SQLudtFLTN = @as(u32, 14);
pub const SQLudtIMAGE = @as(u32, 20);
pub const SQLudtINT1 = @as(u32, 5);
pub const SQLudtINT2 = @as(u32, 6);
pub const SQLudtINT4 = @as(u32, 7);
pub const SQLudtINTN = @as(u32, 13);
pub const SQLudtMONEY = @as(u32, 11);
pub const SQLudtMONEY4 = @as(u32, 21);
pub const SQLudtMONEYN = @as(u32, 17);
pub const SQLudtNUM = @as(u32, 10);
pub const SQLudtNUMN = @as(u32, 25);
pub const SQLudtSYSNAME = @as(u32, 18);
pub const SQLudtTEXT = @as(u32, 19);
pub const SQLudtTIMESTAMP = @as(u32, 80);
pub const SQLudtUNIQUEIDENTIFIER = @as(u32, 0);
pub const SQLudtVARBINARY = @as(u32, 4);
pub const SQLudtVARCHAR = @as(u32, 2);
pub const MIN_USER_DATATYPE = @as(u32, 256);
pub const SQLAOPSTDEV = @as(u32, 48);
pub const SQLAOPSTDEVP = @as(u32, 49);
pub const SQLAOPVAR = @as(u32, 50);
pub const SQLAOPVARP = @as(u32, 51);
pub const SQLAOPCNT = @as(u32, 75);
pub const SQLAOPSUM = @as(u32, 77);
pub const SQLAOPAVG = @as(u32, 79);
pub const SQLAOPMIN = @as(u32, 81);
pub const SQLAOPMAX = @as(u32, 82);
pub const SQLAOPANY = @as(u32, 83);
pub const SQLAOPNOOP = @as(u32, 86);
pub const SQL_INFO_SS_FIRST = @as(u32, 1199);
pub const SQL_INFO_SS_NETLIB_NAMEW = @as(u32, 1199);
pub const SQL_INFO_SS_NETLIB_NAMEA = @as(u32, 1200);
pub const SQL_INFO_SS_MAX_USED = @as(u32, 1200);
pub const SQL_INFO_SS_NETLIB_NAME = @as(u32, 1199);
pub const SQL_SS_VARIANT = @as(i32, -150);
pub const SQL_DIAG_SS_BASE = @as(i32, -1150);
pub const SQL_DIAG_SS_MSGSTATE = @as(i32, -1150);
pub const SQL_DIAG_DFC_SS_BASE = @as(i32, -200);
pub const EX_ANY = @as(u32, 0);
pub const EX_INFO = @as(u32, 10);
pub const EX_MAXISEVERITY = @as(u32, 10);
pub const EX_MISSING = @as(u32, 11);
pub const EX_TYPE = @as(u32, 12);
pub const EX_DEADLOCK = @as(u32, 13);
pub const EX_PERMIT = @as(u32, 14);
pub const EX_SYNTAX = @as(u32, 15);
pub const EX_USER = @as(u32, 16);
pub const EX_RESOURCE = @as(u32, 17);
pub const EX_INTOK = @as(u32, 18);
pub const MAXUSEVERITY = @as(u32, 18);
pub const EX_LIMIT = @as(u32, 19);
pub const EX_CMDFATAL = @as(u32, 20);
pub const MINFATALERR = @as(u32, 20);
pub const EX_DBFATAL = @as(u32, 21);
pub const EX_TABCORRUPT = @as(u32, 22);
pub const EX_DBCORRUPT = @as(u32, 23);
pub const EX_HARDWARE = @as(u32, 24);
pub const EX_CONTROL = @as(u32, 25);
pub const DBMAXCHAR = @as(u32, 8001);
pub const MAXNAME = @as(u32, 129);
pub const MAXNUMERICLEN = @as(u32, 16);
pub const SQL_PERF_START = @as(u32, 1);
pub const SQL_PERF_STOP = @as(u32, 2);
pub const SQL_SS_DL_DEFAULT = "STATS.LOG";
pub const SQL_SS_QL_DEFAULT = "QUERY.LOG";
pub const SQL_SS_QI_DEFAULT = @as(u32, 30000);
pub const SUCCEED = @as(u32, 1);
pub const FAIL = @as(u32, 0);
pub const SUCCEED_ABORT = @as(u32, 2);
pub const SUCCEED_ASYNC = @as(u32, 3);
pub const DB_IN = @as(u32, 1);
pub const DB_OUT = @as(u32, 2);
pub const BCPMAXERRS = @as(u32, 1);
pub const BCPFIRST = @as(u32, 2);
pub const BCPLAST = @as(u32, 3);
pub const BCPBATCH = @as(u32, 4);
pub const BCPKEEPNULLS = @as(u32, 5);
pub const BCPABORT = @as(u32, 6);
pub const BCPODBC = @as(u32, 7);
pub const BCPKEEPIDENTITY = @as(u32, 8);
pub const BCP6xFILEFMT = @as(u32, 9);
pub const BCPHINTSA = @as(u32, 10);
pub const BCPHINTSW = @as(u32, 11);
pub const BCPFILECP = @as(u32, 12);
pub const BCPUNICODEFILE = @as(u32, 13);
pub const BCPTEXTFILE = @as(u32, 14);
pub const BCPFILEFMT = @as(u32, 15);
pub const BCPFILECP_ACP = @as(u32, 0);
pub const BCPFILECP_OEMCP = @as(u32, 1);
pub const BCPFILECP_RAW = @as(i32, -1);
pub const SQL_VARLEN_DATA = @as(i32, -10);
pub const BCPHINTS = @as(u32, 11);
pub const BCP_FMT_TYPE = @as(u32, 1);
pub const BCP_FMT_INDICATOR_LEN = @as(u32, 2);
pub const BCP_FMT_DATA_LEN = @as(u32, 3);
pub const BCP_FMT_TERMINATOR = @as(u32, 4);
pub const BCP_FMT_SERVER_COL = @as(u32, 5);
pub const BCP_FMT_COLLATION = @as(u32, 6);
pub const BCP_FMT_COLLATION_ID = @as(u32, 7);
pub const SQL_FAST_CONNECT = @as(u32, 1200);
pub const SQL_FC_OFF = @as(i32, 0);
pub const SQL_FC_ON = @as(i32, 1);
pub const SQL_FC_DEFAULT = @as(i32, 0);
pub const SQL_COPT_SS_ANSI_OEM = @as(u32, 1206);
pub const SQL_AO_OFF = @as(i32, 0);
pub const SQL_AO_ON = @as(i32, 1);
pub const SQL_AO_DEFAULT = @as(i32, 0);
pub const SQL_REMOTE_PWD = @as(u32, 1201);
pub const SQL_USE_PROCEDURE_FOR_PREPARE = @as(u32, 1202);
pub const SQL_INTEGRATED_SECURITY = @as(u32, 1203);
pub const SQL_PRESERVE_CURSORS = @as(u32, 1204);
pub const SQL_TEXTPTR_LOGGING = @as(u32, 1225);
pub const SQLDECIMALN = @as(u32, 106);
pub const SQLNUMERICN = @as(u32, 108);
pub const DB_E_BOGUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217665));
pub const DB_E_BADACCESSORHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217920));
pub const DB_E_ROWLIMITEXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217919));
pub const DB_E_READONLYACCESSOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217918));
pub const DB_E_SCHEMAVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217917));
pub const DB_E_BADROWHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217916));
pub const DB_E_OBJECTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217915));
pub const DB_E_BADCHAPTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217914));
pub const DB_E_CANTCONVERTVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217913));
pub const DB_E_BADBINDINFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217912));
pub const DB_SEC_E_PERMISSIONDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217911));
pub const DB_E_NOTAREFERENCECOLUMN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217910));
pub const DB_E_LIMITREJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217909));
pub const DB_E_NOCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217908));
pub const DB_E_COSTLIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217907));
pub const DB_E_BADBOOKMARK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217906));
pub const DB_E_BADLOCKMODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217905));
pub const DB_E_PARAMNOTOPTIONAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217904));
pub const DB_E_BADCOLUMNID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217903));
pub const DB_E_BADRATIO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217902));
pub const DB_E_BADVALUES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217901));
pub const DB_E_ERRORSINCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217900));
pub const DB_E_CANTCANCEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217899));
pub const DB_E_DIALECTNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217898));
pub const DB_E_DUPLICATEDATASOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217897));
pub const DB_E_CANNOTRESTART = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217896));
pub const DB_E_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217895));
pub const DB_E_NEWLYINSERTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217893));
pub const DB_E_CANNOTFREE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217894));
pub const DB_E_GOALREJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217892));
pub const DB_E_UNSUPPORTEDCONVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217891));
pub const DB_E_BADSTARTPOSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217890));
pub const DB_E_NOQUERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217889));
pub const DB_E_NOTREENTRANT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217888));
pub const DB_E_ERRORSOCCURRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217887));
pub const DB_E_NOAGGREGATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217886));
pub const DB_E_DELETEDROW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217885));
pub const DB_E_CANTFETCHBACKWARDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217884));
pub const DB_E_ROWSNOTRELEASED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217883));
pub const DB_E_BADSTORAGEFLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217882));
pub const DB_E_BADCOMPAREOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217881));
pub const DB_E_BADSTATUSVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217880));
pub const DB_E_CANTSCROLLBACKWARDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217879));
pub const DB_E_BADREGIONHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217878));
pub const DB_E_NONCONTIGUOUSRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217877));
pub const DB_E_INVALIDTRANSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217876));
pub const DB_E_NOTASUBREGION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217875));
pub const DB_E_MULTIPLESTATEMENTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217874));
pub const DB_E_INTEGRITYVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217873));
pub const DB_E_BADTYPENAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217872));
pub const DB_E_ABORTLIMITREACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217871));
pub const DB_E_ROWSETINCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217870));
pub const DB_E_CANTTRANSLATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217869));
pub const DB_E_DUPLICATEINDEXID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217868));
pub const DB_E_NOINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217867));
pub const DB_E_INDEXINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217866));
pub const DB_E_NOTABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217865));
pub const DB_E_CONCURRENCYVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217864));
pub const DB_E_BADCOPY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217863));
pub const DB_E_BADPRECISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217862));
pub const DB_E_BADSCALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217861));
pub const DB_E_BADTABLEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217860));
pub const DB_E_BADID = @as(i32, -2147217860);
pub const DB_E_BADTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217859));
pub const DB_E_DUPLICATECOLUMNID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217858));
pub const DB_E_DUPLICATETABLEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217857));
pub const DB_E_TABLEINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217856));
pub const DB_E_NOLOCALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217855));
pub const DB_E_BADRECORDNUM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217854));
pub const DB_E_BOOKMARKSKIPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217853));
pub const DB_E_BADPROPERTYVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217852));
pub const DB_E_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217851));
pub const DB_E_BADACCESSORFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217850));
pub const DB_E_BADSTORAGEFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217849));
pub const DB_E_BYREFACCESSORNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217848));
pub const DB_E_NULLACCESSORNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217847));
pub const DB_E_NOTPREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217846));
pub const DB_E_BADACCESSORTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217845));
pub const DB_E_WRITEONLYACCESSOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217844));
pub const DB_SEC_E_AUTH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217843));
pub const DB_E_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217842));
pub const DB_E_CHAPTERNOTRELEASED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217841));
pub const DB_E_BADSOURCEHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217840));
pub const DB_E_PARAMUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217839));
pub const DB_E_ALREADYINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217838));
pub const DB_E_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217837));
pub const DB_E_MAXPENDCHANGESEXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217836));
pub const DB_E_BADORDINAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217835));
pub const DB_E_PENDINGCHANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217834));
pub const DB_E_DATAOVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217833));
pub const DB_E_BADHRESULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217832));
pub const DB_E_BADLOOKUPID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217831));
pub const DB_E_BADDYNAMICERRORID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217830));
pub const DB_E_PENDINGINSERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217829));
pub const DB_E_BADCONVERTFLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217828));
pub const DB_E_BADPARAMETERNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217827));
pub const DB_E_MULTIPLESTORAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217826));
pub const DB_E_CANTFILTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217825));
pub const DB_E_CANTORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217824));
pub const MD_E_BADTUPLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217823));
pub const MD_E_BADCOORDINATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217822));
pub const MD_E_INVALIDAXIS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217821));
pub const MD_E_INVALIDCELLRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217820));
pub const DB_E_NOCOLUMN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217819));
pub const DB_E_COMMANDNOTPERSISTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217817));
pub const DB_E_DUPLICATEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217816));
pub const DB_E_OBJECTCREATIONLIMITREACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217815));
pub const DB_E_BADINDEXID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217806));
pub const DB_E_BADINITSTRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217805));
pub const DB_E_NOPROVIDERSREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217804));
pub const DB_E_MISMATCHEDPROVIDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217803));
pub const DB_E_BADCOMMANDID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217802));
pub const SEC_E_PERMISSIONDENIED = @as(i32, -2147217911);
pub const SEC_E_BADTRUSTEEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217814));
pub const SEC_E_NOTRUSTEEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217813));
pub const SEC_E_NOMEMBERSHIPSUPPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217812));
pub const SEC_E_INVALIDOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217811));
pub const SEC_E_NOOWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217810));
pub const SEC_E_INVALIDACCESSENTRYLIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217809));
pub const SEC_E_INVALIDOWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217808));
pub const SEC_E_INVALIDACCESSENTRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217807));
pub const DB_E_BADCONSTRAINTTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217801));
pub const DB_E_BADCONSTRAINTFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217800));
pub const DB_E_BADDEFERRABILITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217799));
pub const DB_E_BADMATCHTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217792));
pub const DB_E_BADUPDATEDELETERULE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217782));
pub const DB_E_BADCONSTRAINTID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217781));
pub const DB_E_BADCOMMANDFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217780));
pub const DB_E_OBJECTMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217779));
pub const DB_E_NOSOURCEOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217775));
pub const DB_E_RESOURCELOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217774));
pub const DB_E_NOTCOLLECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217773));
pub const DB_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217772));
pub const DB_E_ASYNCNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217771));
pub const DB_E_CANNOTCONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217770));
pub const DB_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217769));
pub const DB_E_RESOURCEEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217768));
pub const DB_E_RESOURCEOUTOFSCOPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217778));
pub const DB_E_DROPRESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217776));
pub const DB_E_DUPLICATECONSTRAINTID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217767));
pub const DB_E_OUTOFSPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217766));
pub const DB_SEC_E_SAFEMODE_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217765));
pub const DB_E_NOSTATISTIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217764));
pub const DB_E_ALTERRESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217763));
pub const DB_E_RESOURCENOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217762));
pub const DB_E_NOCONSTRAINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217761));
pub const DB_E_COLUMNUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217760));
pub const DB_S_ROWLIMITEXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265920));
pub const DB_S_COLUMNTYPEMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265921));
pub const DB_S_TYPEINFOOVERRIDDEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265922));
pub const DB_S_BOOKMARKSKIPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265923));
pub const DB_S_NONEXTROWSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265925));
pub const DB_S_ENDOFROWSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265926));
pub const DB_S_COMMANDREEXECUTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265927));
pub const DB_S_BUFFERFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265928));
pub const DB_S_NORESULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265929));
pub const DB_S_CANTRELEASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265930));
pub const DB_S_GOALCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265931));
pub const DB_S_UNWANTEDOPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265932));
pub const DB_S_DIALECTIGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265933));
pub const DB_S_UNWANTEDPHASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265934));
pub const DB_S_UNWANTEDREASON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265935));
pub const DB_S_ASYNCHRONOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265936));
pub const DB_S_COLUMNSCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265937));
pub const DB_S_ERRORSRETURNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265938));
pub const DB_S_BADROWHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265939));
pub const DB_S_DELETEDROW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265940));
pub const DB_S_TOOMANYCHANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265941));
pub const DB_S_STOPLIMITREACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265942));
pub const DB_S_LOCKUPGRADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265944));
pub const DB_S_PROPERTIESCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265945));
pub const DB_S_ERRORSOCCURRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265946));
pub const DB_S_PARAMUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265947));
pub const DB_S_MULTIPLECHANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265948));
pub const DB_S_NOTSINGLETON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265943));
pub const DB_S_NOROWSPECIFICCOLUMNS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265949));
pub const DBPROPFLAGS_PERSIST = @as(u32, 8192);
pub const DBPROPVAL_PERSIST_ADTG = @as(u32, 0);
pub const DBPROPVAL_PERSIST_XML = @as(u32, 1);
pub const DBPROP_PersistFormat = @as(u32, 2);
pub const DBPROP_PersistSchema = @as(u32, 3);
pub const DBPROP_HCHAPTER = @as(u32, 4);
pub const DBPROP_MAINTAINPROPS = @as(u32, 5);
pub const DBPROP_Unicode = @as(u32, 6);
pub const DBPROP_INTERLEAVEDROWS = @as(u32, 8);
pub const MS_PERSIST_PROGID = "MSPersist";
pub const DISPID_QUERY_RANKVECTOR = @as(u32, 2);
pub const DISPID_QUERY_RANK = @as(u32, 3);
pub const DISPID_QUERY_HITCOUNT = @as(u32, 4);
pub const DISPID_QUERY_WORKID = @as(u32, 5);
pub const DISPID_QUERY_ALL = @as(u32, 6);
pub const DISPID_QUERY_UNFILTERED = @as(u32, 7);
pub const DISPID_QUERY_REVNAME = @as(u32, 8);
pub const DISPID_QUERY_VIRTUALPATH = @as(u32, 9);
pub const DISPID_QUERY_LASTSEENTIME = @as(u32, 10);
pub const CQUERYDISPIDS = @as(u32, 11);
pub const DISPID_QUERY_METADATA_VROOTUSED = @as(u32, 2);
pub const DISPID_QUERY_METADATA_VROOTAUTOMATIC = @as(u32, 3);
pub const DISPID_QUERY_METADATA_VROOTMANUAL = @as(u32, 4);
pub const DISPID_QUERY_METADATA_PROPGUID = @as(u32, 5);
pub const DISPID_QUERY_METADATA_PROPDISPID = @as(u32, 6);
pub const DISPID_QUERY_METADATA_PROPNAME = @as(u32, 7);
pub const DISPID_QUERY_METADATA_STORELEVEL = @as(u32, 8);
pub const DISPID_QUERY_METADATA_PROPMODIFIABLE = @as(u32, 9);
pub const CQUERYMETADISPIDS = @as(u32, 10);
pub const PROPID_DBBMK_BOOKMARK = @as(u32, 2);
pub const PROPID_DBBMK_CHAPTER = @as(u32, 3);
pub const CDBBMKDISPIDS = @as(u32, 8);
pub const PROPID_DBSELF_SELF = @as(u32, 2);
pub const CDBSELFDISPIDS = @as(u32, 8);
pub const CDBCOLDISPIDS = @as(u32, 28);
pub const CQUERYPROPERTY = @as(u32, 64);
pub const QUERY_VALIDBITS = @as(u32, 3);
pub const RTNone = @as(u32, 0);
pub const RTAnd = @as(u32, 1);
pub const RTOr = @as(u32, 2);
pub const RTNot = @as(u32, 3);
pub const RTContent = @as(u32, 4);
pub const RTProperty = @as(u32, 5);
pub const RTProximity = @as(u32, 6);
pub const RTVector = @as(u32, 7);
pub const RTNatLanguage = @as(u32, 8);
pub const GENERATE_METHOD_PREFIXMATCH = @as(u32, 1);
pub const GENERATE_METHOD_STEMMED = @as(u32, 2);
pub const PRRE = @as(u32, 6);
pub const PRAllBits = @as(u32, 7);
pub const PRSomeBits = @as(u32, 8);
pub const PRAll = @as(u32, 256);
pub const PRAny = @as(u32, 512);
pub const QUERY_SORTXASCEND = @as(u32, 2);
pub const QUERY_SORTXDESCEND = @as(u32, 3);
pub const QUERY_SORTDEFAULT = @as(u32, 4);
pub const CATEGORIZE_UNIQUE = @as(u32, 0);
pub const CATEGORIZE_CLUSTER = @as(u32, 1);
pub const CATEGORIZE_BUCKETS = @as(u32, 2);
pub const BUCKET_LINEAR = @as(u32, 0);
pub const BUCKET_EXPONENTIAL = @as(u32, 1);
pub const CATEGORIZE_RANGE = @as(u32, 3);
pub const OCC_INVALID = @as(u32, 4294967295);
pub const MAX_QUERY_RANK = @as(u32, 1000);
pub const OSP_IndexLabel = @as(u32, 0);
pub const SQL_NULL_DATA = @as(i32, -1);
pub const SQL_DATA_AT_EXEC = @as(i32, -2);
pub const SQL_SUCCESS = @as(u32, 0);
pub const SQL_SUCCESS_WITH_INFO = @as(u32, 1);
pub const SQL_NO_DATA = @as(u32, 100);
pub const SQL_PARAM_DATA_AVAILABLE = @as(u32, 101);
pub const SQL_ERROR = @as(i32, -1);
pub const SQL_INVALID_HANDLE = @as(i32, -2);
pub const SQL_STILL_EXECUTING = @as(u32, 2);
pub const SQL_NEED_DATA = @as(u32, 99);
pub const SQL_NTS = @as(i32, -3);
pub const SQL_NTSL = @as(i32, -3);
pub const SQL_MAX_MESSAGE_LENGTH = @as(u32, 512);
pub const SQL_DATE_LEN = @as(u32, 10);
pub const SQL_TIME_LEN = @as(u32, 8);
pub const SQL_TIMESTAMP_LEN = @as(u32, 19);
pub const SQL_HANDLE_ENV = @as(u32, 1);
pub const SQL_HANDLE_DBC = @as(u32, 2);
pub const SQL_HANDLE_STMT = @as(u32, 3);
pub const SQL_HANDLE_DESC = @as(u32, 4);
pub const SQL_ATTR_OUTPUT_NTS = @as(u32, 10001);
pub const SQL_ATTR_AUTO_IPD = @as(u32, 10001);
pub const SQL_ATTR_METADATA_ID = @as(u32, 10014);
pub const SQL_ATTR_APP_ROW_DESC = @as(u32, 10010);
pub const SQL_ATTR_APP_PARAM_DESC = @as(u32, 10011);
pub const SQL_ATTR_IMP_ROW_DESC = @as(u32, 10012);
pub const SQL_ATTR_IMP_PARAM_DESC = @as(u32, 10013);
pub const SQL_ATTR_CURSOR_SCROLLABLE = @as(i32, -1);
pub const SQL_ATTR_CURSOR_SENSITIVITY = @as(i32, -2);
pub const SQL_NONSCROLLABLE = @as(u32, 0);
pub const SQL_SCROLLABLE = @as(u32, 1);
pub const SQL_DESC_COUNT = @as(u32, 1001);
pub const SQL_DESC_TYPE = @as(u32, 1002);
pub const SQL_DESC_LENGTH = @as(u32, 1003);
pub const SQL_DESC_OCTET_LENGTH_PTR = @as(u32, 1004);
pub const SQL_DESC_PRECISION = @as(u32, 1005);
pub const SQL_DESC_SCALE = @as(u32, 1006);
pub const SQL_DESC_DATETIME_INTERVAL_CODE = @as(u32, 1007);
pub const SQL_DESC_NULLABLE = @as(u32, 1008);
pub const SQL_DESC_INDICATOR_PTR = @as(u32, 1009);
pub const SQL_DESC_DATA_PTR = @as(u32, 1010);
pub const SQL_DESC_NAME = @as(u32, 1011);
pub const SQL_DESC_UNNAMED = @as(u32, 1012);
pub const SQL_DESC_OCTET_LENGTH = @as(u32, 1013);
pub const SQL_DESC_ALLOC_TYPE = @as(u32, 1099);
pub const SQL_DIAG_RETURNCODE = @as(u32, 1);
pub const SQL_DIAG_NUMBER = @as(u32, 2);
pub const SQL_DIAG_ROW_COUNT = @as(u32, 3);
pub const SQL_DIAG_SQLSTATE = @as(u32, 4);
pub const SQL_DIAG_NATIVE = @as(u32, 5);
pub const SQL_DIAG_MESSAGE_TEXT = @as(u32, 6);
pub const SQL_DIAG_DYNAMIC_FUNCTION = @as(u32, 7);
pub const SQL_DIAG_CLASS_ORIGIN = @as(u32, 8);
pub const SQL_DIAG_SUBCLASS_ORIGIN = @as(u32, 9);
pub const SQL_DIAG_CONNECTION_NAME = @as(u32, 10);
pub const SQL_DIAG_SERVER_NAME = @as(u32, 11);
pub const SQL_DIAG_DYNAMIC_FUNCTION_CODE = @as(u32, 12);
pub const SQL_DIAG_ALTER_DOMAIN = @as(u32, 3);
pub const SQL_DIAG_ALTER_TABLE = @as(u32, 4);
pub const SQL_DIAG_CALL = @as(u32, 7);
pub const SQL_DIAG_CREATE_ASSERTION = @as(u32, 6);
pub const SQL_DIAG_CREATE_CHARACTER_SET = @as(u32, 8);
pub const SQL_DIAG_CREATE_COLLATION = @as(u32, 10);
pub const SQL_DIAG_CREATE_DOMAIN = @as(u32, 23);
pub const SQL_DIAG_CREATE_INDEX = @as(i32, -1);
pub const SQL_DIAG_CREATE_SCHEMA = @as(u32, 64);
pub const SQL_DIAG_CREATE_TABLE = @as(u32, 77);
pub const SQL_DIAG_CREATE_TRANSLATION = @as(u32, 79);
pub const SQL_DIAG_CREATE_VIEW = @as(u32, 84);
pub const SQL_DIAG_DELETE_WHERE = @as(u32, 19);
pub const SQL_DIAG_DROP_ASSERTION = @as(u32, 24);
pub const SQL_DIAG_DROP_CHARACTER_SET = @as(u32, 25);
pub const SQL_DIAG_DROP_COLLATION = @as(u32, 26);
pub const SQL_DIAG_DROP_DOMAIN = @as(u32, 27);
pub const SQL_DIAG_DROP_INDEX = @as(i32, -2);
pub const SQL_DIAG_DROP_SCHEMA = @as(u32, 31);
pub const SQL_DIAG_DROP_TABLE = @as(u32, 32);
pub const SQL_DIAG_DROP_TRANSLATION = @as(u32, 33);
pub const SQL_DIAG_DROP_VIEW = @as(u32, 36);
pub const SQL_DIAG_DYNAMIC_DELETE_CURSOR = @as(u32, 38);
pub const SQL_DIAG_DYNAMIC_UPDATE_CURSOR = @as(u32, 81);
pub const SQL_DIAG_GRANT = @as(u32, 48);
pub const SQL_DIAG_INSERT = @as(u32, 50);
pub const SQL_DIAG_REVOKE = @as(u32, 59);
pub const SQL_DIAG_SELECT_CURSOR = @as(u32, 85);
pub const SQL_DIAG_UNKNOWN_STATEMENT = @as(u32, 0);
pub const SQL_DIAG_UPDATE_WHERE = @as(u32, 82);
pub const SQL_UNKNOWN_TYPE = @as(u32, 0);
pub const SQL_CHAR = @as(u32, 1);
pub const SQL_NUMERIC = @as(u32, 2);
pub const SQL_DECIMAL = @as(u32, 3);
pub const SQL_INTEGER = @as(u32, 4);
pub const SQL_SMALLINT = @as(u32, 5);
pub const SQL_FLOAT = @as(u32, 6);
pub const SQL_REAL = @as(u32, 7);
pub const SQL_DOUBLE = @as(u32, 8);
pub const SQL_DATETIME = @as(u32, 9);
pub const SQL_VARCHAR = @as(u32, 12);
pub const SQL_TYPE_DATE = @as(u32, 91);
pub const SQL_TYPE_TIME = @as(u32, 92);
pub const SQL_TYPE_TIMESTAMP = @as(u32, 93);
pub const SQL_UNSPECIFIED = @as(u32, 0);
pub const SQL_INSENSITIVE = @as(u32, 1);
pub const SQL_SENSITIVE = @as(u32, 2);
pub const SQL_ALL_TYPES = @as(u32, 0);
pub const SQL_DEFAULT = @as(u32, 99);
pub const SQL_ARD_TYPE = @as(i32, -99);
pub const SQL_APD_TYPE = @as(i32, -100);
pub const SQL_CODE_DATE = @as(u32, 1);
pub const SQL_CODE_TIME = @as(u32, 2);
pub const SQL_CODE_TIMESTAMP = @as(u32, 3);
pub const SQL_FALSE = @as(u32, 0);
pub const SQL_TRUE = @as(u32, 1);
pub const SQL_NO_NULLS = @as(u32, 0);
pub const SQL_NULLABLE = @as(u32, 1);
pub const SQL_NULLABLE_UNKNOWN = @as(u32, 2);
pub const SQL_PRED_NONE = @as(u32, 0);
pub const SQL_PRED_CHAR = @as(u32, 1);
pub const SQL_PRED_BASIC = @as(u32, 2);
pub const SQL_NAMED = @as(u32, 0);
pub const SQL_UNNAMED = @as(u32, 1);
pub const SQL_DESC_ALLOC_AUTO = @as(u32, 1);
pub const SQL_DESC_ALLOC_USER = @as(u32, 2);
pub const SQL_CLOSE = @as(u32, 0);
pub const SQL_DROP = @as(u32, 1);
pub const SQL_UNBIND = @as(u32, 2);
pub const SQL_RESET_PARAMS = @as(u32, 3);
pub const SQL_FETCH_NEXT = @as(u32, 1);
pub const SQL_FETCH_FIRST = @as(u32, 2);
pub const SQL_FETCH_LAST = @as(u32, 3);
pub const SQL_FETCH_PRIOR = @as(u32, 4);
pub const SQL_FETCH_ABSOLUTE = @as(u32, 5);
pub const SQL_FETCH_RELATIVE = @as(u32, 6);
pub const SQL_COMMIT = @as(u32, 0);
pub const SQL_ROLLBACK = @as(u32, 1);
pub const SQL_NULL_HENV = @as(u32, 0);
pub const SQL_NULL_HDBC = @as(u32, 0);
pub const SQL_NULL_HSTMT = @as(u32, 0);
pub const SQL_NULL_HDESC = @as(u32, 0);
pub const SQL_NULL_HANDLE = @as(i32, 0);
pub const SQL_SCOPE_CURROW = @as(u32, 0);
pub const SQL_SCOPE_TRANSACTION = @as(u32, 1);
pub const SQL_SCOPE_SESSION = @as(u32, 2);
pub const SQL_PC_UNKNOWN = @as(u32, 0);
pub const SQL_PC_NON_PSEUDO = @as(u32, 1);
pub const SQL_PC_PSEUDO = @as(u32, 2);
pub const SQL_ROW_IDENTIFIER = @as(u32, 1);
pub const SQL_INDEX_UNIQUE = @as(u32, 0);
pub const SQL_INDEX_ALL = @as(u32, 1);
pub const SQL_INDEX_CLUSTERED = @as(u32, 1);
pub const SQL_INDEX_HASHED = @as(u32, 2);
pub const SQL_INDEX_OTHER = @as(u32, 3);
pub const SQL_API_SQLALLOCCONNECT = @as(u32, 1);
pub const SQL_API_SQLALLOCENV = @as(u32, 2);
pub const SQL_API_SQLALLOCHANDLE = @as(u32, 1001);
pub const SQL_API_SQLALLOCSTMT = @as(u32, 3);
pub const SQL_API_SQLBINDCOL = @as(u32, 4);
pub const SQL_API_SQLBINDPARAM = @as(u32, 1002);
pub const SQL_API_SQLCANCEL = @as(u32, 5);
pub const SQL_API_SQLCLOSECURSOR = @as(u32, 1003);
pub const SQL_API_SQLCOLATTRIBUTE = @as(u32, 6);
pub const SQL_API_SQLCOLUMNS = @as(u32, 40);
pub const SQL_API_SQLCONNECT = @as(u32, 7);
pub const SQL_API_SQLCOPYDESC = @as(u32, 1004);
pub const SQL_API_SQLDATASOURCES = @as(u32, 57);
pub const SQL_API_SQLDESCRIBECOL = @as(u32, 8);
pub const SQL_API_SQLDISCONNECT = @as(u32, 9);
pub const SQL_API_SQLENDTRAN = @as(u32, 1005);
pub const SQL_API_SQLERROR = @as(u32, 10);
pub const SQL_API_SQLEXECDIRECT = @as(u32, 11);
pub const SQL_API_SQLEXECUTE = @as(u32, 12);
pub const SQL_API_SQLFETCH = @as(u32, 13);
pub const SQL_API_SQLFETCHSCROLL = @as(u32, 1021);
pub const SQL_API_SQLFREECONNECT = @as(u32, 14);
pub const SQL_API_SQLFREEENV = @as(u32, 15);
pub const SQL_API_SQLFREEHANDLE = @as(u32, 1006);
pub const SQL_API_SQLFREESTMT = @as(u32, 16);
pub const SQL_API_SQLGETCONNECTATTR = @as(u32, 1007);
pub const SQL_API_SQLGETCONNECTOPTION = @as(u32, 42);
pub const SQL_API_SQLGETCURSORNAME = @as(u32, 17);
pub const SQL_API_SQLGETDATA = @as(u32, 43);
pub const SQL_API_SQLGETDESCFIELD = @as(u32, 1008);
pub const SQL_API_SQLGETDESCREC = @as(u32, 1009);
pub const SQL_API_SQLGETDIAGFIELD = @as(u32, 1010);
pub const SQL_API_SQLGETDIAGREC = @as(u32, 1011);
pub const SQL_API_SQLGETENVATTR = @as(u32, 1012);
pub const SQL_API_SQLGETFUNCTIONS = @as(u32, 44);
pub const SQL_API_SQLGETINFO = @as(u32, 45);
pub const SQL_API_SQLGETSTMTATTR = @as(u32, 1014);
pub const SQL_API_SQLGETSTMTOPTION = @as(u32, 46);
pub const SQL_API_SQLGETTYPEINFO = @as(u32, 47);
pub const SQL_API_SQLNUMRESULTCOLS = @as(u32, 18);
pub const SQL_API_SQLPARAMDATA = @as(u32, 48);
pub const SQL_API_SQLPREPARE = @as(u32, 19);
pub const SQL_API_SQLPUTDATA = @as(u32, 49);
pub const SQL_API_SQLROWCOUNT = @as(u32, 20);
pub const SQL_API_SQLSETCONNECTATTR = @as(u32, 1016);
pub const SQL_API_SQLSETCONNECTOPTION = @as(u32, 50);
pub const SQL_API_SQLSETCURSORNAME = @as(u32, 21);
pub const SQL_API_SQLSETDESCFIELD = @as(u32, 1017);
pub const SQL_API_SQLSETDESCREC = @as(u32, 1018);
pub const SQL_API_SQLSETENVATTR = @as(u32, 1019);
pub const SQL_API_SQLSETPARAM = @as(u32, 22);
pub const SQL_API_SQLSETSTMTATTR = @as(u32, 1020);
pub const SQL_API_SQLSETSTMTOPTION = @as(u32, 51);
pub const SQL_API_SQLSPECIALCOLUMNS = @as(u32, 52);
pub const SQL_API_SQLSTATISTICS = @as(u32, 53);
pub const SQL_API_SQLTABLES = @as(u32, 54);
pub const SQL_API_SQLTRANSACT = @as(u32, 23);
pub const SQL_API_SQLCANCELHANDLE = @as(u32, 1550);
pub const SQL_API_SQLCOMPLETEASYNC = @as(u32, 1551);
pub const SQL_MAX_DRIVER_CONNECTIONS = @as(u32, 0);
pub const SQL_MAXIMUM_DRIVER_CONNECTIONS = @as(u32, 0);
pub const SQL_MAX_CONCURRENT_ACTIVITIES = @as(u32, 1);
pub const SQL_MAXIMUM_CONCURRENT_ACTIVITIES = @as(u32, 1);
pub const SQL_DATA_SOURCE_NAME = @as(u32, 2);
pub const SQL_FETCH_DIRECTION = @as(u32, 8);
pub const SQL_SERVER_NAME = @as(u32, 13);
pub const SQL_SEARCH_PATTERN_ESCAPE = @as(u32, 14);
pub const SQL_DBMS_NAME = @as(u32, 17);
pub const SQL_DBMS_VER = @as(u32, 18);
pub const SQL_ACCESSIBLE_TABLES = @as(u32, 19);
pub const SQL_ACCESSIBLE_PROCEDURES = @as(u32, 20);
pub const SQL_CURSOR_COMMIT_BEHAVIOR = @as(u32, 23);
pub const SQL_DATA_SOURCE_READ_ONLY = @as(u32, 25);
pub const SQL_DEFAULT_TXN_ISOLATION = @as(u32, 26);
pub const SQL_IDENTIFIER_CASE = @as(u32, 28);
pub const SQL_IDENTIFIER_QUOTE_CHAR = @as(u32, 29);
pub const SQL_MAX_COLUMN_NAME_LEN = @as(u32, 30);
pub const SQL_MAXIMUM_COLUMN_NAME_LENGTH = @as(u32, 30);
pub const SQL_MAX_CURSOR_NAME_LEN = @as(u32, 31);
pub const SQL_MAXIMUM_CURSOR_NAME_LENGTH = @as(u32, 31);
pub const SQL_MAX_SCHEMA_NAME_LEN = @as(u32, 32);
pub const SQL_MAXIMUM_SCHEMA_NAME_LENGTH = @as(u32, 32);
pub const SQL_MAX_CATALOG_NAME_LEN = @as(u32, 34);
pub const SQL_MAXIMUM_CATALOG_NAME_LENGTH = @as(u32, 34);
pub const SQL_MAX_TABLE_NAME_LEN = @as(u32, 35);
pub const SQL_SCROLL_CONCURRENCY = @as(u32, 43);
pub const SQL_TXN_CAPABLE = @as(u32, 46);
pub const SQL_TRANSACTION_CAPABLE = @as(u32, 46);
pub const SQL_USER_NAME = @as(u32, 47);
pub const SQL_TXN_ISOLATION_OPTION = @as(u32, 72);
pub const SQL_TRANSACTION_ISOLATION_OPTION = @as(u32, 72);
pub const SQL_INTEGRITY = @as(u32, 73);
pub const SQL_GETDATA_EXTENSIONS = @as(u32, 81);
pub const SQL_NULL_COLLATION = @as(u32, 85);
pub const SQL_ALTER_TABLE = @as(u32, 86);
pub const SQL_ORDER_BY_COLUMNS_IN_SELECT = @as(u32, 90);
pub const SQL_SPECIAL_CHARACTERS = @as(u32, 94);
pub const SQL_MAX_COLUMNS_IN_GROUP_BY = @as(u32, 97);
pub const SQL_MAXIMUM_COLUMNS_IN_GROUP_BY = @as(u32, 97);
pub const SQL_MAX_COLUMNS_IN_INDEX = @as(u32, 98);
pub const SQL_MAXIMUM_COLUMNS_IN_INDEX = @as(u32, 98);
pub const SQL_MAX_COLUMNS_IN_ORDER_BY = @as(u32, 99);
pub const SQL_MAXIMUM_COLUMNS_IN_ORDER_BY = @as(u32, 99);
pub const SQL_MAX_COLUMNS_IN_SELECT = @as(u32, 100);
pub const SQL_MAXIMUM_COLUMNS_IN_SELECT = @as(u32, 100);
pub const SQL_MAX_COLUMNS_IN_TABLE = @as(u32, 101);
pub const SQL_MAX_INDEX_SIZE = @as(u32, 102);
pub const SQL_MAXIMUM_INDEX_SIZE = @as(u32, 102);
pub const SQL_MAX_ROW_SIZE = @as(u32, 104);
pub const SQL_MAXIMUM_ROW_SIZE = @as(u32, 104);
pub const SQL_MAX_STATEMENT_LEN = @as(u32, 105);
pub const SQL_MAXIMUM_STATEMENT_LENGTH = @as(u32, 105);
pub const SQL_MAX_TABLES_IN_SELECT = @as(u32, 106);
pub const SQL_MAXIMUM_TABLES_IN_SELECT = @as(u32, 106);
pub const SQL_MAX_USER_NAME_LEN = @as(u32, 107);
pub const SQL_MAXIMUM_USER_NAME_LENGTH = @as(u32, 107);
pub const SQL_OJ_CAPABILITIES = @as(u32, 115);
pub const SQL_OUTER_JOIN_CAPABILITIES = @as(u32, 115);
pub const SQL_XOPEN_CLI_YEAR = @as(u32, 10000);
pub const SQL_CURSOR_SENSITIVITY = @as(u32, 10001);
pub const SQL_DESCRIBE_PARAMETER = @as(u32, 10002);
pub const SQL_CATALOG_NAME = @as(u32, 10003);
pub const SQL_COLLATION_SEQ = @as(u32, 10004);
pub const SQL_MAX_IDENTIFIER_LEN = @as(u32, 10005);
pub const SQL_MAXIMUM_IDENTIFIER_LENGTH = @as(u32, 10005);
pub const SQL_AT_ADD_COLUMN = @as(i32, 1);
pub const SQL_AT_DROP_COLUMN = @as(i32, 2);
pub const SQL_AT_ADD_CONSTRAINT = @as(i32, 8);
pub const SQL_AM_NONE = @as(u32, 0);
pub const SQL_AM_CONNECTION = @as(u32, 1);
pub const SQL_AM_STATEMENT = @as(u32, 2);
pub const SQL_CB_DELETE = @as(u32, 0);
pub const SQL_CB_CLOSE = @as(u32, 1);
pub const SQL_CB_PRESERVE = @as(u32, 2);
pub const SQL_FD_FETCH_NEXT = @as(i32, 1);
pub const SQL_FD_FETCH_FIRST = @as(i32, 2);
pub const SQL_FD_FETCH_LAST = @as(i32, 4);
pub const SQL_FD_FETCH_PRIOR = @as(i32, 8);
pub const SQL_FD_FETCH_ABSOLUTE = @as(i32, 16);
pub const SQL_FD_FETCH_RELATIVE = @as(i32, 32);
pub const SQL_GD_ANY_COLUMN = @as(i32, 1);
pub const SQL_GD_ANY_ORDER = @as(i32, 2);
pub const SQL_IC_UPPER = @as(u32, 1);
pub const SQL_IC_LOWER = @as(u32, 2);
pub const SQL_IC_SENSITIVE = @as(u32, 3);
pub const SQL_IC_MIXED = @as(u32, 4);
pub const SQL_OJ_LEFT = @as(i32, 1);
pub const SQL_OJ_RIGHT = @as(i32, 2);
pub const SQL_OJ_FULL = @as(i32, 4);
pub const SQL_OJ_NESTED = @as(i32, 8);
pub const SQL_OJ_NOT_ORDERED = @as(i32, 16);
pub const SQL_OJ_INNER = @as(i32, 32);
pub const SQL_OJ_ALL_COMPARISON_OPS = @as(i32, 64);
pub const SQL_SCCO_READ_ONLY = @as(i32, 1);
pub const SQL_SCCO_LOCK = @as(i32, 2);
pub const SQL_SCCO_OPT_ROWVER = @as(i32, 4);
pub const SQL_SCCO_OPT_VALUES = @as(i32, 8);
pub const SQL_TC_NONE = @as(u32, 0);
pub const SQL_TC_DML = @as(u32, 1);
pub const SQL_TC_ALL = @as(u32, 2);
pub const SQL_TC_DDL_COMMIT = @as(u32, 3);
pub const SQL_TC_DDL_IGNORE = @as(u32, 4);
pub const SQL_TXN_READ_UNCOMMITTED = @as(i32, 1);
pub const SQL_TRANSACTION_READ_UNCOMMITTED = @as(i32, 1);
pub const SQL_TXN_READ_COMMITTED = @as(i32, 2);
pub const SQL_TRANSACTION_READ_COMMITTED = @as(i32, 2);
pub const SQL_TXN_REPEATABLE_READ = @as(i32, 4);
pub const SQL_TRANSACTION_REPEATABLE_READ = @as(i32, 4);
pub const SQL_TXN_SERIALIZABLE = @as(i32, 8);
pub const SQL_TRANSACTION_SERIALIZABLE = @as(i32, 8);
pub const SQL_NC_HIGH = @as(u32, 0);
pub const SQL_NC_LOW = @as(u32, 1);
pub const SQL_SPEC_MAJOR = @as(u32, 3);
pub const SQL_SPEC_MINOR = @as(u32, 80);
pub const SQL_SPEC_STRING = "03.80";
pub const SQL_SQLSTATE_SIZE = @as(u32, 5);
pub const SQL_MAX_DSN_LENGTH = @as(u32, 32);
pub const SQL_MAX_OPTION_STRING_LENGTH = @as(u32, 256);
pub const SQL_NO_DATA_FOUND = @as(u32, 100);
pub const SQL_HANDLE_SENV = @as(u32, 5);
pub const SQL_ATTR_ODBC_VERSION = @as(u32, 200);
pub const SQL_ATTR_CONNECTION_POOLING = @as(u32, 201);
pub const SQL_ATTR_CP_MATCH = @as(u32, 202);
pub const SQL_ATTR_APPLICATION_KEY = @as(u32, 203);
pub const SQL_CP_OFF = @as(u32, 0);
pub const SQL_CP_ONE_PER_DRIVER = @as(u32, 1);
pub const SQL_CP_ONE_PER_HENV = @as(u32, 2);
pub const SQL_CP_DRIVER_AWARE = @as(u32, 3);
pub const SQL_CP_DEFAULT = @as(u32, 0);
pub const SQL_CP_STRICT_MATCH = @as(u32, 0);
pub const SQL_CP_RELAXED_MATCH = @as(u32, 1);
pub const SQL_CP_MATCH_DEFAULT = @as(u32, 0);
pub const SQL_OV_ODBC2 = @as(u32, 2);
pub const SQL_OV_ODBC3 = @as(u32, 3);
pub const SQL_OV_ODBC3_80 = @as(u32, 380);
pub const SQL_ACCESS_MODE = @as(u32, 101);
pub const SQL_AUTOCOMMIT = @as(u32, 102);
pub const SQL_LOGIN_TIMEOUT = @as(u32, 103);
pub const SQL_OPT_TRACE = @as(u32, 104);
pub const SQL_OPT_TRACEFILE = @as(u32, 105);
pub const SQL_TRANSLATE_DLL = @as(u32, 106);
pub const SQL_TRANSLATE_OPTION = @as(u32, 107);
pub const SQL_TXN_ISOLATION = @as(u32, 108);
pub const SQL_CURRENT_QUALIFIER = @as(u32, 109);
pub const SQL_ODBC_CURSORS = @as(u32, 110);
pub const SQL_QUIET_MODE = @as(u32, 111);
pub const SQL_PACKET_SIZE = @as(u32, 112);
pub const SQL_ATTR_ACCESS_MODE = @as(u32, 101);
pub const SQL_ATTR_AUTOCOMMIT = @as(u32, 102);
pub const SQL_ATTR_CONNECTION_TIMEOUT = @as(u32, 113);
pub const SQL_ATTR_CURRENT_CATALOG = @as(u32, 109);
pub const SQL_ATTR_DISCONNECT_BEHAVIOR = @as(u32, 114);
pub const SQL_ATTR_ENLIST_IN_DTC = @as(u32, 1207);
pub const SQL_ATTR_ENLIST_IN_XA = @as(u32, 1208);
pub const SQL_ATTR_LOGIN_TIMEOUT = @as(u32, 103);
pub const SQL_ATTR_ODBC_CURSORS = @as(u32, 110);
pub const SQL_ATTR_PACKET_SIZE = @as(u32, 112);
pub const SQL_ATTR_QUIET_MODE = @as(u32, 111);
pub const SQL_ATTR_TRACE = @as(u32, 104);
pub const SQL_ATTR_TRACEFILE = @as(u32, 105);
pub const SQL_ATTR_TRANSLATE_LIB = @as(u32, 106);
pub const SQL_ATTR_TRANSLATE_OPTION = @as(u32, 107);
pub const SQL_ATTR_TXN_ISOLATION = @as(u32, 108);
pub const SQL_ATTR_CONNECTION_DEAD = @as(u32, 1209);
pub const SQL_ATTR_ANSI_APP = @as(u32, 115);
pub const SQL_ATTR_RESET_CONNECTION = @as(u32, 116);
pub const SQL_ATTR_ASYNC_DBC_FUNCTIONS_ENABLE = @as(u32, 117);
pub const SQL_ATTR_ASYNC_DBC_EVENT = @as(u32, 119);
pub const SQL_CONNECT_OPT_DRVR_START = @as(u32, 1000);
pub const SQL_CONN_OPT_MAX = @as(u32, 112);
pub const SQL_CONN_OPT_MIN = @as(u32, 101);
pub const SQL_MODE_READ_WRITE = @as(u32, 0);
pub const SQL_MODE_READ_ONLY = @as(u32, 1);
pub const SQL_MODE_DEFAULT = @as(u32, 0);
pub const SQL_AUTOCOMMIT_OFF = @as(u32, 0);
pub const SQL_AUTOCOMMIT_ON = @as(u32, 1);
pub const SQL_AUTOCOMMIT_DEFAULT = @as(u32, 1);
pub const SQL_LOGIN_TIMEOUT_DEFAULT = @as(u32, 15);
pub const SQL_OPT_TRACE_OFF = @as(u32, 0);
pub const SQL_OPT_TRACE_ON = @as(u32, 1);
pub const SQL_OPT_TRACE_DEFAULT = @as(u32, 0);
pub const SQL_OPT_TRACE_FILE_DEFAULT = "\\SQL.LOG";
pub const SQL_CUR_USE_IF_NEEDED = @as(u32, 0);
pub const SQL_CUR_USE_ODBC = @as(u32, 1);
pub const SQL_CUR_USE_DRIVER = @as(u32, 2);
pub const SQL_CUR_DEFAULT = @as(u32, 2);
pub const SQL_DB_RETURN_TO_POOL = @as(u32, 0);
pub const SQL_DB_DISCONNECT = @as(u32, 1);
pub const SQL_DB_DEFAULT = @as(u32, 0);
pub const SQL_DTC_DONE = @as(i32, 0);
pub const SQL_CD_TRUE = @as(i32, 1);
pub const SQL_CD_FALSE = @as(i32, 0);
pub const SQL_AA_TRUE = @as(i32, 1);
pub const SQL_AA_FALSE = @as(i32, 0);
pub const SQL_RESET_CONNECTION_YES = @as(u32, 1);
pub const SQL_ASYNC_DBC_ENABLE_ON = @as(u32, 1);
pub const SQL_ASYNC_DBC_ENABLE_OFF = @as(u32, 0);
pub const SQL_ASYNC_DBC_ENABLE_DEFAULT = @as(u32, 0);
pub const SQL_QUERY_TIMEOUT = @as(u32, 0);
pub const SQL_MAX_ROWS = @as(u32, 1);
pub const SQL_NOSCAN = @as(u32, 2);
pub const SQL_MAX_LENGTH = @as(u32, 3);
pub const SQL_ASYNC_ENABLE = @as(u32, 4);
pub const SQL_BIND_TYPE = @as(u32, 5);
pub const SQL_CURSOR_TYPE = @as(u32, 6);
pub const SQL_CONCURRENCY = @as(u32, 7);
pub const SQL_KEYSET_SIZE = @as(u32, 8);
pub const SQL_ROWSET_SIZE = @as(u32, 9);
pub const SQL_SIMULATE_CURSOR = @as(u32, 10);
pub const SQL_RETRIEVE_DATA = @as(u32, 11);
pub const SQL_USE_BOOKMARKS = @as(u32, 12);
pub const SQL_GET_BOOKMARK = @as(u32, 13);
pub const SQL_ROW_NUMBER = @as(u32, 14);
pub const SQL_ATTR_ASYNC_ENABLE = @as(u32, 4);
pub const SQL_ATTR_CONCURRENCY = @as(u32, 7);
pub const SQL_ATTR_CURSOR_TYPE = @as(u32, 6);
pub const SQL_ATTR_ENABLE_AUTO_IPD = @as(u32, 15);
pub const SQL_ATTR_FETCH_BOOKMARK_PTR = @as(u32, 16);
pub const SQL_ATTR_KEYSET_SIZE = @as(u32, 8);
pub const SQL_ATTR_MAX_LENGTH = @as(u32, 3);
pub const SQL_ATTR_MAX_ROWS = @as(u32, 1);
pub const SQL_ATTR_NOSCAN = @as(u32, 2);
pub const SQL_ATTR_PARAM_BIND_OFFSET_PTR = @as(u32, 17);
pub const SQL_ATTR_PARAM_BIND_TYPE = @as(u32, 18);
pub const SQL_ATTR_PARAM_OPERATION_PTR = @as(u32, 19);
pub const SQL_ATTR_PARAM_STATUS_PTR = @as(u32, 20);
pub const SQL_ATTR_PARAMS_PROCESSED_PTR = @as(u32, 21);
pub const SQL_ATTR_PARAMSET_SIZE = @as(u32, 22);
pub const SQL_ATTR_QUERY_TIMEOUT = @as(u32, 0);
pub const SQL_ATTR_RETRIEVE_DATA = @as(u32, 11);
pub const SQL_ATTR_ROW_BIND_OFFSET_PTR = @as(u32, 23);
pub const SQL_ATTR_ROW_BIND_TYPE = @as(u32, 5);
pub const SQL_ATTR_ROW_NUMBER = @as(u32, 14);
pub const SQL_ATTR_ROW_OPERATION_PTR = @as(u32, 24);
pub const SQL_ATTR_ROW_STATUS_PTR = @as(u32, 25);
pub const SQL_ATTR_ROWS_FETCHED_PTR = @as(u32, 26);
pub const SQL_ATTR_ROW_ARRAY_SIZE = @as(u32, 27);
pub const SQL_ATTR_SIMULATE_CURSOR = @as(u32, 10);
pub const SQL_ATTR_USE_BOOKMARKS = @as(u32, 12);
pub const SQL_ATTR_ASYNC_STMT_EVENT = @as(u32, 29);
pub const SQL_STMT_OPT_MAX = @as(u32, 14);
pub const SQL_STMT_OPT_MIN = @as(u32, 0);
pub const SQL_IS_POINTER = @as(i32, -4);
pub const SQL_IS_UINTEGER = @as(i32, -5);
pub const SQL_IS_INTEGER = @as(i32, -6);
pub const SQL_IS_USMALLINT = @as(i32, -7);
pub const SQL_IS_SMALLINT = @as(i32, -8);
pub const SQL_PARAM_BIND_BY_COLUMN = @as(u32, 0);
pub const SQL_PARAM_BIND_TYPE_DEFAULT = @as(u32, 0);
pub const SQL_QUERY_TIMEOUT_DEFAULT = @as(u32, 0);
pub const SQL_MAX_ROWS_DEFAULT = @as(u32, 0);
pub const SQL_NOSCAN_OFF = @as(u32, 0);
pub const SQL_NOSCAN_ON = @as(u32, 1);
pub const SQL_NOSCAN_DEFAULT = @as(u32, 0);
pub const SQL_MAX_LENGTH_DEFAULT = @as(u32, 0);
pub const SQL_ASYNC_ENABLE_OFF = @as(u32, 0);
pub const SQL_ASYNC_ENABLE_ON = @as(u32, 1);
pub const SQL_ASYNC_ENABLE_DEFAULT = @as(u32, 0);
pub const SQL_BIND_BY_COLUMN = @as(u32, 0);
pub const SQL_BIND_TYPE_DEFAULT = @as(u32, 0);
pub const SQL_CONCUR_READ_ONLY = @as(u32, 1);
pub const SQL_CONCUR_LOCK = @as(u32, 2);
pub const SQL_CONCUR_ROWVER = @as(u32, 3);
pub const SQL_CONCUR_VALUES = @as(u32, 4);
pub const SQL_CONCUR_DEFAULT = @as(u32, 1);
pub const SQL_CURSOR_FORWARD_ONLY = @as(u32, 0);
pub const SQL_CURSOR_KEYSET_DRIVEN = @as(u32, 1);
pub const SQL_CURSOR_DYNAMIC = @as(u32, 2);
pub const SQL_CURSOR_STATIC = @as(u32, 3);
pub const SQL_CURSOR_TYPE_DEFAULT = @as(u32, 0);
pub const SQL_ROWSET_SIZE_DEFAULT = @as(u32, 1);
pub const SQL_KEYSET_SIZE_DEFAULT = @as(u32, 0);
pub const SQL_SC_NON_UNIQUE = @as(u32, 0);
pub const SQL_SC_TRY_UNIQUE = @as(u32, 1);
pub const SQL_SC_UNIQUE = @as(u32, 2);
pub const SQL_RD_OFF = @as(u32, 0);
pub const SQL_RD_ON = @as(u32, 1);
pub const SQL_RD_DEFAULT = @as(u32, 1);
pub const SQL_UB_OFF = @as(u32, 0);
pub const SQL_UB_ON = @as(u32, 1);
pub const SQL_UB_DEFAULT = @as(u32, 0);
pub const SQL_UB_FIXED = @as(u32, 1);
pub const SQL_UB_VARIABLE = @as(u32, 2);
pub const SQL_DESC_ARRAY_SIZE = @as(u32, 20);
pub const SQL_DESC_ARRAY_STATUS_PTR = @as(u32, 21);
pub const SQL_DESC_BASE_COLUMN_NAME = @as(u32, 22);
pub const SQL_DESC_BASE_TABLE_NAME = @as(u32, 23);
pub const SQL_DESC_BIND_OFFSET_PTR = @as(u32, 24);
pub const SQL_DESC_BIND_TYPE = @as(u32, 25);
pub const SQL_DESC_DATETIME_INTERVAL_PRECISION = @as(u32, 26);
pub const SQL_DESC_LITERAL_PREFIX = @as(u32, 27);
pub const SQL_DESC_LITERAL_SUFFIX = @as(u32, 28);
pub const SQL_DESC_LOCAL_TYPE_NAME = @as(u32, 29);
pub const SQL_DESC_MAXIMUM_SCALE = @as(u32, 30);
pub const SQL_DESC_MINIMUM_SCALE = @as(u32, 31);
pub const SQL_DESC_NUM_PREC_RADIX = @as(u32, 32);
pub const SQL_DESC_PARAMETER_TYPE = @as(u32, 33);
pub const SQL_DESC_ROWS_PROCESSED_PTR = @as(u32, 34);
pub const SQL_DESC_ROWVER = @as(u32, 35);
pub const SQL_DIAG_CURSOR_ROW_COUNT = @as(i32, -1249);
pub const SQL_DIAG_ROW_NUMBER = @as(i32, -1248);
pub const SQL_DIAG_COLUMN_NUMBER = @as(i32, -1247);
pub const SQL_DATE = @as(u32, 9);
pub const SQL_INTERVAL = @as(u32, 10);
pub const SQL_TIME = @as(u32, 10);
pub const SQL_TIMESTAMP = @as(u32, 11);
pub const SQL_LONGVARCHAR = @as(i32, -1);
pub const SQL_BINARY = @as(i32, -2);
pub const SQL_VARBINARY = @as(i32, -3);
pub const SQL_LONGVARBINARY = @as(i32, -4);
pub const SQL_BIGINT = @as(i32, -5);
pub const SQL_TINYINT = @as(i32, -6);
pub const SQL_BIT = @as(i32, -7);
pub const SQL_GUID = @as(i32, -11);
pub const SQL_CODE_YEAR = @as(u32, 1);
pub const SQL_CODE_MONTH = @as(u32, 2);
pub const SQL_CODE_DAY = @as(u32, 3);
pub const SQL_CODE_HOUR = @as(u32, 4);
pub const SQL_CODE_MINUTE = @as(u32, 5);
pub const SQL_CODE_SECOND = @as(u32, 6);
pub const SQL_CODE_YEAR_TO_MONTH = @as(u32, 7);
pub const SQL_CODE_DAY_TO_HOUR = @as(u32, 8);
pub const SQL_CODE_DAY_TO_MINUTE = @as(u32, 9);
pub const SQL_CODE_DAY_TO_SECOND = @as(u32, 10);
pub const SQL_CODE_HOUR_TO_MINUTE = @as(u32, 11);
pub const SQL_CODE_HOUR_TO_SECOND = @as(u32, 12);
pub const SQL_CODE_MINUTE_TO_SECOND = @as(u32, 13);
pub const SQL_INTERVAL_YEAR = @as(i32, -80);
pub const SQL_INTERVAL_MONTH = @as(i32, -81);
pub const SQL_INTERVAL_YEAR_TO_MONTH = @as(i32, -82);
pub const SQL_INTERVAL_DAY = @as(i32, -83);
pub const SQL_INTERVAL_HOUR = @as(i32, -84);
pub const SQL_INTERVAL_MINUTE = @as(i32, -85);
pub const SQL_INTERVAL_SECOND = @as(i32, -86);
pub const SQL_INTERVAL_DAY_TO_HOUR = @as(i32, -87);
pub const SQL_INTERVAL_DAY_TO_MINUTE = @as(i32, -88);
pub const SQL_INTERVAL_DAY_TO_SECOND = @as(i32, -89);
pub const SQL_INTERVAL_HOUR_TO_MINUTE = @as(i32, -90);
pub const SQL_INTERVAL_HOUR_TO_SECOND = @as(i32, -91);
pub const SQL_INTERVAL_MINUTE_TO_SECOND = @as(i32, -92);
pub const SQL_UNICODE = @as(i32, -95);
pub const SQL_UNICODE_VARCHAR = @as(i32, -96);
pub const SQL_UNICODE_LONGVARCHAR = @as(i32, -97);
pub const SQL_UNICODE_CHAR = @as(i32, -95);
pub const SQL_TYPE_DRIVER_START = @as(i32, -80);
pub const SQL_TYPE_DRIVER_END = @as(i32, -97);
pub const SQL_C_CHAR = @as(u32, 1);
pub const SQL_C_LONG = @as(u32, 4);
pub const SQL_C_SHORT = @as(u32, 5);
pub const SQL_C_FLOAT = @as(u32, 7);
pub const SQL_C_DOUBLE = @as(u32, 8);
pub const SQL_C_NUMERIC = @as(u32, 2);
pub const SQL_C_DEFAULT = @as(u32, 99);
pub const SQL_SIGNED_OFFSET = @as(i32, -20);
pub const SQL_UNSIGNED_OFFSET = @as(i32, -22);
pub const SQL_C_DATE = @as(u32, 9);
pub const SQL_C_TIME = @as(u32, 10);
pub const SQL_C_TIMESTAMP = @as(u32, 11);
pub const SQL_C_TYPE_DATE = @as(u32, 91);
pub const SQL_C_TYPE_TIME = @as(u32, 92);
pub const SQL_C_TYPE_TIMESTAMP = @as(u32, 93);
pub const SQL_C_INTERVAL_YEAR = @as(i32, -80);
pub const SQL_C_INTERVAL_MONTH = @as(i32, -81);
pub const SQL_C_INTERVAL_DAY = @as(i32, -83);
pub const SQL_C_INTERVAL_HOUR = @as(i32, -84);
pub const SQL_C_INTERVAL_MINUTE = @as(i32, -85);
pub const SQL_C_INTERVAL_SECOND = @as(i32, -86);
pub const SQL_C_INTERVAL_YEAR_TO_MONTH = @as(i32, -82);
pub const SQL_C_INTERVAL_DAY_TO_HOUR = @as(i32, -87);
pub const SQL_C_INTERVAL_DAY_TO_MINUTE = @as(i32, -88);
pub const SQL_C_INTERVAL_DAY_TO_SECOND = @as(i32, -89);
pub const SQL_C_INTERVAL_HOUR_TO_MINUTE = @as(i32, -90);
pub const SQL_C_INTERVAL_HOUR_TO_SECOND = @as(i32, -91);
pub const SQL_C_INTERVAL_MINUTE_TO_SECOND = @as(i32, -92);
pub const SQL_C_BINARY = @as(i32, -2);
pub const SQL_C_BIT = @as(i32, -7);
pub const SQL_C_TINYINT = @as(i32, -6);
pub const SQL_C_GUID = @as(i32, -11);
pub const SQL_TYPE_NULL = @as(u32, 0);
pub const SQL_TYPE_MIN = @as(i32, -7);
pub const SQL_TYPE_MAX = @as(u32, 12);
pub const SQL_DRIVER_C_TYPE_BASE = @as(u32, 16384);
pub const SQL_DRIVER_SQL_TYPE_BASE = @as(u32, 16384);
pub const SQL_DRIVER_DESC_FIELD_BASE = @as(u32, 16384);
pub const SQL_DRIVER_DIAG_FIELD_BASE = @as(u32, 16384);
pub const SQL_DRIVER_INFO_TYPE_BASE = @as(u32, 16384);
pub const SQL_DRIVER_CONN_ATTR_BASE = @as(u32, 16384);
pub const SQL_DRIVER_STMT_ATTR_BASE = @as(u32, 16384);
pub const SQL_C_VARBOOKMARK = @as(i32, -2);
pub const SQL_NO_ROW_NUMBER = @as(i32, -1);
pub const SQL_NO_COLUMN_NUMBER = @as(i32, -1);
pub const SQL_ROW_NUMBER_UNKNOWN = @as(i32, -2);
pub const SQL_COLUMN_NUMBER_UNKNOWN = @as(i32, -2);
pub const SQL_DEFAULT_PARAM = @as(i32, -5);
pub const SQL_IGNORE = @as(i32, -6);
pub const SQL_COLUMN_IGNORE = @as(i32, -6);
pub const SQL_LEN_DATA_AT_EXEC_OFFSET = @as(i32, -100);
pub const SQL_LEN_BINARY_ATTR_OFFSET = @as(i32, -100);
pub const SQL_SETPARAM_VALUE_MAX = @as(i32, -1);
pub const SQL_COLUMN_COUNT = @as(u32, 0);
pub const SQL_COLUMN_NAME = @as(u32, 1);
pub const SQL_COLUMN_TYPE = @as(u32, 2);
pub const SQL_COLUMN_LENGTH = @as(u32, 3);
pub const SQL_COLUMN_PRECISION = @as(u32, 4);
pub const SQL_COLUMN_SCALE = @as(u32, 5);
pub const SQL_COLUMN_DISPLAY_SIZE = @as(u32, 6);
pub const SQL_COLUMN_NULLABLE = @as(u32, 7);
pub const SQL_COLUMN_UNSIGNED = @as(u32, 8);
pub const SQL_COLUMN_MONEY = @as(u32, 9);
pub const SQL_COLUMN_UPDATABLE = @as(u32, 10);
pub const SQL_COLUMN_AUTO_INCREMENT = @as(u32, 11);
pub const SQL_COLUMN_CASE_SENSITIVE = @as(u32, 12);
pub const SQL_COLUMN_SEARCHABLE = @as(u32, 13);
pub const SQL_COLUMN_TYPE_NAME = @as(u32, 14);
pub const SQL_COLUMN_TABLE_NAME = @as(u32, 15);
pub const SQL_COLUMN_OWNER_NAME = @as(u32, 16);
pub const SQL_COLUMN_QUALIFIER_NAME = @as(u32, 17);
pub const SQL_COLUMN_LABEL = @as(u32, 18);
pub const SQL_COLATT_OPT_MAX = @as(u32, 18);
pub const SQL_COLUMN_DRIVER_START = @as(u32, 1000);
pub const SQL_COLATT_OPT_MIN = @as(u32, 0);
pub const SQL_ATTR_READONLY = @as(u32, 0);
pub const SQL_ATTR_WRITE = @as(u32, 1);
pub const SQL_ATTR_READWRITE_UNKNOWN = @as(u32, 2);
pub const SQL_UNSEARCHABLE = @as(u32, 0);
pub const SQL_LIKE_ONLY = @as(u32, 1);
pub const SQL_ALL_EXCEPT_LIKE = @as(u32, 2);
pub const SQL_SEARCHABLE = @as(u32, 3);
pub const SQL_PRED_SEARCHABLE = @as(u32, 3);
pub const SQL_NO_TOTAL = @as(i32, -4);
pub const SQL_API_SQLALLOCHANDLESTD = @as(u32, 73);
pub const SQL_API_SQLBULKOPERATIONS = @as(u32, 24);
pub const SQL_API_SQLBINDPARAMETER = @as(u32, 72);
pub const SQL_API_SQLBROWSECONNECT = @as(u32, 55);
pub const SQL_API_SQLCOLATTRIBUTES = @as(u32, 6);
pub const SQL_API_SQLCOLUMNPRIVILEGES = @as(u32, 56);
pub const SQL_API_SQLDESCRIBEPARAM = @as(u32, 58);
pub const SQL_API_SQLDRIVERCONNECT = @as(u32, 41);
pub const SQL_API_SQLDRIVERS = @as(u32, 71);
pub const SQL_API_SQLPRIVATEDRIVERS = @as(u32, 79);
pub const SQL_API_SQLEXTENDEDFETCH = @as(u32, 59);
pub const SQL_API_SQLFOREIGNKEYS = @as(u32, 60);
pub const SQL_API_SQLMORERESULTS = @as(u32, 61);
pub const SQL_API_SQLNATIVESQL = @as(u32, 62);
pub const SQL_API_SQLNUMPARAMS = @as(u32, 63);
pub const SQL_API_SQLPARAMOPTIONS = @as(u32, 64);
pub const SQL_API_SQLPRIMARYKEYS = @as(u32, 65);
pub const SQL_API_SQLPROCEDURECOLUMNS = @as(u32, 66);
pub const SQL_API_SQLPROCEDURES = @as(u32, 67);
pub const SQL_API_SQLSETPOS = @as(u32, 68);
pub const SQL_API_SQLSETSCROLLOPTIONS = @as(u32, 69);
pub const SQL_API_SQLTABLEPRIVILEGES = @as(u32, 70);
pub const SQL_EXT_API_LAST = @as(u32, 72);
pub const SQL_NUM_FUNCTIONS = @as(u32, 23);
pub const SQL_EXT_API_START = @as(u32, 40);
pub const SQL_API_ALL_FUNCTIONS = @as(u32, 0);
pub const SQL_API_LOADBYORDINAL = @as(u32, 199);
pub const SQL_API_ODBC3_ALL_FUNCTIONS = @as(u32, 999);
pub const SQL_API_ODBC3_ALL_FUNCTIONS_SIZE = @as(u32, 250);
pub const SQL_INFO_FIRST = @as(u32, 0);
pub const SQL_ACTIVE_CONNECTIONS = @as(u32, 0);
pub const SQL_ACTIVE_STATEMENTS = @as(u32, 1);
pub const SQL_DRIVER_HDBC = @as(u32, 3);
pub const SQL_DRIVER_HENV = @as(u32, 4);
pub const SQL_DRIVER_HSTMT = @as(u32, 5);
pub const SQL_DRIVER_NAME = @as(u32, 6);
pub const SQL_DRIVER_VER = @as(u32, 7);
pub const SQL_ODBC_API_CONFORMANCE = @as(u32, 9);
pub const SQL_ODBC_VER = @as(u32, 10);
pub const SQL_ROW_UPDATES = @as(u32, 11);
pub const SQL_ODBC_SAG_CLI_CONFORMANCE = @as(u32, 12);
pub const SQL_ODBC_SQL_CONFORMANCE = @as(u32, 15);
pub const SQL_PROCEDURES = @as(u32, 21);
pub const SQL_CONCAT_NULL_BEHAVIOR = @as(u32, 22);
pub const SQL_CURSOR_ROLLBACK_BEHAVIOR = @as(u32, 24);
pub const SQL_EXPRESSIONS_IN_ORDERBY = @as(u32, 27);
pub const SQL_MAX_OWNER_NAME_LEN = @as(u32, 32);
pub const SQL_MAX_PROCEDURE_NAME_LEN = @as(u32, 33);
pub const SQL_MAX_QUALIFIER_NAME_LEN = @as(u32, 34);
pub const SQL_MULT_RESULT_SETS = @as(u32, 36);
pub const SQL_MULTIPLE_ACTIVE_TXN = @as(u32, 37);
pub const SQL_OUTER_JOINS = @as(u32, 38);
pub const SQL_OWNER_TERM = @as(u32, 39);
pub const SQL_PROCEDURE_TERM = @as(u32, 40);
pub const SQL_QUALIFIER_NAME_SEPARATOR = @as(u32, 41);
pub const SQL_QUALIFIER_TERM = @as(u32, 42);
pub const SQL_SCROLL_OPTIONS = @as(u32, 44);
pub const SQL_TABLE_TERM = @as(u32, 45);
pub const SQL_CONVERT_FUNCTIONS = @as(u32, 48);
pub const SQL_NUMERIC_FUNCTIONS = @as(u32, 49);
pub const SQL_STRING_FUNCTIONS = @as(u32, 50);
pub const SQL_SYSTEM_FUNCTIONS = @as(u32, 51);
pub const SQL_TIMEDATE_FUNCTIONS = @as(u32, 52);
pub const SQL_CONVERT_BIGINT = @as(u32, 53);
pub const SQL_CONVERT_BINARY = @as(u32, 54);
pub const SQL_CONVERT_BIT = @as(u32, 55);
pub const SQL_CONVERT_CHAR = @as(u32, 56);
pub const SQL_CONVERT_DATE = @as(u32, 57);
pub const SQL_CONVERT_DECIMAL = @as(u32, 58);
pub const SQL_CONVERT_DOUBLE = @as(u32, 59);
pub const SQL_CONVERT_FLOAT = @as(u32, 60);
pub const SQL_CONVERT_INTEGER = @as(u32, 61);
pub const SQL_CONVERT_LONGVARCHAR = @as(u32, 62);
pub const SQL_CONVERT_NUMERIC = @as(u32, 63);
pub const SQL_CONVERT_REAL = @as(u32, 64);
pub const SQL_CONVERT_SMALLINT = @as(u32, 65);
pub const SQL_CONVERT_TIME = @as(u32, 66);
pub const SQL_CONVERT_TIMESTAMP = @as(u32, 67);
pub const SQL_CONVERT_TINYINT = @as(u32, 68);
pub const SQL_CONVERT_VARBINARY = @as(u32, 69);
pub const SQL_CONVERT_VARCHAR = @as(u32, 70);
pub const SQL_CONVERT_LONGVARBINARY = @as(u32, 71);
pub const SQL_ODBC_SQL_OPT_IEF = @as(u32, 73);
pub const SQL_CORRELATION_NAME = @as(u32, 74);
pub const SQL_NON_NULLABLE_COLUMNS = @as(u32, 75);
pub const SQL_DRIVER_HLIB = @as(u32, 76);
pub const SQL_DRIVER_ODBC_VER = @as(u32, 77);
pub const SQL_LOCK_TYPES = @as(u32, 78);
pub const SQL_POS_OPERATIONS = @as(u32, 79);
pub const SQL_POSITIONED_STATEMENTS = @as(u32, 80);
pub const SQL_BOOKMARK_PERSISTENCE = @as(u32, 82);
pub const SQL_STATIC_SENSITIVITY = @as(u32, 83);
pub const SQL_FILE_USAGE = @as(u32, 84);
pub const SQL_COLUMN_ALIAS = @as(u32, 87);
pub const SQL_GROUP_BY = @as(u32, 88);
pub const SQL_KEYWORDS = @as(u32, 89);
pub const SQL_OWNER_USAGE = @as(u32, 91);
pub const SQL_QUALIFIER_USAGE = @as(u32, 92);
pub const SQL_QUOTED_IDENTIFIER_CASE = @as(u32, 93);
pub const SQL_SUBQUERIES = @as(u32, 95);
pub const SQL_UNION = @as(u32, 96);
pub const SQL_MAX_ROW_SIZE_INCLUDES_LONG = @as(u32, 103);
pub const SQL_MAX_CHAR_LITERAL_LEN = @as(u32, 108);
pub const SQL_TIMEDATE_ADD_INTERVALS = @as(u32, 109);
pub const SQL_TIMEDATE_DIFF_INTERVALS = @as(u32, 110);
pub const SQL_NEED_LONG_DATA_LEN = @as(u32, 111);
pub const SQL_MAX_BINARY_LITERAL_LEN = @as(u32, 112);
pub const SQL_LIKE_ESCAPE_CLAUSE = @as(u32, 113);
pub const SQL_QUALIFIER_LOCATION = @as(u32, 114);
pub const SQL_INFO_LAST = @as(u32, 114);
pub const SQL_INFO_DRIVER_START = @as(u32, 1000);
pub const SQL_ACTIVE_ENVIRONMENTS = @as(u32, 116);
pub const SQL_ALTER_DOMAIN = @as(u32, 117);
pub const SQL_SQL_CONFORMANCE = @as(u32, 118);
pub const SQL_DATETIME_LITERALS = @as(u32, 119);
pub const SQL_ASYNC_MODE = @as(u32, 10021);
pub const SQL_BATCH_ROW_COUNT = @as(u32, 120);
pub const SQL_BATCH_SUPPORT = @as(u32, 121);
pub const SQL_CATALOG_LOCATION = @as(u32, 114);
pub const SQL_CATALOG_NAME_SEPARATOR = @as(u32, 41);
pub const SQL_CATALOG_TERM = @as(u32, 42);
pub const SQL_CATALOG_USAGE = @as(u32, 92);
pub const SQL_CONVERT_WCHAR = @as(u32, 122);
pub const SQL_CONVERT_INTERVAL_DAY_TIME = @as(u32, 123);
pub const SQL_CONVERT_INTERVAL_YEAR_MONTH = @as(u32, 124);
pub const SQL_CONVERT_WLONGVARCHAR = @as(u32, 125);
pub const SQL_CONVERT_WVARCHAR = @as(u32, 126);
pub const SQL_CREATE_ASSERTION = @as(u32, 127);
pub const SQL_CREATE_CHARACTER_SET = @as(u32, 128);
pub const SQL_CREATE_COLLATION = @as(u32, 129);
pub const SQL_CREATE_DOMAIN = @as(u32, 130);
pub const SQL_CREATE_SCHEMA = @as(u32, 131);
pub const SQL_CREATE_TABLE = @as(u32, 132);
pub const SQL_CREATE_TRANSLATION = @as(u32, 133);
pub const SQL_CREATE_VIEW = @as(u32, 134);
pub const SQL_DRIVER_HDESC = @as(u32, 135);
pub const SQL_DROP_ASSERTION = @as(u32, 136);
pub const SQL_DROP_CHARACTER_SET = @as(u32, 137);
pub const SQL_DROP_COLLATION = @as(u32, 138);
pub const SQL_DROP_DOMAIN = @as(u32, 139);
pub const SQL_DROP_SCHEMA = @as(u32, 140);
pub const SQL_DROP_TABLE = @as(u32, 141);
pub const SQL_DROP_TRANSLATION = @as(u32, 142);
pub const SQL_DROP_VIEW = @as(u32, 143);
pub const SQL_DYNAMIC_CURSOR_ATTRIBUTES1 = @as(u32, 144);
pub const SQL_DYNAMIC_CURSOR_ATTRIBUTES2 = @as(u32, 145);
pub const SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1 = @as(u32, 146);
pub const SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2 = @as(u32, 147);
pub const SQL_INDEX_KEYWORDS = @as(u32, 148);
pub const SQL_INFO_SCHEMA_VIEWS = @as(u32, 149);
pub const SQL_KEYSET_CURSOR_ATTRIBUTES1 = @as(u32, 150);
pub const SQL_KEYSET_CURSOR_ATTRIBUTES2 = @as(u32, 151);
pub const SQL_MAX_ASYNC_CONCURRENT_STATEMENTS = @as(u32, 10022);
pub const SQL_ODBC_INTERFACE_CONFORMANCE = @as(u32, 152);
pub const SQL_PARAM_ARRAY_ROW_COUNTS = @as(u32, 153);
pub const SQL_PARAM_ARRAY_SELECTS = @as(u32, 154);
pub const SQL_SCHEMA_TERM = @as(u32, 39);
pub const SQL_SCHEMA_USAGE = @as(u32, 91);
pub const SQL_SQL92_DATETIME_FUNCTIONS = @as(u32, 155);
pub const SQL_SQL92_FOREIGN_KEY_DELETE_RULE = @as(u32, 156);
pub const SQL_SQL92_FOREIGN_KEY_UPDATE_RULE = @as(u32, 157);
pub const SQL_SQL92_GRANT = @as(u32, 158);
pub const SQL_SQL92_NUMERIC_VALUE_FUNCTIONS = @as(u32, 159);
pub const SQL_SQL92_PREDICATES = @as(u32, 160);
pub const SQL_SQL92_RELATIONAL_JOIN_OPERATORS = @as(u32, 161);
pub const SQL_SQL92_REVOKE = @as(u32, 162);
pub const SQL_SQL92_ROW_VALUE_CONSTRUCTOR = @as(u32, 163);
pub const SQL_SQL92_STRING_FUNCTIONS = @as(u32, 164);
pub const SQL_SQL92_VALUE_EXPRESSIONS = @as(u32, 165);
pub const SQL_STANDARD_CLI_CONFORMANCE = @as(u32, 166);
pub const SQL_STATIC_CURSOR_ATTRIBUTES1 = @as(u32, 167);
pub const SQL_STATIC_CURSOR_ATTRIBUTES2 = @as(u32, 168);
pub const SQL_AGGREGATE_FUNCTIONS = @as(u32, 169);
pub const SQL_DDL_INDEX = @as(u32, 170);
pub const SQL_DM_VER = @as(u32, 171);
pub const SQL_INSERT_STATEMENT = @as(u32, 172);
pub const SQL_CONVERT_GUID = @as(u32, 173);
pub const SQL_UNION_STATEMENT = @as(u32, 96);
pub const SQL_ASYNC_DBC_FUNCTIONS = @as(u32, 10023);
pub const SQL_DRIVER_AWARE_POOLING_SUPPORTED = @as(u32, 10024);
pub const SQL_ASYNC_NOTIFICATION = @as(u32, 10025);
pub const SQL_ASYNC_NOTIFICATION_NOT_CAPABLE = @as(i32, 0);
pub const SQL_ASYNC_NOTIFICATION_CAPABLE = @as(i32, 1);
pub const SQL_DTC_TRANSITION_COST = @as(u32, 1750);
pub const SQL_AT_ADD_COLUMN_SINGLE = @as(i32, 32);
pub const SQL_AT_ADD_COLUMN_DEFAULT = @as(i32, 64);
pub const SQL_AT_ADD_COLUMN_COLLATION = @as(i32, 128);
pub const SQL_AT_SET_COLUMN_DEFAULT = @as(i32, 256);
pub const SQL_AT_DROP_COLUMN_DEFAULT = @as(i32, 512);
pub const SQL_AT_DROP_COLUMN_CASCADE = @as(i32, 1024);
pub const SQL_AT_DROP_COLUMN_RESTRICT = @as(i32, 2048);
pub const SQL_AT_ADD_TABLE_CONSTRAINT = @as(i32, 4096);
pub const SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE = @as(i32, 8192);
pub const SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT = @as(i32, 16384);
pub const SQL_AT_CONSTRAINT_NAME_DEFINITION = @as(i32, 32768);
pub const SQL_AT_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 65536);
pub const SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 131072);
pub const SQL_AT_CONSTRAINT_DEFERRABLE = @as(i32, 262144);
pub const SQL_AT_CONSTRAINT_NON_DEFERRABLE = @as(i32, 524288);
pub const SQL_CVT_CHAR = @as(i32, 1);
pub const SQL_CVT_NUMERIC = @as(i32, 2);
pub const SQL_CVT_DECIMAL = @as(i32, 4);
pub const SQL_CVT_INTEGER = @as(i32, 8);
pub const SQL_CVT_SMALLINT = @as(i32, 16);
pub const SQL_CVT_FLOAT = @as(i32, 32);
pub const SQL_CVT_REAL = @as(i32, 64);
pub const SQL_CVT_DOUBLE = @as(i32, 128);
pub const SQL_CVT_VARCHAR = @as(i32, 256);
pub const SQL_CVT_LONGVARCHAR = @as(i32, 512);
pub const SQL_CVT_BINARY = @as(i32, 1024);
pub const SQL_CVT_VARBINARY = @as(i32, 2048);
pub const SQL_CVT_BIT = @as(i32, 4096);
pub const SQL_CVT_TINYINT = @as(i32, 8192);
pub const SQL_CVT_BIGINT = @as(i32, 16384);
pub const SQL_CVT_DATE = @as(i32, 32768);
pub const SQL_CVT_TIME = @as(i32, 65536);
pub const SQL_CVT_TIMESTAMP = @as(i32, 131072);
pub const SQL_CVT_LONGVARBINARY = @as(i32, 262144);
pub const SQL_CVT_INTERVAL_YEAR_MONTH = @as(i32, 524288);
pub const SQL_CVT_INTERVAL_DAY_TIME = @as(i32, 1048576);
pub const SQL_CVT_WCHAR = @as(i32, 2097152);
pub const SQL_CVT_WLONGVARCHAR = @as(i32, 4194304);
pub const SQL_CVT_WVARCHAR = @as(i32, 8388608);
pub const SQL_CVT_GUID = @as(i32, 16777216);
pub const SQL_FN_CVT_CONVERT = @as(i32, 1);
pub const SQL_FN_CVT_CAST = @as(i32, 2);
pub const SQL_FN_STR_CONCAT = @as(i32, 1);
pub const SQL_FN_STR_INSERT = @as(i32, 2);
pub const SQL_FN_STR_LEFT = @as(i32, 4);
pub const SQL_FN_STR_LTRIM = @as(i32, 8);
pub const SQL_FN_STR_LENGTH = @as(i32, 16);
pub const SQL_FN_STR_LOCATE = @as(i32, 32);
pub const SQL_FN_STR_LCASE = @as(i32, 64);
pub const SQL_FN_STR_REPEAT = @as(i32, 128);
pub const SQL_FN_STR_REPLACE = @as(i32, 256);
pub const SQL_FN_STR_RIGHT = @as(i32, 512);
pub const SQL_FN_STR_RTRIM = @as(i32, 1024);
pub const SQL_FN_STR_SUBSTRING = @as(i32, 2048);
pub const SQL_FN_STR_UCASE = @as(i32, 4096);
pub const SQL_FN_STR_ASCII = @as(i32, 8192);
pub const SQL_FN_STR_CHAR = @as(i32, 16384);
pub const SQL_FN_STR_DIFFERENCE = @as(i32, 32768);
pub const SQL_FN_STR_LOCATE_2 = @as(i32, 65536);
pub const SQL_FN_STR_SOUNDEX = @as(i32, 131072);
pub const SQL_FN_STR_SPACE = @as(i32, 262144);
pub const SQL_FN_STR_BIT_LENGTH = @as(i32, 524288);
pub const SQL_FN_STR_CHAR_LENGTH = @as(i32, 1048576);
pub const SQL_FN_STR_CHARACTER_LENGTH = @as(i32, 2097152);
pub const SQL_FN_STR_OCTET_LENGTH = @as(i32, 4194304);
pub const SQL_FN_STR_POSITION = @as(i32, 8388608);
pub const SQL_SSF_CONVERT = @as(i32, 1);
pub const SQL_SSF_LOWER = @as(i32, 2);
pub const SQL_SSF_UPPER = @as(i32, 4);
pub const SQL_SSF_SUBSTRING = @as(i32, 8);
pub const SQL_SSF_TRANSLATE = @as(i32, 16);
pub const SQL_SSF_TRIM_BOTH = @as(i32, 32);
pub const SQL_SSF_TRIM_LEADING = @as(i32, 64);
pub const SQL_SSF_TRIM_TRAILING = @as(i32, 128);
pub const SQL_FN_NUM_ABS = @as(i32, 1);
pub const SQL_FN_NUM_ACOS = @as(i32, 2);
pub const SQL_FN_NUM_ASIN = @as(i32, 4);
pub const SQL_FN_NUM_ATAN = @as(i32, 8);
pub const SQL_FN_NUM_ATAN2 = @as(i32, 16);
pub const SQL_FN_NUM_CEILING = @as(i32, 32);
pub const SQL_FN_NUM_COS = @as(i32, 64);
pub const SQL_FN_NUM_COT = @as(i32, 128);
pub const SQL_FN_NUM_EXP = @as(i32, 256);
pub const SQL_FN_NUM_FLOOR = @as(i32, 512);
pub const SQL_FN_NUM_LOG = @as(i32, 1024);
pub const SQL_FN_NUM_MOD = @as(i32, 2048);
pub const SQL_FN_NUM_SIGN = @as(i32, 4096);
pub const SQL_FN_NUM_SIN = @as(i32, 8192);
pub const SQL_FN_NUM_SQRT = @as(i32, 16384);
pub const SQL_FN_NUM_TAN = @as(i32, 32768);
pub const SQL_FN_NUM_PI = @as(i32, 65536);
pub const SQL_FN_NUM_RAND = @as(i32, 131072);
pub const SQL_FN_NUM_DEGREES = @as(i32, 262144);
pub const SQL_FN_NUM_LOG10 = @as(i32, 524288);
pub const SQL_FN_NUM_POWER = @as(i32, 1048576);
pub const SQL_FN_NUM_RADIANS = @as(i32, 2097152);
pub const SQL_FN_NUM_ROUND = @as(i32, 4194304);
pub const SQL_FN_NUM_TRUNCATE = @as(i32, 8388608);
pub const SQL_SNVF_BIT_LENGTH = @as(i32, 1);
pub const SQL_SNVF_CHAR_LENGTH = @as(i32, 2);
pub const SQL_SNVF_CHARACTER_LENGTH = @as(i32, 4);
pub const SQL_SNVF_EXTRACT = @as(i32, 8);
pub const SQL_SNVF_OCTET_LENGTH = @as(i32, 16);
pub const SQL_SNVF_POSITION = @as(i32, 32);
pub const SQL_FN_TD_NOW = @as(i32, 1);
pub const SQL_FN_TD_CURDATE = @as(i32, 2);
pub const SQL_FN_TD_DAYOFMONTH = @as(i32, 4);
pub const SQL_FN_TD_DAYOFWEEK = @as(i32, 8);
pub const SQL_FN_TD_DAYOFYEAR = @as(i32, 16);
pub const SQL_FN_TD_MONTH = @as(i32, 32);
pub const SQL_FN_TD_QUARTER = @as(i32, 64);
pub const SQL_FN_TD_WEEK = @as(i32, 128);
pub const SQL_FN_TD_YEAR = @as(i32, 256);
pub const SQL_FN_TD_CURTIME = @as(i32, 512);
pub const SQL_FN_TD_HOUR = @as(i32, 1024);
pub const SQL_FN_TD_MINUTE = @as(i32, 2048);
pub const SQL_FN_TD_SECOND = @as(i32, 4096);
pub const SQL_FN_TD_TIMESTAMPADD = @as(i32, 8192);
pub const SQL_FN_TD_TIMESTAMPDIFF = @as(i32, 16384);
pub const SQL_FN_TD_DAYNAME = @as(i32, 32768);
pub const SQL_FN_TD_MONTHNAME = @as(i32, 65536);
pub const SQL_FN_TD_CURRENT_DATE = @as(i32, 131072);
pub const SQL_FN_TD_CURRENT_TIME = @as(i32, 262144);
pub const SQL_FN_TD_CURRENT_TIMESTAMP = @as(i32, 524288);
pub const SQL_FN_TD_EXTRACT = @as(i32, 1048576);
pub const SQL_SDF_CURRENT_DATE = @as(i32, 1);
pub const SQL_SDF_CURRENT_TIME = @as(i32, 2);
pub const SQL_SDF_CURRENT_TIMESTAMP = @as(i32, 4);
pub const SQL_FN_SYS_USERNAME = @as(i32, 1);
pub const SQL_FN_SYS_DBNAME = @as(i32, 2);
pub const SQL_FN_SYS_IFNULL = @as(i32, 4);
pub const SQL_FN_TSI_FRAC_SECOND = @as(i32, 1);
pub const SQL_FN_TSI_SECOND = @as(i32, 2);
pub const SQL_FN_TSI_MINUTE = @as(i32, 4);
pub const SQL_FN_TSI_HOUR = @as(i32, 8);
pub const SQL_FN_TSI_DAY = @as(i32, 16);
pub const SQL_FN_TSI_WEEK = @as(i32, 32);
pub const SQL_FN_TSI_MONTH = @as(i32, 64);
pub const SQL_FN_TSI_QUARTER = @as(i32, 128);
pub const SQL_FN_TSI_YEAR = @as(i32, 256);
pub const SQL_CA1_NEXT = @as(i32, 1);
pub const SQL_CA1_ABSOLUTE = @as(i32, 2);
pub const SQL_CA1_RELATIVE = @as(i32, 4);
pub const SQL_CA1_BOOKMARK = @as(i32, 8);
pub const SQL_CA1_LOCK_NO_CHANGE = @as(i32, 64);
pub const SQL_CA1_LOCK_EXCLUSIVE = @as(i32, 128);
pub const SQL_CA1_LOCK_UNLOCK = @as(i32, 256);
pub const SQL_CA1_POS_POSITION = @as(i32, 512);
pub const SQL_CA1_POS_UPDATE = @as(i32, 1024);
pub const SQL_CA1_POS_DELETE = @as(i32, 2048);
pub const SQL_CA1_POS_REFRESH = @as(i32, 4096);
pub const SQL_CA1_POSITIONED_UPDATE = @as(i32, 8192);
pub const SQL_CA1_POSITIONED_DELETE = @as(i32, 16384);
pub const SQL_CA1_SELECT_FOR_UPDATE = @as(i32, 32768);
pub const SQL_CA1_BULK_ADD = @as(i32, 65536);
pub const SQL_CA1_BULK_UPDATE_BY_BOOKMARK = @as(i32, 131072);
pub const SQL_CA1_BULK_DELETE_BY_BOOKMARK = @as(i32, 262144);
pub const SQL_CA1_BULK_FETCH_BY_BOOKMARK = @as(i32, 524288);
pub const SQL_CA2_READ_ONLY_CONCURRENCY = @as(i32, 1);
pub const SQL_CA2_LOCK_CONCURRENCY = @as(i32, 2);
pub const SQL_CA2_OPT_ROWVER_CONCURRENCY = @as(i32, 4);
pub const SQL_CA2_OPT_VALUES_CONCURRENCY = @as(i32, 8);
pub const SQL_CA2_SENSITIVITY_ADDITIONS = @as(i32, 16);
pub const SQL_CA2_SENSITIVITY_DELETIONS = @as(i32, 32);
pub const SQL_CA2_SENSITIVITY_UPDATES = @as(i32, 64);
pub const SQL_CA2_MAX_ROWS_SELECT = @as(i32, 128);
pub const SQL_CA2_MAX_ROWS_INSERT = @as(i32, 256);
pub const SQL_CA2_MAX_ROWS_DELETE = @as(i32, 512);
pub const SQL_CA2_MAX_ROWS_UPDATE = @as(i32, 1024);
pub const SQL_CA2_MAX_ROWS_CATALOG = @as(i32, 2048);
pub const SQL_CA2_CRC_EXACT = @as(i32, 4096);
pub const SQL_CA2_CRC_APPROXIMATE = @as(i32, 8192);
pub const SQL_CA2_SIMULATE_NON_UNIQUE = @as(i32, 16384);
pub const SQL_CA2_SIMULATE_TRY_UNIQUE = @as(i32, 32768);
pub const SQL_CA2_SIMULATE_UNIQUE = @as(i32, 65536);
pub const SQL_OAC_NONE = @as(u32, 0);
pub const SQL_OAC_LEVEL1 = @as(u32, 1);
pub const SQL_OAC_LEVEL2 = @as(u32, 2);
pub const SQL_OSCC_NOT_COMPLIANT = @as(u32, 0);
pub const SQL_OSCC_COMPLIANT = @as(u32, 1);
pub const SQL_OSC_MINIMUM = @as(u32, 0);
pub const SQL_OSC_CORE = @as(u32, 1);
pub const SQL_OSC_EXTENDED = @as(u32, 2);
pub const SQL_CB_NULL = @as(u32, 0);
pub const SQL_CB_NON_NULL = @as(u32, 1);
pub const SQL_SO_FORWARD_ONLY = @as(i32, 1);
pub const SQL_SO_KEYSET_DRIVEN = @as(i32, 2);
pub const SQL_SO_DYNAMIC = @as(i32, 4);
pub const SQL_SO_MIXED = @as(i32, 8);
pub const SQL_SO_STATIC = @as(i32, 16);
pub const SQL_FD_FETCH_RESUME = @as(i32, 64);
pub const SQL_FD_FETCH_BOOKMARK = @as(i32, 128);
pub const SQL_TXN_VERSIONING = @as(i32, 16);
pub const SQL_CN_NONE = @as(u32, 0);
pub const SQL_CN_DIFFERENT = @as(u32, 1);
pub const SQL_CN_ANY = @as(u32, 2);
pub const SQL_NNC_NULL = @as(u32, 0);
pub const SQL_NNC_NON_NULL = @as(u32, 1);
pub const SQL_NC_START = @as(u32, 2);
pub const SQL_NC_END = @as(u32, 4);
pub const SQL_FILE_NOT_SUPPORTED = @as(u32, 0);
pub const SQL_FILE_TABLE = @as(u32, 1);
pub const SQL_FILE_QUALIFIER = @as(u32, 2);
pub const SQL_FILE_CATALOG = @as(u32, 2);
pub const SQL_GD_BLOCK = @as(i32, 4);
pub const SQL_GD_BOUND = @as(i32, 8);
pub const SQL_GD_OUTPUT_PARAMS = @as(i32, 16);
pub const SQL_PS_POSITIONED_DELETE = @as(i32, 1);
pub const SQL_PS_POSITIONED_UPDATE = @as(i32, 2);
pub const SQL_PS_SELECT_FOR_UPDATE = @as(i32, 4);
pub const SQL_GB_NOT_SUPPORTED = @as(u32, 0);
pub const SQL_GB_GROUP_BY_EQUALS_SELECT = @as(u32, 1);
pub const SQL_GB_GROUP_BY_CONTAINS_SELECT = @as(u32, 2);
pub const SQL_GB_NO_RELATION = @as(u32, 3);
pub const SQL_GB_COLLATE = @as(u32, 4);
pub const SQL_OU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_OU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_OU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_OU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_OU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_SU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_SU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_SU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_SU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_SU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_QU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_QU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_QU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_QU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_QU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_CU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_CU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_CU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_CU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_CU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_SQ_COMPARISON = @as(i32, 1);
pub const SQL_SQ_EXISTS = @as(i32, 2);
pub const SQL_SQ_IN = @as(i32, 4);
pub const SQL_SQ_QUANTIFIED = @as(i32, 8);
pub const SQL_SQ_CORRELATED_SUBQUERIES = @as(i32, 16);
pub const SQL_U_UNION = @as(i32, 1);
pub const SQL_U_UNION_ALL = @as(i32, 2);
pub const SQL_BP_CLOSE = @as(i32, 1);
pub const SQL_BP_DELETE = @as(i32, 2);
pub const SQL_BP_DROP = @as(i32, 4);
pub const SQL_BP_TRANSACTION = @as(i32, 8);
pub const SQL_BP_UPDATE = @as(i32, 16);
pub const SQL_BP_OTHER_HSTMT = @as(i32, 32);
pub const SQL_BP_SCROLL = @as(i32, 64);
pub const SQL_SS_ADDITIONS = @as(i32, 1);
pub const SQL_SS_DELETIONS = @as(i32, 2);
pub const SQL_SS_UPDATES = @as(i32, 4);
pub const SQL_CV_CREATE_VIEW = @as(i32, 1);
pub const SQL_CV_CHECK_OPTION = @as(i32, 2);
pub const SQL_CV_CASCADED = @as(i32, 4);
pub const SQL_CV_LOCAL = @as(i32, 8);
pub const SQL_LCK_NO_CHANGE = @as(i32, 1);
pub const SQL_LCK_EXCLUSIVE = @as(i32, 2);
pub const SQL_LCK_UNLOCK = @as(i32, 4);
pub const SQL_POS_POSITION = @as(i32, 1);
pub const SQL_POS_REFRESH = @as(i32, 2);
pub const SQL_POS_UPDATE = @as(i32, 4);
pub const SQL_POS_DELETE = @as(i32, 8);
pub const SQL_POS_ADD = @as(i32, 16);
pub const SQL_QL_START = @as(u32, 1);
pub const SQL_QL_END = @as(u32, 2);
pub const SQL_AF_AVG = @as(i32, 1);
pub const SQL_AF_COUNT = @as(i32, 2);
pub const SQL_AF_MAX = @as(i32, 4);
pub const SQL_AF_MIN = @as(i32, 8);
pub const SQL_AF_SUM = @as(i32, 16);
pub const SQL_AF_DISTINCT = @as(i32, 32);
pub const SQL_AF_ALL = @as(i32, 64);
pub const SQL_SC_SQL92_ENTRY = @as(i32, 1);
pub const SQL_SC_FIPS127_2_TRANSITIONAL = @as(i32, 2);
pub const SQL_SC_SQL92_INTERMEDIATE = @as(i32, 4);
pub const SQL_SC_SQL92_FULL = @as(i32, 8);
pub const SQL_DL_SQL92_DATE = @as(i32, 1);
pub const SQL_DL_SQL92_TIME = @as(i32, 2);
pub const SQL_DL_SQL92_TIMESTAMP = @as(i32, 4);
pub const SQL_DL_SQL92_INTERVAL_YEAR = @as(i32, 8);
pub const SQL_DL_SQL92_INTERVAL_MONTH = @as(i32, 16);
pub const SQL_DL_SQL92_INTERVAL_DAY = @as(i32, 32);
pub const SQL_DL_SQL92_INTERVAL_HOUR = @as(i32, 64);
pub const SQL_DL_SQL92_INTERVAL_MINUTE = @as(i32, 128);
pub const SQL_DL_SQL92_INTERVAL_SECOND = @as(i32, 256);
pub const SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH = @as(i32, 512);
pub const SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR = @as(i32, 1024);
pub const SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE = @as(i32, 2048);
pub const SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND = @as(i32, 4096);
pub const SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE = @as(i32, 8192);
pub const SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND = @as(i32, 16384);
pub const SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND = @as(i32, 32768);
pub const SQL_CL_START = @as(u32, 1);
pub const SQL_CL_END = @as(u32, 2);
pub const SQL_BRC_PROCEDURES = @as(u32, 1);
pub const SQL_BRC_EXPLICIT = @as(u32, 2);
pub const SQL_BRC_ROLLED_UP = @as(u32, 4);
pub const SQL_BS_SELECT_EXPLICIT = @as(i32, 1);
pub const SQL_BS_ROW_COUNT_EXPLICIT = @as(i32, 2);
pub const SQL_BS_SELECT_PROC = @as(i32, 4);
pub const SQL_BS_ROW_COUNT_PROC = @as(i32, 8);
pub const SQL_PARC_BATCH = @as(u32, 1);
pub const SQL_PARC_NO_BATCH = @as(u32, 2);
pub const SQL_PAS_BATCH = @as(u32, 1);
pub const SQL_PAS_NO_BATCH = @as(u32, 2);
pub const SQL_PAS_NO_SELECT = @as(u32, 3);
pub const SQL_IK_NONE = @as(i32, 0);
pub const SQL_IK_ASC = @as(i32, 1);
pub const SQL_IK_DESC = @as(i32, 2);
pub const SQL_ISV_ASSERTIONS = @as(i32, 1);
pub const SQL_ISV_CHARACTER_SETS = @as(i32, 2);
pub const SQL_ISV_CHECK_CONSTRAINTS = @as(i32, 4);
pub const SQL_ISV_COLLATIONS = @as(i32, 8);
pub const SQL_ISV_COLUMN_DOMAIN_USAGE = @as(i32, 16);
pub const SQL_ISV_COLUMN_PRIVILEGES = @as(i32, 32);
pub const SQL_ISV_COLUMNS = @as(i32, 64);
pub const SQL_ISV_CONSTRAINT_COLUMN_USAGE = @as(i32, 128);
pub const SQL_ISV_CONSTRAINT_TABLE_USAGE = @as(i32, 256);
pub const SQL_ISV_DOMAIN_CONSTRAINTS = @as(i32, 512);
pub const SQL_ISV_DOMAINS = @as(i32, 1024);
pub const SQL_ISV_KEY_COLUMN_USAGE = @as(i32, 2048);
pub const SQL_ISV_REFERENTIAL_CONSTRAINTS = @as(i32, 4096);
pub const SQL_ISV_SCHEMATA = @as(i32, 8192);
pub const SQL_ISV_SQL_LANGUAGES = @as(i32, 16384);
pub const SQL_ISV_TABLE_CONSTRAINTS = @as(i32, 32768);
pub const SQL_ISV_TABLE_PRIVILEGES = @as(i32, 65536);
pub const SQL_ISV_TABLES = @as(i32, 131072);
pub const SQL_ISV_TRANSLATIONS = @as(i32, 262144);
pub const SQL_ISV_USAGE_PRIVILEGES = @as(i32, 524288);
pub const SQL_ISV_VIEW_COLUMN_USAGE = @as(i32, 1048576);
pub const SQL_ISV_VIEW_TABLE_USAGE = @as(i32, 2097152);
pub const SQL_ISV_VIEWS = @as(i32, 4194304);
pub const SQL_AD_CONSTRAINT_NAME_DEFINITION = @as(i32, 1);
pub const SQL_AD_ADD_DOMAIN_CONSTRAINT = @as(i32, 2);
pub const SQL_AD_DROP_DOMAIN_CONSTRAINT = @as(i32, 4);
pub const SQL_AD_ADD_DOMAIN_DEFAULT = @as(i32, 8);
pub const SQL_AD_DROP_DOMAIN_DEFAULT = @as(i32, 16);
pub const SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 32);
pub const SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 64);
pub const SQL_AD_ADD_CONSTRAINT_DEFERRABLE = @as(i32, 128);
pub const SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE = @as(i32, 256);
pub const SQL_CS_CREATE_SCHEMA = @as(i32, 1);
pub const SQL_CS_AUTHORIZATION = @as(i32, 2);
pub const SQL_CS_DEFAULT_CHARACTER_SET = @as(i32, 4);
pub const SQL_CTR_CREATE_TRANSLATION = @as(i32, 1);
pub const SQL_CA_CREATE_ASSERTION = @as(i32, 1);
pub const SQL_CA_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 16);
pub const SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 32);
pub const SQL_CA_CONSTRAINT_DEFERRABLE = @as(i32, 64);
pub const SQL_CA_CONSTRAINT_NON_DEFERRABLE = @as(i32, 128);
pub const SQL_CCS_CREATE_CHARACTER_SET = @as(i32, 1);
pub const SQL_CCS_COLLATE_CLAUSE = @as(i32, 2);
pub const SQL_CCS_LIMITED_COLLATION = @as(i32, 4);
pub const SQL_CCOL_CREATE_COLLATION = @as(i32, 1);
pub const SQL_CDO_CREATE_DOMAIN = @as(i32, 1);
pub const SQL_CDO_DEFAULT = @as(i32, 2);
pub const SQL_CDO_CONSTRAINT = @as(i32, 4);
pub const SQL_CDO_COLLATION = @as(i32, 8);
pub const SQL_CDO_CONSTRAINT_NAME_DEFINITION = @as(i32, 16);
pub const SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 32);
pub const SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 64);
pub const SQL_CDO_CONSTRAINT_DEFERRABLE = @as(i32, 128);
pub const SQL_CDO_CONSTRAINT_NON_DEFERRABLE = @as(i32, 256);
pub const SQL_CT_CREATE_TABLE = @as(i32, 1);
pub const SQL_CT_COMMIT_PRESERVE = @as(i32, 2);
pub const SQL_CT_COMMIT_DELETE = @as(i32, 4);
pub const SQL_CT_GLOBAL_TEMPORARY = @as(i32, 8);
pub const SQL_CT_LOCAL_TEMPORARY = @as(i32, 16);
pub const SQL_CT_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 32);
pub const SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 64);
pub const SQL_CT_CONSTRAINT_DEFERRABLE = @as(i32, 128);
pub const SQL_CT_CONSTRAINT_NON_DEFERRABLE = @as(i32, 256);
pub const SQL_CT_COLUMN_CONSTRAINT = @as(i32, 512);
pub const SQL_CT_COLUMN_DEFAULT = @as(i32, 1024);
pub const SQL_CT_COLUMN_COLLATION = @as(i32, 2048);
pub const SQL_CT_TABLE_CONSTRAINT = @as(i32, 4096);
pub const SQL_CT_CONSTRAINT_NAME_DEFINITION = @as(i32, 8192);
pub const SQL_DI_CREATE_INDEX = @as(i32, 1);
pub const SQL_DI_DROP_INDEX = @as(i32, 2);
pub const SQL_DC_DROP_COLLATION = @as(i32, 1);
pub const SQL_DD_DROP_DOMAIN = @as(i32, 1);
pub const SQL_DD_RESTRICT = @as(i32, 2);
pub const SQL_DD_CASCADE = @as(i32, 4);
pub const SQL_DS_DROP_SCHEMA = @as(i32, 1);
pub const SQL_DS_RESTRICT = @as(i32, 2);
pub const SQL_DS_CASCADE = @as(i32, 4);
pub const SQL_DCS_DROP_CHARACTER_SET = @as(i32, 1);
pub const SQL_DA_DROP_ASSERTION = @as(i32, 1);
pub const SQL_DT_DROP_TABLE = @as(i32, 1);
pub const SQL_DT_RESTRICT = @as(i32, 2);
pub const SQL_DT_CASCADE = @as(i32, 4);
pub const SQL_DTR_DROP_TRANSLATION = @as(i32, 1);
pub const SQL_DV_DROP_VIEW = @as(i32, 1);
pub const SQL_DV_RESTRICT = @as(i32, 2);
pub const SQL_DV_CASCADE = @as(i32, 4);
pub const SQL_IS_INSERT_LITERALS = @as(i32, 1);
pub const SQL_IS_INSERT_SEARCHED = @as(i32, 2);
pub const SQL_IS_SELECT_INTO = @as(i32, 4);
pub const SQL_OIC_CORE = @as(u32, 1);
pub const SQL_OIC_LEVEL1 = @as(u32, 2);
pub const SQL_OIC_LEVEL2 = @as(u32, 3);
pub const SQL_SFKD_CASCADE = @as(i32, 1);
pub const SQL_SFKD_NO_ACTION = @as(i32, 2);
pub const SQL_SFKD_SET_DEFAULT = @as(i32, 4);
pub const SQL_SFKD_SET_NULL = @as(i32, 8);
pub const SQL_SFKU_CASCADE = @as(i32, 1);
pub const SQL_SFKU_NO_ACTION = @as(i32, 2);
pub const SQL_SFKU_SET_DEFAULT = @as(i32, 4);
pub const SQL_SFKU_SET_NULL = @as(i32, 8);
pub const SQL_SG_USAGE_ON_DOMAIN = @as(i32, 1);
pub const SQL_SG_USAGE_ON_CHARACTER_SET = @as(i32, 2);
pub const SQL_SG_USAGE_ON_COLLATION = @as(i32, 4);
pub const SQL_SG_USAGE_ON_TRANSLATION = @as(i32, 8);
pub const SQL_SG_WITH_GRANT_OPTION = @as(i32, 16);
pub const SQL_SG_DELETE_TABLE = @as(i32, 32);
pub const SQL_SG_INSERT_TABLE = @as(i32, 64);
pub const SQL_SG_INSERT_COLUMN = @as(i32, 128);
pub const SQL_SG_REFERENCES_TABLE = @as(i32, 256);
pub const SQL_SG_REFERENCES_COLUMN = @as(i32, 512);
pub const SQL_SG_SELECT_TABLE = @as(i32, 1024);
pub const SQL_SG_UPDATE_TABLE = @as(i32, 2048);
pub const SQL_SG_UPDATE_COLUMN = @as(i32, 4096);
pub const SQL_SP_EXISTS = @as(i32, 1);
pub const SQL_SP_ISNOTNULL = @as(i32, 2);
pub const SQL_SP_ISNULL = @as(i32, 4);
pub const SQL_SP_MATCH_FULL = @as(i32, 8);
pub const SQL_SP_MATCH_PARTIAL = @as(i32, 16);
pub const SQL_SP_MATCH_UNIQUE_FULL = @as(i32, 32);
pub const SQL_SP_MATCH_UNIQUE_PARTIAL = @as(i32, 64);
pub const SQL_SP_OVERLAPS = @as(i32, 128);
pub const SQL_SP_UNIQUE = @as(i32, 256);
pub const SQL_SP_LIKE = @as(i32, 512);
pub const SQL_SP_IN = @as(i32, 1024);
pub const SQL_SP_BETWEEN = @as(i32, 2048);
pub const SQL_SP_COMPARISON = @as(i32, 4096);
pub const SQL_SP_QUANTIFIED_COMPARISON = @as(i32, 8192);
pub const SQL_SRJO_CORRESPONDING_CLAUSE = @as(i32, 1);
pub const SQL_SRJO_CROSS_JOIN = @as(i32, 2);
pub const SQL_SRJO_EXCEPT_JOIN = @as(i32, 4);
pub const SQL_SRJO_FULL_OUTER_JOIN = @as(i32, 8);
pub const SQL_SRJO_INNER_JOIN = @as(i32, 16);
pub const SQL_SRJO_INTERSECT_JOIN = @as(i32, 32);
pub const SQL_SRJO_LEFT_OUTER_JOIN = @as(i32, 64);
pub const SQL_SRJO_NATURAL_JOIN = @as(i32, 128);
pub const SQL_SRJO_RIGHT_OUTER_JOIN = @as(i32, 256);
pub const SQL_SRJO_UNION_JOIN = @as(i32, 512);
pub const SQL_SR_USAGE_ON_DOMAIN = @as(i32, 1);
pub const SQL_SR_USAGE_ON_CHARACTER_SET = @as(i32, 2);
pub const SQL_SR_USAGE_ON_COLLATION = @as(i32, 4);
pub const SQL_SR_USAGE_ON_TRANSLATION = @as(i32, 8);
pub const SQL_SR_GRANT_OPTION_FOR = @as(i32, 16);
pub const SQL_SR_CASCADE = @as(i32, 32);
pub const SQL_SR_RESTRICT = @as(i32, 64);
pub const SQL_SR_DELETE_TABLE = @as(i32, 128);
pub const SQL_SR_INSERT_TABLE = @as(i32, 256);
pub const SQL_SR_INSERT_COLUMN = @as(i32, 512);
pub const SQL_SR_REFERENCES_TABLE = @as(i32, 1024);
pub const SQL_SR_REFERENCES_COLUMN = @as(i32, 2048);
pub const SQL_SR_SELECT_TABLE = @as(i32, 4096);
pub const SQL_SR_UPDATE_TABLE = @as(i32, 8192);
pub const SQL_SR_UPDATE_COLUMN = @as(i32, 16384);
pub const SQL_SRVC_VALUE_EXPRESSION = @as(i32, 1);
pub const SQL_SRVC_NULL = @as(i32, 2);
pub const SQL_SRVC_DEFAULT = @as(i32, 4);
pub const SQL_SRVC_ROW_SUBQUERY = @as(i32, 8);
pub const SQL_SVE_CASE = @as(i32, 1);
pub const SQL_SVE_CAST = @as(i32, 2);
pub const SQL_SVE_COALESCE = @as(i32, 4);
pub const SQL_SVE_NULLIF = @as(i32, 8);
pub const SQL_SCC_XOPEN_CLI_VERSION1 = @as(i32, 1);
pub const SQL_SCC_ISO92_CLI = @as(i32, 2);
pub const SQL_US_UNION = @as(i32, 1);
pub const SQL_US_UNION_ALL = @as(i32, 2);
pub const SQL_DRIVER_AWARE_POOLING_NOT_CAPABLE = @as(i32, 0);
pub const SQL_DRIVER_AWARE_POOLING_CAPABLE = @as(i32, 1);
pub const SQL_DTC_ENLIST_EXPENSIVE = @as(i32, 1);
pub const SQL_DTC_UNENLIST_EXPENSIVE = @as(i32, 2);
pub const SQL_ASYNC_DBC_NOT_CAPABLE = @as(i32, 0);
pub const SQL_ASYNC_DBC_CAPABLE = @as(i32, 1);
pub const SQL_FETCH_FIRST_USER = @as(u32, 31);
pub const SQL_FETCH_FIRST_SYSTEM = @as(u32, 32);
pub const SQL_ENTIRE_ROWSET = @as(u32, 0);
pub const SQL_POSITION = @as(u32, 0);
pub const SQL_REFRESH = @as(u32, 1);
pub const SQL_UPDATE = @as(u32, 2);
pub const SQL_DELETE = @as(u32, 3);
pub const SQL_ADD = @as(u32, 4);
pub const SQL_SETPOS_MAX_OPTION_VALUE = @as(u32, 4);
pub const SQL_UPDATE_BY_BOOKMARK = @as(u32, 5);
pub const SQL_DELETE_BY_BOOKMARK = @as(u32, 6);
pub const SQL_FETCH_BY_BOOKMARK = @as(u32, 7);
pub const SQL_LOCK_NO_CHANGE = @as(u32, 0);
pub const SQL_LOCK_EXCLUSIVE = @as(u32, 1);
pub const SQL_LOCK_UNLOCK = @as(u32, 2);
pub const SQL_SETPOS_MAX_LOCK_VALUE = @as(u32, 2);
pub const SQL_BEST_ROWID = @as(u32, 1);
pub const SQL_ROWVER = @as(u32, 2);
pub const SQL_PC_NOT_PSEUDO = @as(u32, 1);
pub const SQL_QUICK = @as(u32, 0);
pub const SQL_ENSURE = @as(u32, 1);
pub const SQL_TABLE_STAT = @as(u32, 0);
pub const SQL_ALL_CATALOGS = "%";
pub const SQL_ALL_SCHEMAS = "%";
pub const SQL_ALL_TABLE_TYPES = "%";
pub const SQL_DRIVER_NOPROMPT = @as(u32, 0);
pub const SQL_DRIVER_COMPLETE = @as(u32, 1);
pub const SQL_DRIVER_PROMPT = @as(u32, 2);
pub const SQL_DRIVER_COMPLETE_REQUIRED = @as(u32, 3);
pub const SQL_FETCH_BOOKMARK = @as(u32, 8);
pub const SQL_ROW_SUCCESS = @as(u32, 0);
pub const SQL_ROW_DELETED = @as(u32, 1);
pub const SQL_ROW_UPDATED = @as(u32, 2);
pub const SQL_ROW_NOROW = @as(u32, 3);
pub const SQL_ROW_ADDED = @as(u32, 4);
pub const SQL_ROW_ERROR = @as(u32, 5);
pub const SQL_ROW_SUCCESS_WITH_INFO = @as(u32, 6);
pub const SQL_ROW_PROCEED = @as(u32, 0);
pub const SQL_ROW_IGNORE = @as(u32, 1);
pub const SQL_PARAM_SUCCESS = @as(u32, 0);
pub const SQL_PARAM_SUCCESS_WITH_INFO = @as(u32, 6);
pub const SQL_PARAM_ERROR = @as(u32, 5);
pub const SQL_PARAM_UNUSED = @as(u32, 7);
pub const SQL_PARAM_DIAG_UNAVAILABLE = @as(u32, 1);
pub const SQL_PARAM_PROCEED = @as(u32, 0);
pub const SQL_PARAM_IGNORE = @as(u32, 1);
pub const SQL_CASCADE = @as(u32, 0);
pub const SQL_RESTRICT = @as(u32, 1);
pub const SQL_SET_NULL = @as(u32, 2);
pub const SQL_NO_ACTION = @as(u32, 3);
pub const SQL_SET_DEFAULT = @as(u32, 4);
pub const SQL_INITIALLY_DEFERRED = @as(u32, 5);
pub const SQL_INITIALLY_IMMEDIATE = @as(u32, 6);
pub const SQL_NOT_DEFERRABLE = @as(u32, 7);
pub const SQL_PARAM_TYPE_UNKNOWN = @as(u32, 0);
pub const SQL_PARAM_INPUT = @as(u32, 1);
pub const SQL_PARAM_INPUT_OUTPUT = @as(u32, 2);
pub const SQL_RESULT_COL = @as(u32, 3);
pub const SQL_PARAM_OUTPUT = @as(u32, 4);
pub const SQL_RETURN_VALUE = @as(u32, 5);
pub const SQL_PARAM_INPUT_OUTPUT_STREAM = @as(u32, 8);
pub const SQL_PARAM_OUTPUT_STREAM = @as(u32, 16);
pub const SQL_PT_UNKNOWN = @as(u32, 0);
pub const SQL_PT_PROCEDURE = @as(u32, 1);
pub const SQL_PT_FUNCTION = @as(u32, 2);
pub const SQL_ODBC_KEYWORDS = "ABSOLUTE,ACTION,ADA,ADD,ALL,ALLOCATE,ALTER,AND,ANY,ARE,AS,ASC,ASSERTION,AT,AUTHORIZATION,AVG,BEGIN,BETWEEN,BIT,BIT_LENGTH,BOTH,BY,CASCADE,CASCADED,CASE,CAST,CATALOG,CHAR,CHAR_LENGTH,CHARACTER,CHARACTER_LENGTH,CHECK,CLOSE,COALESCE,COLLATE,COLLATION,COLUMN,COMMIT,CONNECT,CONNECTION,CONSTRAINT,CONSTRAINTS,CONTINUE,CONVERT,CORRESPONDING,COUNT,CREATE,CROSS,CURRENT,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,CURRENT_USER,CURSOR,DATE,DAY,DEALLOCATE,DEC,DECIMAL,DECLARE,DEFAULT,DEFERRABLE,DEFERRED,DELETE,DESC,DESCRIBE,DESCRIPTOR,DIAGNOSTICS,DISCONNECT,DISTINCT,DOMAIN,DOUBLE,DROP,ELSE,END,END-EXEC,ESCAPE,EXCEPT,EXCEPTION,EXEC,EXECUTE,EXISTS,EXTERNAL,EXTRACT,FALSE,FETCH,FIRST,FLOAT,FOR,FOREIGN,FORTRAN,FOUND,FROM,FULL,GET,GLOBAL,GO,GOTO,GRANT,GROUP,HAVING,HOUR,IDENTITY,IMMEDIATE,IN,INCLUDE,INDEX,INDICATOR,INITIALLY,INNER,INPUT,INSENSITIVE,INSERT,INT,INTEGER,INTERSECT,INTERVAL,INTO,IS,ISOLATION,JOIN,KEY,LANGUAGE,LAST,LEADING,LEFT,LEVEL,LIKE,LOCAL,LOWER,MATCH,MAX,MIN,MINUTE,MODULE,MONTH,NAMES,NATIONAL,NATURAL,NCHAR,NEXT,NO,NONE,NOT,NULL,NULLIF,NUMERIC,OCTET_LENGTH,OF,ON,ONLY,OPEN,OPTION,OR,ORDER,OUTER,OUTPUT,OVERLAPS,PAD,PARTIAL,PASCAL,PLI,POSITION,PRECISION,PREPARE,PRESERVE,PRIMARY,PRIOR,PRIVILEGES,PROCEDURE,PUBLIC,READ,REAL,REFERENCES,RELATIVE,RESTRICT,REVOKE,RIGHT,ROLLBACK,ROWSSCHEMA,SCROLL,SECOND,SECTION,SELECT,SESSION,SESSION_USER,SET,SIZE,SMALLINT,SOME,SPACE,SQL,SQLCA,SQLCODE,SQLERROR,SQLSTATE,SQLWARNING,SUBSTRING,SUM,SYSTEM_USER,TABLE,TEMPORARY,THEN,TIME,TIMESTAMP,TIMEZONE_HOUR,TIMEZONE_MINUTE,TO,TRAILING,TRANSACTION,TRANSLATE,TRANSLATION,TRIM,TRUE,UNION,UNIQUE,UNKNOWN,UPDATE,UPPER,USAGE,USER,USING,VALUE,VALUES,VARCHAR,VARYING,VIEW,WHEN,WHENEVER,WHERE,WITH,WORK,WRITE,YEAR,ZONE";
pub const SQL_YEAR = @as(u32, 1);
pub const SQL_MONTH = @as(u32, 2);
pub const SQL_DAY = @as(u32, 3);
pub const SQL_HOUR = @as(u32, 4);
pub const SQL_MINUTE = @as(u32, 5);
pub const SQL_SECOND = @as(u32, 6);
pub const SQL_YEAR_TO_MONTH = @as(u32, 7);
pub const SQL_DAY_TO_HOUR = @as(u32, 8);
pub const SQL_DAY_TO_MINUTE = @as(u32, 9);
pub const SQL_DAY_TO_SECOND = @as(u32, 10);
pub const SQL_HOUR_TO_MINUTE = @as(u32, 11);
pub const SQL_HOUR_TO_SECOND = @as(u32, 12);
pub const SQL_MINUTE_TO_SECOND = @as(u32, 13);
pub const SQL_DATABASE_NAME = @as(u32, 16);
pub const SQL_FD_FETCH_PREV = @as(i32, 8);
pub const SQL_FETCH_PREV = @as(u32, 4);
pub const SQL_CONCUR_TIMESTAMP = @as(u32, 3);
pub const SQL_SCCO_OPT_TIMESTAMP = @as(i32, 4);
pub const SQL_CC_DELETE = @as(u32, 0);
pub const SQL_CR_DELETE = @as(u32, 0);
pub const SQL_CC_CLOSE = @as(u32, 1);
pub const SQL_CR_CLOSE = @as(u32, 1);
pub const SQL_CC_PRESERVE = @as(u32, 2);
pub const SQL_CR_PRESERVE = @as(u32, 2);
pub const SQL_FETCH_RESUME = @as(u32, 7);
pub const SQL_SCROLL_FORWARD_ONLY = @as(i32, 0);
pub const SQL_SCROLL_KEYSET_DRIVEN = @as(i32, -1);
pub const SQL_SCROLL_DYNAMIC = @as(i32, -2);
pub const SQL_SCROLL_STATIC = @as(i32, -3);
pub const TRACE_VERSION = @as(u32, 1000);
pub const TRACE_ON = @as(i32, 1);
pub const TRACE_VS_EVENT_ON = @as(i32, 2);
pub const ODBC_VS_FLAG_UNICODE_ARG = @as(i32, 1);
pub const ODBC_VS_FLAG_UNICODE_COR = @as(i32, 2);
pub const ODBC_VS_FLAG_RETCODE = @as(i32, 4);
pub const ODBC_VS_FLAG_STOP = @as(i32, 8);
pub const CRESTRICTIONS_DBSCHEMA_LINKEDSERVERS = @as(u32, 1);
pub const SSPROP_ENABLEFASTLOAD = @as(u32, 2);
pub const SSPROP_UNICODELCID = @as(u32, 2);
pub const SSPROP_UNICODECOMPARISONSTYLE = @as(u32, 3);
pub const SSPROP_COLUMNLEVELCOLLATION = @as(u32, 4);
pub const SSPROP_CHARACTERSET = @as(u32, 5);
pub const SSPROP_SORTORDER = @as(u32, 6);
pub const SSPROP_CURRENTCOLLATION = @as(u32, 7);
pub const SSPROP_INIT_CURRENTLANGUAGE = @as(u32, 4);
pub const SSPROP_INIT_NETWORKADDRESS = @as(u32, 5);
pub const SSPROP_INIT_NETWORKLIBRARY = @as(u32, 6);
pub const SSPROP_INIT_USEPROCFORPREP = @as(u32, 7);
pub const SSPROP_INIT_AUTOTRANSLATE = @as(u32, 8);
pub const SSPROP_INIT_PACKETSIZE = @as(u32, 9);
pub const SSPROP_INIT_APPNAME = @as(u32, 10);
pub const SSPROP_INIT_WSID = @as(u32, 11);
pub const SSPROP_INIT_FILENAME = @as(u32, 12);
pub const SSPROP_INIT_ENCRYPT = @as(u32, 13);
pub const SSPROP_AUTH_REPL_SERVER_NAME = @as(u32, 14);
pub const SSPROP_INIT_TAGCOLUMNCOLLATION = @as(u32, 15);
pub const SSPROPVAL_USEPROCFORPREP_OFF = @as(u32, 0);
pub const SSPROPVAL_USEPROCFORPREP_ON = @as(u32, 1);
pub const SSPROPVAL_USEPROCFORPREP_ON_DROP = @as(u32, 2);
pub const SSPROP_QUOTEDCATALOGNAMES = @as(u32, 2);
pub const SSPROP_ALLOWNATIVEVARIANT = @as(u32, 3);
pub const SSPROP_SQLXMLXPROGID = @as(u32, 4);
pub const SSPROP_MAXBLOBLENGTH = @as(u32, 8);
pub const SSPROP_FASTLOADOPTIONS = @as(u32, 9);
pub const SSPROP_FASTLOADKEEPNULLS = @as(u32, 10);
pub const SSPROP_FASTLOADKEEPIDENTITY = @as(u32, 11);
pub const SSPROP_CURSORAUTOFETCH = @as(u32, 12);
pub const SSPROP_DEFERPREPARE = @as(u32, 13);
pub const SSPROP_IRowsetFastLoad = @as(u32, 14);
pub const SSPROP_COL_COLLATIONNAME = @as(u32, 14);
pub const SSPROP_STREAM_MAPPINGSCHEMA = @as(u32, 15);
pub const SSPROP_STREAM_XSL = @as(u32, 16);
pub const SSPROP_STREAM_BASEPATH = @as(u32, 17);
pub const SSPROP_STREAM_COMMANDTYPE = @as(u32, 18);
pub const SSPROP_STREAM_XMLROOT = @as(u32, 19);
pub const SSPROP_STREAM_FLAGS = @as(u32, 20);
pub const SSPROP_STREAM_CONTENTTYPE = @as(u32, 23);
pub const STREAM_FLAGS_DISALLOW_URL = @as(u32, 1);
pub const STREAM_FLAGS_DISALLOW_ABSOLUTE_PATH = @as(u32, 2);
pub const STREAM_FLAGS_DISALLOW_QUERY = @as(u32, 4);
pub const STREAM_FLAGS_DONTCACHEMAPPINGSCHEMA = @as(u32, 8);
pub const STREAM_FLAGS_DONTCACHETEMPLATE = @as(u32, 16);
pub const STREAM_FLAGS_DONTCACHEXSL = @as(u32, 32);
pub const STREAM_FLAGS_DISALLOW_UPDATEGRAMS = @as(u32, 64);
pub const STREAM_FLAGS_RESERVED = @as(u32, 4294901760);
pub const SSPROPVAL_COMMANDTYPE_REGULAR = @as(u32, 21);
pub const SSPROPVAL_COMMANDTYPE_BULKLOAD = @as(u32, 22);
pub const DBTYPE_SQLVARIANT = @as(u32, 144);
pub const SQL_HANDLE_DBC_INFO_TOKEN = @as(u32, 6);
pub const SQL_CONN_POOL_RATING_BEST = @as(u32, 100);
pub const SQL_CONN_POOL_RATING_GOOD_ENOUGH = @as(u32, 99);
pub const SQL_CONN_POOL_RATING_USELESS = @as(u32, 0);
pub const SQL_ATTR_DBC_INFO_TOKEN = @as(u32, 118);
pub const SQL_ATTR_ASYNC_DBC_NOTIFICATION_CALLBACK = @as(u32, 120);
pub const SQL_ATTR_ASYNC_DBC_NOTIFICATION_CONTEXT = @as(u32, 121);
pub const SQL_ATTR_ASYNC_STMT_NOTIFICATION_CALLBACK = @as(u32, 30);
pub const SQL_ATTR_ASYNC_STMT_NOTIFICATION_CONTEXT = @as(u32, 31);
pub const SQL_MAX_NUMERIC_LEN = @as(u32, 16);
pub const SQL_WCHAR = @as(i32, -8);
pub const SQL_WVARCHAR = @as(i32, -9);
pub const SQL_WLONGVARCHAR = @as(i32, -10);
pub const SQL_C_WCHAR = @as(i32, -8);
pub const SQL_C_TCHAR = @as(i32, -8);
pub const SQL_SQLSTATE_SIZEW = @as(u32, 10);
pub const CSTORAGEPROPERTY = @as(u32, 23);
pub const CATEGORY_SEARCH = @as(i32, 1);
pub const CATEGORY_COLLATOR = @as(i32, 2);
pub const CATEGORY_GATHERER = @as(i32, 3);
pub const CATEGORY_INDEXER = @as(i32, 4);
pub const EVENT_SSSEARCH_STARTED = @as(i32, 1073742827);
pub const EVENT_SSSEARCH_STARTING_SETUP = @as(i32, 1073742828);
pub const EVENT_SSSEARCH_SETUP_SUCCEEDED = @as(i32, 1073742829);
pub const EVENT_SSSEARCH_SETUP_FAILED = @as(i32, -1073740818);
pub const EVENT_OUTOFMEMORY = @as(i32, -1073740817);
pub const EVENT_SSSEARCH_SETUP_CLEANUP_STARTED = @as(i32, -2147482640);
pub const EVENT_EXCEPTION = @as(i32, -1073740815);
pub const EVENT_SSSEARCH_SETUP_CLEANUP_SUCCEEDED = @as(i32, 1073742834);
pub const EVENT_SSSEARCH_SETUP_CLEANUP_FAILED = @as(i32, -1073740813);
pub const EVENT_SSSEARCH_STOPPED = @as(i32, 1073742837);
pub const EVENT_SSSEARCH_CREATE_PATH_RULES_FAILED = @as(i32, -2147482634);
pub const EVENT_SSSEARCH_DROPPED_EVENTS = @as(i32, -2147482633);
pub const EVENT_SSSEARCH_DATAFILES_MOVE_FAILED = @as(i32, -1073740808);
pub const EVENT_SSSEARCH_DATAFILES_MOVE_SUCCEEDED = @as(i32, 1073742841);
pub const EVENT_SSSEARCH_DATAFILES_MOVE_ROLLBACK_ERRORS = @as(i32, -2147482630);
pub const EVENT_SSSEARCH_CSM_SAVE_FAILED = @as(i32, -1073740805);
pub const EVENT_CONFIG_SYNTAX = @as(i32, -2147482604);
pub const EVENT_UNPRIVILEGED_SERVICE_ACCOUNT = @as(i32, -2147482596);
pub const EVENT_SYSTEM_EXCEPTION = @as(i32, -2147482595);
pub const EVENT_CONFIG_ERROR = @as(i32, -1073738821);
pub const EVENT_GATHERSVC_PERFMON = @as(i32, -1073738818);
pub const EVENT_GATHERER_PERFMON = @as(i32, -1073738817);
pub const EVENT_HASHMAP_INSERT = @as(i32, -1073738816);
pub const EVENT_TRANSLOG_CREATE_TRX = @as(i32, -1073738815);
pub const EVENT_TRANSLOG_APPEND = @as(i32, -1073738814);
pub const EVENT_TRANSLOG_UPDATE = @as(i32, -1073738813);
pub const EVENT_HASHMAP_UPDATE = @as(i32, -1073738811);
pub const EVENT_GATHER_EXCEPTION = @as(i32, -1073738810);
pub const EVENT_TRANSACTION_READ = @as(i32, -1073738809);
pub const EVENT_GATHER_END_CRAWL = @as(i32, 1073744842);
pub const EVENT_GATHER_START_CRAWL = @as(i32, 1073744843);
pub const EVENT_GATHER_INTERNAL = @as(i32, -1073738804);
pub const EVENT_GATHER_CRAWL_NOT_STARTED = @as(i32, -2147480625);
pub const EVENT_GATHER_CRAWL_SEED_ERROR = @as(i32, -2147480624);
pub const EVENT_GATHER_CRITICAL_ERROR = @as(i32, -1073738799);
pub const EVENT_GATHER_ADVISE_FAILED = @as(i32, -1073738798);
pub const EVENT_GATHER_TRANSACTION_FAIL = @as(i32, -1073738797);
pub const EVENT_GATHER_OBJ_INIT_FAILED = @as(i32, -1073738796);
pub const EVENT_GATHER_PLUGIN_INIT_FAILED = @as(i32, -1073738795);
pub const EVENT_GATHER_SERVICE_INIT = @as(i32, -1073738794);
pub const EVENT_GATHER_CANT_CREATE_DOCID = @as(i32, -1073738793);
pub const EVENT_GATHER_CANT_DELETE_DOCID = @as(i32, -1073738792);
pub const EVENT_TRANSLOG_CREATE = @as(i32, -1073738791);
pub const EVENT_REG_VERSION = @as(i32, -1073738790);
pub const EVENT_GATHER_CRAWL_SEED_FAILED = @as(i32, -2147480612);
pub const EVENT_GATHER_CRAWL_SEED_FAILED_INIT = @as(i32, -2147480611);
pub const EVENT_GATHER_REG_MISSING = @as(i32, -2147480610);
pub const EVENT_GATHER_CRAWL_IN_PROGRESS = @as(i32, -2147480609);
pub const EVENT_GATHER_LOCK_FAILED = @as(i32, -1073738784);
pub const EVENT_GATHER_RESET_START = @as(i32, 1073744865);
pub const EVENT_GATHER_START_PAUSE = @as(i32, -2147480606);
pub const EVENT_GATHER_THROTTLE = @as(i32, 1073744867);
pub const EVENT_GATHER_RESUME = @as(i32, 1073744868);
pub const EVENT_GATHER_AUTODESCLEN_ADJUSTED = @as(i32, -2147480603);
pub const EVENT_GATHER_NO_CRAWL_SEEDS = @as(i32, -2147480602);
pub const EVENT_GATHER_END_INCREMENTAL = @as(i32, 1073744871);
pub const EVENT_GATHER_FROM_NOT_SET = @as(i32, -1073738776);
pub const EVENT_GATHER_DELETING_HISTORY_ITEMS = @as(i32, -1073738774);
pub const EVENT_GATHER_STOP_START = @as(i32, 1073744876);
pub const EVENT_GATHER_START_CRAWL_IF_RESET = @as(i32, -2147480595);
pub const EVENT_GATHER_DISK_FULL = @as(i32, -2147480594);
pub const EVENT_GATHER_NO_SCHEMA = @as(i32, -2147480593);
pub const EVENT_GATHER_AUTODESCENCODE_INVALID = @as(i32, -2147480592);
pub const EVENT_GATHER_PLUGINMGR_INIT_FAILED = @as(i32, -1073738767);
pub const EVENT_GATHER_APP_INIT_FAILED = @as(i32, -1073738766);
pub const EVENT_FAILED_INITIALIZE_CRAWL = @as(i32, -1073738765);
pub const EVENT_CRAWL_SCHEDULED = @as(i32, 1073744884);
pub const EVENT_FAILED_CREATE_GATHERER_LOG = @as(i32, -2147480587);
pub const EVENT_WBREAKER_NOT_LOADED = @as(i32, -2147480586);
pub const EVENT_LEARN_PROPAGATION_COPY_FAILED = @as(i32, -2147480585);
pub const EVENT_LEARN_CREATE_DB_FAILED = @as(i32, -2147480584);
pub const EVENT_LEARN_COMPILE_FAILED = @as(i32, -2147480583);
pub const EVENT_LEARN_PROPAGATION_FAILED = @as(i32, -2147480582);
pub const EVENT_GATHER_END_ADAPTIVE = @as(i32, 1073744891);
pub const EVENT_USING_DIFFERENT_WORD_BREAKER = @as(i32, -2147480580);
pub const EVENT_GATHER_RESTORE_COMPLETE = @as(i32, 3069);
pub const EVENT_GATHER_RESTORE_ERROR = @as(i32, -1073738754);
pub const EVENT_AUTOCAT_PERFMON = @as(i32, -1073738753);
pub const EVENT_GATHER_DIRTY_STARTUP = @as(i32, -2147480576);
pub const EVENT_GATHER_HISTORY_CORRUPTION_DETECTED = @as(i32, -2147480575);
pub const EVENT_GATHER_RESTOREAPP_ERROR = @as(i32, -1073738750);
pub const EVENT_GATHER_RESTOREAPP_COMPLETE = @as(i32, 3075);
pub const EVENT_GATHER_BACKUPAPP_ERROR = @as(i32, -1073738748);
pub const EVENT_GATHER_BACKUPAPP_COMPLETE = @as(i32, 3077);
pub const EVENT_GATHER_DAEMON_TERMINATED = @as(i32, -2147480570);
pub const EVENT_NOTIFICATION_FAILURE = @as(i32, -1073738745);
pub const EVENT_NOTIFICATION_FAILURE_SCOPE_EXCEEDED_LOGGING = @as(i32, -2147480568);
pub const EVENT_NOTIFICATION_RESTORED = @as(i32, 1073744905);
pub const EVENT_NOTIFICATION_RESTORED_SCOPE_EXCEEDED_LOGGING = @as(i32, -2147480566);
pub const EVENT_GATHER_PROTOCOLHANDLER_LOAD_FAILED = @as(i32, -1073738741);
pub const EVENT_GATHER_PROTOCOLHANDLER_INIT_FAILED = @as(i32, -1073738740);
pub const EVENT_GATHER_INVALID_NETWORK_ACCESS_ACCOUNT = @as(i32, -1073738739);
pub const EVENT_GATHER_SYSTEM_LCID_CHANGED = @as(i32, -2147480562);
pub const EVENT_GATHER_FLUSH_FAILED = @as(i32, -1073738737);
pub const EVENT_GATHER_CHECKPOINT_FAILED = @as(i32, -1073738736);
pub const EVENT_GATHER_SAVE_FAILED = @as(i32, -1073738735);
pub const EVENT_GATHER_RESTORE_CHECKPOINT_FAILED = @as(i32, -1073738734);
pub const EVENT_GATHER_READ_CHECKPOINT_FAILED = @as(i32, -1073738733);
pub const EVENT_GATHER_CHECKPOINT_CORRUPT = @as(i32, -1073738732);
pub const EVENT_GATHER_CHECKPOINT_FILE_MISSING = @as(i32, -1073738731);
pub const EVENT_STS_INIT_SECURITY_FAILED = @as(i32, -2147480554);
pub const EVENT_LOCAL_GROUP_NOT_EXPANDED = @as(i32, 1073744919);
pub const EVENT_LOCAL_GROUPS_CACHE_FLUSHED = @as(i32, 1073744920);
pub const EVENT_GATHERER_DATASOURCE = @as(i32, -1073738727);
pub const EVENT_AUTOCAT_CANT_CREATE_FILE_SHARE = @as(i32, -1073738726);
pub const EVENT_NOTIFICATION_THREAD_EXIT_FAILED = @as(i32, -1073738725);
pub const EVENT_FILTER_HOST_NOT_INITIALIZED = @as(i32, -1073738724);
pub const EVENT_FILTER_HOST_NOT_TERMINATED = @as(i32, -1073738723);
pub const EVENT_FILTERPOOL_ADD_FAILED = @as(i32, -1073738722);
pub const EVENT_FILTERPOOL_DELETE_FAILED = @as(i32, -1073738721);
pub const EVENT_ENUMERATE_SESSIONS_FAILED = @as(i32, -1073738720);
pub const EVENT_DETAILED_FILTERPOOL_ADD_FAILED = @as(i32, -1073738719);
pub const EVENT_AUDIENCECOMPUTATION_CANNOTSTART = @as(i32, -1073738223);
pub const EVENT_GATHER_RECOVERY_FAILURE = @as(i32, -1073738222);
pub const EVENT_INDEXER_STARTED = @as(i32, 1073748824);
pub const EVENT_INDEXER_SCHEMA_COPY_ERROR = @as(i32, -1073734823);
pub const EVENT_INDEXER_INIT_ERROR = @as(i32, -1073734814);
pub const EVENT_INDEXER_INVALID_DIRECTORY = @as(i32, -1073734813);
pub const EVENT_INDEXER_PROP_ERROR = @as(i32, -1073734812);
pub const EVENT_INDEXER_PAUSED_FOR_DISKFULL = @as(i32, -1073734811);
pub const EVENT_INDEXER_PROP_STOPPED = @as(i32, -2147476633);
pub const EVENT_INDEXER_PROP_SUCCEEDED = @as(i32, 7016);
pub const EVENT_INDEXER_PROP_STARTED = @as(i32, 1073748841);
pub const EVENT_INDEXER_NO_SEARCH_SERVERS = @as(i32, -2147476630);
pub const EVENT_INDEXER_ADD_DSS_SUCCEEDED = @as(i32, 7019);
pub const EVENT_INDEXER_REMOVE_DSS_SUCCEEDED = @as(i32, 7020);
pub const EVENT_INDEXER_ADD_DSS_FAILED = @as(i32, -2147476627);
pub const EVENT_INDEXER_REMOVE_DSS_FAILED = @as(i32, -1073734801);
pub const EVENT_INDEXER_DSS_CONTACT_FAILED = @as(i32, -1073734800);
pub const EVENT_INDEXER_BUILD_FAILED = @as(i32, -1073734797);
pub const EVENT_INDEXER_REG_MISSING = @as(i32, -1073734796);
pub const EVENT_INDEXER_PROPSTORE_INIT_FAILED = @as(i32, -1073734787);
pub const EVENT_INDEXER_CI_LOAD_ERROR = @as(i32, -1073734785);
pub const EVENT_INDEXER_RESET_FOR_CORRUPTION = @as(i32, -1073734784);
pub const EVENT_INDEXER_SHUTDOWN = @as(i32, 1073748866);
pub const EVENT_INDEXER_LOAD_FAIL = @as(i32, -1073734781);
pub const EVENT_INDEXER_PROP_STATE_CORRUPT = @as(i32, -1073734780);
pub const EVENT_INDEXER_DSS_ALREADY_ADDED = @as(i32, 1073748870);
pub const EVENT_INDEXER_BUILD_START = @as(i32, 1073748872);
pub const EVENT_INDEXER_BUILD_ENDED = @as(i32, 1073748873);
pub const EVENT_INDEXER_VERIFY_PROP_ACCOUNT = @as(i32, -1073734768);
pub const EVENT_INDEXER_ADD_DSS_DISCONNECT = @as(i32, -2147476585);
pub const EVENT_INDEXER_PERFMON = @as(i32, -1073734760);
pub const EVENT_INDEXER_MISSING_APP_DIRECTORY = @as(i32, -1073734758);
pub const EVENT_INDEXER_REG_ERROR = @as(i32, -1073734756);
pub const EVENT_INDEXER_DSS_UNABLE_TO_REMOVE = @as(i32, -1073734755);
pub const EVENT_INDEXER_NEW_PROJECT = @as(i32, -1073734754);
pub const EVENT_INDEXER_REMOVED_PROJECT = @as(i32, -1073734753);
pub const EVENT_INDEXER_PROP_COMMITTED = @as(i32, 1073748898);
pub const EVENT_INDEXER_PROP_ABORTED = @as(i32, 1073748899);
pub const EVENT_DSS_NOT_ENABLED = @as(i32, -2147476572);
pub const EVENT_INDEXER_PROP_COMMIT_FAILED = @as(i32, -1073734747);
pub const JET_INIT_ERROR = @as(i32, -1073732824);
pub const JET_NEW_PROP_STORE_ERROR = @as(i32, -1073732823);
pub const JET_GET_PROP_STORE_ERROR = @as(i32, -1073732822);
pub const JET_MULTIINSTANCE_DISABLED = @as(i32, -2147474645);
pub const EVENT_WARNING_CANNOT_UPGRADE_NOISE_FILES = @as(i32, -2147473635);
pub const EVENT_WARNING_CANNOT_UPGRADE_NOISE_FILE = @as(i32, -2147473634);
pub const EVENT_WIN32_ERROR = @as(i32, -2147473633);
pub const EVENT_PERF_COUNTERS_NOT_LOADED = @as(i32, -2147473628);
pub const EVENT_PERF_COUNTERS_REGISTRY_TROUBLE = @as(i32, -2147473627);
pub const EVENT_PERF_COUNTERS_ALREADY_EXISTS = @as(i32, -2147473626);
pub const EVENT_PROTOCOL_HOST_FORCE_TERMINATE = @as(i32, -2147473625);
pub const EVENT_FILTER_HOST_FORCE_TERMINATE = @as(i32, -2147473624);
pub const EVENT_INDEXER_OUT_OF_DATABASE_INSTANCE = @as(i32, -1073731799);
pub const EVENT_INDEXER_FAIL_TO_SET_MAX_JETINSTANCE = @as(i32, -1073731798);
pub const EVENT_INDEXER_FAIL_TO_CREATE_PER_USER_CATALOG = @as(i32, -1073731797);
pub const EVENT_INDEXER_FAIL_TO_UNLOAD_PER_USER_CATALOG = @as(i32, -1073731796);
pub const ERROR_SOURCE_NETWORKING = @as(u32, 768);
pub const ERROR_SOURCE_DATASOURCE = @as(u32, 1024);
pub const ERROR_SOURCE_COLLATOR = @as(u32, 1280);
pub const ERROR_SOURCE_CONNMGR = @as(u32, 1536);
pub const ERROR_SOURCE_QUERY = @as(u32, 1792);
pub const ERROR_SOURCE_SCHEMA = @as(u32, 3072);
pub const ERROR_SOURCE_GATHERER = @as(u32, 3328);
pub const ERROR_SOURCE_INDEXER = @as(u32, 4352);
pub const ERROR_SOURCE_SETUP = @as(u32, 4864);
pub const ERROR_SOURCE_SECURITY = @as(u32, 5120);
pub const ERROR_SOURCE_CMDLINE = @as(u32, 5376);
pub const ERROR_SOURCE_NLADMIN = @as(u32, 6400);
pub const ERROR_SOURCE_SCRIPTPI = @as(u32, 8192);
pub const ERROR_SOURCE_MSS = @as(u32, 8448);
pub const ERROR_SOURCE_XML = @as(u32, 8704);
pub const ERROR_SOURCE_DAV = @as(u32, 8960);
pub const ERROR_SOURCE_FLTRDMN = @as(u32, 9216);
pub const ERROR_SOURCE_OLEDB_BINDER = @as(u32, 9472);
pub const ERROR_SOURCE_NOTESPH = @as(u32, 9728);
pub const ERROR_SOURCE_EXSTOREPH = @as(u32, 9984);
pub const ERROR_SOURCE_SRCH_SCHEMA_CACHE = @as(u32, 13056);
pub const ERROR_SOURCE_CONTENT_SOURCE = @as(u32, 13312);
pub const ERROR_SOURCE_REMOTE_EXSTOREPH = @as(u32, 13568);
pub const ERROR_SOURCE_PEOPLE_IMPORT = @as(u32, 16384);
pub const ERROR_FTE = @as(u32, 13824);
pub const ERROR_FTE_CB = @as(u32, 51968);
pub const ERROR_FTE_FD = @as(u32, 64768);
pub const XML_E_NODEFAULTNS = @as(i32, -2147212800);
pub const XML_E_BADSXQL = @as(i32, -2147212799);
pub const MSS_E_INVALIDAPPNAME = @as(i32, -2147213056);
pub const MSS_E_APPNOTFOUND = @as(i32, -2147213055);
pub const MSS_E_APPALREADYEXISTS = @as(i32, -2147213054);
pub const MSS_E_CATALOGNOTFOUND = @as(i32, -2147213053);
pub const MSS_E_CATALOGSTOPPING = @as(i32, -2147213052);
pub const MSS_E_UNICODEFILEHEADERMISSING = @as(i32, -2147213051);
pub const MSS_E_CATALOGALREADYEXISTS = @as(i32, -2147213050);
pub const NET_E_GENERAL = @as(i32, -2147220736);
pub const NET_E_DISCONNECTED = @as(i32, -2147220733);
pub const NET_E_INVALIDPARAMS = @as(i32, -2147220728);
pub const NET_E_OPERATIONINPROGRESS = @as(i32, -2147220727);
pub const SEC_E_INVALIDCONTEXT = @as(i32, -2147216381);
pub const SEC_E_INITFAILED = @as(i32, -2147216383);
pub const SEC_E_NOTINITIALIZED = @as(i32, -2147216382);
pub const SEC_E_ACCESSDENIED = @as(i32, -2147216129);
pub const DS_E_NOMOREDATA = @as(i32, -2147220480);
pub const DS_E_INVALIDDATASOURCE = @as(i32, -2147220479);
pub const DS_E_DATASOURCENOTAVAILABLE = @as(i32, -2147220478);
pub const DS_E_QUERYCANCELED = @as(i32, -2147220477);
pub const DS_E_UNKNOWNREQUEST = @as(i32, -2147220476);
pub const DS_E_BADREQUEST = @as(i32, -2147220475);
pub const DS_E_SERVERCAPACITY = @as(i32, -2147220474);
pub const DS_E_BADSEQUENCE = @as(i32, -2147220473);
pub const DS_E_MESSAGETOOLONG = @as(i32, -2147220472);
pub const DS_E_SERVERERROR = @as(i32, -2147220471);
pub const DS_E_CONFIGBAD = @as(i32, -2147220470);
pub const DS_E_DATANOTPRESENT = @as(i32, -2147220464);
pub const DS_E_SETSTATUSINPROGRESS = @as(i32, -2147220463);
pub const DS_E_DUPLICATEID = @as(i32, -2147220462);
pub const DS_E_TOOMANYDATASOURCES = @as(i32, -2147220461);
pub const DS_E_REGISTRY = @as(i32, -2147220460);
pub const DS_E_DATASOURCENOTDISABLED = @as(i32, -2147220459);
pub const DS_E_INVALIDTAGDB = @as(i32, -2147220458);
pub const DS_E_INVALIDCATALOGNAME = @as(i32, -2147220457);
pub const DS_E_CONFIGNOTRIGHTTYPE = @as(i32, -2147220456);
pub const DS_E_PROTOCOLVERSION = @as(i32, -2147220455);
pub const DS_E_ALREADYENABLED = @as(i32, -2147220454);
pub const DS_E_INDEXDIRECTORY = @as(i32, -2147220452);
pub const DS_E_VALUETOOLARGE = @as(i32, -2147220451);
pub const DS_E_UNKNOWNPARAM = @as(i32, -2147220450);
pub const DS_E_BUFFERTOOSMALL = @as(i32, -2147220449);
pub const DS_E_PARAMOUTOFRANGE = @as(i32, -2147220448);
pub const DS_E_ALREADYDISABLED = @as(i32, -2147220447);
pub const DS_E_QUERYHUNG = @as(i32, -2147220446);
pub const DS_E_BADRESULT = @as(i32, -2147220445);
pub const DS_E_CANNOTWRITEREGISTRY = @as(i32, -2147220444);
pub const DS_E_CANNOTREMOVECONCURRENT = @as(i32, -2147220443);
pub const DS_E_SEARCHCATNAMECOLLISION = @as(i32, -2147220442);
pub const DS_E_PROPVERSIONMISMATCH = @as(i32, -2147220441);
pub const DS_E_MISSINGCATALOG = @as(i32, -2147220440);
pub const COLL_E_BADSEQUENCE = @as(i32, -2147220223);
pub const COLL_E_NOMOREDATA = @as(i32, -2147220222);
pub const COLL_E_INCOMPATIBLECOLUMNS = @as(i32, -2147220221);
pub const COLL_E_BUFFERTOOSMALL = @as(i32, -2147220220);
pub const COLL_E_BADRESULT = @as(i32, -2147220218);
pub const COLL_E_NOSORTCOLUMN = @as(i32, -2147220217);
pub const COLL_E_DUPLICATEDBID = @as(i32, -2147220216);
pub const COLL_E_TOOMANYMERGECOLUMNS = @as(i32, -2147220215);
pub const COLL_E_NODEFAULTCATALOG = @as(i32, -2147220214);
pub const COLL_E_MAXCONNEXCEEDED = @as(i32, -2147220213);
pub const CM_E_TOOMANYDATASERVERS = @as(i32, -2147219967);
pub const CM_E_TOOMANYDATASOURCES = @as(i32, -2147219966);
pub const CM_E_NOQUERYCONNECTIONS = @as(i32, -2147219965);
pub const CM_E_DATASOURCENOTAVAILABLE = @as(i32, -2147219964);
pub const CM_E_CONNECTIONTIMEOUT = @as(i32, -2147219963);
pub const CM_E_SERVERNOTFOUND = @as(i32, -2147219962);
pub const CM_S_NODATASERVERS = @as(i32, 263687);
pub const CM_E_REGISTRY = @as(i32, -2147219960);
pub const CM_E_INVALIDDATASOURCE = @as(i32, -2147219959);
pub const CM_E_TIMEOUT = @as(i32, -2147219958);
pub const CM_E_INSUFFICIENTBUFFER = @as(i32, -2147219957);
pub const QRY_E_QUERYSYNTAX = @as(i32, -2147219711);
pub const QRY_E_TYPEMISMATCH = @as(i32, -2147219710);
pub const QRY_E_UNHANDLEDTYPE = @as(i32, -2147219709);
pub const QRY_S_NOROWSFOUND = @as(i32, 263940);
pub const QRY_E_TOOMANYCOLUMNS = @as(i32, -2147219707);
pub const QRY_E_TOOMANYDATABASES = @as(i32, -2147219706);
pub const QRY_E_STARTHITTOBIG = @as(i32, -2147219705);
pub const QRY_E_TOOMANYQUERYTERMS = @as(i32, -2147219704);
pub const QRY_E_NODATASOURCES = @as(i32, -2147219703);
pub const QRY_E_TIMEOUT = @as(i32, -2147219702);
pub const QRY_E_COLUMNNOTSORTABLE = @as(i32, -2147219701);
pub const QRY_E_COLUMNNOTSEARCHABLE = @as(i32, -2147219700);
pub const QRY_E_INVALIDCOLUMN = @as(i32, -2147219699);
pub const QRY_E_QUERYCORRUPT = @as(i32, -2147219698);
pub const QRY_E_PREFIXWILDCARD = @as(i32, -2147219697);
pub const QRY_E_INFIXWILDCARD = @as(i32, -2147219696);
pub const QRY_E_WILDCARDPREFIXLENGTH = @as(i32, -2147219695);
pub const QRY_S_TERMIGNORED = @as(i32, 263954);
pub const QRY_E_ENGINEFAILED = @as(i32, -2147219693);
pub const QRY_E_SEARCHTOOBIG = @as(i32, -2147219692);
pub const QRY_E_NULLQUERY = @as(i32, -2147219691);
pub const QRY_S_INEXACTRESULTS = @as(i32, 263958);
pub const QRY_E_NOCOLUMNS = @as(i32, -2147219689);
pub const QRY_E_INVALIDSCOPES = @as(i32, -2147219688);
pub const QRY_E_INVALIDCATALOG = @as(i32, -2147219687);
pub const QRY_E_SCOPECARDINALIDY = @as(i32, -2147219686);
pub const QRY_E_UNEXPECTED = @as(i32, -2147219685);
pub const QRY_E_INVALIDPATH = @as(i32, -2147219684);
pub const QRY_E_LMNOTINITIALIZED = @as(i32, -2147219683);
pub const QRY_E_INVALIDINTERVAL = @as(i32, -2147219682);
pub const QRY_E_NOLOGMANAGER = @as(i32, -2147219681);
pub const SCHEMA_E_LOAD_SPECIAL = @as(i32, -2147218431);
pub const SCHEMA_E_FILENOTFOUND = @as(i32, -2147218430);
pub const SCHEMA_E_NESTEDTAG = @as(i32, -2147218429);
pub const SCHEMA_E_UNEXPECTEDTAG = @as(i32, -2147218428);
pub const SCHEMA_E_VERSIONMISMATCH = @as(i32, -2147218427);
pub const SCHEMA_E_CANNOTCREATEFILE = @as(i32, -2147218426);
pub const SCHEMA_E_CANNOTWRITEFILE = @as(i32, -2147218425);
pub const SCHEMA_E_EMPTYFILE = @as(i32, -2147218424);
pub const SCHEMA_E_INVALIDFILETYPE = @as(i32, -2147218423);
pub const SCHEMA_E_INVALIDDATATYPE = @as(i32, -2147218422);
pub const SCHEMA_E_CANNOTCREATENOISEWORDFILE = @as(i32, -2147218421);
pub const SCHEMA_E_ADDSTOPWORDS = @as(i32, -2147218420);
pub const SCHEMA_E_NAMEEXISTS = @as(i32, -2147218419);
pub const SCHEMA_E_INVALIDVALUE = @as(i32, -2147218418);
pub const SCHEMA_E_BADPROPSPEC = @as(i32, -2147218417);
pub const SCHEMA_E_NOMORECOLUMNS = @as(i32, -2147218416);
pub const SCHEMA_E_FILECHANGED = @as(i32, -2147218415);
pub const SCHEMA_E_BADCOLUMNNAME = @as(i32, -2147218414);
pub const SCHEMA_E_BADPROPPID = @as(i32, -2147218413);
pub const SCHEMA_E_BADATTRIBUTE = @as(i32, -2147218412);
pub const SCHEMA_E_BADFILENAME = @as(i32, -2147218411);
pub const SCHEMA_E_PROPEXISTS = @as(i32, -2147218410);
pub const SCHEMA_E_DUPLICATENOISE = @as(i32, -2147218409);
pub const GTHR_E_DUPLICATE_OBJECT = @as(i32, -2147218174);
pub const GTHR_E_UNABLE_TO_READ_REGISTRY = @as(i32, -2147218173);
pub const GTHR_E_ERROR_WRITING_REGISTRY = @as(i32, -2147218172);
pub const GTHR_E_ERROR_INITIALIZING_PERFMON = @as(i32, -2147218171);
pub const GTHR_E_ERROR_OBJECT_NOT_FOUND = @as(i32, -2147218170);
pub const GTHR_E_URL_EXCLUDED = @as(i32, -2147218169);
pub const GTHR_E_CONFIG_DUP_PROJECT = @as(i32, -2147218166);
pub const GTHR_E_CONFIG_DUP_EXTENSION = @as(i32, -2147218165);
pub const GTHR_E_DUPLICATE_URL = @as(i32, -2147218163);
pub const GTHR_E_TOO_MANY_PLUGINS = @as(i32, -2147218162);
pub const GTHR_E_INVALIDFUNCTION = @as(i32, -2147218161);
pub const GTHR_E_NOFILTERSINK = @as(i32, -2147218160);
pub const GTHR_E_FILTER_PROCESS_TERMINATED = @as(i32, -2147218159);
pub const GTHR_E_FILTER_INVALID_MESSAGE = @as(i32, -2147218158);
pub const GTHR_E_UNSUPPORTED_PROPERTY_TYPE = @as(i32, -2147218157);
pub const GTHR_E_NAME_TOO_LONG = @as(i32, -2147218156);
pub const GTHR_E_NO_IDENTITY = @as(i32, -2147218155);
pub const GTHR_E_FILTER_NOT_FOUND = @as(i32, -2147218154);
pub const GTHR_E_FILTER_NO_MORE_THREADS = @as(i32, -2147218153);
pub const GTHR_E_PRT_HNDLR_PROGID_MISSING = @as(i32, -2147218152);
pub const GTHR_E_FILTER_PROCESS_TERMINATED_QUOTA = @as(i32, -2147218151);
pub const GTHR_E_UNKNOWN_PROTOCOL = @as(i32, -2147218150);
pub const GTHR_E_PROJECT_NOT_INITIALIZED = @as(i32, -2147218149);
pub const GTHR_S_STATUS_CHANGE_IGNORED = @as(i32, 265500);
pub const GTHR_S_STATUS_END_CRAWL = @as(i32, 265501);
pub const GTHR_S_STATUS_RESET = @as(i32, 265502);
pub const GTHR_S_STATUS_THROTTLE = @as(i32, 265503);
pub const GTHR_S_STATUS_RESUME = @as(i32, 265504);
pub const GTHR_S_STATUS_PAUSE = @as(i32, 265505);
pub const GTHR_E_INVALID_PROJECT_NAME = @as(i32, -2147218142);
pub const GTHR_E_SHUTTING_DOWN = @as(i32, -2147218141);
pub const GTHR_S_END_STD_CHUNKS = @as(i32, 265508);
pub const GTHR_E_VALUE_NOT_AVAILABLE = @as(i32, -2147218139);
pub const GTHR_E_OUT_OF_DOC_ID = @as(i32, -2147218138);
pub const GTHR_E_NOTIFICATION_START_PAGE = @as(i32, -2147218137);
pub const GTHR_E_DUP_PROPERTY_MAPPING = @as(i32, -2147218134);
pub const GTHR_S_NO_CRAWL_SEEDS = @as(i32, 265515);
pub const GTHR_E_INVALID_ACCOUNT = @as(i32, -2147218132);
pub const GTHR_E_FILTER_INIT = @as(i32, -2147218130);
pub const GTHR_E_INVALID_ACCOUNT_SYNTAX = @as(i32, -2147218129);
pub const GTHR_S_CANNOT_FILTER = @as(i32, 265520);
pub const GTHR_E_PROXY_NAME = @as(i32, -2147218127);
pub const GTHR_E_SERVER_UNAVAILABLE = @as(i32, -2147218126);
pub const GTHR_S_STATUS_STOP = @as(i32, 265523);
pub const GTHR_E_INVALID_PATH = @as(i32, -2147218124);
pub const GTHR_E_FILTER_NO_CODEPAGE = @as(i32, -2147218123);
pub const GTHR_S_STATUS_START = @as(i32, 265526);
pub const GTHR_E_NO_PRTCLHNLR = @as(i32, -2147218121);
pub const GTHR_E_IE_OFFLINE = @as(i32, -2147218120);
pub const GTHR_E_BAD_FILTER_DAEMON = @as(i32, -2147218119);
pub const GTHR_E_INVALID_MAPPING = @as(i32, -2147218112);
pub const GTHR_E_USER_AGENT_NOT_SPECIFIED = @as(i32, -2147218111);
pub const GTHR_E_FROM_NOT_SPECIFIED = @as(i32, -2147218109);
pub const GTHR_E_INVALID_STREAM_LOGS_COUNT = @as(i32, -2147218108);
pub const GTHR_E_INVALID_EXTENSION = @as(i32, -2147218107);
pub const GTHR_E_INVALID_GROW_FACTOR = @as(i32, -2147218106);
pub const GTHR_E_INVALID_TIME_OUT = @as(i32, -2147218105);
pub const GTHR_E_INVALID_RETRIES = @as(i32, -2147218104);
pub const GTHR_E_INVALID_LOG_FILE_NAME = @as(i32, -2147218103);
pub const GTHR_E_INVALID_HOST_NAME = @as(i32, -2147218096);
pub const GTHR_E_INVALID_START_PAGE = @as(i32, -2147218095);
pub const GTHR_E_DUPLICATE_PROJECT = @as(i32, -2147218094);
pub const GTHR_E_INVALID_DIRECTORY = @as(i32, -2147218093);
pub const GTHR_E_FILTER_INTERRUPTED = @as(i32, -2147218092);
pub const GTHR_E_INVALID_PROXY_PORT = @as(i32, -2147218091);
pub const GTHR_S_CONFIG_HAS_ACCOUNTS = @as(i32, 265558);
pub const GTHR_E_SECRET_NOT_FOUND = @as(i32, -2147218089);
pub const GTHR_E_INVALID_PATH_EXPRESSION = @as(i32, -2147218088);
pub const GTHR_E_INVALID_START_PAGE_HOST = @as(i32, -2147218087);
pub const GTHR_E_INVALID_START_PAGE_PATH = @as(i32, -2147218080);
pub const GTHR_E_APPLICATION_NOT_FOUND = @as(i32, -2147218079);
pub const GTHR_E_CANNOT_REMOVE_PLUGINMGR = @as(i32, -2147218078);
pub const GTHR_E_INVALID_APPLICATION_NAME = @as(i32, -2147218077);
pub const GTHR_E_FILTER_FAULT = @as(i32, -2147218075);
pub const GTHR_E_NON_FIXED_DRIVE = @as(i32, -2147218074);
pub const GTHR_S_PROB_NOT_MODIFIED = @as(i32, 265575);
pub const GTHR_S_CRAWL_SCHEDULED = @as(i32, 265576);
pub const GTHR_S_TRANSACTION_IGNORED = @as(i32, 265577);
pub const GTHR_S_START_FILTER_FROM_PROTOCOL = @as(i32, 265578);
pub const GTHR_E_FILTER_SINGLE_THREADED = @as(i32, -2147218069);
pub const GTHR_S_BAD_FILE_LINK = @as(i32, 265580);
pub const GTHR_E_URL_UNIDENTIFIED = @as(i32, -2147218067);
pub const GTHR_S_NOT_ALL_PARTS = @as(i32, 265582);
pub const GTHR_E_FORCE_NOTIFICATION_RESET = @as(i32, -2147218065);
pub const GTHR_S_END_PROCESS_LOOP_NOTIFY_QUEUE = @as(i32, 265584);
pub const GTHR_S_START_FILTER_FROM_BODY = @as(i32, 265585);
pub const GTHR_E_CONTENT_ID_CONFLICT = @as(i32, -2147218062);
pub const GTHR_E_UNABLE_TO_READ_EXCHANGE_STORE = @as(i32, -2147218061);
pub const GTHR_E_RECOVERABLE_EXOLEDB_ERROR = @as(i32, -2147218060);
pub const GTHR_E_INVALID_CALL_FROM_WBREAKER = @as(i32, -2147218058);
pub const GTHR_E_PROPERTY_LIST_NOT_INITIALIZED = @as(i32, -2147218057);
pub const GTHR_S_MODIFIED_PARTS = @as(i32, 265592);
pub const GHTR_E_LOCAL_SERVER_UNAVAILABLE = @as(i32, -2147218055);
pub const GTHR_E_SCHEMA_ERRORS_OCCURRED = @as(i32, -2147218054);
pub const GTHR_E_TIMEOUT = @as(i32, -2147218053);
pub const GTHR_S_CRAWL_FULL = @as(i32, 265603);
pub const GTHR_S_CRAWL_INCREMENTAL = @as(i32, 265604);
pub const GTHR_S_CRAWL_ADAPTIVE = @as(i32, 265605);
pub const GTHR_E_NOTIFICATION_START_ADDRESS_INVALID = @as(i32, -2147218042);
pub const GTHR_E_NOTIFICATION_TYPE_NOT_SUPPORTED = @as(i32, -2147218041);
pub const GTHR_E_NOTIFICATION_FILE_SHARE_INFO_NOT_AVAILABLE = @as(i32, -2147218040);
pub const GTHR_E_NOTIFICATION_LOCAL_PATH_MUST_USE_FIXED_DRIVE = @as(i32, -2147218039);
pub const GHTR_E_INSUFFICIENT_DISK_SPACE = @as(i32, -2147218037);
pub const GTHR_E_INVALID_RESOURCE_ID = @as(i32, -2147218035);
pub const GTHR_E_NESTED_HIERARCHICAL_START_ADDRESSES = @as(i32, -2147218034);
pub const GTHR_S_NO_INDEX = @as(i32, 265616);
pub const GTHR_S_PAUSE_REASON_EXTERNAL = @as(i32, 265618);
pub const GTHR_S_PAUSE_REASON_UPGRADING = @as(i32, 265619);
pub const GTHR_S_PAUSE_REASON_BACKOFF = @as(i32, 265620);
pub const GTHR_E_RETRY = @as(i32, -2147218027);
pub const GTHR_E_JET_BACKUP_ERROR = @as(i32, -2147218026);
pub const GTHR_E_JET_RESTORE_ERROR = @as(i32, -2147218025);
pub const GTHR_S_OFFICE_CHILD = @as(i32, 265626);
pub const GTHR_E_PLUGIN_NOT_REGISTERED = @as(i32, -2147218021);
pub const GTHR_E_NOTIF_ACCESS_TOKEN_UPDATED = @as(i32, -2147218020);
pub const GTHR_E_DIRMON_NOT_INITIALZED = @as(i32, -2147218019);
pub const GTHR_E_NOTIF_BEING_REMOVED = @as(i32, -2147218018);
pub const GTHR_E_NOTIF_EXCESSIVE_THROUGHPUT = @as(i32, -2147218017);
pub const GTHR_E_INVALID_PATH_SPEC = @as(i32, -2147218016);
pub const GTHR_E_INSUFFICIENT_FEATURE_TERMS = @as(i32, -2147218015);
pub const GTHR_E_INSUFFICIENT_EXAMPLE_CATEGORIES = @as(i32, -2147218014);
pub const GTHR_E_INSUFFICIENT_EXAMPLE_DOCUMENTS = @as(i32, -2147218013);
pub const GTHR_E_AUTOCAT_UNEXPECTED = @as(i32, -2147218012);
pub const GTHR_E_SINGLE_THREADED_EMBEDDING = @as(i32, -2147218011);
pub const GTHR_S_CANNOT_WORDBREAK = @as(i32, 265638);
pub const GTHR_S_USE_MIME_FILTER = @as(i32, 265639);
pub const GTHR_E_FOLDER_CRAWLED_BY_ANOTHER_WORKSPACE = @as(i32, -2147218007);
pub const GTHR_E_EMPTY_DACL = @as(i32, -2147218006);
pub const GTHR_E_OBJECT_NOT_VALID = @as(i32, -2147218005);
pub const GTHR_E_CANNOT_ENABLE_CHECKPOINT = @as(i32, -2147218002);
pub const GTHR_E_SCOPES_EXCEEDED = @as(i32, -2147218001);
pub const GTHR_E_PROPERTIES_EXCEEDED = @as(i32, -2147218000);
pub const GTHR_E_INVALID_START_ADDRESS = @as(i32, -2147217998);
pub const GTHR_S_PAUSE_REASON_PROFILE_IMPORT = @as(i32, 265651);
pub const GTHR_E_PIPE_NOT_CONNECTTED = @as(i32, -2147217996);
pub const GTHR_E_BACKUP_VALIDATION_FAIL = @as(i32, -2147217994);
pub const GTHR_E_BAD_FILTER_HOST = @as(i32, -2147217993);
pub const GTHR_E_NTF_CLIENT_NOT_SUBSCRIBED = @as(i32, -1073476167);
pub const GTHR_E_FILTERPOOL_NOTFOUND = @as(i32, -2147217990);
pub const GTHR_E_ADDLINKS_FAILED_WILL_RETRY_PARENT = @as(i32, -2147217989);
pub const IDX_E_INVALIDTAG = @as(i32, -2147217151);
pub const IDX_E_METAFILE_CORRUPT = @as(i32, -2147217150);
pub const IDX_E_TOO_MANY_SEARCH_SERVERS = @as(i32, -2147217149);
pub const IDX_E_SEARCH_SERVER_ALREADY_EXISTS = @as(i32, -2147217148);
pub const IDX_E_BUILD_IN_PROGRESS = @as(i32, -2147217147);
pub const IDX_E_IDXLSTFILE_CORRUPT = @as(i32, -2147217146);
pub const IDX_E_REGISTRY_ENTRY = @as(i32, -2147217145);
pub const IDX_E_OBJECT_NOT_FOUND = @as(i32, -2147217144);
pub const IDX_E_SEARCH_SERVER_NOT_FOUND = @as(i32, -2147217143);
pub const IDX_E_WB_NOTFOUND = @as(i32, -2147217142);
pub const IDX_E_NOISELIST_NOTFOUND = @as(i32, -2147217141);
pub const IDX_E_STEMMER_NOTFOUND = @as(i32, -2147217140);
pub const IDX_E_PROP_STOPPED = @as(i32, -2147217139);
pub const IDX_E_DISKFULL = @as(i32, -2147217138);
pub const IDX_E_INVALID_INDEX = @as(i32, -2147217137);
pub const IDX_E_CORRUPT_INDEX = @as(i32, -2147217136);
pub const IDX_E_PROPSTORE_INIT_FAILED = @as(i32, -2147217134);
pub const IDX_E_PROP_STATE_CORRUPT = @as(i32, -2147217133);
pub const IDX_S_NO_BUILD_IN_PROGRESS = @as(i32, 266516);
pub const IDX_S_SEARCH_SERVER_ALREADY_EXISTS = @as(i32, 266517);
pub const IDX_S_SEARCH_SERVER_DOES_NOT_EXIST = @as(i32, 266518);
pub const IDX_E_NOT_LOADED = @as(i32, -2147217129);
pub const IDX_E_PROP_MAJOR_VERSION_MISMATCH = @as(i32, -2147217128);
pub const IDX_E_PROP_MINOR_VERSION_MISMATCH = @as(i32, -2147217127);
pub const IDX_E_DSS_NOT_CONNECTED = @as(i32, -2147217126);
pub const IDX_E_DOCUMENT_ABORTED = @as(i32, -2147217125);
pub const IDX_E_CATALOG_DISMOUNTED = @as(i32, -2147217124);
pub const IDX_S_DSS_NOT_AVAILABLE = @as(i32, 266525);
pub const IDX_E_USE_DEFAULT_CONTENTCLASS = @as(i32, -2147217121);
pub const IDX_E_USE_APPGLOBAL_PROPTABLE = @as(i32, -2147217120);
pub const JPS_E_JET_ERR = @as(i32, -2147217025);
pub const JPS_S_DUPLICATE_DOC_DETECTED = @as(i32, 266624);
pub const JPS_E_CATALOG_DECSRIPTION_MISSING = @as(i32, -2147217023);
pub const JPS_E_MISSING_INFORMATION = @as(i32, -2147217022);
pub const JPS_E_INSUFFICIENT_VERSION_STORAGE = @as(i32, -2147217021);
pub const JPS_E_INSUFFICIENT_DATABASE_SESSIONS = @as(i32, -2147217020);
pub const JPS_E_INSUFFICIENT_DATABASE_RESOURCES = @as(i32, -2147217019);
pub const JPS_E_SCHEMA_ERROR = @as(i32, -2147217018);
pub const JPS_E_PROPAGATION_FILE = @as(i32, -2147217017);
pub const JPS_E_PROPAGATION_CORRUPTION = @as(i32, -2147217016);
pub const JPS_E_PROPAGATION_VERSION_MISMATCH = @as(i32, -2147217015);
pub const JPS_E_SHARING_VIOLATION = @as(i32, -2147217014);
pub const EXCI_E_NO_CONFIG = @as(i32, -2147216992);
pub const EXCI_E_INVALID_SERVER_CONFIG = @as(i32, -2147216991);
pub const EXCI_E_ACCESS_DENIED = @as(i32, -2147216990);
pub const EXCI_E_INVALID_EXCHANGE_SERVER = @as(i32, -2147216989);
pub const EXCI_E_BADCONFIG_OR_ACCESSDENIED = @as(i32, -2147216988);
pub const EXCI_E_WRONG_SERVER_OR_ACCT = @as(i32, -2147216987);
pub const EXCI_E_NOT_ADMIN_OR_WRONG_SITE = @as(i32, -2147216986);
pub const EXCI_E_NO_MAPI = @as(i32, -2147216985);
pub const EXCI_E_INVALID_ACCOUNT_INFO = @as(i32, -2147216984);
pub const PRTH_E_INTERNAL_ERROR = @as(i32, -2147216892);
pub const PRTH_S_MAX_GROWTH = @as(i32, 266761);
pub const PRTH_E_WININET = @as(i32, -2147216886);
pub const PRTH_E_RETRY = @as(i32, -2147216885);
pub const PRTH_S_MAX_DOWNLOAD = @as(i32, 266764);
pub const PRTH_E_MIME_EXCLUDED = @as(i32, -2147216883);
pub const PRTH_E_CANT_TRANSFORM_EXTERNAL_ACL = @as(i32, -2147216882);
pub const PRTH_E_CANT_TRANSFORM_DENIED_ACE = @as(i32, -2147216881);
pub const PRTH_E_NO_PROPERTY = @as(i32, -2147216877);
pub const PRTH_S_USE_ROSEBUD = @as(i32, 266772);
pub const PRTH_E_DATABASE_OPEN_ERROR = @as(i32, -2147216875);
pub const PRTH_E_OPLOCK_BROKEN = @as(i32, -2147216874);
pub const PRTH_E_LOAD_FAILED = @as(i32, -2147216873);
pub const PRTH_E_INIT_FAILED = @as(i32, -2147216872);
pub const PRTH_E_VOLUME_MOUNT_POINT = @as(i32, -2147216871);
pub const PRTH_E_TRUNCATED = @as(i32, -2147216870);
pub const GTHR_E_LOCAL_GROUPS_EXPANSION_INTERNAL_ERROR = @as(i32, -2147216867);
pub const PRTH_E_HTTPS_CERTIFICATE_ERROR = @as(i32, -2147216861);
pub const PRTH_E_HTTPS_REQUIRE_CERTIFICATE = @as(i32, -2147216860);
pub const PRTH_S_TRY_IMPERSONATING = @as(i32, 266789);
pub const CMDLINE_E_UNEXPECTED = @as(i32, -2147216127);
pub const CMDLINE_E_PAREN = @as(i32, -2147216126);
pub const CMDLINE_E_PARAM_SIZE = @as(i32, -2147216125);
pub const CMDLINE_E_NOT_INIT = @as(i32, -2147216124);
pub const CMDLINE_E_ALREADY_INIT = @as(i32, -2147216123);
pub const CMDLINE_E_NUM_PARAMS = @as(i32, -2147216122);
pub const NLADMIN_E_DUPLICATE_CATALOG = @as(i32, -2147215103);
pub const NLADMIN_S_NOT_ALL_BUILD_CATALOGS_INITIALIZED = @as(i32, 268546);
pub const NLADMIN_E_FAILED_TO_GIVE_ACCOUNT_PRIVILEGE = @as(i32, -2147215101);
pub const NLADMIN_E_BUILD_CATALOG_NOT_INITIALIZED = @as(i32, -2147215100);
pub const SCRIPTPI_E_CHUNK_NOT_TEXT = @as(i32, -2147213312);
pub const SCRIPTPI_E_PID_NOT_NAME = @as(i32, -2147213311);
pub const SCRIPTPI_E_PID_NOT_NUMERIC = @as(i32, -2147213310);
pub const SCRIPTPI_E_CHUNK_NOT_VALUE = @as(i32, -2147213309);
pub const SCRIPTPI_E_CANNOT_ALTER_CHUNK = @as(i32, -2147213308);
pub const SCRIPTPI_E_ALREADY_COMPLETED = @as(i32, -2147213307);
pub const _MAPI_E_NO_SUPPORT = @as(i32, -2147221246);
pub const _MAPI_E_BAD_CHARWIDTH = @as(i32, -2147221245);
pub const _MAPI_E_STRING_TOO_LONG = @as(i32, -2147221243);
pub const _MAPI_E_UNKNOWN_FLAGS = @as(i32, -2147221242);
pub const _MAPI_E_INVALID_ENTRYID = @as(i32, -2147221241);
pub const _MAPI_E_INVALID_OBJECT = @as(i32, -2147221240);
pub const _MAPI_E_OBJECT_CHANGED = @as(i32, -2147221239);
pub const _MAPI_E_OBJECT_DELETED = @as(i32, -2147221238);
pub const _MAPI_E_BUSY = @as(i32, -2147221237);
pub const _MAPI_E_NOT_ENOUGH_DISK = @as(i32, -2147221235);
pub const _MAPI_E_NOT_ENOUGH_RESOURCES = @as(i32, -2147221234);
pub const _MAPI_E_NOT_FOUND = @as(i32, -2147221233);
pub const _MAPI_E_VERSION = @as(i32, -2147221232);
pub const _MAPI_E_LOGON_FAILED = @as(i32, -2147221231);
pub const _MAPI_E_SESSION_LIMIT = @as(i32, -2147221230);
pub const _MAPI_E_USER_CANCEL = @as(i32, -2147221229);
pub const _MAPI_E_UNABLE_TO_ABORT = @as(i32, -2147221228);
pub const _MAPI_E_NETWORK_ERROR = @as(i32, -2147221227);
pub const _MAPI_E_DISK_ERROR = @as(i32, -2147221226);
pub const _MAPI_E_TOO_COMPLEX = @as(i32, -2147221225);
pub const _MAPI_E_BAD_COLUMN = @as(i32, -2147221224);
pub const _MAPI_E_EXTENDED_ERROR = @as(i32, -2147221223);
pub const _MAPI_E_COMPUTED = @as(i32, -2147221222);
pub const _MAPI_E_CORRUPT_DATA = @as(i32, -2147221221);
pub const _MAPI_E_UNCONFIGURED = @as(i32, -2147221220);
pub const _MAPI_E_FAILONEPROVIDER = @as(i32, -2147221219);
pub const _MAPI_E_UNKNOWN_CPID = @as(i32, -2147221218);
pub const _MAPI_E_UNKNOWN_LCID = @as(i32, -2147221217);
pub const _MAPI_E_PASSWORD_CHANGE_REQUIRED = @as(i32, -2147221216);
pub const _MAPI_E_PASSWORD_EXPIRED = @as(i32, -2147221215);
pub const _MAPI_E_INVALID_WORKSTATION_ACCOUNT = @as(i32, -2147221214);
pub const _MAPI_E_INVALID_ACCESS_TIME = @as(i32, -2147221213);
pub const _MAPI_E_ACCOUNT_DISABLED = @as(i32, -2147221212);
pub const _MAPI_E_END_OF_SESSION = @as(i32, -2147220992);
pub const _MAPI_E_UNKNOWN_ENTRYID = @as(i32, -2147220991);
pub const _MAPI_E_MISSING_REQUIRED_COLUMN = @as(i32, -2147220990);
pub const _MAPI_W_NO_SERVICE = @as(i32, 262659);
pub const MSG_TEST_MESSAGE = @as(i32, 1074008064);
pub const FLTRDMN_E_UNEXPECTED = @as(i32, -2147212287);
pub const FLTRDMN_E_QI_FILTER_FAILED = @as(i32, -2147212286);
pub const FLTRDMN_E_FILTER_INIT_FAILED = @as(i32, -2147212284);
pub const FLTRDMN_E_ENCRYPTED_DOCUMENT = @as(i32, -2147212283);
pub const FLTRDMN_E_CANNOT_DECRYPT_PASSWORD = @as(i32, -2147212282);
pub const OLEDB_BINDER_CUSTOM_ERROR = @as(i32, -2147212032);
pub const NOTESPH_E_UNEXPECTED_STATE = @as(i32, -2147211775);
pub const NOTESPH_S_IGNORE_ID = @as(i32, 271874);
pub const NOTESPH_E_UNSUPPORTED_CONTENT_FIELD_TYPE = @as(i32, -2147211773);
pub const NOTESPH_E_ITEM_NOT_FOUND = @as(i32, -2147211772);
pub const NOTESPH_E_SERVER_CONFIG = @as(i32, -2147211771);
pub const NOTESPH_E_ATTACHMENTS = @as(i32, -2147211770);
pub const NOTESPH_E_NO_NTID = @as(i32, -2147211769);
pub const NOTESPH_E_DB_ACCESS_DENIED = @as(i32, -2147211768);
pub const NOTESPH_E_NOTESSETUP_ID_MAPPING_ERROR = @as(i32, -2147211767);
pub const NOTESPH_S_LISTKNOWNFIELDS = @as(i32, 271888);
pub const NOTESPH_E_FAIL = @as(i32, -2147211759);
pub const STS_ABORTXMLPARSE = @as(i32, -2147211756);
pub const STS_WS_ERROR = @as(i32, -2147211754);
pub const SPS_WS_ERROR = @as(i32, -2147211753);
pub const EXSTOREPH_E_UNEXPECTED = @as(i32, -2147211519);
pub const CERT_E_NOT_FOUND_OR_NO_PERMISSSION = @as(i32, -2147211263);
pub const SRCH_SCHEMA_CACHE_E_UNEXPECTED = @as(i32, -2147208447);
pub const CONTENT_SOURCE_E_PROPERTY_MAPPING_READ = @as(i32, -2147208191);
pub const CONTENT_SOURCE_E_UNEXPECTED_NULL_POINTER = @as(i32, -2147208190);
pub const CONTENT_SOURCE_E_PROPERTY_MAPPING_BAD_VECTOR_SIZE = @as(i32, -2147208189);
pub const CONTENT_SOURCE_E_CONTENT_CLASS_READ = @as(i32, -2147208188);
pub const CONTENT_SOURCE_E_UNEXPECTED_EXCEPTION = @as(i32, -2147208187);
pub const CONTENT_SOURCE_E_NULL_CONTENT_CLASS_BSTR = @as(i32, -2147208186);
pub const CONTENT_SOURCE_E_CONTENT_SOURCE_COLUMN_TYPE = @as(i32, -2147208185);
pub const CONTENT_SOURCE_E_OUT_OF_RANGE = @as(i32, -2147208184);
pub const CONTENT_SOURCE_E_NULL_URI = @as(i32, -2147208183);
pub const REXSPH_E_INVALID_CALL = @as(i32, -2147207936);
pub const REXSPH_S_REDIRECTED = @as(i32, 275713);
pub const REXSPH_E_REDIRECT_ON_SECURITY_UPDATE = @as(i32, -2147207934);
pub const REXSPH_E_MULTIPLE_REDIRECT = @as(i32, -2147207933);
pub const REXSPH_E_NO_PROPERTY_ON_ROW = @as(i32, -2147207932);
pub const REXSPH_E_TYPE_MISMATCH_ON_READ = @as(i32, -2147207931);
pub const REXSPH_E_UNEXPECTED_DATA_STATUS = @as(i32, -2147207930);
pub const REXSPH_E_UNKNOWN_DATA_TYPE = @as(i32, -2147207929);
pub const REXSPH_E_UNEXPECTED_FILTER_STATE = @as(i32, -2147207928);
pub const REXSPH_E_DUPLICATE_PROPERTY = @as(i32, -2147207927);
pub const PEOPLE_IMPORT_E_DBCONNFAIL = @as(i32, -2147205120);
pub const PEOPLE_IMPORT_NODSDEFINED = @as(i32, -2147205119);
pub const PEOPLE_IMPORT_E_FAILTOGETDSDEF = @as(i32, -2147205118);
pub const PEOPLE_IMPORT_NOMAPPINGDEFINED = @as(i32, -2147205117);
pub const PEOPLE_IMPORT_E_FAILTOGETDSMAPPING = @as(i32, -2147205116);
pub const PEOPLE_IMPORT_E_DATATYPENOTSUPPORTED = @as(i32, -2147205115);
pub const PEOPLE_IMPORT_E_NOCASTINGSUPPORTED = @as(i32, -2147205114);
pub const PEOPLE_IMPORT_E_UPDATE_DIRSYNC_COOKIE = @as(i32, -2147205113);
pub const PEOPLE_IMPORT_E_DIRSYNC_ZERO_COOKIE = @as(i32, -2147205112);
pub const PEOPLE_IMPORT_E_LDAPPATH_TOOLONG = @as(i32, -2147205111);
pub const PEOPLE_IMPORT_E_CANONICALURL_TOOLONG = @as(i32, -2147205110);
pub const PEOPLE_IMPORT_E_USERNAME_NOTRESOLVED = @as(i32, -2147205109);
pub const PEOPLE_IMPORT_E_DC_NOT_AVAILABLE = @as(i32, -2147205108);
pub const PEOPLE_IMPORT_E_DOMAIN_DISCOVER_FAILED = @as(i32, -2147205107);
pub const PEOPLE_IMPORT_E_FAILTOGETLCID = @as(i32, -2147205106);
pub const PEOPLE_IMPORT_E_DOMAIN_REMOVED = @as(i32, -2147205105);
pub const PEOPLE_IMPORT_E_ENUM_ACCESSDENIED = @as(i32, -2147205104);
pub const PEOPLE_IMPORT_E_DIRSYNC_NOTREFRESHED = @as(i32, -2147205103);
pub const FTE_E_SECRET_NOT_FOUND = @as(i32, -2147207678);
pub const FTE_E_PIPE_NOT_CONNECTED = @as(i32, -2147207677);
pub const FTE_E_ADMIN_BLOB_CORRUPT = @as(i32, -2147207676);
pub const FTE_E_FILTER_SINGLE_THREADED = @as(i32, -2147207675);
pub const FTE_E_ERROR_WRITING_REGISTRY = @as(i32, -2147207674);
pub const FTE_E_PROJECT_SHUTDOWN = @as(i32, -2147207673);
pub const FTE_E_PROJECT_NOT_INITALIZED = @as(i32, -2147207672);
pub const FTE_E_PIPE_DATA_CORRUPTED = @as(i32, -2147207671);
pub const FTE_E_URB_TOO_BIG = @as(i32, -2147207664);
pub const FTE_E_INVALID_DOCID = @as(i32, -2147207663);
pub const FTE_E_PAUSE_EXTERNAL = @as(i32, -2147207662);
pub const FTE_E_REJECTED_DUE_TO_PROJECT_STATUS = @as(i32, -2147207661);
pub const FTE_E_FD_DID_NOT_CONNECT = @as(i32, -2147207660);
pub const FTE_E_PROGID_REQUIRED = @as(i32, -2147207658);
pub const FTE_E_STATIC_THREAD_INVALID_ARGUMENTS = @as(i32, -2147207657);
pub const FTE_E_CATALOG_ALREADY_EXISTS = @as(i32, -2147207656);
pub const FTE_S_RESOURCES_STARTING_TO_GET_LOW = @as(i32, 275993);
pub const FTE_E_PATH_TOO_LONG = @as(i32, -2147207654);
pub const FTE_INVALID_ADMIN_CLIENT = @as(i32, -2147207653);
pub const FTE_E_COM_SIGNATURE_VALIDATION = @as(i32, -2147207652);
pub const FTE_E_AFFINITY_MASK = @as(i32, -2147207651);
pub const FTE_E_FD_OWNERSHIP_OBSOLETE = @as(i32, -2147207650);
pub const FTE_E_EXCEEDED_MAX_PLUGINS = @as(i32, -2147207647);
pub const FTE_S_BEYOND_QUOTA = @as(i32, 276002);
pub const FTE_E_DUPLICATE_OBJECT = @as(i32, -2147207644);
pub const FTE_S_REDUNDANT = @as(i32, 276005);
pub const FTE_E_REDUNDANT_TRAN_FAILURE = @as(i32, -2147207642);
pub const FTE_E_DEPENDENT_TRAN_FAILED_TO_PERSIST = @as(i32, -2147207641);
pub const FTE_E_FD_SHUTDOWN = @as(i32, -2147207640);
pub const FTE_E_CATALOG_DOES_NOT_EXIST = @as(i32, -2147207639);
pub const FTE_E_NO_PLUGINS = @as(i32, -2147207638);
pub const FTE_S_STATUS_CHANGE_REQUEST = @as(i32, 276011);
pub const FTE_E_BATCH_ABORTED = @as(i32, -2147207636);
pub const FTE_E_ANOTHER_STATUS_CHANGE_IS_ALREADY_ACTIVE = @as(i32, -2147207635);
pub const FTE_S_RESUME = @as(i32, 276014);
pub const FTE_E_NOT_PROCESSED_DUE_TO_PREVIOUS_ERRORS = @as(i32, -2147207633);
pub const FTE_E_FD_TIMEOUT = @as(i32, -2147207632);
pub const FTE_E_RESOURCE_SHUTDOWN = @as(i32, -2147207631);
pub const FTE_E_INVALID_PROPERTY = @as(i32, -2147207630);
pub const FTE_E_NO_MORE_PROPERTIES = @as(i32, -2147207629);
pub const FTE_E_UNKNOWN_PLUGIN = @as(i32, -2147207628);
pub const FTE_E_LIBRARY_NOT_LOADED = @as(i32, -2147207627);
pub const FTE_E_PERFMON_FULL = @as(i32, -2147207626);
pub const FTE_E_FAILED_TO_CREATE_ACCESSOR = @as(i32, -2147207625);
pub const FTE_E_INVALID_TYPE = @as(i32, -2147207624);
pub const FTE_E_OUT_OF_RANGE = @as(i32, -2147207623);
pub const FTE_E_CORRUPT_PROPERTY_STORE = @as(i32, -2147207622);
pub const FTE_E_PROPERTY_STORE_WORKID_NOTVALID = @as(i32, -2147207621);
pub const FTE_S_PROPERTY_STORE_END_OF_ENUMERATION = @as(i32, 276028);
pub const FTE_E_CORRUPT_GATHERER_HASH_MAP = @as(i32, -2147207619);
pub const FTE_E_KEY_NOT_CACHED = @as(i32, -2147207618);
pub const FTE_E_UPGRADE_INTERFACE_ALREADY_SHUTDOWN = @as(i32, -2147207617);
pub const FTE_E_UPGRADE_INTERFACE_ALREADY_INSTANTIATED = @as(i32, -2147207616);
pub const FTE_E_STACK_CORRUPTED = @as(i32, -2147207615);
pub const FTE_E_INVALID_PROG_ID = @as(i32, -2147207614);
pub const FTE_E_SERIAL_STREAM_CORRUPT = @as(i32, -2147207613);
pub const FTE_E_READONLY_CATALOG = @as(i32, -2147207612);
pub const FTE_E_PERF_NOT_LOADED = @as(i32, -2147207611);
pub const FTE_S_READONLY_CATALOG = @as(i32, 276038);
pub const FTE_E_RETRY_HUGE_DOC = @as(i32, -2147207608);
pub const FTE_E_UNKNOWN_FD_TYPE = @as(i32, -2147207607);
pub const FTE_E_DOC_TOO_HUGE = @as(i32, -2147207606);
pub const FTE_E_DATATYPE_MISALIGNMENT = @as(i32, -2147207605);
pub const FTE_E_ALREADY_INITIALIZED = @as(i32, -2147207604);
pub const FTE_E_FD_USED_TOO_MUCH_MEMORY = @as(i32, -2147207603);
pub const FTE_E_UNEXPECTED_EXIT = @as(i32, -2147207602);
pub const FTE_E_HIGH_MEMORY_PRESSURE = @as(i32, -2147207601);
pub const FTE_E_INVALID_ISOLATE_ERROR_BATCH = @as(i32, -2147207600);
pub const FTE_E_RETRY_SINGLE_DOC_PER_BATCH = @as(i32, -2147207599);
pub const FTE_E_INVALID_PROJECT_ID = @as(i32, -2147207598);
pub const FTE_E_FAILURE_TO_POST_SETCOMPLETION_STATUS = @as(i32, -2147207597);
pub const FTE_E_INVALID_CODEPAGE = @as(i32, -2147207596);
pub const FTE_E_FD_IDLE = @as(i32, -2147207595);
pub const FTE_E_FD_UNRESPONSIVE = @as(i32, -2147207594);
pub const FTE_S_TRY_TO_FLUSH = @as(i32, 276055);
pub const FTE_S_CATALOG_BLOB_MISMATCHED = @as(i32, 276056);
pub const FTE_S_PROPERTY_RESET = @as(i32, 276057);
pub const FTE_E_NO_PROPERTY_STORE = @as(i32, -1073465766);
pub const FTE_E_CB_OUT_OF_MEMORY = @as(i32, -2147169536);
pub const FTE_E_CB_CBID_OUT_OF_BOUND = @as(i32, -2147169535);
pub const FTE_E_CB_NOT_ENOUGH_AVAIL_PHY_MEM = @as(i32, -2147169534);
pub const FTE_E_CB_NOT_ENOUGH_OCC_BUFFER = @as(i32, -2147169533);
pub const FTE_E_CORRUPT_WORDLIST = @as(i32, -2147169532);
pub const FTE_E_FD_NO_IPERSIST_INTERFACE = @as(i32, -2147156736);
pub const FTE_E_FD_IFILTER_INIT_FAILED = @as(i32, -2147156735);
pub const FTE_E_FD_FAILED_TO_LOAD_IFILTER = @as(i32, -2147156734);
pub const FTE_E_FD_DOC_TIMEOUT = @as(i32, -2147156733);
pub const FTE_E_FD_UNEXPECTED_EXIT = @as(i32, -2147156732);
pub const FTE_E_FD_DOC_UNEXPECTED_EXIT = @as(i32, -2147156731);
pub const FTE_E_FD_NOISE_NO_TEXT_FILTER = @as(i32, -2147156730);
pub const FTE_E_FD_NOISE_NO_IPERSISTSTREAM_ON_TEXT_FILTER = @as(i32, -2147156729);
pub const FTE_E_FD_NOISE_TEXT_FILTER_LOAD_FAILED = @as(i32, -2147156728);
pub const FTE_E_FD_NOISE_TEXT_FILTER_INIT_FAILED = @as(i32, -2147156727);
pub const FTE_E_FD_OCCURRENCE_OVERFLOW = @as(i32, -2147156726);
pub const FTE_E_FD_FILTER_CAUSED_SHARING_VIOLATION = @as(i32, -2147156725);
pub const ERROR_SOURCE_PROTHNDLR = @as(u32, 4608);
pub const QUERY_E_ALLNOISE_AND_NO_RELDOC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215859));
pub const QUERY_E_NO_RELDOC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215858));
pub const QUERY_E_ALLNOISE_AND_NO_RELPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215857));
pub const QUERY_E_NO_RELPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215856));
pub const QUERY_E_REPEATED_RELDOC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215855));
pub const QUERY_E_RELDOC_SYNTAX_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215854));
pub const QUERY_E_INVALID_DOCUMENT_IDENTIFIER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215853));
pub const QUERY_E_INCORRECT_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215852));
pub const QUERY_E_INVALIDSCOPE_COALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215851));
pub const QUERY_E_INVALIDSORT_COALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215850));
pub const QUERY_E_INVALIDCOALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215849));
pub const QUERY_E_UPGRADEINPROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215848));
pub const QUERY_E_AGGREGATE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215847));
pub const QUERY_E_TOP_LEVEL_IN_GROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215846));
pub const QUERY_E_DUPLICATE_RANGE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215845));
pub const CI_S_NEW_AUXMETADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268329));
pub const CI_E_NO_AUXMETADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215318));
pub const CI_S_CLIENT_REQUESTED_ABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268331));
pub const CI_S_RETRY_DOCUMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268332));
pub const CI_E_CORRUPT_FWIDX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473491));
pub const CI_E_DIACRITIC_SETTINGS_DIFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473490));
pub const CI_E_INVALID_CATALOG_LIST_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215313));
pub const CI_S_CATALOG_RESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268336));
pub const CI_E_NO_CATALOG_MANAGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473487));
pub const CI_E_INCONSISTENT_TRANSACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473486));
pub const CI_E_PROTECTED_CATALOG_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473485));
pub const CI_E_NO_PROTECTED_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473484));
pub const CI_E_MULTIPLE_PROTECTED_USERS_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473483));
pub const CI_E_PROTECTED_CATALOG_SID_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473482));
pub const CI_E_PROTECTED_CATALOG_NON_INTERACTIVE_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473481));
pub const MSG_CI_MASTER_MERGE_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745926));
pub const MSG_CI_MASTER_MERGE_COMPLETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745927));
pub const MSG_CI_MASTER_MERGE_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745928));
pub const MSG_CI_MASTER_MERGE_CANT_START = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073737719));
pub const MSG_CI_MASTER_MERGE_CANT_RESTART = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073737718));
pub const MSG_CI_MASTER_MERGE_RESTARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745945));
pub const MSG_CI_CORRUPT_INDEX_COMPONENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745962));
pub const MSG_CI_MASTER_MERGE_ABORTED_LOW_DISK = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745987));
pub const MSG_CI_MASTER_MERGE_REASON_EXTERNAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745988));
pub const MSG_CI_MASTER_MERGE_REASON_INDEX_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745989));
pub const MSG_CI_MASTER_MERGE_REASON_EXPECTED_DOCS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745990));
pub const MSG_CI_MASTER_MERGE_REASON_NUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745991));
pub const MSG_CI_CREATE_SEVER_ITEM_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479480));
pub const NOT_N_PARSE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 526638));
pub const IDS_MON_DEFAULT_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264495));
pub const IDS_MON_ILLEGAL_PASSTHROUGH = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264496));
pub const IDS_MON_PARSE_ERR_1_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264497));
pub const IDS_MON_PARSE_ERR_2_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264498));
pub const IDS_MON_SEMI_COLON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264499));
pub const IDS_MON_ORDINAL_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264500));
pub const IDS_MON_VIEW_NOT_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264501));
pub const IDS_MON_COLUMN_NOT_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264502));
pub const IDS_MON_BUILTIN_VIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264503));
pub const IDS_MON_OUT_OF_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264504));
pub const IDS_MON_SELECT_STAR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264505));
pub const IDS_MON_OR_NOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264506));
pub const IDS_MON_CANNOT_CONVERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264507));
pub const IDS_MON_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264508));
pub const IDS_MON_RELATIVE_INTERVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264509));
pub const IDS_MON_NOT_COLUMN_OF_VIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264510));
pub const IDS_MON_BUILTIN_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264511));
pub const IDS_MON_WEIGHT_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264512));
pub const IDS_MON_MATCH_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264513));
pub const IDS_MON_PROPERTY_NAME_IN_VIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264514));
pub const IDS_MON_VIEW_ALREADY_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264515));
pub const IDS_MON_INVALID_CATALOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264516));
pub const IDS_MON_INVALIDSELECT_COALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264517));
pub const IDS_MON_CANNOT_CAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264518));
pub const IDS_MON_DATE_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264519));
pub const IDS_MON_INVALID_IN_GROUP_CLAUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264520));
pub const DBPROPSET_MSDAORA_ROWSET = Guid.initString("e8cc4cbd-fdff-11d0-b865-00a0c9081c1d");
pub const DBPROPSET_MSDAORA8_ROWSET = Guid.initString("7f06a375-dd6a-43db-b4e0-1fc121e5e62b");
pub const CLSID_MSDASQL = Guid.initString("c8b522cb-5cf3-11ce-ade5-00aa0044773d");
pub const CLSID_MSDASQL_ENUMERATOR = Guid.initString("c8b522cd-5cf3-11ce-ade5-00aa0044773d");
pub const DBPROPSET_PROVIDERDATASOURCEINFO = Guid.initString("497c60e0-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERROWSET = Guid.initString("497c60e1-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERDBINIT = Guid.initString("497c60e2-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERSTMTATTR = Guid.initString("497c60e3-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERCONNATTR = Guid.initString("497c60e4-7123-11cf-b171-00aa0057599e");
pub const CLSID_DataShapeProvider = Guid.initString("3449a1c8-c56c-11d0-ad72-00c04fc29863");
pub const DBPROPSET_MSDSDBINIT = Guid.initString("55cb91a8-5c7a-11d1-adad-00c04fc29863");
pub const DBPROPSET_MSDSSESSION = Guid.initString("edf17536-afbf-11d1-8847-0000f879f98c");
pub const CLSID_MSPersist = Guid.initString("7c07e0d0-4418-11d2-9212-00c04fbbbfb3");
pub const DBPROPSET_PERSIST = Guid.initString("4d7839a0-5b8e-11d1-a6b3-00a0c9138c66");
pub const PROGID_MSPersist_W = "MSPersist";
pub const PROGID_MSPersist_Version_W = "MSPersist.1";
pub const CLSID_SQLOLEDB = Guid.initString("0c7ff16c-38e3-11d0-97ab-00c04fc2ad98");
pub const CLSID_SQLOLEDB_ERROR = Guid.initString("c0932c62-38e5-11d0-97ab-00c04fc2ad98");
pub const CLSID_SQLOLEDB_ENUMERATOR = Guid.initString("dfa22b8e-e68d-11d0-97e4-00c04fc2ad98");
pub const DBGUID_MSSQLXML = Guid.initString("5d531cb2-e6ed-11d2-b252-00c04f681b71");
pub const DBGUID_XPATH = Guid.initString("ec2a4293-e898-11d2-b1b7-00c04f680c56");
pub const DBSCHEMA_LINKEDSERVERS = Guid.initString("9093caf4-2eac-11d1-9809-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERDATASOURCE = Guid.initString("28efaee4-2d2c-11d1-9807-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERDATASOURCEINFO = Guid.initString("df10cb94-35f6-11d2-9c54-00c04f7971d3");
pub const DBPROPSET_SQLSERVERDBINIT = Guid.initString("5cf4ca10-ef21-11d0-97e7-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERROWSET = Guid.initString("5cf4ca11-ef21-11d0-97e7-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERSESSION = Guid.initString("28efaee5-2d2c-11d1-9807-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERCOLUMN = Guid.initString("3b63fb5e-3fbb-11d3-9f29-00c04f8ee9dc");
pub const DBPROPSET_SQLSERVERSTREAM = Guid.initString("9f79c073-8a6d-4bca-a8a8-c9b79a9b962d");

//--------------------------------------------------------------------------------
// Section: Types (437)
//--------------------------------------------------------------------------------
pub const IRowsetExactScroll = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IWordSink_Value = Guid.initString("cc907054-c058-101a-b554-08002b33b0e6");
pub const IID_IWordSink = &IID_IWordSink_Value;
pub const IWordSink = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutWord: *const fn(
            self: *const IWordSink,
            cwc: u32,
            pwcInBuf: ?[*:0]const u16,
            cwcSrcLen: u32,
            cwcSrcPos: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutAltWord: *const fn(
            self: *const IWordSink,
            cwc: u32,
            pwcInBuf: ?[*:0]const u16,
            cwcSrcLen: u32,
            cwcSrcPos: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartAltPhrase: *const fn(
            self: *const IWordSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndAltPhrase: *const fn(
            self: *const IWordSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutBreak: *const fn(
            self: *const IWordSink,
            breakType: WORDREP_BREAK_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn PutWord(self: *const IWordSink, cwc: u32, pwcInBuf: ?[*:0]const u16, cwcSrcLen: u32, cwcSrcPos: u32) callconv(.Inline) HRESULT {
        return self.vtable.PutWord(self, cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
    }
    pub fn PutAltWord(self: *const IWordSink, cwc: u32, pwcInBuf: ?[*:0]const u16, cwcSrcLen: u32, cwcSrcPos: u32) callconv(.Inline) HRESULT {
        return self.vtable.PutAltWord(self, cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
    }
    pub fn StartAltPhrase(self: *const IWordSink) callconv(.Inline) HRESULT {
        return self.vtable.StartAltPhrase(self);
    }
    pub fn EndAltPhrase(self: *const IWordSink) callconv(.Inline) HRESULT {
        return self.vtable.EndAltPhrase(self);
    }
    pub fn PutBreak(self: *const IWordSink, breakType: WORDREP_BREAK_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.PutBreak(self, breakType);
    }
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const PFNFILLTEXTBUFFER = *const fn() callconv(@import("std").os.windows.WINAPI) void;

pub const TEXT_SOURCE = extern struct {
    pfnFillTextBuffer: ?PFNFILLTEXTBUFFER,
    awcBuffer: ?[*:0]const u16,
    iEnd: u32,
    iCur: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWordBreaker_Value = Guid.initString("d53552c8-77e3-101a-b552-08002b33b0e6");
pub const IID_IWordBreaker = &IID_IWordBreaker_Value;
pub const IWordBreaker = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn(
            self: *const IWordBreaker,
            fQuery: BOOL,
            ulMaxTokenSize: u32,
            pfLicense: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BreakText: *const fn(
            self: *const IWordBreaker,
            pTextSource: ?*TEXT_SOURCE,
            pWordSink: ?*IWordSink,
            pPhraseSink: ?*IPhraseSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComposePhrase: *const fn(
            self: *const IWordBreaker,
            pwcNoun: ?[*:0]const u16,
            cwcNoun: u32,
            pwcModifier: ?[*:0]const u16,
            cwcModifier: u32,
            ulAttachmentType: u32,
            pwcPhrase: ?PWSTR,
            pcwcPhrase: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseToUse: *const fn(
            self: *const IWordBreaker,
            ppwcsLicense: ?*const ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Init(self: *const IWordBreaker, fQuery: BOOL, ulMaxTokenSize: u32, pfLicense: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.Init(self, fQuery, ulMaxTokenSize, pfLicense);
    }
    pub fn BreakText(self: *const IWordBreaker, pTextSource: ?*TEXT_SOURCE, pWordSink: ?*IWordSink, pPhraseSink: ?*IPhraseSink) callconv(.Inline) HRESULT {
        return self.vtable.BreakText(self, pTextSource, pWordSink, pPhraseSink);
    }
    pub fn ComposePhrase(self: *const IWordBreaker, pwcNoun: ?[*:0]const u16, cwcNoun: u32, pwcModifier: ?[*:0]const u16, cwcModifier: u32, ulAttachmentType: u32, pwcPhrase: ?PWSTR, pcwcPhrase: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.ComposePhrase(self, pwcNoun, cwcNoun, pwcModifier, cwcModifier, ulAttachmentType, pwcPhrase, pcwcPhrase);
    }
    pub fn GetLicenseToUse(self: *const IWordBreaker, ppwcsLicense: ?*const ?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetLicenseToUse(self, ppwcsLicense);
    }
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWordFormSink_Value = Guid.initString("fe77c330-7f42-11ce-be57-00aa0051fe20");
pub const IID_IWordFormSink = &IID_IWordFormSink_Value;
pub const IWordFormSink = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutAltWord: *const fn(
            self: *const IWordFormSink,
            pwcInBuf: ?[*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutWord: *const fn(
            self: *const IWordFormSink,
            pwcInBuf: ?[*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn PutAltWord(self: *const IWordFormSink, pwcInBuf: ?[*:0]const u16, cwc: u32) callconv(.Inline) HRESULT {
        return self.vtable.PutAltWord(self, pwcInBuf, cwc);
    }
    pub fn PutWord(self: *const IWordFormSink, pwcInBuf: ?[*:0]const u16, cwc: u32) callconv(.Inline) HRESULT {
        return self.vtable.PutWord(self, pwcInBuf, cwc);
    }
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStemmer_Value = Guid.initString("efbaf140-7f42-11ce-be57-00aa0051fe20");
pub const IID_IStemmer = &IID_IStemmer_Value;
pub const IStemmer = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn(
            self: *const IStemmer,
            ulMaxTokenSize: u32,
            pfLicense: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateWordForms: *const fn(
            self: *const IStemmer,
            pwcInBuf: ?[*:0]const u16,
            cwc: u32,
            pStemSink: ?*IWordFormSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseToUse: *const fn(
            self: *const IStemmer,
            ppwcsLicense: ?*const ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Init(self: *const IStemmer, ulMaxTokenSize: u32, pfLicense: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.Init(self, ulMaxTokenSize, pfLicense);
    }
    pub fn GenerateWordForms(self: *const IStemmer, pwcInBuf: ?[*:0]const u16, cwc: u32, pStemSink: ?*IWordFormSink) callconv(.Inline) HRESULT {
        return self.vtable.GenerateWordForms(self, pwcInBuf, cwc, pStemSink);
    }
    pub fn GetLicenseToUse(self: *const IStemmer, ppwcsLicense: ?*const ?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetLicenseToUse(self, ppwcsLicense);
    }
};

const IID_ISimpleCommandCreator_Value = Guid.initString("5e341ab7-02d0-11d1-900c-00a0c9063796");
pub const IID_ISimpleCommandCreator = &IID_ISimpleCommandCreator_Value;
pub const ISimpleCommandCreator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateICommand: *const fn(
            self: *const ISimpleCommandCreator,
            ppIUnknown: ?*?*IUnknown,
            pOuterUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VerifyCatalog: *const fn(
            self: *const ISimpleCommandCreator,
            pwszMachine: ?[*:0]const u16,
            pwszCatalogName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultCatalog: *const fn(
            self: *const ISimpleCommandCreator,
            pwszCatalogName: ?PWSTR,
            cwcIn: u32,
            pcwcOut: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateICommand(self: *const ISimpleCommandCreator, ppIUnknown: ?*?*IUnknown, pOuterUnk: ?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.CreateICommand(self, ppIUnknown, pOuterUnk);
    }
    pub fn VerifyCatalog(self: *const ISimpleCommandCreator, pwszMachine: ?[*:0]const u16, pwszCatalogName: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.VerifyCatalog(self, pwszMachine, pwszCatalogName);
    }
    pub fn GetDefaultCatalog(self: *const ISimpleCommandCreator, pwszCatalogName: ?PWSTR, cwcIn: u32, pcwcOut: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetDefaultCatalog(self, pwszCatalogName, cwcIn, pcwcOut);
    }
};

const IID_IColumnMapper_Value = Guid.initString("0b63e37a-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IColumnMapper = &IID_IColumnMapper_Value;
pub const IColumnMapper = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropInfoFromName: *const fn(
            self: *const IColumnMapper,
            wcsPropName: ?[*:0]const u16,
            ppPropId: ?*?*DBID,
            pPropType: ?*u16,
            puiWidth: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropInfoFromId: *const fn(
            self: *const IColumnMapper,
            pPropId: ?*const DBID,
            pwcsName: ?*?*u16,
            pPropType: ?*u16,
            puiWidth: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPropInfo: *const fn(
            self: *const IColumnMapper,
            iEntry: u32,
            pwcsName: ?*const ?*u16,
            ppPropId: ?*?*DBID,
            pPropType: ?*u16,
            puiWidth: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMapUpToDate: *const fn(
            self: *const IColumnMapper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetPropInfoFromName(self: *const IColumnMapper, wcsPropName: ?[*:0]const u16, ppPropId: ?*?*DBID, pPropType: ?*u16, puiWidth: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetPropInfoFromName(self, wcsPropName, ppPropId, pPropType, puiWidth);
    }
    pub fn GetPropInfoFromId(self: *const IColumnMapper, pPropId: ?*const DBID, pwcsName: ?*?*u16, pPropType: ?*u16, puiWidth: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetPropInfoFromId(self, pPropId, pwcsName, pPropType, puiWidth);
    }
    pub fn EnumPropInfo(self: *const IColumnMapper, iEntry: u32, pwcsName: ?*const ?*u16, ppPropId: ?*?*DBID, pPropType: ?*u16, puiWidth: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.EnumPropInfo(self, iEntry, pwcsName, ppPropId, pPropType, puiWidth);
    }
    pub fn IsMapUpToDate(self: *const IColumnMapper) callconv(.Inline) HRESULT {
        return self.vtable.IsMapUpToDate(self);
    }
};

const IID_IColumnMapperCreator_Value = Guid.initString("0b63e37b-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IColumnMapperCreator = &IID_IColumnMapperCreator_Value;
pub const IColumnMapperCreator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnMapper: *const fn(
            self: *const IColumnMapperCreator,
            wcsMachineName: ?[*:0]const u16,
            wcsCatalogName: ?[*:0]const u16,
            ppColumnMapper: ?*?*IColumnMapper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetColumnMapper(self: *const IColumnMapperCreator, wcsMachineName: ?[*:0]const u16, wcsCatalogName: ?[*:0]const u16, ppColumnMapper: ?*?*IColumnMapper) callconv(.Inline) HRESULT {
        return self.vtable.GetColumnMapper(self, wcsMachineName, wcsCatalogName, ppColumnMapper);
    }
};

const CLSID_CSearchManager_Value = Guid.initString("7d096c5f-ac08-4f1f-beb7-5c22c517ce39");
pub const CLSID_CSearchManager = &CLSID_CSearchManager_Value;

const CLSID_CSearchRoot_Value = Guid.initString("30766bd2-ea1c-4f28-bf27-0b44e2f68db7");
pub const CLSID_CSearchRoot = &CLSID_CSearchRoot_Value;

const CLSID_CSearchScopeRule_Value = Guid.initString("e63de750-3bd7-4be5-9c84-6b4281988c44");
pub const CLSID_CSearchScopeRule = &CLSID_CSearchScopeRule_Value;

const CLSID_FilterRegistration_Value = Guid.initString("9e175b8d-f52a-11d8-b9a5-505054503030");
pub const CLSID_FilterRegistration = &CLSID_FilterRegistration_Value;

pub const FILTERED_DATA_SOURCES = extern struct {
    pwcsExtension: ?[*:0]const u16,
    pwcsMime: ?[*:0]const u16,
    pClsid: ?*const Guid,
    pwcsOverride: ?[*:0]const u16,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ILoadFilter_Value = Guid.initString("c7310722-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_ILoadFilter = &IID_ILoadFilter_Value;
pub const ILoadFilter = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadIFilter: *const fn(
            self: *const ILoadFilter,
            pwcsPath: ?[*:0]const u16,
            pFilteredSources: ?*FILTERED_DATA_SOURCES,
            pUnkOuter: ?*IUnknown,
            fUseDefault: BOOL,
            pFilterClsid: ?*Guid,
            SearchDecSize: ?*i32,
            pwcsSearchDesc: ?*?*u16,
            ppIFilt: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadIFilterFromStorage: *const fn(
            self: *const ILoadFilter,
            pStg: ?*IStorage,
            pUnkOuter: ?*IUnknown,
            pwcsOverride: ?[*:0]const u16,
            fUseDefault: BOOL,
            pFilterClsid: ?*Guid,
            SearchDecSize: ?*i32,
            pwcsSearchDesc: ?*?*u16,
            ppIFilt: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadIFilterFromStream: *const fn(
            self: *const ILoadFilter,
            pStm: ?*IStream,
            pFilteredSources: ?*FILTERED_DATA_SOURCES,
            pUnkOuter: ?*IUnknown,
            fUseDefault: BOOL,
            pFilterClsid: ?*Guid,
            SearchDecSize: ?*i32,
            pwcsSearchDesc: ?*?*u16,
            ppIFilt: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn LoadIFilter(self: *const ILoadFilter, pwcsPath: ?[*:0]const u16, pFilteredSources: ?*FILTERED_DATA_SOURCES, pUnkOuter: ?*IUnknown, fUseDefault: BOOL, pFilterClsid: ?*Guid, SearchDecSize: ?*i32, pwcsSearchDesc: ?*?*u16, ppIFilt: ?*?*IFilter) callconv(.Inline) HRESULT {
        return self.vtable.LoadIFilter(self, pwcsPath, pFilteredSources, pUnkOuter, fUseDefault, pFilterClsid, SearchDecSize, pwcsSearchDesc, ppIFilt);
    }
    pub fn LoadIFilterFromStorage(self: *const ILoadFilter, pStg: ?*IStorage, pUnkOuter: ?*IUnknown, pwcsOverride: ?[*:0]const u16, fUseDefault: BOOL, pFilterClsid: ?*Guid, SearchDecSize: ?*i32, pwcsSearchDesc: ?*?*u16, ppIFilt: ?*?*IFilter) callconv(.Inline) HRESULT {
        return self.vtable.LoadIFilterFromStorage(self, pStg, pUnkOuter, pwcsOverride, fUseDefault, pFilterClsid, SearchDecSize, pwcsSearchDesc, ppIFilt);
    }
    pub fn LoadIFilterFromStream(self: *const ILoadFilter, pStm: ?*IStream, pFilteredSources: ?*FILTERED_DATA_SOURCES, pUnkOuter: ?*IUnknown, fUseDefault: BOOL, pFilterClsid: ?*Guid, SearchDecSize: ?*i32, pwcsSearchDesc: ?*?*u16, ppIFilt: ?*?*IFilter) callconv(.Inline) HRESULT {
        return self.vtable.LoadIFilterFromStream(self, pStm, pFilteredSources, pUnkOuter, fUseDefault, pFilterClsid, SearchDecSize, pwcsSearchDesc, ppIFilt);
    }
};

const IID_ILoadFilterWithPrivateComActivation_Value = Guid.initString("40bdbd34-780b-48d3-9bb6-12ebd4ad2e75");
pub const IID_ILoadFilterWithPrivateComActivation = &IID_ILoadFilterWithPrivateComActivation_Value;
pub const ILoadFilterWithPrivateComActivation = extern union {
    pub const VTable = extern struct {
        base: ILoadFilter.VTable,
        LoadIFilterWithPrivateComActivation: *const fn(
            self: *const ILoadFilterWithPrivateComActivation,
            filteredSources: ?*FILTERED_DATA_SOURCES,
            useDefault: BOOL,
            filterClsid: ?*Guid,
            isFilterPrivateComActivated: ?*BOOL,
            filterObj: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ILoadFilter: ILoadFilter,
    IUnknown: IUnknown,
    pub fn LoadIFilterWithPrivateComActivation(self: *const ILoadFilterWithPrivateComActivation, filteredSources: ?*FILTERED_DATA_SOURCES, useDefault: BOOL, filterClsid: ?*Guid, isFilterPrivateComActivated: ?*BOOL, filterObj: ?*?*IFilter) callconv(.Inline) HRESULT {
        return self.vtable.LoadIFilterWithPrivateComActivation(self, filteredSources, useDefault, filterClsid, isFilterPrivateComActivated, filterObj);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRichChunk_Value = Guid.initString("4fdef69c-dbc9-454e-9910-b34f3c64b510");
pub const IID_IRichChunk = &IID_IRichChunk_Value;
pub const IRichChunk = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: *const fn(
            self: *const IRichChunk,
            pFirstPos: ?*u32,
            pLength: ?*u32,
            ppsz: ?*?PWSTR,
            pValue: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetData(self: *const IRichChunk, pFirstPos: ?*u32, pLength: ?*u32, ppsz: ?*?PWSTR, pValue: ?*PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetData(self, pFirstPos, pLength, ppsz, pValue);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICondition_Value = Guid.initString("0fc988d4-c935-4b97-a973-46282ea175c8");
pub const IID_ICondition = &IID_ICondition_Value;
pub const ICondition = extern union {
    pub const VTable = extern struct {
        base: IPersistStream.VTable,
        GetConditionType: *const fn(
            self: *const ICondition,
            pNodeType: ?*CONDITION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubConditions: *const fn(
            self: *const ICondition,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComparisonInfo: *const fn(
            self: *const ICondition,
            ppszPropertyName: ?*?PWSTR,
            pcop: ?*CONDITION_OPERATION,
            ppropvar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueType: *const fn(
            self: *const ICondition,
            ppszValueTypeName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueNormalization: *const fn(
            self: *const ICondition,
            ppszNormalization: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputTerms: *const fn(
            self: *const ICondition,
            ppPropertyTerm: ?*?*IRichChunk,
            ppOperationTerm: ?*?*IRichChunk,
            ppValueTerm: ?*?*IRichChunk,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn(
            self: *const ICondition,
            ppc: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IPersistStream: IPersistStream,
    IPersist: IPersist,
    IUnknown: IUnknown,
    pub fn GetConditionType(self: *const ICondition, pNodeType: ?*CONDITION_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.GetConditionType(self, pNodeType);
    }
    pub fn GetSubConditions(self: *const ICondition, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetSubConditions(self, riid, ppv);
    }
    pub fn GetComparisonInfo(self: *const ICondition, ppszPropertyName: ?*?PWSTR, pcop: ?*CONDITION_OPERATION, ppropvar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetComparisonInfo(self, ppszPropertyName, pcop, ppropvar);
    }
    pub fn GetValueType(self: *const ICondition, ppszValueTypeName: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetValueType(self, ppszValueTypeName);
    }
    pub fn GetValueNormalization(self: *const ICondition, ppszNormalization: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetValueNormalization(self, ppszNormalization);
    }
    pub fn GetInputTerms(self: *const ICondition, ppPropertyTerm: ?*?*IRichChunk, ppOperationTerm: ?*?*IRichChunk, ppValueTerm: ?*?*IRichChunk) callconv(.Inline) HRESULT {
        return self.vtable.GetInputTerms(self, ppPropertyTerm, ppOperationTerm, ppValueTerm);
    }
    pub fn Clone(self: *const ICondition, ppc: ?*?*ICondition) callconv(.Inline) HRESULT {
        return self.vtable.Clone(self, ppc);
    }
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ICondition2_Value = Guid.initString("0db8851d-2e5b-47eb-9208-d28c325a01d7");
pub const IID_ICondition2 = &IID_ICondition2_Value;
pub const ICondition2 = extern union {
    pub const VTable = extern struct {
        base: ICondition.VTable,
        GetLocale: *const fn(
            self: *const ICondition2,
            ppszLocaleName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeafConditionInfo: *const fn(
            self: *const ICondition2,
            ppropkey: ?*PROPERTYKEY,
            pcop: ?*CONDITION_OPERATION,
            ppropvar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ICondition: ICondition,
    IPersistStream: IPersistStream,
    IPersist: IPersist,
    IUnknown: IUnknown,
    pub fn GetLocale(self: *const ICondition2, ppszLocaleName: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetLocale(self, ppszLocaleName);
    }
    pub fn GetLeafConditionInfo(self: *const ICondition2, ppropkey: ?*PROPERTYKEY, pcop: ?*CONDITION_OPERATION, ppropvar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetLeafConditionInfo(self, ppropkey, pcop, ppropvar);
    }
};

pub const DB_NUMERIC = extern struct {
    precision: u8,
    scale: u8,
    sign: u8,
    val: [16]u8,
};


pub const DBDATE = extern struct {
    year: i16,
    month: u16,
    day: u16,
};

pub const DBTIME = extern struct {
    hour: u16,
    minute: u16,
    second: u16,
};


pub const DB_VARNUMERIC = extern struct {
    precision: u8,
    scale: i8,
    sign: u8,
    val: [1]u8,
};




pub const DBTYPEENUM = enum(i32) {
    EMPTY = 0,
    NULL = 1,
    I2 = 2,
    I4 = 3,
    R4 = 4,
    R8 = 5,
    CY = 6,
    DATE = 7,
    BSTR = 8,
    IDISPATCH = 9,
    ERROR = 10,
    BOOL = 11,
    VARIANT = 12,
    IUNKNOWN = 13,
    DECIMAL = 14,
    UI1 = 17,
    ARRAY = 8192,
    BYREF = 16384,
    I1 = 16,
    UI2 = 18,
    UI4 = 19,
    I8 = 20,
    UI8 = 21,
    GUID = 72,
    VECTOR = 4096,
    RESERVED = 32768,
    BYTES = 128,
    STR = 129,
    WSTR = 130,
    NUMERIC = 131,
    UDT = 132,
    DBDATE = 133,
    DBTIME = 134,
    DBTIMESTAMP = 135,
};
pub const DBTYPE_EMPTY = DBTYPEENUM.EMPTY;
pub const DBTYPE_NULL = DBTYPEENUM.NULL;
pub const DBTYPE_I2 = DBTYPEENUM.I2;
pub const DBTYPE_I4 = DBTYPEENUM.I4;
pub const DBTYPE_R4 = DBTYPEENUM.R4;
pub const DBTYPE_R8 = DBTYPEENUM.R8;
pub const DBTYPE_CY = DBTYPEENUM.CY;
pub const DBTYPE_DATE = DBTYPEENUM.DATE;
pub const DBTYPE_BSTR = DBTYPEENUM.BSTR;
pub const DBTYPE_IDISPATCH = DBTYPEENUM.IDISPATCH;
pub const DBTYPE_ERROR = DBTYPEENUM.ERROR;
pub const DBTYPE_BOOL = DBTYPEENUM.BOOL;
pub const DBTYPE_VARIANT = DBTYPEENUM.VARIANT;
pub const DBTYPE_IUNKNOWN = DBTYPEENUM.IUNKNOWN;
pub const DBTYPE_DECIMAL = DBTYPEENUM.DECIMAL;
pub const DBTYPE_UI1 = DBTYPEENUM.UI1;
pub const DBTYPE_ARRAY = DBTYPEENUM.ARRAY;
pub const DBTYPE_BYREF = DBTYPEENUM.BYREF;
pub const DBTYPE_I1 = DBTYPEENUM.I1;
pub const DBTYPE_UI2 = DBTYPEENUM.UI2;
pub const DBTYPE_UI4 = DBTYPEENUM.UI4;
pub const DBTYPE_I8 = DBTYPEENUM.I8;
pub const DBTYPE_UI8 = DBTYPEENUM.UI8;
pub const DBTYPE_GUID = DBTYPEENUM.GUID;
pub const DBTYPE_VECTOR = DBTYPEENUM.VECTOR;
pub const DBTYPE_RESERVED = DBTYPEENUM.RESERVED;
pub const DBTYPE_BYTES = DBTYPEENUM.BYTES;
pub const DBTYPE_STR = DBTYPEENUM.STR;
pub const DBTYPE_WSTR = DBTYPEENUM.WSTR;
pub const DBTYPE_NUMERIC = DBTYPEENUM.NUMERIC;
pub const DBTYPE_UDT = DBTYPEENUM.UDT;
pub const DBTYPE_DBDATE = DBTYPEENUM.DBDATE;
pub const DBTYPE_DBTIME = DBTYPEENUM.DBTIME;
pub const DBTYPE_DBTIMESTAMP = DBTYPEENUM.DBTIMESTAMP;

pub const DBTYPEENUM15 = enum(i32) {
    R = 136,
};
pub const DBTYPE_HCHAPTER = DBTYPEENUM15.R;

pub const DBTYPEENUM20 = enum(i32) {
    FILETIME = 64,
    PROPVARIANT = 138,
    VARNUMERIC = 139,
};
pub const DBTYPE_FILETIME = DBTYPEENUM20.FILETIME;
pub const DBTYPE_PROPVARIANT = DBTYPEENUM20.PROPVARIANT;
pub const DBTYPE_VARNUMERIC = DBTYPEENUM20.VARNUMERIC;

pub const DBPARTENUM = enum(i32) {
    INVALID = 0,
    VALUE = 1,
    LENGTH = 2,
    STATUS = 4,
};
pub const DBPART_INVALID = DBPARTENUM.INVALID;
pub const DBPART_VALUE = DBPARTENUM.VALUE;
pub const DBPART_LENGTH = DBPARTENUM.LENGTH;
pub const DBPART_STATUS = DBPARTENUM.STATUS;

pub const DBPARAMIOENUM = enum(i32) {
    NOTPARAM = 0,
    INPUT = 1,
    OUTPUT = 2,
};
pub const DBPARAMIO_NOTPARAM = DBPARAMIOENUM.NOTPARAM;
pub const DBPARAMIO_INPUT = DBPARAMIOENUM.INPUT;
pub const DBPARAMIO_OUTPUT = DBPARAMIOENUM.OUTPUT;

pub const DBBINDFLAGENUM = enum(i32) {
    L = 1,
};
pub const DBBINDFLAG_HTML = DBBINDFLAGENUM.L;

pub const DBMEMOWNERENUM = enum(i32) {
    CLIENTOWNED = 0,
    PROVIDEROWNED = 1,
};
pub const DBMEMOWNER_CLIENTOWNED = DBMEMOWNERENUM.CLIENTOWNED;
pub const DBMEMOWNER_PROVIDEROWNED = DBMEMOWNERENUM.PROVIDEROWNED;


pub const DBSTATUSENUM = enum(i32) {
    S_OK = 0,
    E_BADACCESSOR = 1,
    E_CANTCONVERTVALUE = 2,
    S_ISNULL = 3,
    S_TRUNCATED = 4,
    E_SIGNMISMATCH = 5,
    E_DATAOVERFLOW = 6,
    E_CANTCREATE = 7,
    E_UNAVAILABLE = 8,
    E_PERMISSIONDENIED = 9,
    E_INTEGRITYVIOLATION = 10,
    E_SCHEMAVIOLATION = 11,
    E_BADSTATUS = 12,
    S_DEFAULT = 13,
};
pub const DBSTATUS_S_OK = DBSTATUSENUM.S_OK;
pub const DBSTATUS_E_BADACCESSOR = DBSTATUSENUM.E_BADACCESSOR;
pub const DBSTATUS_E_CANTCONVERTVALUE = DBSTATUSENUM.E_CANTCONVERTVALUE;
pub const DBSTATUS_S_ISNULL = DBSTATUSENUM.S_ISNULL;
pub const DBSTATUS_S_TRUNCATED = DBSTATUSENUM.S_TRUNCATED;
pub const DBSTATUS_E_SIGNMISMATCH = DBSTATUSENUM.E_SIGNMISMATCH;
pub const DBSTATUS_E_DATAOVERFLOW = DBSTATUSENUM.E_DATAOVERFLOW;
pub const DBSTATUS_E_CANTCREATE = DBSTATUSENUM.E_CANTCREATE;
pub const DBSTATUS_E_UNAVAILABLE = DBSTATUSENUM.E_UNAVAILABLE;
pub const DBSTATUS_E_PERMISSIONDENIED = DBSTATUSENUM.E_PERMISSIONDENIED;
pub const DBSTATUS_E_INTEGRITYVIOLATION = DBSTATUSENUM.E_INTEGRITYVIOLATION;
pub const DBSTATUS_E_SCHEMAVIOLATION = DBSTATUSENUM.E_SCHEMAVIOLATION;
pub const DBSTATUS_E_BADSTATUS = DBSTATUSENUM.E_BADSTATUS;
pub const DBSTATUS_S_DEFAULT = DBSTATUSENUM.S_DEFAULT;

pub const DBSTATUSENUM20 = enum(i32) {
    MDSTATUS_S_CELLEMPTY = 14,
    DBSTATUS_S_IGNORE = 15,
};
pub const MDSTATUS_S_CELLEMPTY = DBSTATUSENUM20.MDSTATUS_S_CELLEMPTY;
pub const DBSTATUS_S_IGNORE = DBSTATUSENUM20.DBSTATUS_S_IGNORE;

pub const DBSTATUSENUM21 = enum(i32) {
    E_DOESNOTEXIST = 16,
    E_INVALIDURL = 17,
    E_RESOURCELOCKED = 18,
    E_RESOURCEEXISTS = 19,
    E_CANNOTCOMPLETE = 20,
    E_VOLUMENOTFOUND = 21,
    E_OUTOFSPACE = 22,
    S_CANNOTDELETESOURCE = 23,
    E_READONLY = 24,
    E_RESOURCEOUTOFSCOPE = 25,
    S_ALREADYEXISTS = 26,
};
pub const DBSTATUS_E_DOESNOTEXIST = DBSTATUSENUM21.E_DOESNOTEXIST;
pub const DBSTATUS_E_INVALIDURL = DBSTATUSENUM21.E_INVALIDURL;
pub const DBSTATUS_E_RESOURCELOCKED = DBSTATUSENUM21.E_RESOURCELOCKED;
pub const DBSTATUS_E_RESOURCEEXISTS = DBSTATUSENUM21.E_RESOURCEEXISTS;
pub const DBSTATUS_E_CANNOTCOMPLETE = DBSTATUSENUM21.E_CANNOTCOMPLETE;
pub const DBSTATUS_E_VOLUMENOTFOUND = DBSTATUSENUM21.E_VOLUMENOTFOUND;
pub const DBSTATUS_E_OUTOFSPACE = DBSTATUSENUM21.E_OUTOFSPACE;
pub const DBSTATUS_S_CANNOTDELETESOURCE = DBSTATUSENUM21.S_CANNOTDELETESOURCE;
pub const DBSTATUS_E_READONLY = DBSTATUSENUM21.E_READONLY;
pub const DBSTATUS_E_RESOURCEOUTOFSCOPE = DBSTATUSENUM21.E_RESOURCEOUTOFSCOPE;
pub const DBSTATUS_S_ALREADYEXISTS = DBSTATUSENUM21.S_ALREADYEXISTS;

pub const DBBINDURLFLAGENUM = enum(i32) {
    READ = 1,
    WRITE = 2,
    READWRITE = 3,
    SHARE_DENY_READ = 4,
    SHARE_DENY_WRITE = 8,
    SHARE_EXCLUSIVE = 12,
    SHARE_DENY_NONE = 16,
    ASYNCHRONOUS = 4096,
    COLLECTION = 8192,
    DELAYFETCHSTREAM = 16384,
    DELAYFETCHCOLUMNS = 32768,
    RECURSIVE = 4194304,
    OUTPUT = 8388608,
    WAITFORINIT = 16777216,
    OPENIFEXISTS = 33554432,
    OVERWRITE = 67108864,
    ISSTRUCTUREDDOCUMENT = 134217728,
};
pub const DBBINDURLFLAG_READ = DBBINDURLFLAGENUM.READ;
pub const DBBINDURLFLAG_WRITE = DBBINDURLFLAGENUM.WRITE;
pub const DBBINDURLFLAG_READWRITE = DBBINDURLFLAGENUM.READWRITE;
pub const DBBINDURLFLAG_SHARE_DENY_READ = DBBINDURLFLAGENUM.SHARE_DENY_READ;
pub const DBBINDURLFLAG_SHARE_DENY_WRITE = DBBINDURLFLAGENUM.SHARE_DENY_WRITE;
pub const DBBINDURLFLAG_SHARE_EXCLUSIVE = DBBINDURLFLAGENUM.SHARE_EXCLUSIVE;
pub const DBBINDURLFLAG_SHARE_DENY_NONE = DBBINDURLFLAGENUM.SHARE_DENY_NONE;
pub const DBBINDURLFLAG_ASYNCHRONOUS = DBBINDURLFLAGENUM.ASYNCHRONOUS;
pub const DBBINDURLFLAG_COLLECTION = DBBINDURLFLAGENUM.COLLECTION;
pub const DBBINDURLFLAG_DELAYFETCHSTREAM = DBBINDURLFLAGENUM.DELAYFETCHSTREAM;
pub const DBBINDURLFLAG_DELAYFETCHCOLUMNS = DBBINDURLFLAGENUM.DELAYFETCHCOLUMNS;
pub const DBBINDURLFLAG_RECURSIVE = DBBINDURLFLAGENUM.RECURSIVE;
pub const DBBINDURLFLAG_OUTPUT = DBBINDURLFLAGENUM.OUTPUT;
pub const DBBINDURLFLAG_WAITFORINIT = DBBINDURLFLAGENUM.WAITFORINIT;
pub const DBBINDURLFLAG_OPENIFEXISTS = DBBINDURLFLAGENUM.OPENIFEXISTS;
pub const DBBINDURLFLAG_OVERWRITE = DBBINDURLFLAGENUM.OVERWRITE;
pub const DBBINDURLFLAG_ISSTRUCTUREDDOCUMENT = DBBINDURLFLAGENUM.ISSTRUCTUREDDOCUMENT;

pub const DBBINDURLSTATUSENUM = enum(i32) {
    OK = 0,
    DENYNOTSUPPORTED = 1,
    DENYTYPENOTSUPPORTED = 4,
    REDIRECTED = 8,
};
pub const DBBINDURLSTATUS_S_OK = DBBINDURLSTATUSENUM.OK;
pub const DBBINDURLSTATUS_S_DENYNOTSUPPORTED = DBBINDURLSTATUSENUM.DENYNOTSUPPORTED;
pub const DBBINDURLSTATUS_S_DENYTYPENOTSUPPORTED = DBBINDURLSTATUSENUM.DENYTYPENOTSUPPORTED;
pub const DBBINDURLSTATUS_S_REDIRECTED = DBBINDURLSTATUSENUM.REDIRECTED;

pub const DBSTATUSENUM25 = enum(i32) {
    CANCELED = 27,
    NOTCOLLECTION = 28,
};
pub const DBSTATUS_E_CANCELED = DBSTATUSENUM25.CANCELED;
pub const DBSTATUS_E_NOTCOLLECTION = DBSTATUSENUM25.NOTCOLLECTION;



pub const DBROWSTATUSENUM = enum(i32) {
    S_OK = 0,
    S_MULTIPLECHANGES = 2,
    S_PENDINGCHANGES = 3,
    E_CANCELED = 4,
    E_CANTRELEASE = 6,
    E_CONCURRENCYVIOLATION = 7,
    E_DELETED = 8,
    E_PENDINGINSERT = 9,
    E_NEWLYINSERTED = 10,
    E_INTEGRITYVIOLATION = 11,
    E_INVALID = 12,
    E_MAXPENDCHANGESEXCEEDED = 13,
    E_OBJECTOPEN = 14,
    E_OUTOFMEMORY = 15,
    E_PERMISSIONDENIED = 16,
    E_LIMITREACHED = 17,
    E_SCHEMAVIOLATION = 18,
    E_FAIL = 19,
};
pub const DBROWSTATUS_S_OK = DBROWSTATUSENUM.S_OK;
pub const DBROWSTATUS_S_MULTIPLECHANGES = DBROWSTATUSENUM.S_MULTIPLECHANGES;
pub const DBROWSTATUS_S_PENDINGCHANGES = DBROWSTATUSENUM.S_PENDINGCHANGES;
pub const DBROWSTATUS_E_CANCELED = DBROWSTATUSENUM.E_CANCELED;
pub const DBROWSTATUS_E_CANTRELEASE = DBROWSTATUSENUM.E_CANTRELEASE;
pub const DBROWSTATUS_E_CONCURRENCYVIOLATION = DBROWSTATUSENUM.E_CONCURRENCYVIOLATION;
pub const DBROWSTATUS_E_DELETED = DBROWSTATUSENUM.E_DELETED;
pub const DBROWSTATUS_E_PENDINGINSERT = DBROWSTATUSENUM.E_PENDINGINSERT;
pub const DBROWSTATUS_E_NEWLYINSERTED = DBROWSTATUSENUM.E_NEWLYINSERTED;
pub const DBROWSTATUS_E_INTEGRITYVIOLATION = DBROWSTATUSENUM.E_INTEGRITYVIOLATION;
pub const DBROWSTATUS_E_INVALID = DBROWSTATUSENUM.E_INVALID;
pub const DBROWSTATUS_E_MAXPENDCHANGESEXCEEDED = DBROWSTATUSENUM.E_MAXPENDCHANGESEXCEEDED;
pub const DBROWSTATUS_E_OBJECTOPEN = DBROWSTATUSENUM.E_OBJECTOPEN;
pub const DBROWSTATUS_E_OUTOFMEMORY = DBROWSTATUSENUM.E_OUTOFMEMORY;
pub const DBROWSTATUS_E_PERMISSIONDENIED = DBROWSTATUSENUM.E_PERMISSIONDENIED;
pub const DBROWSTATUS_E_LIMITREACHED = DBROWSTATUSENUM.E_LIMITREACHED;
pub const DBROWSTATUS_E_SCHEMAVIOLATION = DBROWSTATUSENUM.E_SCHEMAVIOLATION;
pub const DBROWSTATUS_E_FAIL = DBROWSTATUSENUM.E_FAIL;

pub const DBROWSTATUSENUM20 = enum(i32) {
    E = 20,
};
pub const DBROWSTATUS_S_NOCHANGE = DBROWSTATUSENUM20.E;

pub const DBSTATUSENUM26 = enum(i32) {
    N = 29,
};
pub const DBSTATUS_S_ROWSETCOLUMN = DBSTATUSENUM26.N;


pub const DBCOLUMNFLAGSENUM = enum(i32) {
    ISBOOKMARK = 1,
    MAYDEFER = 2,
    WRITE = 4,
    WRITEUNKNOWN = 8,
    ISFIXEDLENGTH = 16,
    ISNULLABLE = 32,
    MAYBENULL = 64,
    ISLONG = 128,
    ISROWID = 256,
    ISROWVER = 512,
    CACHEDEFERRED = 4096,
};
pub const DBCOLUMNFLAGS_ISBOOKMARK = DBCOLUMNFLAGSENUM.ISBOOKMARK;
pub const DBCOLUMNFLAGS_MAYDEFER = DBCOLUMNFLAGSENUM.MAYDEFER;
pub const DBCOLUMNFLAGS_WRITE = DBCOLUMNFLAGSENUM.WRITE;
pub const DBCOLUMNFLAGS_WRITEUNKNOWN = DBCOLUMNFLAGSENUM.WRITEUNKNOWN;
pub const DBCOLUMNFLAGS_ISFIXEDLENGTH = DBCOLUMNFLAGSENUM.ISFIXEDLENGTH;
pub const DBCOLUMNFLAGS_ISNULLABLE = DBCOLUMNFLAGSENUM.ISNULLABLE;
pub const DBCOLUMNFLAGS_MAYBENULL = DBCOLUMNFLAGSENUM.MAYBENULL;
pub const DBCOLUMNFLAGS_ISLONG = DBCOLUMNFLAGSENUM.ISLONG;
pub const DBCOLUMNFLAGS_ISROWID = DBCOLUMNFLAGSENUM.ISROWID;
pub const DBCOLUMNFLAGS_ISROWVER = DBCOLUMNFLAGSENUM.ISROWVER;
pub const DBCOLUMNFLAGS_CACHEDEFERRED = DBCOLUMNFLAGSENUM.CACHEDEFERRED;

pub const DBCOLUMNFLAGSENUM20 = enum(i32) {
    SCALEISNEGATIVE = 16384,
    RESERVED = 32768,
};
pub const DBCOLUMNFLAGS_SCALEISNEGATIVE = DBCOLUMNFLAGSENUM20.SCALEISNEGATIVE;
pub const DBCOLUMNFLAGS_RESERVED = DBCOLUMNFLAGSENUM20.RESERVED;

pub const DBCOLUMNFLAGS15ENUM = enum(i32) {
    R = 8192,
};
pub const DBCOLUMNFLAGS_ISCHAPTER = DBCOLUMNFLAGS15ENUM.R;

pub const DBCOLUMNFLAGSENUM21 = enum(i32) {
    ROWURL = 65536,
    DEFAULTSTREAM = 131072,
    COLLECTION = 262144,
};
pub const DBCOLUMNFLAGS_ISROWURL = DBCOLUMNFLAGSENUM21.ROWURL;
pub const DBCOLUMNFLAGS_ISDEFAULTSTREAM = DBCOLUMNFLAGSENUM21.DEFAULTSTREAM;
pub const DBCOLUMNFLAGS_ISCOLLECTION = DBCOLUMNFLAGSENUM21.COLLECTION;

pub const DBCOLUMNFLAGSENUM26 = enum(i32) {
    ISSTREAM = 524288,
    ISROWSET = 1048576,
    ISROW = 2097152,
    ROWSPECIFICCOLUMN = 4194304,
};
pub const DBCOLUMNFLAGS_ISSTREAM = DBCOLUMNFLAGSENUM26.ISSTREAM;
pub const DBCOLUMNFLAGS_ISROWSET = DBCOLUMNFLAGSENUM26.ISROWSET;
pub const DBCOLUMNFLAGS_ISROW = DBCOLUMNFLAGSENUM26.ISROW;
pub const DBCOLUMNFLAGS_ROWSPECIFICCOLUMN = DBCOLUMNFLAGSENUM26.ROWSPECIFICCOLUMN;

pub const DBTABLESTATISTICSTYPE26 = enum(i32) {
    HISTOGRAM = 1,
    COLUMN_CARDINALITY = 2,
    TUPLE_CARDINALITY = 4,
};
pub const DBSTAT_HISTOGRAM = DBTABLESTATISTICSTYPE26.HISTOGRAM;
pub const DBSTAT_COLUMN_CARDINALITY = DBTABLESTATISTICSTYPE26.COLUMN_CARDINALITY;
pub const DBSTAT_TUPLE_CARDINALITY = DBTABLESTATISTICSTYPE26.TUPLE_CARDINALITY;


pub const DBBOOKMARK = enum(i32) {
    INVALID = 0,
    FIRST = 1,
    LAST = 2,
};
pub const DBBMK_INVALID = DBBOOKMARK.INVALID;
pub const DBBMK_FIRST = DBBOOKMARK.FIRST;
pub const DBBMK_LAST = DBBOOKMARK.LAST;

pub const DBPROPENUM = enum(i32) {
    ABORTPRESERVE = 2,
    ACTIVESESSIONS = 3,
    APPENDONLY = 187,
    ASYNCTXNABORT = 168,
    ASYNCTXNCOMMIT = 4,
    AUTH_CACHE_AUTHINFO = 5,
    AUTH_ENCRYPT_PASSWORD = 6,
    AUTH_INTEGRATED = 7,
    AUTH_MASK_PASSWORD = 8,
    AUTH_PASSWORD = 9,
    AUTH_PERSIST_ENCRYPTED = 10,
    AUTH_PERSIST_SENSITIVE_AUTHINFO = 11,
    AUTH_USERID = 12,
    BLOCKINGSTORAGEOBJECTS = 13,
    BOOKMARKS = 14,
    BOOKMARKSKIPPED = 15,
    BOOKMARKTYPE = 16,
    BYREFACCESSORS = 120,
    CACHEDEFERRED = 17,
    CANFETCHBACKWARDS = 18,
    CANHOLDROWS = 19,
    CANSCROLLBACKWARDS = 21,
    CATALOGLOCATION = 22,
    CATALOGTERM = 23,
    CATALOGUSAGE = 24,
    CHANGEINSERTEDROWS = 188,
    COL_AUTOINCREMENT = 26,
    COL_DEFAULT = 27,
    COL_DESCRIPTION = 28,
    COL_FIXEDLENGTH = 167,
    COL_NULLABLE = 29,
    COL_PRIMARYKEY = 30,
    COL_UNIQUE = 31,
    COLUMNDEFINITION = 32,
    COLUMNRESTRICT = 33,
    COMMANDTIMEOUT = 34,
    COMMITPRESERVE = 35,
    CONCATNULLBEHAVIOR = 36,
    CURRENTCATALOG = 37,
    DATASOURCENAME = 38,
    DATASOURCEREADONLY = 39,
    DBMSNAME = 40,
    DBMSVER = 41,
    DEFERRED = 42,
    DELAYSTORAGEOBJECTS = 43,
    DSOTHREADMODEL = 169,
    GROUPBY = 44,
    HETEROGENEOUSTABLES = 45,
    IAccessor = 121,
    IColumnsInfo = 122,
    IColumnsRowset = 123,
    IConnectionPointContainer = 124,
    IConvertType = 194,
    IRowset = 126,
    IRowsetChange = 127,
    IRowsetIdentity = 128,
    IRowsetIndex = 159,
    IRowsetInfo = 129,
    IRowsetLocate = 130,
    IRowsetResynch = 132,
    IRowsetScroll = 133,
    IRowsetUpdate = 134,
    ISupportErrorInfo = 135,
    ILockBytes = 136,
    ISequentialStream = 137,
    IStorage = 138,
    IStream = 139,
    IDENTIFIERCASE = 46,
    IMMOBILEROWS = 47,
    INDEX_AUTOUPDATE = 48,
    INDEX_CLUSTERED = 49,
    INDEX_FILLFACTOR = 50,
    INDEX_INITIALSIZE = 51,
    INDEX_NULLCOLLATION = 52,
    INDEX_NULLS = 53,
    INDEX_PRIMARYKEY = 54,
    INDEX_SORTBOOKMARKS = 55,
    INDEX_TEMPINDEX = 163,
    INDEX_TYPE = 56,
    INDEX_UNIQUE = 57,
    INIT_DATASOURCE = 59,
    INIT_HWND = 60,
    INIT_IMPERSONATION_LEVEL = 61,
    INIT_LCID = 186,
    INIT_LOCATION = 62,
    INIT_MODE = 63,
    INIT_PROMPT = 64,
    INIT_PROTECTION_LEVEL = 65,
    INIT_PROVIDERSTRING = 160,
    INIT_TIMEOUT = 66,
    LITERALBOOKMARKS = 67,
    LITERALIDENTITY = 68,
    MAXINDEXSIZE = 70,
    MAXOPENROWS = 71,
    MAXPENDINGROWS = 72,
    MAXROWS = 73,
    MAXROWSIZE = 74,
    MAXROWSIZEINCLUDESBLOB = 75,
    MAXTABLESINSELECT = 76,
    MAYWRITECOLUMN = 77,
    MEMORYUSAGE = 78,
    MULTIPLEPARAMSETS = 191,
    MULTIPLERESULTS = 196,
    MULTIPLESTORAGEOBJECTS = 80,
    MULTITABLEUPDATE = 81,
    NOTIFICATIONGRANULARITY = 198,
    NOTIFICATIONPHASES = 82,
    NOTIFYCOLUMNSET = 171,
    NOTIFYROWDELETE = 173,
    NOTIFYROWFIRSTCHANGE = 174,
    NOTIFYROWINSERT = 175,
    NOTIFYROWRESYNCH = 177,
    NOTIFYROWSETCHANGED = 211,
    NOTIFYROWSETRELEASE = 178,
    NOTIFYROWSETFETCHPOSITIONCHANGE = 179,
    NOTIFYROWUNDOCHANGE = 180,
    NOTIFYROWUNDODELETE = 181,
    NOTIFYROWUNDOINSERT = 182,
    NOTIFYROWUPDATE = 183,
    NULLCOLLATION = 83,
    OLEOBJECTS = 84,
    ORDERBYCOLUMNSINSELECT = 85,
    ORDEREDBOOKMARKS = 86,
    OTHERINSERT = 87,
    OTHERUPDATEDELETE = 88,
    OUTPUTPARAMETERAVAILABILITY = 184,
    OWNINSERT = 89,
    OWNUPDATEDELETE = 90,
    PERSISTENTIDTYPE = 185,
    PREPAREABORTBEHAVIOR = 91,
    PREPARECOMMITBEHAVIOR = 92,
    PROCEDURETERM = 93,
    PROVIDERNAME = 96,
    PROVIDEROLEDBVER = 97,
    PROVIDERVER = 98,
    QUICKRESTART = 99,
    QUOTEDIDENTIFIERCASE = 100,
    REENTRANTEVENTS = 101,
    REMOVEDELETED = 102,
    REPORTMULTIPLECHANGES = 103,
    RETURNPENDINGINSERTS = 189,
    ROWRESTRICT = 104,
    ROWSETCONVERSIONSONCOMMAND = 192,
    ROWTHREADMODEL = 105,
    SCHEMATERM = 106,
    SCHEMAUSAGE = 107,
    SERVERCURSOR = 108,
    SESS_AUTOCOMMITISOLEVELS = 190,
    SQLSUPPORT = 109,
    STRONGIDENTITY = 119,
    STRUCTUREDSTORAGE = 111,
    SUBQUERIES = 112,
    SUPPORTEDTXNDDL = 161,
    SUPPORTEDTXNISOLEVELS = 113,
    SUPPORTEDTXNISORETAIN = 114,
    TABLETERM = 115,
    TBL_TEMPTABLE = 140,
    TRANSACTEDOBJECT = 116,
    UPDATABILITY = 117,
    USERNAME = 118,
};
pub const DBPROP_ABORTPRESERVE = DBPROPENUM.ABORTPRESERVE;
pub const DBPROP_ACTIVESESSIONS = DBPROPENUM.ACTIVESESSIONS;
pub const DBPROP_APPENDONLY = DBPROPENUM.APPENDONLY;
pub const DBPROP_ASYNCTXNABORT = DBPROPENUM.ASYNCTXNABORT;
pub const DBPROP_ASYNCTXNCOMMIT = DBPROPENUM.ASYNCTXNCOMMIT;
pub const DBPROP_AUTH_CACHE_AUTHINFO = DBPROPENUM.AUTH_CACHE_AUTHINFO;
pub const DBPROP_AUTH_ENCRYPT_PASSWORD = DBPROPENUM.AUTH_ENCRYPT_PASSWORD;
pub const DBPROP_AUTH_INTEGRATED = DBPROPENUM.AUTH_INTEGRATED;
pub const DBPROP_AUTH_MASK_PASSWORD = DBPROPENUM.AUTH_MASK_PASSWORD;
pub const DBPROP_AUTH_PASSWORD = DBPROPENUM.AUTH_PASSWORD;
pub const DBPROP_AUTH_PERSIST_ENCRYPTED = DBPROPENUM.AUTH_PERSIST_ENCRYPTED;
pub const DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO = DBPROPENUM.AUTH_PERSIST_SENSITIVE_AUTHINFO;
pub const DBPROP_AUTH_USERID = DBPROPENUM.AUTH_USERID;
pub const DBPROP_BLOCKINGSTORAGEOBJECTS = DBPROPENUM.BLOCKINGSTORAGEOBJECTS;
pub const DBPROP_BOOKMARKS = DBPROPENUM.BOOKMARKS;
pub const DBPROP_BOOKMARKSKIPPED = DBPROPENUM.BOOKMARKSKIPPED;
pub const DBPROP_BOOKMARKTYPE = DBPROPENUM.BOOKMARKTYPE;
pub const DBPROP_BYREFACCESSORS = DBPROPENUM.BYREFACCESSORS;
pub const DBPROP_CACHEDEFERRED = DBPROPENUM.CACHEDEFERRED;
pub const DBPROP_CANFETCHBACKWARDS = DBPROPENUM.CANFETCHBACKWARDS;
pub const DBPROP_CANHOLDROWS = DBPROPENUM.CANHOLDROWS;
pub const DBPROP_CANSCROLLBACKWARDS = DBPROPENUM.CANSCROLLBACKWARDS;
pub const DBPROP_CATALOGLOCATION = DBPROPENUM.CATALOGLOCATION;
pub const DBPROP_CATALOGTERM = DBPROPENUM.CATALOGTERM;
pub const DBPROP_CATALOGUSAGE = DBPROPENUM.CATALOGUSAGE;
pub const DBPROP_CHANGEINSERTEDROWS = DBPROPENUM.CHANGEINSERTEDROWS;
pub const DBPROP_COL_AUTOINCREMENT = DBPROPENUM.COL_AUTOINCREMENT;
pub const DBPROP_COL_DEFAULT = DBPROPENUM.COL_DEFAULT;
pub const DBPROP_COL_DESCRIPTION = DBPROPENUM.COL_DESCRIPTION;
pub const DBPROP_COL_FIXEDLENGTH = DBPROPENUM.COL_FIXEDLENGTH;
pub const DBPROP_COL_NULLABLE = DBPROPENUM.COL_NULLABLE;
pub const DBPROP_COL_PRIMARYKEY = DBPROPENUM.COL_PRIMARYKEY;
pub const DBPROP_COL_UNIQUE = DBPROPENUM.COL_UNIQUE;
pub const DBPROP_COLUMNDEFINITION = DBPROPENUM.COLUMNDEFINITION;
pub const DBPROP_COLUMNRESTRICT = DBPROPENUM.COLUMNRESTRICT;
pub const DBPROP_COMMANDTIMEOUT = DBPROPENUM.COMMANDTIMEOUT;
pub const DBPROP_COMMITPRESERVE = DBPROPENUM.COMMITPRESERVE;
pub const DBPROP_CONCATNULLBEHAVIOR = DBPROPENUM.CONCATNULLBEHAVIOR;
pub const DBPROP_CURRENTCATALOG = DBPROPENUM.CURRENTCATALOG;
pub const DBPROP_DATASOURCENAME = DBPROPENUM.DATASOURCENAME;
pub const DBPROP_DATASOURCEREADONLY = DBPROPENUM.DATASOURCEREADONLY;
pub const DBPROP_DBMSNAME = DBPROPENUM.DBMSNAME;
pub const DBPROP_DBMSVER = DBPROPENUM.DBMSVER;
pub const DBPROP_DEFERRED = DBPROPENUM.DEFERRED;
pub const DBPROP_DELAYSTORAGEOBJECTS = DBPROPENUM.DELAYSTORAGEOBJECTS;
pub const DBPROP_DSOTHREADMODEL = DBPROPENUM.DSOTHREADMODEL;
pub const DBPROP_GROUPBY = DBPROPENUM.GROUPBY;
pub const DBPROP_HETEROGENEOUSTABLES = DBPROPENUM.HETEROGENEOUSTABLES;
pub const DBPROP_IAccessor = DBPROPENUM.IAccessor;
pub const DBPROP_IColumnsInfo = DBPROPENUM.IColumnsInfo;
pub const DBPROP_IColumnsRowset = DBPROPENUM.IColumnsRowset;
pub const DBPROP_IConnectionPointContainer = DBPROPENUM.IConnectionPointContainer;
pub const DBPROP_IConvertType = DBPROPENUM.IConvertType;
pub const DBPROP_IRowset = DBPROPENUM.IRowset;
pub const DBPROP_IRowsetChange = DBPROPENUM.IRowsetChange;
pub const DBPROP_IRowsetIdentity = DBPROPENUM.IRowsetIdentity;
pub const DBPROP_IRowsetIndex = DBPROPENUM.IRowsetIndex;
pub const DBPROP_IRowsetInfo = DBPROPENUM.IRowsetInfo;
pub const DBPROP_IRowsetLocate = DBPROPENUM.IRowsetLocate;
pub const DBPROP_IRowsetResynch = DBPROPENUM.IRowsetResynch;
pub const DBPROP_IRowsetScroll = DBPROPENUM.IRowsetScroll;
pub const DBPROP_IRowsetUpdate = DBPROPENUM.IRowsetUpdate;
pub const DBPROP_ISupportErrorInfo = DBPROPENUM.ISupportErrorInfo;
pub const DBPROP_ILockBytes = DBPROPENUM.ILockBytes;
pub const DBPROP_ISequentialStream = DBPROPENUM.ISequentialStream;
pub const DBPROP_IStorage = DBPROPENUM.IStorage;
pub const DBPROP_IStream = DBPROPENUM.IStream;
pub const DBPROP_IDENTIFIERCASE = DBPROPENUM.IDENTIFIERCASE;
pub const DBPROP_IMMOBILEROWS = DBPROPENUM.IMMOBILEROWS;
pub const DBPROP_INDEX_AUTOUPDATE = DBPROPENUM.INDEX_AUTOUPDATE;
pub const DBPROP_INDEX_CLUSTERED = DBPROPENUM.INDEX_CLUSTERED;
pub const DBPROP_INDEX_FILLFACTOR = DBPROPENUM.INDEX_FILLFACTOR;
pub const DBPROP_INDEX_INITIALSIZE = DBPROPENUM.INDEX_INITIALSIZE;
pub const DBPROP_INDEX_NULLCOLLATION = DBPROPENUM.INDEX_NULLCOLLATION;
pub const DBPROP_INDEX_NULLS = DBPROPENUM.INDEX_NULLS;
pub const DBPROP_INDEX_PRIMARYKEY = DBPROPENUM.INDEX_PRIMARYKEY;
pub const DBPROP_INDEX_SORTBOOKMARKS = DBPROPENUM.INDEX_SORTBOOKMARKS;
pub const DBPROP_INDEX_TEMPINDEX = DBPROPENUM.INDEX_TEMPINDEX;
pub const DBPROP_INDEX_TYPE = DBPROPENUM.INDEX_TYPE;
pub const DBPROP_INDEX_UNIQUE = DBPROPENUM.INDEX_UNIQUE;
pub const DBPROP_INIT_DATASOURCE = DBPROPENUM.INIT_DATASOURCE;
pub const DBPROP_INIT_HWND = DBPROPENUM.INIT_HWND;
pub const DBPROP_INIT_IMPERSONATION_LEVEL = DBPROPENUM.INIT_IMPERSONATION_LEVEL;
pub const DBPROP_INIT_LCID = DBPROPENUM.INIT_LCID;
pub const DBPROP_INIT_LOCATION = DBPROPENUM.INIT_LOCATION;
pub const DBPROP_INIT_MODE = DBPROPENUM.INIT_MODE;
pub const DBPROP_INIT_PROMPT = DBPROPENUM.INIT_PROMPT;
pub const DBPROP_INIT_PROTECTION_LEVEL = DBPROPENUM.INIT_PROTECTION_LEVEL;
pub const DBPROP_INIT_PROVIDERSTRING = DBPROPENUM.INIT_PROVIDERSTRING;
pub const DBPROP_INIT_TIMEOUT = DBPROPENUM.INIT_TIMEOUT;
pub const DBPROP_LITERALBOOKMARKS = DBPROPENUM.LITERALBOOKMARKS;
pub const DBPROP_LITERALIDENTITY = DBPROPENUM.LITERALIDENTITY;
pub const DBPROP_MAXINDEXSIZE = DBPROPENUM.MAXINDEXSIZE;
pub const DBPROP_MAXOPENROWS = DBPROPENUM.MAXOPENROWS;
pub const DBPROP_MAXPENDINGROWS = DBPROPENUM.MAXPENDINGROWS;
pub const DBPROP_MAXROWS = DBPROPENUM.MAXROWS;
pub const DBPROP_MAXROWSIZE = DBPROPENUM.MAXROWSIZE;
pub const DBPROP_MAXROWSIZEINCLUDESBLOB = DBPROPENUM.MAXROWSIZEINCLUDESBLOB;
pub const DBPROP_MAXTABLESINSELECT = DBPROPENUM.MAXTABLESINSELECT;
pub const DBPROP_MAYWRITECOLUMN = DBPROPENUM.MAYWRITECOLUMN;
pub const DBPROP_MEMORYUSAGE = DBPROPENUM.MEMORYUSAGE;
pub const DBPROP_MULTIPLEPARAMSETS = DBPROPENUM.MULTIPLEPARAMSETS;
pub const DBPROP_MULTIPLERESULTS = DBPROPENUM.MULTIPLERESULTS;
pub const DBPROP_MULTIPLESTORAGEOBJECTS = DBPROPENUM.MULTIPLESTORAGEOBJECTS;
pub const DBPROP_MULTITABLEUPDATE = DBPROPENUM.MULTITABLEUPDATE;
pub const DBPROP_NOTIFICATIONGRANULARITY = DBPROPENUM.NOTIFICATIONGRANULARITY;
pub const DBPROP_NOTIFICATIONPHASES = DBPROPENUM.NOTIFICATIONPHASES;
pub const DBPROP_NOTIFYCOLUMNSET = DBPROPENUM.NOTIFYCOLUMNSET;
pub const DBPROP_NOTIFYROWDELETE = DBPROPENUM.NOTIFYROWDELETE;
pub const DBPROP_NOTIFYROWFIRSTCHANGE = DBPROPENUM.NOTIFYROWFIRSTCHANGE;
pub const DBPROP_NOTIFYROWINSERT = DBPROPENUM.NOTIFYROWINSERT;
pub const DBPROP_NOTIFYROWRESYNCH = DBPROPENUM.NOTIFYROWRESYNCH;
pub const DBPROP_NOTIFYROWSETCHANGED = DBPROPENUM.NOTIFYROWSETCHANGED;
pub const DBPROP_NOTIFYROWSETRELEASE = DBPROPENUM.NOTIFYROWSETRELEASE;
pub const DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE = DBPROPENUM.NOTIFYROWSETFETCHPOSITIONCHANGE;
pub const DBPROP_NOTIFYROWUNDOCHANGE = DBPROPENUM.NOTIFYROWUNDOCHANGE;
pub const DBPROP_NOTIFYROWUNDODELETE = DBPROPENUM.NOTIFYROWUNDODELETE;
pub const DBPROP_NOTIFYROWUNDOINSERT = DBPROPENUM.NOTIFYROWUNDOINSERT;
pub const DBPROP_NOTIFYROWUPDATE = DBPROPENUM.NOTIFYROWUPDATE;
pub const DBPROP_NULLCOLLATION = DBPROPENUM.NULLCOLLATION;
pub const DBPROP_OLEOBJECTS = DBPROPENUM.OLEOBJECTS;
pub const DBPROP_ORDERBYCOLUMNSINSELECT = DBPROPENUM.ORDERBYCOLUMNSINSELECT;
pub const DBPROP_ORDEREDBOOKMARKS = DBPROPENUM.ORDEREDBOOKMARKS;
pub const DBPROP_OTHERINSERT = DBPROPENUM.OTHERINSERT;
pub const DBPROP_OTHERUPDATEDELETE = DBPROPENUM.OTHERUPDATEDELETE;
pub const DBPROP_OUTPUTPARAMETERAVAILABILITY = DBPROPENUM.OUTPUTPARAMETERAVAILABILITY;
pub const DBPROP_OWNINSERT = DBPROPENUM.OWNINSERT;
pub const DBPROP_OWNUPDATEDELETE = DBPROPENUM.OWNUPDATEDELETE;
pub const DBPROP_PERSISTENTIDTYPE = DBPROPENUM.PERSISTENTIDTYPE;
pub const DBPROP_PREPAREABORTBEHAVIOR = DBPROPENUM.PREPAREABORTBEHAVIOR;
pub const DBPROP_PREPARECOMMITBEHAVIOR = DBPROPENUM.PREPARECOMMITBEHAVIOR;
pub const DBPROP_PROCEDURETERM = DBPROPENUM.PROCEDURETERM;
pub const DBPROP_PROVIDERNAME = DBPROPENUM.PROVIDERNAME;
pub const DBPROP_PROVIDEROLEDBVER = DBPROPENUM.PROVIDEROLEDBVER;
pub const DBPROP_PROVIDERVER = DBPROPENUM.PROVIDERVER;
pub const DBPROP_QUICKRESTART = DBPROPENUM.QUICKRESTART;
pub const DBPROP_QUOTEDIDENTIFIERCASE = DBPROPENUM.QUOTEDIDENTIFIERCASE;
pub const DBPROP_REENTRANTEVENTS = DBPROPENUM.REENTRANTEVENTS;
pub const DBPROP_REMOVEDELETED = DBPROPENUM.REMOVEDELETED;
pub const DBPROP_REPORTMULTIPLECHANGES = DBPROPENUM.REPORTMULTIPLECHANGES;
pub const DBPROP_RETURNPENDINGINSERTS = DBPROPENUM.RETURNPENDINGINSERTS;
pub const DBPROP_ROWRESTRICT = DBPROPENUM.ROWRESTRICT;
pub const DBPROP_ROWSETCONVERSIONSONCOMMAND = DBPROPENUM.ROWSETCONVERSIONSONCOMMAND;
pub const DBPROP_ROWTHREADMODEL = DBPROPENUM.ROWTHREADMODEL;
pub const DBPROP_SCHEMATERM = DBPROPENUM.SCHEMATERM;
pub const DBPROP_SCHEMAUSAGE = DBPROPENUM.SCHEMAUSAGE;
pub const DBPROP_SERVERCURSOR = DBPROPENUM.SERVERCURSOR;
pub const DBPROP_SESS_AUTOCOMMITISOLEVELS = DBPROPENUM.SESS_AUTOCOMMITISOLEVELS;
pub const DBPROP_SQLSUPPORT = DBPROPENUM.SQLSUPPORT;
pub const DBPROP_STRONGIDENTITY = DBPROPENUM.STRONGIDENTITY;
pub const DBPROP_STRUCTUREDSTORAGE = DBPROPENUM.STRUCTUREDSTORAGE;
pub const DBPROP_SUBQUERIES = DBPROPENUM.SUBQUERIES;
pub const DBPROP_SUPPORTEDTXNDDL = DBPROPENUM.SUPPORTEDTXNDDL;
pub const DBPROP_SUPPORTEDTXNISOLEVELS = DBPROPENUM.SUPPORTEDTXNISOLEVELS;
pub const DBPROP_SUPPORTEDTXNISORETAIN = DBPROPENUM.SUPPORTEDTXNISORETAIN;
pub const DBPROP_TABLETERM = DBPROPENUM.TABLETERM;
pub const DBPROP_TBL_TEMPTABLE = DBPROPENUM.TBL_TEMPTABLE;
pub const DBPROP_TRANSACTEDOBJECT = DBPROPENUM.TRANSACTEDOBJECT;
pub const DBPROP_UPDATABILITY = DBPROPENUM.UPDATABILITY;
pub const DBPROP_USERNAME = DBPROPENUM.USERNAME;

pub const DBPROPENUM15 = enum(i32) {
    FILTERCOMPAREOPS = 209,
    FINDCOMPAREOPS = 210,
    IChapteredRowset = 202,
    IDBAsynchStatus = 203,
    IRowsetFind = 204,
    IRowsetView = 212,
    IViewChapter = 213,
    IViewFilter = 214,
    IViewRowset = 215,
    IViewSort = 216,
    INIT_ASYNCH = 200,
    MAXOPENCHAPTERS = 199,
    MAXORSINFILTER = 205,
    MAXSORTCOLUMNS = 206,
    ROWSET_ASYNCH = 201,
    SORTONINDEX = 207,
};
pub const DBPROP_FILTERCOMPAREOPS = DBPROPENUM15.FILTERCOMPAREOPS;
pub const DBPROP_FINDCOMPAREOPS = DBPROPENUM15.FINDCOMPAREOPS;
pub const DBPROP_IChapteredRowset = DBPROPENUM15.IChapteredRowset;
pub const DBPROP_IDBAsynchStatus = DBPROPENUM15.IDBAsynchStatus;
pub const DBPROP_IRowsetFind = DBPROPENUM15.IRowsetFind;
pub const DBPROP_IRowsetView = DBPROPENUM15.IRowsetView;
pub const DBPROP_IViewChapter = DBPROPENUM15.IViewChapter;
pub const DBPROP_IViewFilter = DBPROPENUM15.IViewFilter;
pub const DBPROP_IViewRowset = DBPROPENUM15.IViewRowset;
pub const DBPROP_IViewSort = DBPROPENUM15.IViewSort;
pub const DBPROP_INIT_ASYNCH = DBPROPENUM15.INIT_ASYNCH;
pub const DBPROP_MAXOPENCHAPTERS = DBPROPENUM15.MAXOPENCHAPTERS;
pub const DBPROP_MAXORSINFILTER = DBPROPENUM15.MAXORSINFILTER;
pub const DBPROP_MAXSORTCOLUMNS = DBPROPENUM15.MAXSORTCOLUMNS;
pub const DBPROP_ROWSET_ASYNCH = DBPROPENUM15.ROWSET_ASYNCH;
pub const DBPROP_SORTONINDEX = DBPROPENUM15.SORTONINDEX;

pub const DBPROPENUM20 = enum(i32) {
    DBPROP_IMultipleResults = 217,
    DBPROP_DATASOURCE_TYPE = 251,
    MDPROP_AXES = 252,
    MDPROP_FLATTENING_SUPPORT = 253,
    MDPROP_MDX_JOINCUBES = 254,
    MDPROP_NAMED_LEVELS = 255,
    MDPROP_RANGEROWSET = 256,
    MDPROP_MDX_SLICER = 218,
    MDPROP_MDX_CUBEQUALIFICATION = 219,
    MDPROP_MDX_OUTERREFERENCE = 220,
    MDPROP_MDX_QUERYBYPROPERTY = 221,
    MDPROP_MDX_CASESUPPORT = 222,
    MDPROP_MDX_STRING_COMPOP = 224,
    MDPROP_MDX_DESCFLAGS = 225,
    MDPROP_MDX_SET_FUNCTIONS = 226,
    MDPROP_MDX_MEMBER_FUNCTIONS = 227,
    MDPROP_MDX_NUMERIC_FUNCTIONS = 228,
    MDPROP_MDX_FORMULAS = 229,
    MDPROP_AGGREGATECELL_UPDATE = 230,
    MDPROP_MDX_OBJQUALIFICATION = 261,
    MDPROP_MDX_NONMEASURE_EXPRESSIONS = 262,
    DBPROP_ACCESSORDER = 231,
    DBPROP_BOOKMARKINFO = 232,
    DBPROP_INIT_CATALOG = 233,
    DBPROP_ROW_BULKOPS = 234,
    DBPROP_PROVIDERFRIENDLYNAME = 235,
    DBPROP_LOCKMODE = 236,
    DBPROP_MULTIPLECONNECTIONS = 237,
    DBPROP_UNIQUEROWS = 238,
    DBPROP_SERVERDATAONINSERT = 239,
    DBPROP_STORAGEFLAGS = 240,
    DBPROP_CONNECTIONSTATUS = 244,
    DBPROP_ALTERCOLUMN = 245,
    DBPROP_COLUMNLCID = 246,
    DBPROP_RESETDATASOURCE = 247,
    DBPROP_INIT_OLEDBSERVICES = 248,
    DBPROP_IRowsetRefresh = 249,
    DBPROP_SERVERNAME = 250,
    DBPROP_IParentRowset = 257,
    DBPROP_HIDDENCOLUMNS = 258,
    DBPROP_PROVIDERMEMORY = 259,
    DBPROP_CLIENTCURSOR = 260,
    pub const MDPROP_MDX_AGGREGATECELL_UPDATE = .MDPROP_AGGREGATECELL_UPDATE;
};
pub const DBPROP_IMultipleResults = DBPROPENUM20.DBPROP_IMultipleResults;
pub const DBPROP_DATASOURCE_TYPE = DBPROPENUM20.DBPROP_DATASOURCE_TYPE;
pub const MDPROP_AXES = DBPROPENUM20.MDPROP_AXES;
pub const MDPROP_FLATTENING_SUPPORT = DBPROPENUM20.MDPROP_FLATTENING_SUPPORT;
pub const MDPROP_MDX_JOINCUBES = DBPROPENUM20.MDPROP_MDX_JOINCUBES;
pub const MDPROP_NAMED_LEVELS = DBPROPENUM20.MDPROP_NAMED_LEVELS;
pub const MDPROP_RANGEROWSET = DBPROPENUM20.MDPROP_RANGEROWSET;
pub const MDPROP_MDX_SLICER = DBPROPENUM20.MDPROP_MDX_SLICER;
pub const MDPROP_MDX_CUBEQUALIFICATION = DBPROPENUM20.MDPROP_MDX_CUBEQUALIFICATION;
pub const MDPROP_MDX_OUTERREFERENCE = DBPROPENUM20.MDPROP_MDX_OUTERREFERENCE;
pub const MDPROP_MDX_QUERYBYPROPERTY = DBPROPENUM20.MDPROP_MDX_QUERYBYPROPERTY;
pub const MDPROP_MDX_CASESUPPORT = DBPROPENUM20.MDPROP_MDX_CASESUPPORT;
pub const MDPROP_MDX_STRING_COMPOP = DBPROPENUM20.MDPROP_MDX_STRING_COMPOP;
pub const MDPROP_MDX_DESCFLAGS = DBPROPENUM20.MDPROP_MDX_DESCFLAGS;
pub const MDPROP_MDX_SET_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_SET_FUNCTIONS;
pub const MDPROP_MDX_MEMBER_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_MEMBER_FUNCTIONS;
pub const MDPROP_MDX_NUMERIC_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_NUMERIC_FUNCTIONS;
pub const MDPROP_MDX_FORMULAS = DBPROPENUM20.MDPROP_MDX_FORMULAS;
pub const MDPROP_AGGREGATECELL_UPDATE = DBPROPENUM20.MDPROP_AGGREGATECELL_UPDATE;
pub const MDPROP_MDX_AGGREGATECELL_UPDATE = DBPROPENUM20.MDPROP_AGGREGATECELL_UPDATE;
pub const MDPROP_MDX_OBJQUALIFICATION = DBPROPENUM20.MDPROP_MDX_OBJQUALIFICATION;
pub const MDPROP_MDX_NONMEASURE_EXPRESSIONS = DBPROPENUM20.MDPROP_MDX_NONMEASURE_EXPRESSIONS;
pub const DBPROP_ACCESSORDER = DBPROPENUM20.DBPROP_ACCESSORDER;
pub const DBPROP_BOOKMARKINFO = DBPROPENUM20.DBPROP_BOOKMARKINFO;
pub const DBPROP_INIT_CATALOG = DBPROPENUM20.DBPROP_INIT_CATALOG;
pub const DBPROP_ROW_BULKOPS = DBPROPENUM20.DBPROP_ROW_BULKOPS;
pub const DBPROP_PROVIDERFRIENDLYNAME = DBPROPENUM20.DBPROP_PROVIDERFRIENDLYNAME;
pub const DBPROP_LOCKMODE = DBPROPENUM20.DBPROP_LOCKMODE;
pub const DBPROP_MULTIPLECONNECTIONS = DBPROPENUM20.DBPROP_MULTIPLECONNECTIONS;
pub const DBPROP_UNIQUEROWS = DBPROPENUM20.DBPROP_UNIQUEROWS;
pub const DBPROP_SERVERDATAONINSERT = DBPROPENUM20.DBPROP_SERVERDATAONINSERT;
pub const DBPROP_STORAGEFLAGS = DBPROPENUM20.DBPROP_STORAGEFLAGS;
pub const DBPROP_CONNECTIONSTATUS = DBPROPENUM20.DBPROP_CONNECTIONSTATUS;
pub const DBPROP_ALTERCOLUMN = DBPROPENUM20.DBPROP_ALTERCOLUMN;
pub const DBPROP_COLUMNLCID = DBPROPENUM20.DBPROP_COLUMNLCID;
pub const DBPROP_RESETDATASOURCE = DBPROPENUM20.DBPROP_RESETDATASOURCE;
pub const DBPROP_INIT_OLEDBSERVICES = DBPROPENUM20.DBPROP_INIT_OLEDBSERVICES;
pub const DBPROP_IRowsetRefresh = DBPROPENUM20.DBPROP_IRowsetRefresh;
pub const DBPROP_SERVERNAME = DBPROPENUM20.DBPROP_SERVERNAME;
pub const DBPROP_IParentRowset = DBPROPENUM20.DBPROP_IParentRowset;
pub const DBPROP_HIDDENCOLUMNS = DBPROPENUM20.DBPROP_HIDDENCOLUMNS;
pub const DBPROP_PROVIDERMEMORY = DBPROPENUM20.DBPROP_PROVIDERMEMORY;
pub const DBPROP_CLIENTCURSOR = DBPROPENUM20.DBPROP_CLIENTCURSOR;

pub const DBPROPENUM21 = enum(i32) {
    TRUSTEE_USERNAME = 241,
    TRUSTEE_AUTHENTICATION = 242,
    TRUSTEE_NEWAUTHENTICATION = 243,
    IRow = 263,
    IRowChange = 264,
    IRowSchemaChange = 265,
    IGetRow = 266,
    IScopedOperations = 267,
    IBindResource = 268,
    ICreateRow = 269,
    INIT_BINDFLAGS = 270,
    INIT_LOCKOWNER = 271,
    GENERATEURL = 273,
    IDBBinderProperties = 274,
    IColumnsInfo2 = 275,
    IRegisterProvider = 276,
    IGetSession = 277,
    IGetSourceRow = 278,
    IRowsetCurrentIndex = 279,
    OPENROWSETSUPPORT = 280,
    COL_ISLONG = 281,
};
pub const DBPROP_TRUSTEE_USERNAME = DBPROPENUM21.TRUSTEE_USERNAME;
pub const DBPROP_TRUSTEE_AUTHENTICATION = DBPROPENUM21.TRUSTEE_AUTHENTICATION;
pub const DBPROP_TRUSTEE_NEWAUTHENTICATION = DBPROPENUM21.TRUSTEE_NEWAUTHENTICATION;
pub const DBPROP_IRow = DBPROPENUM21.IRow;
pub const DBPROP_IRowChange = DBPROPENUM21.IRowChange;
pub const DBPROP_IRowSchemaChange = DBPROPENUM21.IRowSchemaChange;
pub const DBPROP_IGetRow = DBPROPENUM21.IGetRow;
pub const DBPROP_IScopedOperations = DBPROPENUM21.IScopedOperations;
pub const DBPROP_IBindResource = DBPROPENUM21.IBindResource;
pub const DBPROP_ICreateRow = DBPROPENUM21.ICreateRow;
pub const DBPROP_INIT_BINDFLAGS = DBPROPENUM21.INIT_BINDFLAGS;
pub const DBPROP_INIT_LOCKOWNER = DBPROPENUM21.INIT_LOCKOWNER;
pub const DBPROP_GENERATEURL = DBPROPENUM21.GENERATEURL;
pub const DBPROP_IDBBinderProperties = DBPROPENUM21.IDBBinderProperties;
pub const DBPROP_IColumnsInfo2 = DBPROPENUM21.IColumnsInfo2;
pub const DBPROP_IRegisterProvider = DBPROPENUM21.IRegisterProvider;
pub const DBPROP_IGetSession = DBPROPENUM21.IGetSession;
pub const DBPROP_IGetSourceRow = DBPROPENUM21.IGetSourceRow;
pub const DBPROP_IRowsetCurrentIndex = DBPROPENUM21.IRowsetCurrentIndex;
pub const DBPROP_OPENROWSETSUPPORT = DBPROPENUM21.OPENROWSETSUPPORT;
pub const DBPROP_COL_ISLONG = DBPROPENUM21.COL_ISLONG;

pub const DBPROPENUM25 = enum(i32) {
    COL_SEED = 282,
    COL_INCREMENT = 283,
    INIT_GENERALTIMEOUT = 284,
    COMSERVICES = 285,
};
pub const DBPROP_COL_SEED = DBPROPENUM25.COL_SEED;
pub const DBPROP_COL_INCREMENT = DBPROPENUM25.COL_INCREMENT;
pub const DBPROP_INIT_GENERALTIMEOUT = DBPROPENUM25.INIT_GENERALTIMEOUT;
pub const DBPROP_COMSERVICES = DBPROPENUM25.COMSERVICES;

pub const DBPROPENUM26 = enum(i32) {
    DBPROP_OUTPUTSTREAM = 286,
    DBPROP_OUTPUTENCODING = 287,
    DBPROP_TABLESTATISTICS = 288,
    DBPROP_SKIPROWCOUNTRESULTS = 291,
    DBPROP_IRowsetBookmark = 292,
    MDPROP_VISUALMODE = 293,
};
pub const DBPROP_OUTPUTSTREAM = DBPROPENUM26.DBPROP_OUTPUTSTREAM;
pub const DBPROP_OUTPUTENCODING = DBPROPENUM26.DBPROP_OUTPUTENCODING;
pub const DBPROP_TABLESTATISTICS = DBPROPENUM26.DBPROP_TABLESTATISTICS;
pub const DBPROP_SKIPROWCOUNTRESULTS = DBPROPENUM26.DBPROP_SKIPROWCOUNTRESULTS;
pub const DBPROP_IRowsetBookmark = DBPROPENUM26.DBPROP_IRowsetBookmark;
pub const MDPROP_VISUALMODE = DBPROPENUM26.MDPROP_VISUALMODE;


pub const DBPARAMFLAGSENUM = enum(i32) {
    INPUT = 1,
    OUTPUT = 2,
    SIGNED = 16,
    NULLABLE = 64,
    LONG = 128,
};
pub const DBPARAMFLAGS_ISINPUT = DBPARAMFLAGSENUM.INPUT;
pub const DBPARAMFLAGS_ISOUTPUT = DBPARAMFLAGSENUM.OUTPUT;
pub const DBPARAMFLAGS_ISSIGNED = DBPARAMFLAGSENUM.SIGNED;
pub const DBPARAMFLAGS_ISNULLABLE = DBPARAMFLAGSENUM.NULLABLE;
pub const DBPARAMFLAGS_ISLONG = DBPARAMFLAGSENUM.LONG;

pub const DBPARAMFLAGSENUM20 = enum(i32) {
    E = 256,
};
pub const DBPARAMFLAGS_SCALEISNEGATIVE = DBPARAMFLAGSENUM20.E;



pub const DBPROPFLAGSENUM = enum(i32) {
    NOTSUPPORTED = 0,
    COLUMN = 1,
    DATASOURCE = 2,
    DATASOURCECREATE = 4,
    DATASOURCEINFO = 8,
    DBINIT = 16,
    INDEX = 32,
    ROWSET = 64,
    TABLE = 128,
    COLUMNOK = 256,
    READ = 512,
    WRITE = 1024,
    REQUIRED = 2048,
    SESSION = 4096,
};
pub const DBPROPFLAGS_NOTSUPPORTED = DBPROPFLAGSENUM.NOTSUPPORTED;
pub const DBPROPFLAGS_COLUMN = DBPROPFLAGSENUM.COLUMN;
pub const DBPROPFLAGS_DATASOURCE = DBPROPFLAGSENUM.DATASOURCE;
pub const DBPROPFLAGS_DATASOURCECREATE = DBPROPFLAGSENUM.DATASOURCECREATE;
pub const DBPROPFLAGS_DATASOURCEINFO = DBPROPFLAGSENUM.DATASOURCEINFO;
pub const DBPROPFLAGS_DBINIT = DBPROPFLAGSENUM.DBINIT;
pub const DBPROPFLAGS_INDEX = DBPROPFLAGSENUM.INDEX;
pub const DBPROPFLAGS_ROWSET = DBPROPFLAGSENUM.ROWSET;
pub const DBPROPFLAGS_TABLE = DBPROPFLAGSENUM.TABLE;
pub const DBPROPFLAGS_COLUMNOK = DBPROPFLAGSENUM.COLUMNOK;
pub const DBPROPFLAGS_READ = DBPROPFLAGSENUM.READ;
pub const DBPROPFLAGS_WRITE = DBPROPFLAGSENUM.WRITE;
pub const DBPROPFLAGS_REQUIRED = DBPROPFLAGSENUM.REQUIRED;
pub const DBPROPFLAGS_SESSION = DBPROPFLAGSENUM.SESSION;

pub const DBPROPFLAGSENUM21 = enum(i32) {
    E = 8192,
};
pub const DBPROPFLAGS_TRUSTEE = DBPROPFLAGSENUM21.E;

pub const DBPROPFLAGSENUM25 = enum(i32) {
    W = 16384,
};
pub const DBPROPFLAGS_VIEW = DBPROPFLAGSENUM25.W;

pub const DBPROPFLAGSENUM26 = enum(i32) {
    M = 32768,
};
pub const DBPROPFLAGS_STREAM = DBPROPFLAGSENUM26.M;



pub const DBPROPOPTIONSENUM = enum(i32) {
    REQUIRED = 0,
    SETIFCHEAP = 1,
    pub const OPTIONAL = .SETIFCHEAP;
};
pub const DBPROPOPTIONS_REQUIRED = DBPROPOPTIONSENUM.REQUIRED;
pub const DBPROPOPTIONS_SETIFCHEAP = DBPROPOPTIONSENUM.SETIFCHEAP;
pub const DBPROPOPTIONS_OPTIONAL = DBPROPOPTIONSENUM.SETIFCHEAP;

pub const DBPROPSTATUSENUM = enum(i32) {
    OK = 0,
    NOTSUPPORTED = 1,
    BADVALUE = 2,
    BADOPTION = 3,
    BADCOLUMN = 4,
    NOTALLSETTABLE = 5,
    NOTSETTABLE = 6,
    NOTSET = 7,
    CONFLICTING = 8,
};
pub const DBPROPSTATUS_OK = DBPROPSTATUSENUM.OK;
pub const DBPROPSTATUS_NOTSUPPORTED = DBPROPSTATUSENUM.NOTSUPPORTED;
pub const DBPROPSTATUS_BADVALUE = DBPROPSTATUSENUM.BADVALUE;
pub const DBPROPSTATUS_BADOPTION = DBPROPSTATUSENUM.BADOPTION;
pub const DBPROPSTATUS_BADCOLUMN = DBPROPSTATUSENUM.BADCOLUMN;
pub const DBPROPSTATUS_NOTALLSETTABLE = DBPROPSTATUSENUM.NOTALLSETTABLE;
pub const DBPROPSTATUS_NOTSETTABLE = DBPROPSTATUSENUM.NOTSETTABLE;
pub const DBPROPSTATUS_NOTSET = DBPROPSTATUSENUM.NOTSET;
pub const DBPROPSTATUS_CONFLICTING = DBPROPSTATUSENUM.CONFLICTING;

pub const DBPROPSTATUSENUM21 = enum(i32) {
    E = 9,
};
pub const DBPROPSTATUS_NOTAVAILABLE = DBPROPSTATUSENUM21.E;



pub const DBINDEX_COL_ORDERENUM = enum(i32) {
    ASC = 0,
    DESC = 1,
};
pub const DBINDEX_COL_ORDER_ASC = DBINDEX_COL_ORDERENUM.ASC;
pub const DBINDEX_COL_ORDER_DESC = DBINDEX_COL_ORDERENUM.DESC;




pub const DBCOLUMNDESCFLAGSENUM = enum(i32) {
    TYPENAME = 1,
    ITYPEINFO = 2,
    PROPERTIES = 4,
    CLSID = 8,
    COLSIZE = 16,
    DBCID = 32,
    WTYPE = 64,
    PRECISION = 128,
    SCALE = 256,
};
pub const DBCOLUMNDESCFLAGS_TYPENAME = DBCOLUMNDESCFLAGSENUM.TYPENAME;
pub const DBCOLUMNDESCFLAGS_ITYPEINFO = DBCOLUMNDESCFLAGSENUM.ITYPEINFO;
pub const DBCOLUMNDESCFLAGS_PROPERTIES = DBCOLUMNDESCFLAGSENUM.PROPERTIES;
pub const DBCOLUMNDESCFLAGS_CLSID = DBCOLUMNDESCFLAGSENUM.CLSID;
pub const DBCOLUMNDESCFLAGS_COLSIZE = DBCOLUMNDESCFLAGSENUM.COLSIZE;
pub const DBCOLUMNDESCFLAGS_DBCID = DBCOLUMNDESCFLAGSENUM.DBCID;
pub const DBCOLUMNDESCFLAGS_WTYPE = DBCOLUMNDESCFLAGSENUM.WTYPE;
pub const DBCOLUMNDESCFLAGS_PRECISION = DBCOLUMNDESCFLAGSENUM.PRECISION;
pub const DBCOLUMNDESCFLAGS_SCALE = DBCOLUMNDESCFLAGSENUM.SCALE;

pub const DBEVENTPHASEENUM = enum(i32) {
    OKTODO = 0,
    ABOUTTODO = 1,
    SYNCHAFTER = 2,
    FAILEDTODO = 3,
    DIDEVENT = 4,
};
pub const DBEVENTPHASE_OKTODO = DBEVENTPHASEENUM.OKTODO;
pub const DBEVENTPHASE_ABOUTTODO = DBEVENTPHASEENUM.ABOUTTODO;
pub const DBEVENTPHASE_SYNCHAFTER = DBEVENTPHASEENUM.SYNCHAFTER;
pub const DBEVENTPHASE_FAILEDTODO = DBEVENTPHASEENUM.FAILEDTODO;
pub const DBEVENTPHASE_DIDEVENT = DBEVENTPHASEENUM.DIDEVENT;

pub const DBREASONENUM = enum(i32) {
    ROWSET_FETCHPOSITIONCHANGE = 0,
    ROWSET_RELEASE = 1,
    COLUMN_SET = 2,
    COLUMN_RECALCULATED = 3,
    ROW_ACTIVATE = 4,
    ROW_RELEASE = 5,
    ROW_DELETE = 6,
    ROW_FIRSTCHANGE = 7,
    ROW_INSERT = 8,
    ROW_RESYNCH = 9,
    ROW_UNDOCHANGE = 10,
    ROW_UNDOINSERT = 11,
    ROW_UNDODELETE = 12,
    ROW_UPDATE = 13,
    ROWSET_CHANGED = 14,
};
pub const DBREASON_ROWSET_FETCHPOSITIONCHANGE = DBREASONENUM.ROWSET_FETCHPOSITIONCHANGE;
pub const DBREASON_ROWSET_RELEASE = DBREASONENUM.ROWSET_RELEASE;
pub const DBREASON_COLUMN_SET = DBREASONENUM.COLUMN_SET;
pub const DBREASON_COLUMN_RECALCULATED = DBREASONENUM.COLUMN_RECALCULATED;
pub const DBREASON_ROW_ACTIVATE = DBREASONENUM.ROW_ACTIVATE;
pub const DBREASON_ROW_RELEASE = DBREASONENUM.ROW_RELEASE;
pub const DBREASON_ROW_DELETE = DBREASONENUM.ROW_DELETE;
pub const DBREASON_ROW_FIRSTCHANGE = DBREASONENUM.ROW_FIRSTCHANGE;
pub const DBREASON_ROW_INSERT = DBREASONENUM.ROW_INSERT;
pub const DBREASON_ROW_RESYNCH = DBREASONENUM.ROW_RESYNCH;
pub const DBREASON_ROW_UNDOCHANGE = DBREASONENUM.ROW_UNDOCHANGE;
pub const DBREASON_ROW_UNDOINSERT = DBREASONENUM.ROW_UNDOINSERT;
pub const DBREASON_ROW_UNDODELETE = DBREASONENUM.ROW_UNDODELETE;
pub const DBREASON_ROW_UPDATE = DBREASONENUM.ROW_UPDATE;
pub const DBREASON_ROWSET_CHANGED = DBREASONENUM.ROWSET_CHANGED;

pub const DBREASONENUM15 = enum(i32) {
    POSITION_CHANGED = 15,
    POSITION_CHAPTERCHANGED = 16,
    POSITION_CLEARED = 17,
    _ASYNCHINSERT = 18,
};
pub const DBREASON_ROWPOSITION_CHANGED = DBREASONENUM15.POSITION_CHANGED;
pub const DBREASON_ROWPOSITION_CHAPTERCHANGED = DBREASONENUM15.POSITION_CHAPTERCHANGED;
pub const DBREASON_ROWPOSITION_CLEARED = DBREASONENUM15.POSITION_CLEARED;
pub const DBREASON_ROW_ASYNCHINSERT = DBREASONENUM15._ASYNCHINSERT;

pub const DBCOMPAREOPSENUM = enum(i32) {
    LT = 0,
    LE = 1,
    EQ = 2,
    GE = 3,
    GT = 4,
    BEGINSWITH = 5,
    CONTAINS = 6,
    NE = 7,
    IGNORE = 8,
    CASESENSITIVE = 4096,
    CASEINSENSITIVE = 8192,
};
pub const DBCOMPAREOPS_LT = DBCOMPAREOPSENUM.LT;
pub const DBCOMPAREOPS_LE = DBCOMPAREOPSENUM.LE;
pub const DBCOMPAREOPS_EQ = DBCOMPAREOPSENUM.EQ;
pub const DBCOMPAREOPS_GE = DBCOMPAREOPSENUM.GE;
pub const DBCOMPAREOPS_GT = DBCOMPAREOPSENUM.GT;
pub const DBCOMPAREOPS_BEGINSWITH = DBCOMPAREOPSENUM.BEGINSWITH;
pub const DBCOMPAREOPS_CONTAINS = DBCOMPAREOPSENUM.CONTAINS;
pub const DBCOMPAREOPS_NE = DBCOMPAREOPSENUM.NE;
pub const DBCOMPAREOPS_IGNORE = DBCOMPAREOPSENUM.IGNORE;
pub const DBCOMPAREOPS_CASESENSITIVE = DBCOMPAREOPSENUM.CASESENSITIVE;
pub const DBCOMPAREOPS_CASEINSENSITIVE = DBCOMPAREOPSENUM.CASEINSENSITIVE;

pub const DBCOMPAREOPSENUM20 = enum(i32) {
    BEGINSWITH = 9,
    CONTAINS = 10,
};
pub const DBCOMPAREOPS_NOTBEGINSWITH = DBCOMPAREOPSENUM20.BEGINSWITH;
pub const DBCOMPAREOPS_NOTCONTAINS = DBCOMPAREOPSENUM20.CONTAINS;

pub const DBASYNCHOPENUM = enum(i32) {
    N = 0,
};
pub const DBASYNCHOP_OPEN = DBASYNCHOPENUM.N;

pub const DBASYNCHPHASEENUM = enum(i32) {
    INITIALIZATION = 0,
    POPULATION = 1,
    COMPLETE = 2,
    CANCELED = 3,
};
pub const DBASYNCHPHASE_INITIALIZATION = DBASYNCHPHASEENUM.INITIALIZATION;
pub const DBASYNCHPHASE_POPULATION = DBASYNCHPHASEENUM.POPULATION;
pub const DBASYNCHPHASE_COMPLETE = DBASYNCHPHASEENUM.COMPLETE;
pub const DBASYNCHPHASE_CANCELED = DBASYNCHPHASEENUM.CANCELED;

pub const DBSORTENUM = enum(i32) {
    ASCENDING = 0,
    DESCENDING = 1,
};
pub const DBSORT_ASCENDING = DBSORTENUM.ASCENDING;
pub const DBSORT_DESCENDING = DBSORTENUM.DESCENDING;

pub const DBCOMMANDPERSISTFLAGENUM = enum(i32) {
    E = 1,
};
pub const DBCOMMANDPERSISTFLAG_NOSAVE = DBCOMMANDPERSISTFLAGENUM.E;

pub const DBCOMMANDPERSISTFLAGENUM21 = enum(i32) {
    DEFAULT = 0,
    PERSISTVIEW = 2,
    PERSISTPROCEDURE = 4,
};
pub const DBCOMMANDPERSISTFLAG_DEFAULT = DBCOMMANDPERSISTFLAGENUM21.DEFAULT;
pub const DBCOMMANDPERSISTFLAG_PERSISTVIEW = DBCOMMANDPERSISTFLAGENUM21.PERSISTVIEW;
pub const DBCOMMANDPERSISTFLAG_PERSISTPROCEDURE = DBCOMMANDPERSISTFLAGENUM21.PERSISTPROCEDURE;

pub const DBCONSTRAINTTYPEENUM = enum(i32) {
    UNIQUE = 0,
    FOREIGNKEY = 1,
    PRIMARYKEY = 2,
    CHECK = 3,
};
pub const DBCONSTRAINTTYPE_UNIQUE = DBCONSTRAINTTYPEENUM.UNIQUE;
pub const DBCONSTRAINTTYPE_FOREIGNKEY = DBCONSTRAINTTYPEENUM.FOREIGNKEY;
pub const DBCONSTRAINTTYPE_PRIMARYKEY = DBCONSTRAINTTYPEENUM.PRIMARYKEY;
pub const DBCONSTRAINTTYPE_CHECK = DBCONSTRAINTTYPEENUM.CHECK;

pub const DBUPDELRULEENUM = enum(i32) {
    NOACTION = 0,
    CASCADE = 1,
    SETNULL = 2,
    SETDEFAULT = 3,
};
pub const DBUPDELRULE_NOACTION = DBUPDELRULEENUM.NOACTION;
pub const DBUPDELRULE_CASCADE = DBUPDELRULEENUM.CASCADE;
pub const DBUPDELRULE_SETNULL = DBUPDELRULEENUM.SETNULL;
pub const DBUPDELRULE_SETDEFAULT = DBUPDELRULEENUM.SETDEFAULT;

pub const DBMATCHTYPEENUM = enum(i32) {
    FULL = 0,
    NONE = 1,
    PARTIAL = 2,
};
pub const DBMATCHTYPE_FULL = DBMATCHTYPEENUM.FULL;
pub const DBMATCHTYPE_NONE = DBMATCHTYPEENUM.NONE;
pub const DBMATCHTYPE_PARTIAL = DBMATCHTYPEENUM.PARTIAL;

pub const DBDEFERRABILITYENUM = enum(i32) {
    ED = 1,
    ABLE = 2,
};
pub const DBDEFERRABILITY_DEFERRED = DBDEFERRABILITYENUM.ED;
pub const DBDEFERRABILITY_DEFERRABLE = DBDEFERRABILITYENUM.ABLE;




pub const DBACCESSORFLAGSENUM = enum(i32) {
    INVALID = 0,
    PASSBYREF = 1,
    ROWDATA = 2,
    PARAMETERDATA = 4,
    OPTIMIZED = 8,
    INHERITED = 16,
};
pub const DBACCESSOR_INVALID = DBACCESSORFLAGSENUM.INVALID;
pub const DBACCESSOR_PASSBYREF = DBACCESSORFLAGSENUM.PASSBYREF;
pub const DBACCESSOR_ROWDATA = DBACCESSORFLAGSENUM.ROWDATA;
pub const DBACCESSOR_PARAMETERDATA = DBACCESSORFLAGSENUM.PARAMETERDATA;
pub const DBACCESSOR_OPTIMIZED = DBACCESSORFLAGSENUM.OPTIMIZED;
pub const DBACCESSOR_INHERITED = DBACCESSORFLAGSENUM.INHERITED;

pub const DBBINDSTATUSENUM = enum(i32) {
    OK = 0,
    BADORDINAL = 1,
    UNSUPPORTEDCONVERSION = 2,
    BADBINDINFO = 3,
    BADSTORAGEFLAGS = 4,
    NOINTERFACE = 5,
    MULTIPLESTORAGE = 6,
};
pub const DBBINDSTATUS_OK = DBBINDSTATUSENUM.OK;
pub const DBBINDSTATUS_BADORDINAL = DBBINDSTATUSENUM.BADORDINAL;
pub const DBBINDSTATUS_UNSUPPORTEDCONVERSION = DBBINDSTATUSENUM.UNSUPPORTEDCONVERSION;
pub const DBBINDSTATUS_BADBINDINFO = DBBINDSTATUSENUM.BADBINDINFO;
pub const DBBINDSTATUS_BADSTORAGEFLAGS = DBBINDSTATUSENUM.BADSTORAGEFLAGS;
pub const DBBINDSTATUS_NOINTERFACE = DBBINDSTATUSENUM.NOINTERFACE;
pub const DBBINDSTATUS_MULTIPLESTORAGE = DBBINDSTATUSENUM.MULTIPLESTORAGE;

const IID_IAccessor_Value = Guid.initString("0c733a8c-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IAccessor = &IID_IAccessor_Value;
pub const IAccessor = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefAccessor: *const fn(
            self: *const IAccessor,
            hAccessor: usize,
            pcRefCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAccessor: *const fn(
            self: *const IAccessor,
            dwAccessorFlags: u32,
            cBindings: usize,
            rgBindings: [*]const DBBINDING,
            cbRowSize: usize,
            phAccessor: ?*usize,
            rgStatus: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindings: *const fn(
            self: *const IAccessor,
            hAccessor: usize,
            pdwAccessorFlags: ?*u32,
            pcBindings: ?*usize,
            prgBindings: ?*?*DBBINDING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseAccessor: *const fn(
            self: *const IAccessor,
            hAccessor: usize,
            pcRefCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn AddRefAccessor(self: *const IAccessor, hAccessor: usize, pcRefCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.AddRefAccessor(self, hAccessor, pcRefCount);
    }
    pub fn CreateAccessor(self: *const IAccessor, dwAccessorFlags: u32, cBindings: usize, rgBindings: [*]const DBBINDING, cbRowSize: usize, phAccessor: ?*usize, rgStatus: ?[*]u32) callconv(.Inline) HRESULT {
        return self.vtable.CreateAccessor(self, dwAccessorFlags, cBindings, rgBindings, cbRowSize, phAccessor, rgStatus);
    }
    pub fn GetBindings(self: *const IAccessor, hAccessor: usize, pdwAccessorFlags: ?*u32, pcBindings: ?*usize, prgBindings: ?*?*DBBINDING) callconv(.Inline) HRESULT {
        return self.vtable.GetBindings(self, hAccessor, pdwAccessorFlags, pcBindings, prgBindings);
    }
    pub fn ReleaseAccessor(self: *const IAccessor, hAccessor: usize, pcRefCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.ReleaseAccessor(self, hAccessor, pcRefCount);
    }
};

const IID_IRowset_Value = Guid.initString("0c733a7c-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowset = &IID_IRowset_Value;
pub const IRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefRows: *const fn(
            self: *const IRowset,
            cRows: usize,
            rghRows: ?*const usize,
            rgRefCounts: ?*u32,
            rgRowStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: *const fn(
            self: *const IRowset,
            hRow: usize,
            hAccessor: usize,
            pData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextRows: *const fn(
            self: *const IRowset,
            hReserved: usize,
            lRowsOffset: isize,
            cRows: isize,
            pcRowsObtained: ?*usize,
            prghRows: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseRows: *const fn(
            self: *const IRowset,
            cRows: usize,
            rghRows: ?*const usize,
            rgRowOptions: ?*u32,
            rgRefCounts: ?*u32,
            rgRowStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestartPosition: *const fn(
            self: *const IRowset,
            hReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn AddRefRows(self: *const IRowset, cRows: usize, rghRows: ?*const usize, rgRefCounts: ?*u32, rgRowStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.AddRefRows(self, cRows, rghRows, rgRefCounts, rgRowStatus);
    }
    pub fn GetData(self: *const IRowset, hRow: usize, hAccessor: usize, pData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetData(self, hRow, hAccessor, pData);
    }
    pub fn GetNextRows(self: *const IRowset, hReserved: usize, lRowsOffset: isize, cRows: isize, pcRowsObtained: ?*usize, prghRows: ?*?*usize) callconv(.Inline) HRESULT {
        return self.vtable.GetNextRows(self, hReserved, lRowsOffset, cRows, pcRowsObtained, prghRows);
    }
    pub fn ReleaseRows(self: *const IRowset, cRows: usize, rghRows: ?*const usize, rgRowOptions: ?*u32, rgRefCounts: ?*u32, rgRowStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.ReleaseRows(self, cRows, rghRows, rgRowOptions, rgRefCounts, rgRowStatus);
    }
    pub fn RestartPosition(self: *const IRowset, hReserved: usize) callconv(.Inline) HRESULT {
        return self.vtable.RestartPosition(self, hReserved);
    }
};

const IID_IRowsetInfo_Value = Guid.initString("0c733a55-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetInfo = &IID_IRowsetInfo_Value;
pub const IRowsetInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: *const fn(
            self: *const IRowsetInfo,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertySets: ?*u32,
            prgPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReferencedRowset: *const fn(
            self: *const IRowsetInfo,
            iOrdinal: usize,
            riid: ?*const Guid,
            ppReferencedRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecification: *const fn(
            self: *const IRowsetInfo,
            riid: ?*const Guid,
            ppSpecification: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetProperties(self: *const IRowsetInfo, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.GetProperties(self, cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
    }
    pub fn GetReferencedRowset(self: *const IRowsetInfo, iOrdinal: usize, riid: ?*const Guid, ppReferencedRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetReferencedRowset(self, iOrdinal, riid, ppReferencedRowset);
    }
    pub fn GetSpecification(self: *const IRowsetInfo, riid: ?*const Guid, ppSpecification: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetSpecification(self, riid, ppSpecification);
    }
};

pub const DBCOMPAREENUM = enum(i32) {
    LT = 0,
    EQ = 1,
    GT = 2,
    NE = 3,
    NOTCOMPARABLE = 4,
};
pub const DBCOMPARE_LT = DBCOMPAREENUM.LT;
pub const DBCOMPARE_EQ = DBCOMPAREENUM.EQ;
pub const DBCOMPARE_GT = DBCOMPAREENUM.GT;
pub const DBCOMPARE_NE = DBCOMPAREENUM.NE;
pub const DBCOMPARE_NOTCOMPARABLE = DBCOMPAREENUM.NOTCOMPARABLE;

const IID_IRowsetLocate_Value = Guid.initString("0c733a7d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetLocate = &IID_IRowsetLocate_Value;
pub const IRowsetLocate = extern union {
    pub const VTable = extern struct {
        base: IRowset.VTable,
        Compare: *const fn(
            self: *const IRowsetLocate,
            hReserved: usize,
            cbBookmark1: usize,
            pBookmark1: ?*const u8,
            cbBookmark2: usize,
            pBookmark2: ?*const u8,
            pComparison: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowsAt: *const fn(
            self: *const IRowsetLocate,
            hReserved1: usize,
            hReserved2: usize,
            cbBookmark: usize,
            pBookmark: ?*const u8,
            lRowsOffset: isize,
            cRows: isize,
            pcRowsObtained: ?*usize,
            prghRows: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowsByBookmark: *const fn(
            self: *const IRowsetLocate,
            hReserved: usize,
            cRows: usize,
            rgcbBookmarks: ?*const usize,
            rgpBookmarks: ?*const ?*u8,
            rghRows: ?*usize,
            rgRowStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hash: *const fn(
            self: *const IRowsetLocate,
            hReserved: usize,
            cBookmarks: usize,
            rgcbBookmarks: ?*const usize,
            rgpBookmarks: ?*const ?*u8,
            rgHashedValues: ?*usize,
            rgBookmarkStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IRowset: IRowset,
    IUnknown: IUnknown,
    pub fn Compare(self: *const IRowsetLocate, hReserved: usize, cbBookmark1: usize, pBookmark1: ?*const u8, cbBookmark2: usize, pBookmark2: ?*const u8, pComparison: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Compare(self, hReserved, cbBookmark1, pBookmark1, cbBookmark2, pBookmark2, pComparison);
    }
    pub fn GetRowsAt(self: *const IRowsetLocate, hReserved1: usize, hReserved2: usize, cbBookmark: usize, pBookmark: ?*const u8, lRowsOffset: isize, cRows: isize, pcRowsObtained: ?*usize, prghRows: ?*?*usize) callconv(.Inline) HRESULT {
        return self.vtable.GetRowsAt(self, hReserved1, hReserved2, cbBookmark, pBookmark, lRowsOffset, cRows, pcRowsObtained, prghRows);
    }
    pub fn GetRowsByBookmark(self: *const IRowsetLocate, hReserved: usize, cRows: usize, rgcbBookmarks: ?*const usize, rgpBookmarks: ?*const ?*u8, rghRows: ?*usize, rgRowStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetRowsByBookmark(self, hReserved, cRows, rgcbBookmarks, rgpBookmarks, rghRows, rgRowStatus);
    }
    pub fn Hash(self: *const IRowsetLocate, hReserved: usize, cBookmarks: usize, rgcbBookmarks: ?*const usize, rgpBookmarks: ?*const ?*u8, rgHashedValues: ?*usize, rgBookmarkStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Hash(self, hReserved, cBookmarks, rgcbBookmarks, rgpBookmarks, rgHashedValues, rgBookmarkStatus);
    }
};

const IID_IRowsetResynch_Value = Guid.initString("0c733a84-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetResynch = &IID_IRowsetResynch_Value;
pub const IRowsetResynch = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVisibleData: *const fn(
            self: *const IRowsetResynch,
            hRow: usize,
            hAccessor: usize,
            pData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResynchRows: *const fn(
            self: *const IRowsetResynch,
            cRows: usize,
            rghRows: ?*const usize,
            pcRowsResynched: ?*usize,
            prghRowsResynched: ?*?*usize,
            prgRowStatus: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetVisibleData(self: *const IRowsetResynch, hRow: usize, hAccessor: usize, pData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetVisibleData(self, hRow, hAccessor, pData);
    }
    pub fn ResynchRows(self: *const IRowsetResynch, cRows: usize, rghRows: ?*const usize, pcRowsResynched: ?*usize, prghRowsResynched: ?*?*usize, prgRowStatus: ?*?*u32) callconv(.Inline) HRESULT {
        return self.vtable.ResynchRows(self, cRows, rghRows, pcRowsResynched, prghRowsResynched, prgRowStatus);
    }
};

const IID_IRowsetScroll_Value = Guid.initString("0c733a7e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetScroll = &IID_IRowsetScroll_Value;
pub const IRowsetScroll = extern union {
    pub const VTable = extern struct {
        base: IRowsetLocate.VTable,
        GetApproximatePosition: *const fn(
            self: *const IRowsetScroll,
            hReserved: usize,
            cbBookmark: usize,
            pBookmark: ?*const u8,
            pulPosition: ?*usize,
            pcRows: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowsAtRatio: *const fn(
            self: *const IRowsetScroll,
            hReserved1: usize,
            hReserved2: usize,
            ulNumerator: usize,
            ulDenominator: usize,
            cRows: isize,
            pcRowsObtained: ?*usize,
            prghRows: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IRowsetLocate: IRowsetLocate,
    IRowset: IRowset,
    IUnknown: IUnknown,
    pub fn GetApproximatePosition(self: *const IRowsetScroll, hReserved: usize, cbBookmark: usize, pBookmark: ?*const u8, pulPosition: ?*usize, pcRows: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.GetApproximatePosition(self, hReserved, cbBookmark, pBookmark, pulPosition, pcRows);
    }
    pub fn GetRowsAtRatio(self: *const IRowsetScroll, hReserved1: usize, hReserved2: usize, ulNumerator: usize, ulDenominator: usize, cRows: isize, pcRowsObtained: ?*usize, prghRows: ?*?*usize) callconv(.Inline) HRESULT {
        return self.vtable.GetRowsAtRatio(self, hReserved1, hReserved2, ulNumerator, ulDenominator, cRows, pcRowsObtained, prghRows);
    }
};

const IID_IChapteredRowset_Value = Guid.initString("0c733a93-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IChapteredRowset = &IID_IChapteredRowset_Value;
pub const IChapteredRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefChapter: *const fn(
            self: *const IChapteredRowset,
            hChapter: usize,
            pcRefCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseChapter: *const fn(
            self: *const IChapteredRowset,
            hChapter: usize,
            pcRefCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn AddRefChapter(self: *const IChapteredRowset, hChapter: usize, pcRefCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.AddRefChapter(self, hChapter, pcRefCount);
    }
    pub fn ReleaseChapter(self: *const IChapteredRowset, hChapter: usize, pcRefCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.ReleaseChapter(self, hChapter, pcRefCount);
    }
};

const IID_IRowsetFind_Value = Guid.initString("0c733a9d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetFind = &IID_IRowsetFind_Value;
pub const IRowsetFind = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindNextRow: *const fn(
            self: *const IRowsetFind,
            hChapter: usize,
            hAccessor: usize,
            pFindValue: ?*anyopaque,
            CompareOp: u32,
            cbBookmark: usize,
            pBookmark: ?*const u8,
            lRowsOffset: isize,
            cRows: isize,
            pcRowsObtained: ?*usize,
            prghRows: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn FindNextRow(self: *const IRowsetFind, hChapter: usize, hAccessor: usize, pFindValue: ?*anyopaque, CompareOp: u32, cbBookmark: usize, pBookmark: ?*const u8, lRowsOffset: isize, cRows: isize, pcRowsObtained: ?*usize, prghRows: ?*?*usize) callconv(.Inline) HRESULT {
        return self.vtable.FindNextRow(self, hChapter, hAccessor, pFindValue, CompareOp, cbBookmark, pBookmark, lRowsOffset, cRows, pcRowsObtained, prghRows);
    }
};

pub const DBPOSITIONFLAGSENUM = enum(i32) {
    OK = 0,
    NOROW = 1,
    BOF = 2,
    EOF = 3,
};
pub const DBPOSITION_OK = DBPOSITIONFLAGSENUM.OK;
pub const DBPOSITION_NOROW = DBPOSITIONFLAGSENUM.NOROW;
pub const DBPOSITION_BOF = DBPOSITIONFLAGSENUM.BOF;
pub const DBPOSITION_EOF = DBPOSITIONFLAGSENUM.EOF;

const IID_IRowPosition_Value = Guid.initString("0c733a94-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowPosition = &IID_IRowPosition_Value;
pub const IRowPosition = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ClearRowPosition: *const fn(
            self: *const IRowPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowPosition: *const fn(
            self: *const IRowPosition,
            phChapter: ?*usize,
            phRow: ?*usize,
            pdwPositionFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowset: *const fn(
            self: *const IRowPosition,
            riid: ?*const Guid,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: *const fn(
            self: *const IRowPosition,
            pRowset: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRowPosition: *const fn(
            self: *const IRowPosition,
            hChapter: usize,
            hRow: usize,
            dwPositionFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn ClearRowPosition(self: *const IRowPosition) callconv(.Inline) HRESULT {
        return self.vtable.ClearRowPosition(self);
    }
    pub fn GetRowPosition(self: *const IRowPosition, phChapter: ?*usize, phRow: ?*usize, pdwPositionFlags: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetRowPosition(self, phChapter, phRow, pdwPositionFlags);
    }
    pub fn GetRowset(self: *const IRowPosition, riid: ?*const Guid, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetRowset(self, riid, ppRowset);
    }
    pub fn Initialize(self: *const IRowPosition, pRowset: ?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.Initialize(self, pRowset);
    }
    pub fn SetRowPosition(self: *const IRowPosition, hChapter: usize, hRow: usize, dwPositionFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetRowPosition(self, hChapter, hRow, dwPositionFlags);
    }
};

const IID_IRowPositionChange_Value = Guid.initString("0997a571-126e-11d0-9f8a-00a0c9a0631e");
pub const IID_IRowPositionChange = &IID_IRowPositionChange_Value;
pub const IRowPositionChange = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRowPositionChange: *const fn(
            self: *const IRowPositionChange,
            eReason: u32,
            ePhase: u32,
            fCantDeny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OnRowPositionChange(self: *const IRowPositionChange, eReason: u32, ePhase: u32, fCantDeny: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.OnRowPositionChange(self, eReason, ePhase, fCantDeny);
    }
};

const IID_IViewRowset_Value = Guid.initString("0c733a97-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewRowset = &IID_IViewRowset_Value;
pub const IViewRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSpecification: *const fn(
            self: *const IViewRowset,
            riid: ?*const Guid,
            ppObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenViewRowset: *const fn(
            self: *const IViewRowset,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetSpecification(self: *const IViewRowset, riid: ?*const Guid, ppObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetSpecification(self, riid, ppObject);
    }
    pub fn OpenViewRowset(self: *const IViewRowset, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.OpenViewRowset(self, pUnkOuter, riid, ppRowset);
    }
};

const IID_IViewChapter_Value = Guid.initString("0c733a98-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewChapter = &IID_IViewChapter_Value;
pub const IViewChapter = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSpecification: *const fn(
            self: *const IViewChapter,
            riid: ?*const Guid,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenViewChapter: *const fn(
            self: *const IViewChapter,
            hSource: usize,
            phViewChapter: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetSpecification(self: *const IViewChapter, riid: ?*const Guid, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetSpecification(self, riid, ppRowset);
    }
    pub fn OpenViewChapter(self: *const IViewChapter, hSource: usize, phViewChapter: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.OpenViewChapter(self, hSource, phViewChapter);
    }
};

const IID_IViewSort_Value = Guid.initString("0c733a9a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewSort = &IID_IViewSort_Value;
pub const IViewSort = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSortOrder: *const fn(
            self: *const IViewSort,
            pcValues: ?*usize,
            prgColumns: ?*?*usize,
            prgOrders: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSortOrder: *const fn(
            self: *const IViewSort,
            cValues: usize,
            rgColumns: [*]const usize,
            rgOrders: [*]const u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetSortOrder(self: *const IViewSort, pcValues: ?*usize, prgColumns: ?*?*usize, prgOrders: ?*?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetSortOrder(self, pcValues, prgColumns, prgOrders);
    }
    pub fn SetSortOrder(self: *const IViewSort, cValues: usize, rgColumns: [*]const usize, rgOrders: [*]const u32) callconv(.Inline) HRESULT {
        return self.vtable.SetSortOrder(self, cValues, rgColumns, rgOrders);
    }
};

const IID_IViewFilter_Value = Guid.initString("0c733a9b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewFilter = &IID_IViewFilter_Value;
pub const IViewFilter = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilter: *const fn(
            self: *const IViewFilter,
            hAccessor: usize,
            pcRows: ?*usize,
            pCompareOps: [*]?*u32,
            pCriteriaData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterBindings: *const fn(
            self: *const IViewFilter,
            pcBindings: ?*usize,
            prgBindings: ?*?*DBBINDING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilter: *const fn(
            self: *const IViewFilter,
            hAccessor: usize,
            cRows: usize,
            CompareOps: [*]u32,
            pCriteriaData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetFilter(self: *const IViewFilter, hAccessor: usize, pcRows: ?*usize, pCompareOps: [*]?*u32, pCriteriaData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetFilter(self, hAccessor, pcRows, pCompareOps, pCriteriaData);
    }
    pub fn GetFilterBindings(self: *const IViewFilter, pcBindings: ?*usize, prgBindings: ?*?*DBBINDING) callconv(.Inline) HRESULT {
        return self.vtable.GetFilterBindings(self, pcBindings, prgBindings);
    }
    pub fn SetFilter(self: *const IViewFilter, hAccessor: usize, cRows: usize, CompareOps: [*]u32, pCriteriaData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.SetFilter(self, hAccessor, cRows, CompareOps, pCriteriaData);
    }
};

const IID_IRowsetView_Value = Guid.initString("0c733a99-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetView = &IID_IRowsetView_Value;
pub const IRowsetView = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateView: *const fn(
            self: *const IRowsetView,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppView: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetView: *const fn(
            self: *const IRowsetView,
            hChapter: usize,
            riid: ?*const Guid,
            phChapterSource: ?*usize,
            ppView: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateView(self: *const IRowsetView, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppView: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.CreateView(self, pUnkOuter, riid, ppView);
    }
    pub fn GetView(self: *const IRowsetView, hChapter: usize, riid: ?*const Guid, phChapterSource: ?*usize, ppView: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetView(self, hChapter, riid, phChapterSource, ppView);
    }
};

const IID_IRowsetChange_Value = Guid.initString("0c733a05-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetChange = &IID_IRowsetChange_Value;
pub const IRowsetChange = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteRows: *const fn(
            self: *const IRowsetChange,
            hReserved: usize,
            cRows: usize,
            rghRows: ?*const usize,
            rgRowStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetData: *const fn(
            self: *const IRowsetChange,
            hRow: usize,
            hAccessor: usize,
            pData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertRow: *const fn(
            self: *const IRowsetChange,
            hReserved: usize,
            hAccessor: usize,
            pData: ?*anyopaque,
            phRow: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn DeleteRows(self: *const IRowsetChange, hReserved: usize, cRows: usize, rghRows: ?*const usize, rgRowStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.DeleteRows(self, hReserved, cRows, rghRows, rgRowStatus);
    }
    pub fn SetData(self: *const IRowsetChange, hRow: usize, hAccessor: usize, pData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.SetData(self, hRow, hAccessor, pData);
    }
    pub fn InsertRow(self: *const IRowsetChange, hReserved: usize, hAccessor: usize, pData: ?*anyopaque, phRow: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.InsertRow(self, hReserved, hAccessor, pData, phRow);
    }
};

pub const DBPENDINGSTATUSENUM = enum(i32) {
    NEW = 1,
    CHANGED = 2,
    DELETED = 4,
    UNCHANGED = 8,
    INVALIDROW = 16,
};
pub const DBPENDINGSTATUS_NEW = DBPENDINGSTATUSENUM.NEW;
pub const DBPENDINGSTATUS_CHANGED = DBPENDINGSTATUSENUM.CHANGED;
pub const DBPENDINGSTATUS_DELETED = DBPENDINGSTATUSENUM.DELETED;
pub const DBPENDINGSTATUS_UNCHANGED = DBPENDINGSTATUSENUM.UNCHANGED;
pub const DBPENDINGSTATUS_INVALIDROW = DBPENDINGSTATUSENUM.INVALIDROW;

const IID_IRowsetUpdate_Value = Guid.initString("0c733a6d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetUpdate = &IID_IRowsetUpdate_Value;
pub const IRowsetUpdate = extern union {
    pub const VTable = extern struct {
        base: IRowsetChange.VTable,
        GetOriginalData: *const fn(
            self: *const IRowsetUpdate,
            hRow: usize,
            hAccessor: usize,
            pData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPendingRows: *const fn(
            self: *const IRowsetUpdate,
            hReserved: usize,
            dwRowStatus: u32,
            pcPendingRows: ?*usize,
            prgPendingRows: ?*?*usize,
            prgPendingStatus: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowStatus: *const fn(
            self: *const IRowsetUpdate,
            hReserved: usize,
            cRows: usize,
            rghRows: ?*const usize,
            rgPendingStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Undo: *const fn(
            self: *const IRowsetUpdate,
            hReserved: usize,
            cRows: usize,
            rghRows: ?*const usize,
            pcRowsUndone: ?*usize,
            prgRowsUndone: ?*?*usize,
            prgRowStatus: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: *const fn(
            self: *const IRowsetUpdate,
            hReserved: usize,
            cRows: usize,
            rghRows: ?*const usize,
            pcRows: ?*usize,
            prgRows: ?*?*usize,
            prgRowStatus: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IRowsetChange: IRowsetChange,
    IUnknown: IUnknown,
    pub fn GetOriginalData(self: *const IRowsetUpdate, hRow: usize, hAccessor: usize, pData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetOriginalData(self, hRow, hAccessor, pData);
    }
    pub fn GetPendingRows(self: *const IRowsetUpdate, hReserved: usize, dwRowStatus: u32, pcPendingRows: ?*usize, prgPendingRows: ?*?*usize, prgPendingStatus: ?*?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetPendingRows(self, hReserved, dwRowStatus, pcPendingRows, prgPendingRows, prgPendingStatus);
    }
    pub fn GetRowStatus(self: *const IRowsetUpdate, hReserved: usize, cRows: usize, rghRows: ?*const usize, rgPendingStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetRowStatus(self, hReserved, cRows, rghRows, rgPendingStatus);
    }
    pub fn Undo(self: *const IRowsetUpdate, hReserved: usize, cRows: usize, rghRows: ?*const usize, pcRowsUndone: ?*usize, prgRowsUndone: ?*?*usize, prgRowStatus: ?*?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Undo(self, hReserved, cRows, rghRows, pcRowsUndone, prgRowsUndone, prgRowStatus);
    }
    pub fn Update(self: *const IRowsetUpdate, hReserved: usize, cRows: usize, rghRows: ?*const usize, pcRows: ?*usize, prgRows: ?*?*usize, prgRowStatus: ?*?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Update(self, hReserved, cRows, rghRows, pcRows, prgRows, prgRowStatus);
    }
};

const IID_IRowsetIdentity_Value = Guid.initString("0c733a09-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetIdentity = &IID_IRowsetIdentity_Value;
pub const IRowsetIdentity = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSameRow: *const fn(
            self: *const IRowsetIdentity,
            hThisRow: usize,
            hThatRow: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn IsSameRow(self: *const IRowsetIdentity, hThisRow: usize, hThatRow: usize) callconv(.Inline) HRESULT {
        return self.vtable.IsSameRow(self, hThisRow, hThatRow);
    }
};

const IID_IRowsetNotify_Value = Guid.initString("0c733a83-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetNotify = &IID_IRowsetNotify_Value;
pub const IRowsetNotify = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFieldChange: *const fn(
            self: *const IRowsetNotify,
            pRowset: ?*IRowset,
            hRow: usize,
            cColumns: usize,
            rgColumns: [*]usize,
            eReason: u32,
            ePhase: u32,
            fCantDeny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRowChange: *const fn(
            self: *const IRowsetNotify,
            pRowset: ?*IRowset,
            cRows: usize,
            rghRows: [*]const usize,
            eReason: u32,
            ePhase: u32,
            fCantDeny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRowsetChange: *const fn(
            self: *const IRowsetNotify,
            pRowset: ?*IRowset,
            eReason: u32,
            ePhase: u32,
            fCantDeny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OnFieldChange(self: *const IRowsetNotify, pRowset: ?*IRowset, hRow: usize, cColumns: usize, rgColumns: [*]usize, eReason: u32, ePhase: u32, fCantDeny: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.OnFieldChange(self, pRowset, hRow, cColumns, rgColumns, eReason, ePhase, fCantDeny);
    }
    pub fn OnRowChange(self: *const IRowsetNotify, pRowset: ?*IRowset, cRows: usize, rghRows: [*]const usize, eReason: u32, ePhase: u32, fCantDeny: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.OnRowChange(self, pRowset, cRows, rghRows, eReason, ePhase, fCantDeny);
    }
    pub fn OnRowsetChange(self: *const IRowsetNotify, pRowset: ?*IRowset, eReason: u32, ePhase: u32, fCantDeny: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.OnRowsetChange(self, pRowset, eReason, ePhase, fCantDeny);
    }
};

pub const DBSEEKENUM = enum(i32) {
    INVALID = 0,
    FIRSTEQ = 1,
    LASTEQ = 2,
    AFTEREQ = 4,
    AFTER = 8,
    BEFOREEQ = 16,
    BEFORE = 32,
};
pub const DBSEEK_INVALID = DBSEEKENUM.INVALID;
pub const DBSEEK_FIRSTEQ = DBSEEKENUM.FIRSTEQ;
pub const DBSEEK_LASTEQ = DBSEEKENUM.LASTEQ;
pub const DBSEEK_AFTEREQ = DBSEEKENUM.AFTEREQ;
pub const DBSEEK_AFTER = DBSEEKENUM.AFTER;
pub const DBSEEK_BEFOREEQ = DBSEEKENUM.BEFOREEQ;
pub const DBSEEK_BEFORE = DBSEEKENUM.BEFORE;

pub const DBRANGEENUM = enum(i32) {
    INCLUSIVESTART = 0,
    EXCLUSIVESTART = 1,
    EXCLUSIVEEND = 2,
    EXCLUDENULLS = 4,
    PREFIX = 8,
    MATCH = 16,
    pub const INCLUSIVEEND = .INCLUSIVESTART;
};
pub const DBRANGE_INCLUSIVESTART = DBRANGEENUM.INCLUSIVESTART;
pub const DBRANGE_INCLUSIVEEND = DBRANGEENUM.INCLUSIVESTART;
pub const DBRANGE_EXCLUSIVESTART = DBRANGEENUM.EXCLUSIVESTART;
pub const DBRANGE_EXCLUSIVEEND = DBRANGEENUM.EXCLUSIVEEND;
pub const DBRANGE_EXCLUDENULLS = DBRANGEENUM.EXCLUDENULLS;
pub const DBRANGE_PREFIX = DBRANGEENUM.PREFIX;
pub const DBRANGE_MATCH = DBRANGEENUM.MATCH;

pub const DBRANGEENUM20 = enum(i32) {
    SHIFT = 24,
    MASK = 255,
};
pub const DBRANGE_MATCH_N_SHIFT = DBRANGEENUM20.SHIFT;
pub const DBRANGE_MATCH_N_MASK = DBRANGEENUM20.MASK;

const IID_IRowsetIndex_Value = Guid.initString("0c733a82-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetIndex = &IID_IRowsetIndex_Value;
pub const IRowsetIndex = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIndexInfo: *const fn(
            self: *const IRowsetIndex,
            pcKeyColumns: ?*usize,
            prgIndexColumnDesc: ?*?*DBINDEXCOLUMNDESC,
            pcIndexPropertySets: ?*u32,
            prgIndexPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Seek: *const fn(
            self: *const IRowsetIndex,
            hAccessor: usize,
            cKeyValues: usize,
            pData: ?*anyopaque,
            dwSeekOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRange: *const fn(
            self: *const IRowsetIndex,
            hAccessor: usize,
            cStartKeyColumns: usize,
            pStartData: ?*anyopaque,
            cEndKeyColumns: usize,
            pEndData: ?*anyopaque,
            dwRangeOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetIndexInfo(self: *const IRowsetIndex, pcKeyColumns: ?*usize, prgIndexColumnDesc: ?*?*DBINDEXCOLUMNDESC, pcIndexPropertySets: ?*u32, prgIndexPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.GetIndexInfo(self, pcKeyColumns, prgIndexColumnDesc, pcIndexPropertySets, prgIndexPropertySets);
    }
    pub fn Seek(self: *const IRowsetIndex, hAccessor: usize, cKeyValues: usize, pData: ?*anyopaque, dwSeekOptions: u32) callconv(.Inline) HRESULT {
        return self.vtable.Seek(self, hAccessor, cKeyValues, pData, dwSeekOptions);
    }
    pub fn SetRange(self: *const IRowsetIndex, hAccessor: usize, cStartKeyColumns: usize, pStartData: ?*anyopaque, cEndKeyColumns: usize, pEndData: ?*anyopaque, dwRangeOptions: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetRange(self, hAccessor, cStartKeyColumns, pStartData, cEndKeyColumns, pEndData, dwRangeOptions);
    }
};

const IID_ICommand_Value = Guid.initString("0c733a63-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommand = &IID_ICommand_Value;
pub const ICommand = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: *const fn(
            self: *const ICommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: *const fn(
            self: *const ICommand,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            pParams: ?*DBPARAMS,
            pcRowsAffected: ?*isize,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDBSession: *const fn(
            self: *const ICommand,
            riid: ?*const Guid,
            ppSession: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Cancel(self: *const ICommand) callconv(.Inline) HRESULT {
        return self.vtable.Cancel(self);
    }
    pub fn Execute(self: *const ICommand, pUnkOuter: ?*IUnknown, riid: ?*const Guid, pParams: ?*DBPARAMS, pcRowsAffected: ?*isize, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.Execute(self, pUnkOuter, riid, pParams, pcRowsAffected, ppRowset);
    }
    pub fn GetDBSession(self: *const ICommand, riid: ?*const Guid, ppSession: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetDBSession(self, riid, ppSession);
    }
};

pub const DBRESULTFLAGENUM = enum(i32) {
    DEFAULT = 0,
    ROWSET = 1,
    ROW = 2,
};
pub const DBRESULTFLAG_DEFAULT = DBRESULTFLAGENUM.DEFAULT;
pub const DBRESULTFLAG_ROWSET = DBRESULTFLAGENUM.ROWSET;
pub const DBRESULTFLAG_ROW = DBRESULTFLAGENUM.ROW;

const IID_IMultipleResults_Value = Guid.initString("0c733a90-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IMultipleResults = &IID_IMultipleResults_Value;
pub const IMultipleResults = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResult: *const fn(
            self: *const IMultipleResults,
            pUnkOuter: ?*IUnknown,
            lResultFlag: isize,
            riid: ?*const Guid,
            pcRowsAffected: ?*isize,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetResult(self: *const IMultipleResults, pUnkOuter: ?*IUnknown, lResultFlag: isize, riid: ?*const Guid, pcRowsAffected: ?*isize, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetResult(self, pUnkOuter, lResultFlag, riid, pcRowsAffected, ppRowset);
    }
};

pub const DBCONVERTFLAGSENUM = enum(i32) {
    COLUMN = 0,
    PARAMETER = 1,
};
pub const DBCONVERTFLAGS_COLUMN = DBCONVERTFLAGSENUM.COLUMN;
pub const DBCONVERTFLAGS_PARAMETER = DBCONVERTFLAGSENUM.PARAMETER;

pub const DBCONVERTFLAGSENUM20 = enum(i32) {
    ISLONG = 2,
    ISFIXEDLENGTH = 4,
    FROMVARIANT = 8,
};
pub const DBCONVERTFLAGS_ISLONG = DBCONVERTFLAGSENUM20.ISLONG;
pub const DBCONVERTFLAGS_ISFIXEDLENGTH = DBCONVERTFLAGSENUM20.ISFIXEDLENGTH;
pub const DBCONVERTFLAGS_FROMVARIANT = DBCONVERTFLAGSENUM20.FROMVARIANT;

const IID_IConvertType_Value = Guid.initString("0c733a88-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IConvertType = &IID_IConvertType_Value;
pub const IConvertType = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanConvert: *const fn(
            self: *const IConvertType,
            wFromType: u16,
            wToType: u16,
            dwConvertFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CanConvert(self: *const IConvertType, wFromType: u16, wToType: u16, dwConvertFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.CanConvert(self, wFromType, wToType, dwConvertFlags);
    }
};

const IID_ICommandPrepare_Value = Guid.initString("0c733a26-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandPrepare = &IID_ICommandPrepare_Value;
pub const ICommandPrepare = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Prepare: *const fn(
            self: *const ICommandPrepare,
            cExpectedRuns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unprepare: *const fn(
            self: *const ICommandPrepare,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Prepare(self: *const ICommandPrepare, cExpectedRuns: u32) callconv(.Inline) HRESULT {
        return self.vtable.Prepare(self, cExpectedRuns);
    }
    pub fn Unprepare(self: *const ICommandPrepare) callconv(.Inline) HRESULT {
        return self.vtable.Unprepare(self);
    }
};

const IID_ICommandProperties_Value = Guid.initString("0c733a79-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandProperties = &IID_ICommandProperties_Value;
pub const ICommandProperties = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: *const fn(
            self: *const ICommandProperties,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertySets: ?*u32,
            prgPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: *const fn(
            self: *const ICommandProperties,
            cPropertySets: u32,
            rgPropertySets: [*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetProperties(self: *const ICommandProperties, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.GetProperties(self, cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
    }
    pub fn SetProperties(self: *const ICommandProperties, cPropertySets: u32, rgPropertySets: [*]DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.SetProperties(self, cPropertySets, rgPropertySets);
    }
};

const IID_ICommandText_Value = Guid.initString("0c733a27-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandText = &IID_ICommandText_Value;
pub const ICommandText = extern union {
    pub const VTable = extern struct {
        base: ICommand.VTable,
        GetCommandText: *const fn(
            self: *const ICommandText,
            pguidDialect: ?*Guid,
            ppwszCommand: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommandText: *const fn(
            self: *const ICommandText,
            rguidDialect: ?*const Guid,
            pwszCommand: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ICommand: ICommand,
    IUnknown: IUnknown,
    pub fn GetCommandText(self: *const ICommandText, pguidDialect: ?*Guid, ppwszCommand: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetCommandText(self, pguidDialect, ppwszCommand);
    }
    pub fn SetCommandText(self: *const ICommandText, rguidDialect: ?*const Guid, pwszCommand: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.SetCommandText(self, rguidDialect, pwszCommand);
    }
};


const IID_ICommandWithParameters_Value = Guid.initString("0c733a64-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandWithParameters = &IID_ICommandWithParameters_Value;
pub const ICommandWithParameters = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParameterInfo: *const fn(
            self: *const ICommandWithParameters,
            pcParams: ?*usize,
            prgParamInfo: ?*?*DBPARAMINFO,
            ppNamesBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapParameterNames: *const fn(
            self: *const ICommandWithParameters,
            cParamNames: usize,
            rgParamNames: [*]?PWSTR,
            rgParamOrdinals: [*]isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameterInfo: *const fn(
            self: *const ICommandWithParameters,
            cParams: usize,
            rgParamOrdinals: ?[*]const usize,
            rgParamBindInfo: ?[*]const DBPARAMBINDINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetParameterInfo(self: *const ICommandWithParameters, pcParams: ?*usize, prgParamInfo: ?*?*DBPARAMINFO, ppNamesBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetParameterInfo(self, pcParams, prgParamInfo, ppNamesBuffer);
    }
    pub fn MapParameterNames(self: *const ICommandWithParameters, cParamNames: usize, rgParamNames: [*]?PWSTR, rgParamOrdinals: [*]isize) callconv(.Inline) HRESULT {
        return self.vtable.MapParameterNames(self, cParamNames, rgParamNames, rgParamOrdinals);
    }
    pub fn SetParameterInfo(self: *const ICommandWithParameters, cParams: usize, rgParamOrdinals: ?[*]const usize, rgParamBindInfo: ?[*]const DBPARAMBINDINFO) callconv(.Inline) HRESULT {
        return self.vtable.SetParameterInfo(self, cParams, rgParamOrdinals, rgParamBindInfo);
    }
};

const IID_IColumnsRowset_Value = Guid.initString("0c733a10-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IColumnsRowset = &IID_IColumnsRowset_Value;
pub const IColumnsRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableColumns: *const fn(
            self: *const IColumnsRowset,
            pcOptColumns: ?*usize,
            prgOptColumns: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnsRowset: *const fn(
            self: *const IColumnsRowset,
            pUnkOuter: ?*IUnknown,
            cOptColumns: usize,
            rgOptColumns: [*]const DBID,
            riid: ?*const Guid,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            ppColRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetAvailableColumns(self: *const IColumnsRowset, pcOptColumns: ?*usize, prgOptColumns: ?*?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.GetAvailableColumns(self, pcOptColumns, prgOptColumns);
    }
    pub fn GetColumnsRowset(self: *const IColumnsRowset, pUnkOuter: ?*IUnknown, cOptColumns: usize, rgOptColumns: [*]const DBID, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppColRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetColumnsRowset(self, pUnkOuter, cOptColumns, rgOptColumns, riid, cPropertySets, rgPropertySets, ppColRowset);
    }
};

const IID_IColumnsInfo_Value = Guid.initString("0c733a11-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IColumnsInfo = &IID_IColumnsInfo_Value;
pub const IColumnsInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnInfo: *const fn(
            self: *const IColumnsInfo,
            pcColumns: ?*usize,
            prgInfo: ?*?*DBCOLUMNINFO,
            ppStringsBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapColumnIDs: *const fn(
            self: *const IColumnsInfo,
            cColumnIDs: usize,
            rgColumnIDs: ?[*]const DBID,
            rgColumns: ?[*]usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetColumnInfo(self: *const IColumnsInfo, pcColumns: ?*usize, prgInfo: ?*?*DBCOLUMNINFO, ppStringsBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetColumnInfo(self, pcColumns, prgInfo, ppStringsBuffer);
    }
    pub fn MapColumnIDs(self: *const IColumnsInfo, cColumnIDs: usize, rgColumnIDs: ?[*]const DBID, rgColumns: ?[*]usize) callconv(.Inline) HRESULT {
        return self.vtable.MapColumnIDs(self, cColumnIDs, rgColumnIDs, rgColumns);
    }
};

const IID_IDBCreateCommand_Value = Guid.initString("0c733a1d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBCreateCommand = &IID_IDBCreateCommand_Value;
pub const IDBCreateCommand = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCommand: *const fn(
            self: *const IDBCreateCommand,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppCommand: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateCommand(self: *const IDBCreateCommand, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppCommand: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.CreateCommand(self, pUnkOuter, riid, ppCommand);
    }
};

const IID_IDBCreateSession_Value = Guid.initString("0c733a5d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBCreateSession = &IID_IDBCreateSession_Value;
pub const IDBCreateSession = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSession: *const fn(
            self: *const IDBCreateSession,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppDBSession: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateSession(self: *const IDBCreateSession, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppDBSession: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.CreateSession(self, pUnkOuter, riid, ppDBSession);
    }
};

pub const DBSOURCETYPEENUM = enum(i32) {
    DATASOURCE = 1,
    ENUMERATOR = 2,
};
pub const DBSOURCETYPE_DATASOURCE = DBSOURCETYPEENUM.DATASOURCE;
pub const DBSOURCETYPE_ENUMERATOR = DBSOURCETYPEENUM.ENUMERATOR;

pub const DBSOURCETYPEENUM20 = enum(i32) {
    TDP = 1,
    MDP = 3,
};
pub const DBSOURCETYPE_DATASOURCE_TDP = DBSOURCETYPEENUM20.TDP;
pub const DBSOURCETYPE_DATASOURCE_MDP = DBSOURCETYPEENUM20.MDP;

pub const DBSOURCETYPEENUM25 = enum(i32) {
    R = 4,
};
pub const DBSOURCETYPE_BINDER = DBSOURCETYPEENUM25.R;

const IID_ISourcesRowset_Value = Guid.initString("0c733a1e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISourcesRowset = &IID_ISourcesRowset_Value;
pub const ISourcesRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourcesRowset: *const fn(
            self: *const ISourcesRowset,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            cPropertySets: u32,
            rgProperties: ?[*]DBPROPSET,
            ppSourcesRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetSourcesRowset(self: *const ISourcesRowset, pUnkOuter: ?*IUnknown, riid: ?*const Guid, cPropertySets: u32, rgProperties: ?[*]DBPROPSET, ppSourcesRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetSourcesRowset(self, pUnkOuter, riid, cPropertySets, rgProperties, ppSourcesRowset);
    }
};

const IID_IDBProperties_Value = Guid.initString("0c733a8a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBProperties = &IID_IDBProperties_Value;
pub const IDBProperties = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: *const fn(
            self: *const IDBProperties,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertySets: ?*u32,
            prgPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: *const fn(
            self: *const IDBProperties,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertyInfoSets: ?*u32,
            prgPropertyInfoSets: ?*?*DBPROPINFOSET,
            ppDescBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: *const fn(
            self: *const IDBProperties,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetProperties(self: *const IDBProperties, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.GetProperties(self, cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
    }
    pub fn GetPropertyInfo(self: *const IDBProperties, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertyInfoSets: ?*u32, prgPropertyInfoSets: ?*?*DBPROPINFOSET, ppDescBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetPropertyInfo(self, cPropertyIDSets, rgPropertyIDSets, pcPropertyInfoSets, prgPropertyInfoSets, ppDescBuffer);
    }
    pub fn SetProperties(self: *const IDBProperties, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.SetProperties(self, cPropertySets, rgPropertySets);
    }
};

const IID_IDBInitialize_Value = Guid.initString("0c733a8b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBInitialize = &IID_IDBInitialize_Value;
pub const IDBInitialize = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn(
            self: *const IDBInitialize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Uninitialize: *const fn(
            self: *const IDBInitialize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Initialize(self: *const IDBInitialize) callconv(.Inline) HRESULT {
        return self.vtable.Initialize(self);
    }
    pub fn Uninitialize(self: *const IDBInitialize) callconv(.Inline) HRESULT {
        return self.vtable.Uninitialize(self);
    }
};

pub const DBLITERALENUM = enum(i32) {
    INVALID = 0,
    BINARY_LITERAL = 1,
    CATALOG_NAME = 2,
    CATALOG_SEPARATOR = 3,
    CHAR_LITERAL = 4,
    COLUMN_ALIAS = 5,
    COLUMN_NAME = 6,
    CORRELATION_NAME = 7,
    CURSOR_NAME = 8,
    ESCAPE_PERCENT = 9,
    ESCAPE_UNDERSCORE = 10,
    INDEX_NAME = 11,
    LIKE_PERCENT = 12,
    LIKE_UNDERSCORE = 13,
    PROCEDURE_NAME = 14,
    QUOTE = 15,
    SCHEMA_NAME = 16,
    TABLE_NAME = 17,
    TEXT_COMMAND = 18,
    USER_NAME = 19,
    VIEW_NAME = 20,
};
pub const DBLITERAL_INVALID = DBLITERALENUM.INVALID;
pub const DBLITERAL_BINARY_LITERAL = DBLITERALENUM.BINARY_LITERAL;
pub const DBLITERAL_CATALOG_NAME = DBLITERALENUM.CATALOG_NAME;
pub const DBLITERAL_CATALOG_SEPARATOR = DBLITERALENUM.CATALOG_SEPARATOR;
pub const DBLITERAL_CHAR_LITERAL = DBLITERALENUM.CHAR_LITERAL;
pub const DBLITERAL_COLUMN_ALIAS = DBLITERALENUM.COLUMN_ALIAS;
pub const DBLITERAL_COLUMN_NAME = DBLITERALENUM.COLUMN_NAME;
pub const DBLITERAL_CORRELATION_NAME = DBLITERALENUM.CORRELATION_NAME;
pub const DBLITERAL_CURSOR_NAME = DBLITERALENUM.CURSOR_NAME;
pub const DBLITERAL_ESCAPE_PERCENT = DBLITERALENUM.ESCAPE_PERCENT;
pub const DBLITERAL_ESCAPE_UNDERSCORE = DBLITERALENUM.ESCAPE_UNDERSCORE;
pub const DBLITERAL_INDEX_NAME = DBLITERALENUM.INDEX_NAME;
pub const DBLITERAL_LIKE_PERCENT = DBLITERALENUM.LIKE_PERCENT;
pub const DBLITERAL_LIKE_UNDERSCORE = DBLITERALENUM.LIKE_UNDERSCORE;
pub const DBLITERAL_PROCEDURE_NAME = DBLITERALENUM.PROCEDURE_NAME;
pub const DBLITERAL_QUOTE = DBLITERALENUM.QUOTE;
pub const DBLITERAL_SCHEMA_NAME = DBLITERALENUM.SCHEMA_NAME;
pub const DBLITERAL_TABLE_NAME = DBLITERALENUM.TABLE_NAME;
pub const DBLITERAL_TEXT_COMMAND = DBLITERALENUM.TEXT_COMMAND;
pub const DBLITERAL_USER_NAME = DBLITERALENUM.USER_NAME;
pub const DBLITERAL_VIEW_NAME = DBLITERALENUM.VIEW_NAME;

pub const DBLITERALENUM20 = enum(i32) {
    CUBE_NAME = 21,
    DIMENSION_NAME = 22,
    HIERARCHY_NAME = 23,
    LEVEL_NAME = 24,
    MEMBER_NAME = 25,
    PROPERTY_NAME = 26,
    SCHEMA_SEPARATOR = 27,
    QUOTE_SUFFIX = 28,
};
pub const DBLITERAL_CUBE_NAME = DBLITERALENUM20.CUBE_NAME;
pub const DBLITERAL_DIMENSION_NAME = DBLITERALENUM20.DIMENSION_NAME;
pub const DBLITERAL_HIERARCHY_NAME = DBLITERALENUM20.HIERARCHY_NAME;
pub const DBLITERAL_LEVEL_NAME = DBLITERALENUM20.LEVEL_NAME;
pub const DBLITERAL_MEMBER_NAME = DBLITERALENUM20.MEMBER_NAME;
pub const DBLITERAL_PROPERTY_NAME = DBLITERALENUM20.PROPERTY_NAME;
pub const DBLITERAL_SCHEMA_SEPARATOR = DBLITERALENUM20.SCHEMA_SEPARATOR;
pub const DBLITERAL_QUOTE_SUFFIX = DBLITERALENUM20.QUOTE_SUFFIX;

pub const DBLITERALENUM21 = enum(i32) {
    PERCENT_SUFFIX = 29,
    UNDERSCORE_SUFFIX = 30,
};
pub const DBLITERAL_ESCAPE_PERCENT_SUFFIX = DBLITERALENUM21.PERCENT_SUFFIX;
pub const DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX = DBLITERALENUM21.UNDERSCORE_SUFFIX;


const IID_IDBInfo_Value = Guid.initString("0c733a89-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBInfo = &IID_IDBInfo_Value;
pub const IDBInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKeywords: *const fn(
            self: *const IDBInfo,
            ppwszKeywords: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLiteralInfo: *const fn(
            self: *const IDBInfo,
            cLiterals: u32,
            rgLiterals: ?[*]const u32,
            pcLiteralInfo: ?*u32,
            prgLiteralInfo: ?*?*DBLITERALINFO,
            ppCharBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetKeywords(self: *const IDBInfo, ppwszKeywords: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetKeywords(self, ppwszKeywords);
    }
    pub fn GetLiteralInfo(self: *const IDBInfo, cLiterals: u32, rgLiterals: ?[*]const u32, pcLiteralInfo: ?*u32, prgLiteralInfo: ?*?*DBLITERALINFO, ppCharBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetLiteralInfo(self, cLiterals, rgLiterals, pcLiteralInfo, prgLiteralInfo, ppCharBuffer);
    }
};

const IID_IDBDataSourceAdmin_Value = Guid.initString("0c733a7a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBDataSourceAdmin = &IID_IDBDataSourceAdmin_Value;
pub const IDBDataSourceAdmin = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateDataSource: *const fn(
            self: *const IDBDataSourceAdmin,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppDBSession: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyDataSource: *const fn(
            self: *const IDBDataSourceAdmin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCreationProperties: *const fn(
            self: *const IDBDataSourceAdmin,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertyInfoSets: ?*u32,
            prgPropertyInfoSets: ?*?*DBPROPINFOSET,
            ppDescBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyDataSource: *const fn(
            self: *const IDBDataSourceAdmin,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateDataSource(self: *const IDBDataSourceAdmin, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppDBSession: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.CreateDataSource(self, cPropertySets, rgPropertySets, pUnkOuter, riid, ppDBSession);
    }
    pub fn DestroyDataSource(self: *const IDBDataSourceAdmin) callconv(.Inline) HRESULT {
        return self.vtable.DestroyDataSource(self);
    }
    pub fn GetCreationProperties(self: *const IDBDataSourceAdmin, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertyInfoSets: ?*u32, prgPropertyInfoSets: ?*?*DBPROPINFOSET, ppDescBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetCreationProperties(self, cPropertyIDSets, rgPropertyIDSets, pcPropertyInfoSets, prgPropertyInfoSets, ppDescBuffer);
    }
    pub fn ModifyDataSource(self: *const IDBDataSourceAdmin, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.ModifyDataSource(self, cPropertySets, rgPropertySets);
    }
};

const IID_IDBAsynchNotify_Value = Guid.initString("0c733a96-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBAsynchNotify = &IID_IDBAsynchNotify_Value;
pub const IDBAsynchNotify = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLowResource: *const fn(
            self: *const IDBAsynchNotify,
            dwReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnProgress: *const fn(
            self: *const IDBAsynchNotify,
            hChapter: usize,
            eOperation: u32,
            ulProgress: usize,
            ulProgressMax: usize,
            eAsynchPhase: u32,
            pwszStatusText: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStop: *const fn(
            self: *const IDBAsynchNotify,
            hChapter: usize,
            eOperation: u32,
            hrStatus: HRESULT,
            pwszStatusText: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OnLowResource(self: *const IDBAsynchNotify, dwReserved: usize) callconv(.Inline) HRESULT {
        return self.vtable.OnLowResource(self, dwReserved);
    }
    pub fn OnProgress(self: *const IDBAsynchNotify, hChapter: usize, eOperation: u32, ulProgress: usize, ulProgressMax: usize, eAsynchPhase: u32, pwszStatusText: ?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.OnProgress(self, hChapter, eOperation, ulProgress, ulProgressMax, eAsynchPhase, pwszStatusText);
    }
    pub fn OnStop(self: *const IDBAsynchNotify, hChapter: usize, eOperation: u32, hrStatus: HRESULT, pwszStatusText: ?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.OnStop(self, hChapter, eOperation, hrStatus, pwszStatusText);
    }
};

const IID_IDBAsynchStatus_Value = Guid.initString("0c733a95-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBAsynchStatus = &IID_IDBAsynchStatus_Value;
pub const IDBAsynchStatus = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Abort: *const fn(
            self: *const IDBAsynchStatus,
            hChapter: usize,
            eOperation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn(
            self: *const IDBAsynchStatus,
            hChapter: usize,
            eOperation: u32,
            pulProgress: ?*usize,
            pulProgressMax: ?*usize,
            peAsynchPhase: ?*u32,
            ppwszStatusText: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Abort(self: *const IDBAsynchStatus, hChapter: usize, eOperation: u32) callconv(.Inline) HRESULT {
        return self.vtable.Abort(self, hChapter, eOperation);
    }
    pub fn GetStatus(self: *const IDBAsynchStatus, hChapter: usize, eOperation: u32, pulProgress: ?*usize, pulProgressMax: ?*usize, peAsynchPhase: ?*u32, ppwszStatusText: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetStatus(self, hChapter, eOperation, pulProgress, pulProgressMax, peAsynchPhase, ppwszStatusText);
    }
};

const IID_ISessionProperties_Value = Guid.initString("0c733a85-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISessionProperties = &IID_ISessionProperties_Value;
pub const ISessionProperties = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: *const fn(
            self: *const ISessionProperties,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertySets: ?*u32,
            prgPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: *const fn(
            self: *const ISessionProperties,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetProperties(self: *const ISessionProperties, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.GetProperties(self, cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
    }
    pub fn SetProperties(self: *const ISessionProperties, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.SetProperties(self, cPropertySets, rgPropertySets);
    }
};

const IID_IIndexDefinition_Value = Guid.initString("0c733a68-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IIndexDefinition = &IID_IIndexDefinition_Value;
pub const IIndexDefinition = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIndex: *const fn(
            self: *const IIndexDefinition,
            pTableID: ?*DBID,
            pIndexID: ?*DBID,
            cIndexColumnDescs: usize,
            rgIndexColumnDescs: [*]const DBINDEXCOLUMNDESC,
            cPropertySets: u32,
            rgPropertySets: [*]DBPROPSET,
            ppIndexID: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropIndex: *const fn(
            self: *const IIndexDefinition,
            pTableID: ?*DBID,
            pIndexID: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateIndex(self: *const IIndexDefinition, pTableID: ?*DBID, pIndexID: ?*DBID, cIndexColumnDescs: usize, rgIndexColumnDescs: [*]const DBINDEXCOLUMNDESC, cPropertySets: u32, rgPropertySets: [*]DBPROPSET, ppIndexID: ?*?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.CreateIndex(self, pTableID, pIndexID, cIndexColumnDescs, rgIndexColumnDescs, cPropertySets, rgPropertySets, ppIndexID);
    }
    pub fn DropIndex(self: *const IIndexDefinition, pTableID: ?*DBID, pIndexID: ?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.DropIndex(self, pTableID, pIndexID);
    }
};

const IID_ITableDefinition_Value = Guid.initString("0c733a86-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableDefinition = &IID_ITableDefinition_Value;
pub const ITableDefinition = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTable: *const fn(
            self: *const ITableDefinition,
            pUnkOuter: ?*IUnknown,
            pTableID: ?*DBID,
            cColumnDescs: usize,
            rgColumnDescs: ?[*]const DBCOLUMNDESC,
            riid: ?*const Guid,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            ppTableID: ?*?*DBID,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropTable: *const fn(
            self: *const ITableDefinition,
            pTableID: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddColumn: *const fn(
            self: *const ITableDefinition,
            pTableID: ?*DBID,
            pColumnDesc: ?*DBCOLUMNDESC,
            ppColumnID: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropColumn: *const fn(
            self: *const ITableDefinition,
            pTableID: ?*DBID,
            pColumnID: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateTable(self: *const ITableDefinition, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, cColumnDescs: usize, rgColumnDescs: ?[*]const DBCOLUMNDESC, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppTableID: ?*?*DBID, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.CreateTable(self, pUnkOuter, pTableID, cColumnDescs, rgColumnDescs, riid, cPropertySets, rgPropertySets, ppTableID, ppRowset);
    }
    pub fn DropTable(self: *const ITableDefinition, pTableID: ?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.DropTable(self, pTableID);
    }
    pub fn AddColumn(self: *const ITableDefinition, pTableID: ?*DBID, pColumnDesc: ?*DBCOLUMNDESC, ppColumnID: ?*?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.AddColumn(self, pTableID, pColumnDesc, ppColumnID);
    }
    pub fn DropColumn(self: *const ITableDefinition, pTableID: ?*DBID, pColumnID: ?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.DropColumn(self, pTableID, pColumnID);
    }
};

const IID_IOpenRowset_Value = Guid.initString("0c733a69-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IOpenRowset = &IID_IOpenRowset_Value;
pub const IOpenRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenRowset: *const fn(
            self: *const IOpenRowset,
            pUnkOuter: ?*IUnknown,
            pTableID: ?*DBID,
            pIndexID: ?*DBID,
            riid: ?*const Guid,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OpenRowset(self: *const IOpenRowset, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, pIndexID: ?*DBID, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.OpenRowset(self, pUnkOuter, pTableID, pIndexID, riid, cPropertySets, rgPropertySets, ppRowset);
    }
};

const IID_IDBSchemaRowset_Value = Guid.initString("0c733a7b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBSchemaRowset = &IID_IDBSchemaRowset_Value;
pub const IDBSchemaRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowset: *const fn(
            self: *const IDBSchemaRowset,
            pUnkOuter: ?*IUnknown,
            rguidSchema: ?*const Guid,
            cRestrictions: u32,
            rgRestrictions: ?[*]const VARIANT,
            riid: ?*const Guid,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemas: *const fn(
            self: *const IDBSchemaRowset,
            pcSchemas: ?*u32,
            prgSchemas: ?*?*Guid,
            prgRestrictionSupport: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetRowset(self: *const IDBSchemaRowset, pUnkOuter: ?*IUnknown, rguidSchema: ?*const Guid, cRestrictions: u32, rgRestrictions: ?[*]const VARIANT, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetRowset(self, pUnkOuter, rguidSchema, cRestrictions, rgRestrictions, riid, cPropertySets, rgPropertySets, ppRowset);
    }
    pub fn GetSchemas(self: *const IDBSchemaRowset, pcSchemas: ?*u32, prgSchemas: ?*?*Guid, prgRestrictionSupport: ?*?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetSchemas(self, pcSchemas, prgSchemas, prgRestrictionSupport);
    }
};

const IID_IMDDataset_Value = Guid.initString("a07cccd1-8148-11d0-87bb-00c04fc33942");
pub const IID_IMDDataset = &IID_IMDDataset_Value;
pub const IMDDataset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FreeAxisInfo: *const fn(
            self: *const IMDDataset,
            cAxes: usize,
            rgAxisInfo: ?*MDAXISINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAxisInfo: *const fn(
            self: *const IMDDataset,
            pcAxes: ?*usize,
            prgAxisInfo: ?*?*MDAXISINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAxisRowset: *const fn(
            self: *const IMDDataset,
            pUnkOuter: ?*IUnknown,
            iAxis: usize,
            riid: ?*const Guid,
            cPropertySets: u32,
            rgPropertySets: ?*DBPROPSET,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellData: *const fn(
            self: *const IMDDataset,
            hAccessor: usize,
            ulStartCell: usize,
            ulEndCell: usize,
            pData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecification: *const fn(
            self: *const IMDDataset,
            riid: ?*const Guid,
            ppSpecification: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn FreeAxisInfo(self: *const IMDDataset, cAxes: usize, rgAxisInfo: ?*MDAXISINFO) callconv(.Inline) HRESULT {
        return self.vtable.FreeAxisInfo(self, cAxes, rgAxisInfo);
    }
    pub fn GetAxisInfo(self: *const IMDDataset, pcAxes: ?*usize, prgAxisInfo: ?*?*MDAXISINFO) callconv(.Inline) HRESULT {
        return self.vtable.GetAxisInfo(self, pcAxes, prgAxisInfo);
    }
    pub fn GetAxisRowset(self: *const IMDDataset, pUnkOuter: ?*IUnknown, iAxis: usize, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?*DBPROPSET, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetAxisRowset(self, pUnkOuter, iAxis, riid, cPropertySets, rgPropertySets, ppRowset);
    }
    pub fn GetCellData(self: *const IMDDataset, hAccessor: usize, ulStartCell: usize, ulEndCell: usize, pData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetCellData(self, hAccessor, ulStartCell, ulEndCell, pData);
    }
    pub fn GetSpecification(self: *const IMDDataset, riid: ?*const Guid, ppSpecification: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetSpecification(self, riid, ppSpecification);
    }
};

const IID_IMDFind_Value = Guid.initString("a07cccd2-8148-11d0-87bb-00c04fc33942");
pub const IID_IMDFind = &IID_IMDFind_Value;
pub const IMDFind = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindCell: *const fn(
            self: *const IMDFind,
            ulStartingOrdinal: usize,
            cMembers: usize,
            rgpwszMember: ?*?PWSTR,
            pulCellOrdinal: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTuple: *const fn(
            self: *const IMDFind,
            ulAxisIdentifier: u32,
            ulStartingOrdinal: usize,
            cMembers: usize,
            rgpwszMember: ?*?PWSTR,
            pulTupleOrdinal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn FindCell(self: *const IMDFind, ulStartingOrdinal: usize, cMembers: usize, rgpwszMember: ?*?PWSTR, pulCellOrdinal: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.FindCell(self, ulStartingOrdinal, cMembers, rgpwszMember, pulCellOrdinal);
    }
    pub fn FindTuple(self: *const IMDFind, ulAxisIdentifier: u32, ulStartingOrdinal: usize, cMembers: usize, rgpwszMember: ?*?PWSTR, pulTupleOrdinal: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.FindTuple(self, ulAxisIdentifier, ulStartingOrdinal, cMembers, rgpwszMember, pulTupleOrdinal);
    }
};

const IID_IMDRangeRowset_Value = Guid.initString("0c733aa0-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IMDRangeRowset = &IID_IMDRangeRowset_Value;
pub const IMDRangeRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRangeRowset: *const fn(
            self: *const IMDRangeRowset,
            pUnkOuter: ?*IUnknown,
            ulStartCell: usize,
            ulEndCell: usize,
            riid: ?*const Guid,
            cPropertySets: u32,
            rgPropertySets: ?*DBPROPSET,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetRangeRowset(self: *const IMDRangeRowset, pUnkOuter: ?*IUnknown, ulStartCell: usize, ulEndCell: usize, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?*DBPROPSET, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetRangeRowset(self, pUnkOuter, ulStartCell, ulEndCell, riid, cPropertySets, rgPropertySets, ppRowset);
    }
};

const IID_IAlterTable_Value = Guid.initString("0c733aa5-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IAlterTable = &IID_IAlterTable_Value;
pub const IAlterTable = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AlterColumn: *const fn(
            self: *const IAlterTable,
            pTableId: ?*DBID,
            pColumnId: ?*DBID,
            dwColumnDescFlags: u32,
            pColumnDesc: ?*DBCOLUMNDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AlterTable: *const fn(
            self: *const IAlterTable,
            pTableId: ?*DBID,
            pNewTableId: ?*DBID,
            cPropertySets: u32,
            rgPropertySets: ?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn AlterColumn(self: *const IAlterTable, pTableId: ?*DBID, pColumnId: ?*DBID, dwColumnDescFlags: u32, pColumnDesc: ?*DBCOLUMNDESC) callconv(.Inline) HRESULT {
        return self.vtable.AlterColumn(self, pTableId, pColumnId, dwColumnDescFlags, pColumnDesc);
    }
    pub fn AlterTable(self: *const IAlterTable, pTableId: ?*DBID, pNewTableId: ?*DBID, cPropertySets: u32, rgPropertySets: ?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.AlterTable(self, pTableId, pNewTableId, cPropertySets, rgPropertySets);
    }
};

const IID_IAlterIndex_Value = Guid.initString("0c733aa6-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IAlterIndex = &IID_IAlterIndex_Value;
pub const IAlterIndex = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AlterIndex: *const fn(
            self: *const IAlterIndex,
            pTableId: ?*DBID,
            pIndexId: ?*DBID,
            pNewIndexId: ?*DBID,
            cPropertySets: u32,
            rgPropertySets: ?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn AlterIndex(self: *const IAlterIndex, pTableId: ?*DBID, pIndexId: ?*DBID, pNewIndexId: ?*DBID, cPropertySets: u32, rgPropertySets: ?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.AlterIndex(self, pTableId, pIndexId, pNewIndexId, cPropertySets, rgPropertySets);
    }
};

const IID_IRowsetChapterMember_Value = Guid.initString("0c733aa8-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetChapterMember = &IID_IRowsetChapterMember_Value;
pub const IRowsetChapterMember = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsRowInChapter: *const fn(
            self: *const IRowsetChapterMember,
            hChapter: usize,
            hRow: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn IsRowInChapter(self: *const IRowsetChapterMember, hChapter: usize, hRow: usize) callconv(.Inline) HRESULT {
        return self.vtable.IsRowInChapter(self, hChapter, hRow);
    }
};

const IID_ICommandPersist_Value = Guid.initString("0c733aa7-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandPersist = &IID_ICommandPersist_Value;
pub const ICommandPersist = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteCommand: *const fn(
            self: *const ICommandPersist,
            pCommandID: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentCommand: *const fn(
            self: *const ICommandPersist,
            ppCommandID: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCommand: *const fn(
            self: *const ICommandPersist,
            pCommandID: ?*DBID,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCommand: *const fn(
            self: *const ICommandPersist,
            pCommandID: ?*DBID,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn DeleteCommand(self: *const ICommandPersist, pCommandID: ?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.DeleteCommand(self, pCommandID);
    }
    pub fn GetCurrentCommand(self: *const ICommandPersist, ppCommandID: ?*?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.GetCurrentCommand(self, ppCommandID);
    }
    pub fn LoadCommand(self: *const ICommandPersist, pCommandID: ?*DBID, dwFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.LoadCommand(self, pCommandID, dwFlags);
    }
    pub fn SaveCommand(self: *const ICommandPersist, pCommandID: ?*DBID, dwFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SaveCommand(self, pCommandID, dwFlags);
    }
};

const IID_IRowsetRefresh_Value = Guid.initString("0c733aa9-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetRefresh = &IID_IRowsetRefresh_Value;
pub const IRowsetRefresh = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RefreshVisibleData: *const fn(
            self: *const IRowsetRefresh,
            hChapter: usize,
            cRows: usize,
            rghRows: ?*const usize,
            fOverWrite: BOOL,
            pcRowsRefreshed: ?*usize,
            prghRowsRefreshed: ?*?*usize,
            prgRowStatus: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastVisibleData: *const fn(
            self: *const IRowsetRefresh,
            hRow: usize,
            hAccessor: usize,
            pData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn RefreshVisibleData(self: *const IRowsetRefresh, hChapter: usize, cRows: usize, rghRows: ?*const usize, fOverWrite: BOOL, pcRowsRefreshed: ?*usize, prghRowsRefreshed: ?*?*usize, prgRowStatus: ?*?*u32) callconv(.Inline) HRESULT {
        return self.vtable.RefreshVisibleData(self, hChapter, cRows, rghRows, fOverWrite, pcRowsRefreshed, prghRowsRefreshed, prgRowStatus);
    }
    pub fn GetLastVisibleData(self: *const IRowsetRefresh, hRow: usize, hAccessor: usize, pData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetLastVisibleData(self, hRow, hAccessor, pData);
    }
};

const IID_IParentRowset_Value = Guid.initString("0c733aaa-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IParentRowset = &IID_IParentRowset_Value;
pub const IParentRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChildRowset: *const fn(
            self: *const IParentRowset,
            pUnkOuter: ?*IUnknown,
            iOrdinal: usize,
            riid: ?*const Guid,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetChildRowset(self: *const IParentRowset, pUnkOuter: ?*IUnknown, iOrdinal: usize, riid: ?*const Guid, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetChildRowset(self, pUnkOuter, iOrdinal, riid, ppRowset);
    }
};


const IID_IErrorRecords_Value = Guid.initString("0c733a67-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IErrorRecords = &IID_IErrorRecords_Value;
pub const IErrorRecords = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddErrorRecord: *const fn(
            self: *const IErrorRecords,
            pErrorInfo: ?*ERRORINFO,
            dwLookupID: u32,
            pdispparams: ?*DISPPARAMS,
            punkCustomError: ?*IUnknown,
            dwDynamicErrorID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBasicErrorInfo: *const fn(
            self: *const IErrorRecords,
            ulRecordNum: u32,
            pErrorInfo: ?*ERRORINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustomErrorObject: *const fn(
            self: *const IErrorRecords,
            ulRecordNum: u32,
            riid: ?*const Guid,
            ppObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorInfo: *const fn(
            self: *const IErrorRecords,
            ulRecordNum: u32,
            lcid: u32,
            ppErrorInfo: ?*?*IErrorInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorParameters: *const fn(
            self: *const IErrorRecords,
            ulRecordNum: u32,
            pdispparams: ?*DISPPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCount: *const fn(
            self: *const IErrorRecords,
            pcRecords: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn AddErrorRecord(self: *const IErrorRecords, pErrorInfo: ?*ERRORINFO, dwLookupID: u32, pdispparams: ?*DISPPARAMS, punkCustomError: ?*IUnknown, dwDynamicErrorID: u32) callconv(.Inline) HRESULT {
        return self.vtable.AddErrorRecord(self, pErrorInfo, dwLookupID, pdispparams, punkCustomError, dwDynamicErrorID);
    }
    pub fn GetBasicErrorInfo(self: *const IErrorRecords, ulRecordNum: u32, pErrorInfo: ?*ERRORINFO) callconv(.Inline) HRESULT {
        return self.vtable.GetBasicErrorInfo(self, ulRecordNum, pErrorInfo);
    }
    pub fn GetCustomErrorObject(self: *const IErrorRecords, ulRecordNum: u32, riid: ?*const Guid, ppObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetCustomErrorObject(self, ulRecordNum, riid, ppObject);
    }
    pub fn GetErrorInfo(self: *const IErrorRecords, ulRecordNum: u32, lcid: u32, ppErrorInfo: ?*?*IErrorInfo) callconv(.Inline) HRESULT {
        return self.vtable.GetErrorInfo(self, ulRecordNum, lcid, ppErrorInfo);
    }
    pub fn GetErrorParameters(self: *const IErrorRecords, ulRecordNum: u32, pdispparams: ?*DISPPARAMS) callconv(.Inline) HRESULT {
        return self.vtable.GetErrorParameters(self, ulRecordNum, pdispparams);
    }
    pub fn GetRecordCount(self: *const IErrorRecords, pcRecords: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetRecordCount(self, pcRecords);
    }
};

const IID_IErrorLookup_Value = Guid.initString("0c733a66-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IErrorLookup = &IID_IErrorLookup_Value;
pub const IErrorLookup = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorDescription: *const fn(
            self: *const IErrorLookup,
            hrError: HRESULT,
            dwLookupID: u32,
            pdispparams: ?*DISPPARAMS,
            lcid: u32,
            pbstrSource: ?*?BSTR,
            pbstrDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpInfo: *const fn(
            self: *const IErrorLookup,
            hrError: HRESULT,
            dwLookupID: u32,
            lcid: u32,
            pbstrHelpFile: ?*?BSTR,
            pdwHelpContext: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseErrors: *const fn(
            self: *const IErrorLookup,
            dwDynamicErrorID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetErrorDescription(self: *const IErrorLookup, hrError: HRESULT, dwLookupID: u32, pdispparams: ?*DISPPARAMS, lcid: u32, pbstrSource: ?*?BSTR, pbstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetErrorDescription(self, hrError, dwLookupID, pdispparams, lcid, pbstrSource, pbstrDescription);
    }
    pub fn GetHelpInfo(self: *const IErrorLookup, hrError: HRESULT, dwLookupID: u32, lcid: u32, pbstrHelpFile: ?*?BSTR, pdwHelpContext: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetHelpInfo(self, hrError, dwLookupID, lcid, pbstrHelpFile, pdwHelpContext);
    }
    pub fn ReleaseErrors(self: *const IErrorLookup, dwDynamicErrorID: u32) callconv(.Inline) HRESULT {
        return self.vtable.ReleaseErrors(self, dwDynamicErrorID);
    }
};

const IID_ISQLErrorInfo_Value = Guid.initString("0c733a74-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISQLErrorInfo = &IID_ISQLErrorInfo_Value;
pub const ISQLErrorInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSQLInfo: *const fn(
            self: *const ISQLErrorInfo,
            pbstrSQLState: ?*?BSTR,
            plNativeError: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetSQLInfo(self: *const ISQLErrorInfo, pbstrSQLState: ?*?BSTR, plNativeError: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.GetSQLInfo(self, pbstrSQLState, plNativeError);
    }
};

const IID_IGetDataSource_Value = Guid.initString("0c733a75-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetDataSource = &IID_IGetDataSource_Value;
pub const IGetDataSource = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataSource: *const fn(
            self: *const IGetDataSource,
            riid: ?*const Guid,
            ppDataSource: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetDataSource(self: *const IGetDataSource, riid: ?*const Guid, ppDataSource: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetDataSource(self, riid, ppDataSource);
    }
};

const IID_ITransactionLocal_Value = Guid.initString("0c733a5f-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITransactionLocal = &IID_ITransactionLocal_Value;
pub const ITransactionLocal = extern union {
    pub const VTable = extern struct {
        base: ITransaction.VTable,
        GetOptionsObject: *const fn(
            self: *const ITransactionLocal,
            ppOptions: ?*?*ITransactionOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartTransaction: *const fn(
            self: *const ITransactionLocal,
            isoLevel: i32,
            isoFlags: u32,
            pOtherOptions: ?*ITransactionOptions,
            pulTransactionLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ITransaction: ITransaction,
    IUnknown: IUnknown,
    pub fn GetOptionsObject(self: *const ITransactionLocal, ppOptions: ?*?*ITransactionOptions) callconv(.Inline) HRESULT {
        return self.vtable.GetOptionsObject(self, ppOptions);
    }
    pub fn StartTransaction(self: *const ITransactionLocal, isoLevel: i32, isoFlags: u32, pOtherOptions: ?*ITransactionOptions, pulTransactionLevel: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.StartTransaction(self, isoLevel, isoFlags, pOtherOptions, pulTransactionLevel);
    }
};

const IID_ITransactionJoin_Value = Guid.initString("0c733a5e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITransactionJoin = &IID_ITransactionJoin_Value;
pub const ITransactionJoin = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOptionsObject: *const fn(
            self: *const ITransactionJoin,
            ppOptions: ?*?*ITransactionOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinTransaction: *const fn(
            self: *const ITransactionJoin,
            punkTransactionCoord: ?*IUnknown,
            isoLevel: i32,
            isoFlags: u32,
            pOtherOptions: ?*ITransactionOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetOptionsObject(self: *const ITransactionJoin, ppOptions: ?*?*ITransactionOptions) callconv(.Inline) HRESULT {
        return self.vtable.GetOptionsObject(self, ppOptions);
    }
    pub fn JoinTransaction(self: *const ITransactionJoin, punkTransactionCoord: ?*IUnknown, isoLevel: i32, isoFlags: u32, pOtherOptions: ?*ITransactionOptions) callconv(.Inline) HRESULT {
        return self.vtable.JoinTransaction(self, punkTransactionCoord, isoLevel, isoFlags, pOtherOptions);
    }
};

const IID_ITransactionObject_Value = Guid.initString("0c733a60-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITransactionObject = &IID_ITransactionObject_Value;
pub const ITransactionObject = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTransactionObject: *const fn(
            self: *const ITransactionObject,
            ulTransactionLevel: u32,
            ppTransactionObject: ?*?*ITransaction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetTransactionObject(self: *const ITransactionObject, ulTransactionLevel: u32, ppTransactionObject: ?*?*ITransaction) callconv(.Inline) HRESULT {
        return self.vtable.GetTransactionObject(self, ulTransactionLevel, ppTransactionObject);
    }
};

const IID_ITrusteeAdmin_Value = Guid.initString("0c733aa1-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITrusteeAdmin = &IID_ITrusteeAdmin_Value;
pub const ITrusteeAdmin = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareTrustees: *const fn(
            self: *const ITrusteeAdmin,
            pTrustee1: ?*TRUSTEE_W,
            pTrustee2: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTrustee: *const fn(
            self: *const ITrusteeAdmin,
            pTrustee: ?*TRUSTEE_W,
            cPropertySets: u32,
            rgPropertySets: ?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTrustee: *const fn(
            self: *const ITrusteeAdmin,
            pTrustee: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrusteeProperties: *const fn(
            self: *const ITrusteeAdmin,
            pTrustee: ?*TRUSTEE_W,
            cPropertySets: u32,
            rgPropertySets: ?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrusteeProperties: *const fn(
            self: *const ITrusteeAdmin,
            pTrustee: ?*TRUSTEE_W,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?*const DBPROPIDSET,
            pcPropertySets: ?*u32,
            prgPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CompareTrustees(self: *const ITrusteeAdmin, pTrustee1: ?*TRUSTEE_W, pTrustee2: ?*TRUSTEE_W) callconv(.Inline) HRESULT {
        return self.vtable.CompareTrustees(self, pTrustee1, pTrustee2);
    }
    pub fn CreateTrustee(self: *const ITrusteeAdmin, pTrustee: ?*TRUSTEE_W, cPropertySets: u32, rgPropertySets: ?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.CreateTrustee(self, pTrustee, cPropertySets, rgPropertySets);
    }
    pub fn DeleteTrustee(self: *const ITrusteeAdmin, pTrustee: ?*TRUSTEE_W) callconv(.Inline) HRESULT {
        return self.vtable.DeleteTrustee(self, pTrustee);
    }
    pub fn SetTrusteeProperties(self: *const ITrusteeAdmin, pTrustee: ?*TRUSTEE_W, cPropertySets: u32, rgPropertySets: ?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.SetTrusteeProperties(self, pTrustee, cPropertySets, rgPropertySets);
    }
    pub fn GetTrusteeProperties(self: *const ITrusteeAdmin, pTrustee: ?*TRUSTEE_W, cPropertyIDSets: u32, rgPropertyIDSets: ?*const DBPROPIDSET, pcPropertySets: ?*u32, prgPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
        return self.vtable.GetTrusteeProperties(self, pTrustee, cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
    }
};

const IID_ITrusteeGroupAdmin_Value = Guid.initString("0c733aa2-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITrusteeGroupAdmin = &IID_ITrusteeGroupAdmin_Value;
pub const ITrusteeGroupAdmin = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddMember: *const fn(
            self: *const ITrusteeGroupAdmin,
            pMembershipTrustee: ?*TRUSTEE_W,
            pMemberTrustee: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMember: *const fn(
            self: *const ITrusteeGroupAdmin,
            pMembershipTrustee: ?*TRUSTEE_W,
            pMemberTrustee: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMember: *const fn(
            self: *const ITrusteeGroupAdmin,
            pMembershipTrustee: ?*TRUSTEE_W,
            pMemberTrustee: ?*TRUSTEE_W,
            pfStatus: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMembers: *const fn(
            self: *const ITrusteeGroupAdmin,
            pMembershipTrustee: ?*TRUSTEE_W,
            pcMembers: ?*u32,
            prgMembers: ?*?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMemberships: *const fn(
            self: *const ITrusteeGroupAdmin,
            pTrustee: ?*TRUSTEE_W,
            pcMemberships: ?*u32,
            prgMemberships: ?*?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn AddMember(self: *const ITrusteeGroupAdmin, pMembershipTrustee: ?*TRUSTEE_W, pMemberTrustee: ?*TRUSTEE_W) callconv(.Inline) HRESULT {
        return self.vtable.AddMember(self, pMembershipTrustee, pMemberTrustee);
    }
    pub fn DeleteMember(self: *const ITrusteeGroupAdmin, pMembershipTrustee: ?*TRUSTEE_W, pMemberTrustee: ?*TRUSTEE_W) callconv(.Inline) HRESULT {
        return self.vtable.DeleteMember(self, pMembershipTrustee, pMemberTrustee);
    }
    pub fn IsMember(self: *const ITrusteeGroupAdmin, pMembershipTrustee: ?*TRUSTEE_W, pMemberTrustee: ?*TRUSTEE_W, pfStatus: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.IsMember(self, pMembershipTrustee, pMemberTrustee, pfStatus);
    }
    pub fn GetMembers(self: *const ITrusteeGroupAdmin, pMembershipTrustee: ?*TRUSTEE_W, pcMembers: ?*u32, prgMembers: ?*?*TRUSTEE_W) callconv(.Inline) HRESULT {
        return self.vtable.GetMembers(self, pMembershipTrustee, pcMembers, prgMembers);
    }
    pub fn GetMemberships(self: *const ITrusteeGroupAdmin, pTrustee: ?*TRUSTEE_W, pcMemberships: ?*u32, prgMemberships: ?*?*TRUSTEE_W) callconv(.Inline) HRESULT {
        return self.vtable.GetMemberships(self, pTrustee, pcMemberships, prgMemberships);
    }
};

const IID_IObjectAccessControl_Value = Guid.initString("0c733aa3-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IObjectAccessControl = &IID_IObjectAccessControl_Value;
pub const IObjectAccessControl = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectAccessRights: *const fn(
            self: *const IObjectAccessControl,
            pObject: ?*SEC_OBJECT,
            pcAccessEntries: ?*u32,
            prgAccessEntries: ?*?*EXPLICIT_ACCESS_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectOwner: *const fn(
            self: *const IObjectAccessControl,
            pObject: ?*SEC_OBJECT,
            ppOwner: ?*?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsObjectAccessAllowed: *const fn(
            self: *const IObjectAccessControl,
            pObject: ?*SEC_OBJECT,
            pAccessEntry: ?*EXPLICIT_ACCESS_W,
            pfResult: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetObjectAccessRights: *const fn(
            self: *const IObjectAccessControl,
            pObject: ?*SEC_OBJECT,
            cAccessEntries: u32,
            prgAccessEntries: ?*EXPLICIT_ACCESS_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetObjectOwner: *const fn(
            self: *const IObjectAccessControl,
            pObject: ?*SEC_OBJECT,
            pOwner: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetObjectAccessRights(self: *const IObjectAccessControl, pObject: ?*SEC_OBJECT, pcAccessEntries: ?*u32, prgAccessEntries: ?*?*EXPLICIT_ACCESS_W) callconv(.Inline) HRESULT {
        return self.vtable.GetObjectAccessRights(self, pObject, pcAccessEntries, prgAccessEntries);
    }
    pub fn GetObjectOwner(self: *const IObjectAccessControl, pObject: ?*SEC_OBJECT, ppOwner: ?*?*TRUSTEE_W) callconv(.Inline) HRESULT {
        return self.vtable.GetObjectOwner(self, pObject, ppOwner);
    }
    pub fn IsObjectAccessAllowed(self: *const IObjectAccessControl, pObject: ?*SEC_OBJECT, pAccessEntry: ?*EXPLICIT_ACCESS_W, pfResult: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.IsObjectAccessAllowed(self, pObject, pAccessEntry, pfResult);
    }
    pub fn SetObjectAccessRights(self: *const IObjectAccessControl, pObject: ?*SEC_OBJECT, cAccessEntries: u32, prgAccessEntries: ?*EXPLICIT_ACCESS_W) callconv(.Inline) HRESULT {
        return self.vtable.SetObjectAccessRights(self, pObject, cAccessEntries, prgAccessEntries);
    }
    pub fn SetObjectOwner(self: *const IObjectAccessControl, pObject: ?*SEC_OBJECT, pOwner: ?*TRUSTEE_W) callconv(.Inline) HRESULT {
        return self.vtable.SetObjectOwner(self, pObject, pOwner);
    }
};

pub const ACCESS_MASKENUM = enum(i32) {
    EXCLUSIVE = 512,
    READDESIGN = 1024,
    WRITEDESIGN = 2048,
    WITHGRANT = 4096,
    REFERENCE = 8192,
    CREATE = 16384,
    INSERT = 32768,
    DELETE = 65536,
    READCONTROL = 131072,
    WRITEPERMISSIONS = 262144,
    WRITEOWNER = 524288,
    MAXIMUM_ALLOWED = 33554432,
    ALL = 268435456,
    EXECUTE = 536870912,
    READ = -2147483648,
    UPDATE = 1073741824,
    DROP = 256,
};
pub const PERM_EXCLUSIVE = ACCESS_MASKENUM.EXCLUSIVE;
pub const PERM_READDESIGN = ACCESS_MASKENUM.READDESIGN;
pub const PERM_WRITEDESIGN = ACCESS_MASKENUM.WRITEDESIGN;
pub const PERM_WITHGRANT = ACCESS_MASKENUM.WITHGRANT;
pub const PERM_REFERENCE = ACCESS_MASKENUM.REFERENCE;
pub const PERM_CREATE = ACCESS_MASKENUM.CREATE;
pub const PERM_INSERT = ACCESS_MASKENUM.INSERT;
pub const PERM_DELETE = ACCESS_MASKENUM.DELETE;
pub const PERM_READCONTROL = ACCESS_MASKENUM.READCONTROL;
pub const PERM_WRITEPERMISSIONS = ACCESS_MASKENUM.WRITEPERMISSIONS;
pub const PERM_WRITEOWNER = ACCESS_MASKENUM.WRITEOWNER;
pub const PERM_MAXIMUM_ALLOWED = ACCESS_MASKENUM.MAXIMUM_ALLOWED;
pub const PERM_ALL = ACCESS_MASKENUM.ALL;
pub const PERM_EXECUTE = ACCESS_MASKENUM.EXECUTE;
pub const PERM_READ = ACCESS_MASKENUM.READ;
pub const PERM_UPDATE = ACCESS_MASKENUM.UPDATE;
pub const PERM_DROP = ACCESS_MASKENUM.DROP;

const IID_ISecurityInfo_Value = Guid.initString("0c733aa4-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISecurityInfo = &IID_ISecurityInfo_Value;
pub const ISecurityInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentTrustee: *const fn(
            self: *const ISecurityInfo,
            ppTrustee: ?*?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectTypes: *const fn(
            self: *const ISecurityInfo,
            cObjectTypes: ?*u32,
            rgObjectTypes: ?*?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPermissions: *const fn(
            self: *const ISecurityInfo,
            ObjectType: Guid,
            pPermissions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetCurrentTrustee(self: *const ISecurityInfo, ppTrustee: ?*?*TRUSTEE_W) callconv(.Inline) HRESULT {
        return self.vtable.GetCurrentTrustee(self, ppTrustee);
    }
    pub fn GetObjectTypes(self: *const ISecurityInfo, cObjectTypes: ?*u32, rgObjectTypes: ?*?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.GetObjectTypes(self, cObjectTypes, rgObjectTypes);
    }
    pub fn GetPermissions(self: *const ISecurityInfo, ObjectType: Guid, pPermissions: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetPermissions(self, ObjectType, pPermissions);
    }
};

const IID_ITableCreation_Value = Guid.initString("0c733abc-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableCreation = &IID_ITableCreation_Value;
pub const ITableCreation = extern union {
    pub const VTable = extern struct {
        base: ITableDefinition.VTable,
        GetTableDefinition: *const fn(
            self: *const ITableCreation,
            pTableID: ?*DBID,
            pcColumnDescs: ?*usize,
            prgColumnDescs: ?[*]?*DBCOLUMNDESC,
            pcPropertySets: ?*u32,
            prgPropertySets: ?[*]?*DBPROPSET,
            pcConstraintDescs: ?*u32,
            prgConstraintDescs: ?[*]?*DBCONSTRAINTDESC,
            ppwszStringBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ITableDefinition: ITableDefinition,
    IUnknown: IUnknown,
    pub fn GetTableDefinition(self: *const ITableCreation, pTableID: ?*DBID, pcColumnDescs: ?*usize, prgColumnDescs: ?[*]?*DBCOLUMNDESC, pcPropertySets: ?*u32, prgPropertySets: ?[*]?*DBPROPSET, pcConstraintDescs: ?*u32, prgConstraintDescs: ?[*]?*DBCONSTRAINTDESC, ppwszStringBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetTableDefinition(self, pTableID, pcColumnDescs, prgColumnDescs, pcPropertySets, prgPropertySets, pcConstraintDescs, prgConstraintDescs, ppwszStringBuffer);
    }
};

const IID_ITableDefinitionWithConstraints_Value = Guid.initString("0c733aab-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableDefinitionWithConstraints = &IID_ITableDefinitionWithConstraints_Value;
pub const ITableDefinitionWithConstraints = extern union {
    pub const VTable = extern struct {
        base: ITableCreation.VTable,
        AddConstraint: *const fn(
            self: *const ITableDefinitionWithConstraints,
            pTableID: ?*DBID,
            pConstraintDesc: ?*DBCONSTRAINTDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTableWithConstraints: *const fn(
            self: *const ITableDefinitionWithConstraints,
            pUnkOuter: ?*IUnknown,
            pTableID: ?*DBID,
            cColumnDescs: usize,
            rgColumnDescs: ?*DBCOLUMNDESC,
            cConstraintDescs: u32,
            rgConstraintDescs: ?*DBCONSTRAINTDESC,
            riid: ?*const Guid,
            cPropertySets: u32,
            rgPropertySets: ?*DBPROPSET,
            ppTableID: ?*?*DBID,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropConstraint: *const fn(
            self: *const ITableDefinitionWithConstraints,
            pTableID: ?*DBID,
            pConstraintID: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ITableCreation: ITableCreation,
    ITableDefinition: ITableDefinition,
    IUnknown: IUnknown,
    pub fn AddConstraint(self: *const ITableDefinitionWithConstraints, pTableID: ?*DBID, pConstraintDesc: ?*DBCONSTRAINTDESC) callconv(.Inline) HRESULT {
        return self.vtable.AddConstraint(self, pTableID, pConstraintDesc);
    }
    pub fn CreateTableWithConstraints(self: *const ITableDefinitionWithConstraints, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, cColumnDescs: usize, rgColumnDescs: ?*DBCOLUMNDESC, cConstraintDescs: u32, rgConstraintDescs: ?*DBCONSTRAINTDESC, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: ?*DBPROPSET, ppTableID: ?*?*DBID, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.CreateTableWithConstraints(self, pUnkOuter, pTableID, cColumnDescs, rgColumnDescs, cConstraintDescs, rgConstraintDescs, riid, cPropertySets, rgPropertySets, ppTableID, ppRowset);
    }
    pub fn DropConstraint(self: *const ITableDefinitionWithConstraints, pTableID: ?*DBID, pConstraintID: ?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.DropConstraint(self, pTableID, pConstraintID);
    }
};

const IID_IRow_Value = Guid.initString("0c733ab4-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRow = &IID_IRow_Value;
pub const IRow = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumns: *const fn(
            self: *const IRow,
            cColumns: usize,
            rgColumns: [*]DBCOLUMNACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceRowset: *const fn(
            self: *const IRow,
            riid: ?*const Guid,
            ppRowset: ?*?*IUnknown,
            phRow: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: *const fn(
            self: *const IRow,
            pUnkOuter: ?*IUnknown,
            pColumnID: ?*DBID,
            rguidColumnType: ?*const Guid,
            dwBindFlags: u32,
            riid: ?*const Guid,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetColumns(self: *const IRow, cColumns: usize, rgColumns: [*]DBCOLUMNACCESS) callconv(.Inline) HRESULT {
        return self.vtable.GetColumns(self, cColumns, rgColumns);
    }
    pub fn GetSourceRowset(self: *const IRow, riid: ?*const Guid, ppRowset: ?*?*IUnknown, phRow: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.GetSourceRowset(self, riid, ppRowset, phRow);
    }
    pub fn Open(self: *const IRow, pUnkOuter: ?*IUnknown, pColumnID: ?*DBID, rguidColumnType: ?*const Guid, dwBindFlags: u32, riid: ?*const Guid, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.Open(self, pUnkOuter, pColumnID, rguidColumnType, dwBindFlags, riid, ppUnk);
    }
};

const IID_IRowChange_Value = Guid.initString("0c733ab5-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowChange = &IID_IRowChange_Value;
pub const IRowChange = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumns: *const fn(
            self: *const IRowChange,
            cColumns: usize,
            rgColumns: [*]DBCOLUMNACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn SetColumns(self: *const IRowChange, cColumns: usize, rgColumns: [*]DBCOLUMNACCESS) callconv(.Inline) HRESULT {
        return self.vtable.SetColumns(self, cColumns, rgColumns);
    }
};

const IID_IRowSchemaChange_Value = Guid.initString("0c733aae-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowSchemaChange = &IID_IRowSchemaChange_Value;
pub const IRowSchemaChange = extern union {
    pub const VTable = extern struct {
        base: IRowChange.VTable,
        DeleteColumns: *const fn(
            self: *const IRowSchemaChange,
            cColumns: usize,
            rgColumnIDs: ?*const DBID,
            rgdwStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddColumns: *const fn(
            self: *const IRowSchemaChange,
            cColumns: usize,
            rgNewColumnInfo: ?*const DBCOLUMNINFO,
            rgColumns: ?*DBCOLUMNACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IRowChange: IRowChange,
    IUnknown: IUnknown,
    pub fn DeleteColumns(self: *const IRowSchemaChange, cColumns: usize, rgColumnIDs: ?*const DBID, rgdwStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.DeleteColumns(self, cColumns, rgColumnIDs, rgdwStatus);
    }
    pub fn AddColumns(self: *const IRowSchemaChange, cColumns: usize, rgNewColumnInfo: ?*const DBCOLUMNINFO, rgColumns: ?*DBCOLUMNACCESS) callconv(.Inline) HRESULT {
        return self.vtable.AddColumns(self, cColumns, rgNewColumnInfo, rgColumns);
    }
};

const IID_IGetRow_Value = Guid.initString("0c733aaf-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetRow = &IID_IGetRow_Value;
pub const IGetRow = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowFromHROW: *const fn(
            self: *const IGetRow,
            pUnkOuter: ?*IUnknown,
            hRow: usize,
            riid: ?*const Guid,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURLFromHROW: *const fn(
            self: *const IGetRow,
            hRow: usize,
            ppwszURL: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetRowFromHROW(self: *const IGetRow, pUnkOuter: ?*IUnknown, hRow: usize, riid: ?*const Guid, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetRowFromHROW(self, pUnkOuter, hRow, riid, ppUnk);
    }
    pub fn GetURLFromHROW(self: *const IGetRow, hRow: usize, ppwszURL: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetURLFromHROW(self, hRow, ppwszURL);
    }
};

const IID_IBindResource_Value = Guid.initString("0c733ab1-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IBindResource = &IID_IBindResource_Value;
pub const IBindResource = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Bind: *const fn(
            self: *const IBindResource,
            pUnkOuter: ?*IUnknown,
            pwszURL: ?[*:0]const u16,
            dwBindURLFlags: u32,
            rguid: ?*const Guid,
            riid: ?*const Guid,
            pAuthenticate: ?*IAuthenticate,
            pImplSession: ?*DBIMPLICITSESSION,
            pdwBindStatus: ?*u32,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Bind(self: *const IBindResource, pUnkOuter: ?*IUnknown, pwszURL: ?[*:0]const u16, dwBindURLFlags: u32, rguid: ?*const Guid, riid: ?*const Guid, pAuthenticate: ?*IAuthenticate, pImplSession: ?*DBIMPLICITSESSION, pdwBindStatus: ?*u32, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.Bind(self, pUnkOuter, pwszURL, dwBindURLFlags, rguid, riid, pAuthenticate, pImplSession, pdwBindStatus, ppUnk);
    }
};

pub const DBCOPYFLAGSENUM = enum(i32) {
    ASYNC = 256,
    REPLACE_EXISTING = 512,
    ALLOW_EMULATION = 1024,
    NON_RECURSIVE = 2048,
    ATOMIC = 4096,
};
pub const DBCOPY_ASYNC = DBCOPYFLAGSENUM.ASYNC;
pub const DBCOPY_REPLACE_EXISTING = DBCOPYFLAGSENUM.REPLACE_EXISTING;
pub const DBCOPY_ALLOW_EMULATION = DBCOPYFLAGSENUM.ALLOW_EMULATION;
pub const DBCOPY_NON_RECURSIVE = DBCOPYFLAGSENUM.NON_RECURSIVE;
pub const DBCOPY_ATOMIC = DBCOPYFLAGSENUM.ATOMIC;

pub const DBMOVEFLAGSENUM = enum(i32) {
    REPLACE_EXISTING = 1,
    ASYNC = 256,
    DONT_UPDATE_LINKS = 512,
    ALLOW_EMULATION = 1024,
    ATOMIC = 4096,
};
pub const DBMOVE_REPLACE_EXISTING = DBMOVEFLAGSENUM.REPLACE_EXISTING;
pub const DBMOVE_ASYNC = DBMOVEFLAGSENUM.ASYNC;
pub const DBMOVE_DONT_UPDATE_LINKS = DBMOVEFLAGSENUM.DONT_UPDATE_LINKS;
pub const DBMOVE_ALLOW_EMULATION = DBMOVEFLAGSENUM.ALLOW_EMULATION;
pub const DBMOVE_ATOMIC = DBMOVEFLAGSENUM.ATOMIC;

pub const DBDELETEFLAGSENUM = enum(i32) {
    SYNC = 256,
    TOMIC = 4096,
};
pub const DBDELETE_ASYNC = DBDELETEFLAGSENUM.SYNC;
pub const DBDELETE_ATOMIC = DBDELETEFLAGSENUM.TOMIC;

const IID_IScopedOperations_Value = Guid.initString("0c733ab0-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IScopedOperations = &IID_IScopedOperations_Value;
pub const IScopedOperations = extern union {
    pub const VTable = extern struct {
        base: IBindResource.VTable,
        Copy: *const fn(
            self: *const IScopedOperations,
            cRows: usize,
            rgpwszSourceURLs: ?[*]?PWSTR,
            rgpwszDestURLs: [*]?PWSTR,
            dwCopyFlags: u32,
            pAuthenticate: ?*IAuthenticate,
            rgdwStatus: [*]u32,
            rgpwszNewURLs: ?[*]?PWSTR,
            ppStringsBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: *const fn(
            self: *const IScopedOperations,
            cRows: usize,
            rgpwszSourceURLs: ?[*]?PWSTR,
            rgpwszDestURLs: [*]?PWSTR,
            dwMoveFlags: u32,
            pAuthenticate: ?*IAuthenticate,
            rgdwStatus: [*]u32,
            rgpwszNewURLs: ?[*]?PWSTR,
            ppStringsBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: *const fn(
            self: *const IScopedOperations,
            cRows: usize,
            rgpwszURLs: [*]?PWSTR,
            dwDeleteFlags: u32,
            rgdwStatus: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenRowset: *const fn(
            self: *const IScopedOperations,
            pUnkOuter: ?*IUnknown,
            pTableID: ?*DBID,
            pIndexID: ?*DBID,
            riid: ?*const Guid,
            cPropertySets: u32,
            rgPropertySets: [*]DBPROPSET,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IBindResource: IBindResource,
    IUnknown: IUnknown,
    pub fn Copy(self: *const IScopedOperations, cRows: usize, rgpwszSourceURLs: ?[*]?PWSTR, rgpwszDestURLs: [*]?PWSTR, dwCopyFlags: u32, pAuthenticate: ?*IAuthenticate, rgdwStatus: [*]u32, rgpwszNewURLs: ?[*]?PWSTR, ppStringsBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.Copy(self, cRows, rgpwszSourceURLs, rgpwszDestURLs, dwCopyFlags, pAuthenticate, rgdwStatus, rgpwszNewURLs, ppStringsBuffer);
    }
    pub fn Move(self: *const IScopedOperations, cRows: usize, rgpwszSourceURLs: ?[*]?PWSTR, rgpwszDestURLs: [*]?PWSTR, dwMoveFlags: u32, pAuthenticate: ?*IAuthenticate, rgdwStatus: [*]u32, rgpwszNewURLs: ?[*]?PWSTR, ppStringsBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.Move(self, cRows, rgpwszSourceURLs, rgpwszDestURLs, dwMoveFlags, pAuthenticate, rgdwStatus, rgpwszNewURLs, ppStringsBuffer);
    }
    pub fn Delete(self: *const IScopedOperations, cRows: usize, rgpwszURLs: [*]?PWSTR, dwDeleteFlags: u32, rgdwStatus: [*]u32) callconv(.Inline) HRESULT {
        return self.vtable.Delete(self, cRows, rgpwszURLs, dwDeleteFlags, rgdwStatus);
    }
    pub fn OpenRowset(self: *const IScopedOperations, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, pIndexID: ?*DBID, riid: ?*const Guid, cPropertySets: u32, rgPropertySets: [*]DBPROPSET, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.OpenRowset(self, pUnkOuter, pTableID, pIndexID, riid, cPropertySets, rgPropertySets, ppRowset);
    }
};

const IID_ICreateRow_Value = Guid.initString("0c733ab2-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICreateRow = &IID_ICreateRow_Value;
pub const ICreateRow = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateRow: *const fn(
            self: *const ICreateRow,
            pUnkOuter: ?*IUnknown,
            pwszURL: ?[*:0]const u16,
            dwBindURLFlags: u32,
            rguid: ?*const Guid,
            riid: ?*const Guid,
            pAuthenticate: ?*IAuthenticate,
            pImplSession: ?*DBIMPLICITSESSION,
            pdwBindStatus: ?*u32,
            ppwszNewURL: ?*?PWSTR,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateRow(self: *const ICreateRow, pUnkOuter: ?*IUnknown, pwszURL: ?[*:0]const u16, dwBindURLFlags: u32, rguid: ?*const Guid, riid: ?*const Guid, pAuthenticate: ?*IAuthenticate, pImplSession: ?*DBIMPLICITSESSION, pdwBindStatus: ?*u32, ppwszNewURL: ?*?PWSTR, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.CreateRow(self, pUnkOuter, pwszURL, dwBindURLFlags, rguid, riid, pAuthenticate, pImplSession, pdwBindStatus, ppwszNewURL, ppUnk);
    }
};

const IID_IDBBinderProperties_Value = Guid.initString("0c733ab3-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBBinderProperties = &IID_IDBBinderProperties_Value;
pub const IDBBinderProperties = extern union {
    pub const VTable = extern struct {
        base: IDBProperties.VTable,
        Reset: *const fn(
            self: *const IDBBinderProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDBProperties: IDBProperties,
    IUnknown: IUnknown,
    pub fn Reset(self: *const IDBBinderProperties) callconv(.Inline) HRESULT {
        return self.vtable.Reset(self);
    }
};

const IID_IColumnsInfo2_Value = Guid.initString("0c733ab8-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IColumnsInfo2 = &IID_IColumnsInfo2_Value;
pub const IColumnsInfo2 = extern union {
    pub const VTable = extern struct {
        base: IColumnsInfo.VTable,
        GetRestrictedColumnInfo: *const fn(
            self: *const IColumnsInfo2,
            cColumnIDMasks: usize,
            rgColumnIDMasks: [*]const DBID,
            dwFlags: u32,
            pcColumns: ?*usize,
            prgColumnIDs: ?*?*DBID,
            prgColumnInfo: ?*?*DBCOLUMNINFO,
            ppStringsBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IColumnsInfo: IColumnsInfo,
    IUnknown: IUnknown,
    pub fn GetRestrictedColumnInfo(self: *const IColumnsInfo2, cColumnIDMasks: usize, rgColumnIDMasks: [*]const DBID, dwFlags: u32, pcColumns: ?*usize, prgColumnIDs: ?*?*DBID, prgColumnInfo: ?*?*DBCOLUMNINFO, ppStringsBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetRestrictedColumnInfo(self, cColumnIDMasks, rgColumnIDMasks, dwFlags, pcColumns, prgColumnIDs, prgColumnInfo, ppStringsBuffer);
    }
};

const IID_IRegisterProvider_Value = Guid.initString("0c733ab9-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRegisterProvider = &IID_IRegisterProvider_Value;
pub const IRegisterProvider = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetURLMapping: *const fn(
            self: *const IRegisterProvider,
            pwszURL: ?[*:0]const u16,
            dwReserved: usize,
            pclsidProvider: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetURLMapping: *const fn(
            self: *const IRegisterProvider,
            pwszURL: ?[*:0]const u16,
            dwReserved: usize,
            rclsidProvider: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterProvider: *const fn(
            self: *const IRegisterProvider,
            pwszURL: ?[*:0]const u16,
            dwReserved: usize,
            rclsidProvider: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetURLMapping(self: *const IRegisterProvider, pwszURL: ?[*:0]const u16, dwReserved: usize, pclsidProvider: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.GetURLMapping(self, pwszURL, dwReserved, pclsidProvider);
    }
    pub fn SetURLMapping(self: *const IRegisterProvider, pwszURL: ?[*:0]const u16, dwReserved: usize, rclsidProvider: ?*const Guid) callconv(.Inline) HRESULT {
        return self.vtable.SetURLMapping(self, pwszURL, dwReserved, rclsidProvider);
    }
    pub fn UnregisterProvider(self: *const IRegisterProvider, pwszURL: ?[*:0]const u16, dwReserved: usize, rclsidProvider: ?*const Guid) callconv(.Inline) HRESULT {
        return self.vtable.UnregisterProvider(self, pwszURL, dwReserved, rclsidProvider);
    }
};

const IID_IGetSession_Value = Guid.initString("0c733aba-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetSession = &IID_IGetSession_Value;
pub const IGetSession = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSession: *const fn(
            self: *const IGetSession,
            riid: ?*const Guid,
            ppSession: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetSession(self: *const IGetSession, riid: ?*const Guid, ppSession: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetSession(self, riid, ppSession);
    }
};

const IID_IGetSourceRow_Value = Guid.initString("0c733abb-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetSourceRow = &IID_IGetSourceRow_Value;
pub const IGetSourceRow = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceRow: *const fn(
            self: *const IGetSourceRow,
            riid: ?*const Guid,
            ppRow: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetSourceRow(self: *const IGetSourceRow, riid: ?*const Guid, ppRow: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetSourceRow(self, riid, ppRow);
    }
};

const IID_IRowsetCurrentIndex_Value = Guid.initString("0c733abd-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetCurrentIndex = &IID_IRowsetCurrentIndex_Value;
pub const IRowsetCurrentIndex = extern union {
    pub const VTable = extern struct {
        base: IRowsetIndex.VTable,
        GetIndex: *const fn(
            self: *const IRowsetCurrentIndex,
            ppIndexID: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndex: *const fn(
            self: *const IRowsetCurrentIndex,
            pIndexID: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IRowsetIndex: IRowsetIndex,
    IUnknown: IUnknown,
    pub fn GetIndex(self: *const IRowsetCurrentIndex, ppIndexID: ?*?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.GetIndex(self, ppIndexID);
    }
    pub fn SetIndex(self: *const IRowsetCurrentIndex, pIndexID: ?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.SetIndex(self, pIndexID);
    }
};

const IID_ICommandStream_Value = Guid.initString("0c733abf-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandStream = &IID_ICommandStream_Value;
pub const ICommandStream = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCommandStream: *const fn(
            self: *const ICommandStream,
            piid: ?*Guid,
            pguidDialect: ?*Guid,
            ppCommandStream: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommandStream: *const fn(
            self: *const ICommandStream,
            riid: ?*const Guid,
            rguidDialect: ?*const Guid,
            pCommandStream: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetCommandStream(self: *const ICommandStream, piid: ?*Guid, pguidDialect: ?*Guid, ppCommandStream: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetCommandStream(self, piid, pguidDialect, ppCommandStream);
    }
    pub fn SetCommandStream(self: *const ICommandStream, riid: ?*const Guid, rguidDialect: ?*const Guid, pCommandStream: ?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.SetCommandStream(self, riid, rguidDialect, pCommandStream);
    }
};

const IID_IRowsetBookmark_Value = Guid.initString("0c733ac2-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetBookmark = &IID_IRowsetBookmark_Value;
pub const IRowsetBookmark = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PositionOnBookmark: *const fn(
            self: *const IRowsetBookmark,
            hChapter: usize,
            cbBookmark: usize,
            // TODO: what to do with BytesParamIndex 1?
            pBookmark: ?*const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn PositionOnBookmark(self: *const IRowsetBookmark, hChapter: usize, cbBookmark: usize, pBookmark: ?*const u8) callconv(.Inline) HRESULT {
        return self.vtable.PositionOnBookmark(self, hChapter, cbBookmark, pBookmark);
    }
};

const CLSID_QueryParser_Value = Guid.initString("b72f8fd8-0fab-4dd9-bdbf-245a6ce1485b");
pub const CLSID_QueryParser = &CLSID_QueryParser_Value;

const CLSID_NegationCondition_Value = Guid.initString("8de9c74c-605a-4acd-bee3-2b222aa2d23d");
pub const CLSID_NegationCondition = &CLSID_NegationCondition_Value;

const CLSID_CompoundCondition_Value = Guid.initString("116f8d13-101e-4fa5-84d4-ff8279381935");
pub const CLSID_CompoundCondition = &CLSID_CompoundCondition_Value;

const CLSID_LeafCondition_Value = Guid.initString("52f15c89-5a17-48e1-bbcd-46a3f89c7cc2");
pub const CLSID_LeafCondition = &CLSID_LeafCondition_Value;

const CLSID_ConditionFactory_Value = Guid.initString("e03e85b0-7be3-4000-ba98-6c13de9fa486");
pub const CLSID_ConditionFactory = &CLSID_ConditionFactory_Value;

const CLSID_Interval_Value = Guid.initString("d957171f-4bf9-4de2-bcd5-c70a7ca55836");
pub const CLSID_Interval = &CLSID_Interval_Value;

const CLSID_QueryParserManager_Value = Guid.initString("5088b39a-29b4-4d9d-8245-4ee289222f66");
pub const CLSID_QueryParserManager = &CLSID_QueryParserManager_Value;

pub const STRUCTURED_QUERY_SYNTAX = enum(i32) {
    NO_SYNTAX = 0,
    ADVANCED_QUERY_SYNTAX = 1,
    NATURAL_QUERY_SYNTAX = 2,
};
pub const SQS_NO_SYNTAX = STRUCTURED_QUERY_SYNTAX.NO_SYNTAX;
pub const SQS_ADVANCED_QUERY_SYNTAX = STRUCTURED_QUERY_SYNTAX.ADVANCED_QUERY_SYNTAX;
pub const SQS_NATURAL_QUERY_SYNTAX = STRUCTURED_QUERY_SYNTAX.NATURAL_QUERY_SYNTAX;

pub const STRUCTURED_QUERY_SINGLE_OPTION = enum(i32) {
    SCHEMA = 0,
    LOCALE_WORD_BREAKING = 1,
    WORD_BREAKER = 2,
    NATURAL_SYNTAX = 3,
    AUTOMATIC_WILDCARD = 4,
    TRACE_LEVEL = 5,
    LANGUAGE_KEYWORDS = 6,
    SYNTAX = 7,
    TIME_ZONE = 8,
    IMPLICIT_CONNECTOR = 9,
    CONNECTOR_CASE = 10,
};
pub const SQSO_SCHEMA = STRUCTURED_QUERY_SINGLE_OPTION.SCHEMA;
pub const SQSO_LOCALE_WORD_BREAKING = STRUCTURED_QUERY_SINGLE_OPTION.LOCALE_WORD_BREAKING;
pub const SQSO_WORD_BREAKER = STRUCTURED_QUERY_SINGLE_OPTION.WORD_BREAKER;
pub const SQSO_NATURAL_SYNTAX = STRUCTURED_QUERY_SINGLE_OPTION.NATURAL_SYNTAX;
pub const SQSO_AUTOMATIC_WILDCARD = STRUCTURED_QUERY_SINGLE_OPTION.AUTOMATIC_WILDCARD;
pub const SQSO_TRACE_LEVEL = STRUCTURED_QUERY_SINGLE_OPTION.TRACE_LEVEL;
pub const SQSO_LANGUAGE_KEYWORDS = STRUCTURED_QUERY_SINGLE_OPTION.LANGUAGE_KEYWORDS;
pub const SQSO_SYNTAX = STRUCTURED_QUERY_SINGLE_OPTION.SYNTAX;
pub const SQSO_TIME_ZONE = STRUCTURED_QUERY_SINGLE_OPTION.TIME_ZONE;
pub const SQSO_IMPLICIT_CONNECTOR = STRUCTURED_QUERY_SINGLE_OPTION.IMPLICIT_CONNECTOR;
pub const SQSO_CONNECTOR_CASE = STRUCTURED_QUERY_SINGLE_OPTION.CONNECTOR_CASE;

pub const STRUCTURED_QUERY_MULTIOPTION = enum(i32) {
    VIRTUAL_PROPERTY = 0,
    DEFAULT_PROPERTY = 1,
    GENERATOR_FOR_TYPE = 2,
    MAP_PROPERTY = 3,
};
pub const SQMO_VIRTUAL_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.VIRTUAL_PROPERTY;
pub const SQMO_DEFAULT_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.DEFAULT_PROPERTY;
pub const SQMO_GENERATOR_FOR_TYPE = STRUCTURED_QUERY_MULTIOPTION.GENERATOR_FOR_TYPE;
pub const SQMO_MAP_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.MAP_PROPERTY;

pub const STRUCTURED_QUERY_PARSE_ERROR = enum(i32) {
    NONE = 0,
    EXTRA_OPENING_PARENTHESIS = 1,
    EXTRA_CLOSING_PARENTHESIS = 2,
    IGNORED_MODIFIER = 3,
    IGNORED_CONNECTOR = 4,
    IGNORED_KEYWORD = 5,
    UNHANDLED = 6,
};
pub const SQPE_NONE = STRUCTURED_QUERY_PARSE_ERROR.NONE;
pub const SQPE_EXTRA_OPENING_PARENTHESIS = STRUCTURED_QUERY_PARSE_ERROR.EXTRA_OPENING_PARENTHESIS;
pub const SQPE_EXTRA_CLOSING_PARENTHESIS = STRUCTURED_QUERY_PARSE_ERROR.EXTRA_CLOSING_PARENTHESIS;
pub const SQPE_IGNORED_MODIFIER = STRUCTURED_QUERY_PARSE_ERROR.IGNORED_MODIFIER;
pub const SQPE_IGNORED_CONNECTOR = STRUCTURED_QUERY_PARSE_ERROR.IGNORED_CONNECTOR;
pub const SQPE_IGNORED_KEYWORD = STRUCTURED_QUERY_PARSE_ERROR.IGNORED_KEYWORD;
pub const SQPE_UNHANDLED = STRUCTURED_QUERY_PARSE_ERROR.UNHANDLED;

pub const STRUCTURED_QUERY_RESOLVE_OPTION = packed struct(u32) {
    DONT_RESOLVE_DATETIME: u1 = 0,
    ALWAYS_ONE_INTERVAL: u1 = 0,
    DONT_SIMPLIFY_CONDITION_TREES: u1 = 0,
    DONT_MAP_RELATIONS: u1 = 0,
    DONT_RESOLVE_RANGES: u1 = 0,
    DONT_REMOVE_UNRESTRICTED_KEYWORDS: u1 = 0,
    DONT_SPLIT_WORDS: u1 = 0,
    IGNORE_PHRASE_ORDER: u1 = 0,
    ADD_VALUE_TYPE_FOR_PLAIN_VALUES: u1 = 0,
    ADD_ROBUST_ITEM_NAME: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const SQRO_DEFAULT = STRUCTURED_QUERY_RESOLVE_OPTION{ };
pub const SQRO_DONT_RESOLVE_DATETIME = STRUCTURED_QUERY_RESOLVE_OPTION{ .DONT_RESOLVE_DATETIME = 1 };
pub const SQRO_ALWAYS_ONE_INTERVAL = STRUCTURED_QUERY_RESOLVE_OPTION{ .ALWAYS_ONE_INTERVAL = 1 };
pub const SQRO_DONT_SIMPLIFY_CONDITION_TREES = STRUCTURED_QUERY_RESOLVE_OPTION{ .DONT_SIMPLIFY_CONDITION_TREES = 1 };
pub const SQRO_DONT_MAP_RELATIONS = STRUCTURED_QUERY_RESOLVE_OPTION{ .DONT_MAP_RELATIONS = 1 };
pub const SQRO_DONT_RESOLVE_RANGES = STRUCTURED_QUERY_RESOLVE_OPTION{ .DONT_RESOLVE_RANGES = 1 };
pub const SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS = STRUCTURED_QUERY_RESOLVE_OPTION{ .DONT_REMOVE_UNRESTRICTED_KEYWORDS = 1 };
pub const SQRO_DONT_SPLIT_WORDS = STRUCTURED_QUERY_RESOLVE_OPTION{ .DONT_SPLIT_WORDS = 1 };
pub const SQRO_IGNORE_PHRASE_ORDER = STRUCTURED_QUERY_RESOLVE_OPTION{ .IGNORE_PHRASE_ORDER = 1 };
pub const SQRO_ADD_VALUE_TYPE_FOR_PLAIN_VALUES = STRUCTURED_QUERY_RESOLVE_OPTION{ .ADD_VALUE_TYPE_FOR_PLAIN_VALUES = 1 };
pub const SQRO_ADD_ROBUST_ITEM_NAME = STRUCTURED_QUERY_RESOLVE_OPTION{ .ADD_ROBUST_ITEM_NAME = 1 };

pub const CASE_REQUIREMENT = enum(i32) {
    ANY = 0,
    UPPER_IF_AQS = 1,
};
pub const CASE_REQUIREMENT_ANY = CASE_REQUIREMENT.ANY;
pub const CASE_REQUIREMENT_UPPER_IF_AQS = CASE_REQUIREMENT.UPPER_IF_AQS;

pub const INTERVAL_LIMIT_KIND = enum(i32) {
    EXPLICIT_INCLUDED = 0,
    EXPLICIT_EXCLUDED = 1,
    NEGATIVE_INFINITY = 2,
    POSITIVE_INFINITY = 3,
};
pub const ILK_EXPLICIT_INCLUDED = INTERVAL_LIMIT_KIND.EXPLICIT_INCLUDED;
pub const ILK_EXPLICIT_EXCLUDED = INTERVAL_LIMIT_KIND.EXPLICIT_EXCLUDED;
pub const ILK_NEGATIVE_INFINITY = INTERVAL_LIMIT_KIND.NEGATIVE_INFINITY;
pub const ILK_POSITIVE_INFINITY = INTERVAL_LIMIT_KIND.POSITIVE_INFINITY;

pub const QUERY_PARSER_MANAGER_OPTION = enum(i32) {
    SCHEMA_BINARY_NAME = 0,
    PRELOCALIZED_SCHEMA_BINARY_PATH = 1,
    UNLOCALIZED_SCHEMA_BINARY_PATH = 2,
    LOCALIZED_SCHEMA_BINARY_PATH = 3,
    APPEND_LCID_TO_LOCALIZED_PATH = 4,
    LOCALIZER_SUPPORT = 5,
};
pub const QPMO_SCHEMA_BINARY_NAME = QUERY_PARSER_MANAGER_OPTION.SCHEMA_BINARY_NAME;
pub const QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.PRELOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.UNLOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_LOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.LOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_APPEND_LCID_TO_LOCALIZED_PATH = QUERY_PARSER_MANAGER_OPTION.APPEND_LCID_TO_LOCALIZED_PATH;
pub const QPMO_LOCALIZER_SUPPORT = QUERY_PARSER_MANAGER_OPTION.LOCALIZER_SUPPORT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryParser_Value = Guid.initString("2ebdee67-3505-43f8-9946-ea44abc8e5b0");
pub const IID_IQueryParser = &IID_IQueryParser_Value;
pub const IQueryParser = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Parse: *const fn(
            self: *const IQueryParser,
            pszInputString: ?[*:0]const u16,
            pCustomProperties: ?*IEnumUnknown,
            ppSolution: ?*?*IQuerySolution,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOption: *const fn(
            self: *const IQueryParser,
            option: STRUCTURED_QUERY_SINGLE_OPTION,
            pOptionValue: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOption: *const fn(
            self: *const IQueryParser,
            option: STRUCTURED_QUERY_SINGLE_OPTION,
            pOptionValue: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMultiOption: *const fn(
            self: *const IQueryParser,
            option: STRUCTURED_QUERY_MULTIOPTION,
            pszOptionKey: ?[*:0]const u16,
            pOptionValue: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemaProvider: *const fn(
            self: *const IQueryParser,
            ppSchemaProvider: ?*?*ISchemaProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestateToString: *const fn(
            self: *const IQueryParser,
            pCondition: ?*ICondition,
            fUseEnglish: BOOL,
            ppszQueryString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParsePropertyValue: *const fn(
            self: *const IQueryParser,
            pszPropertyName: ?[*:0]const u16,
            pszInputString: ?[*:0]const u16,
            ppSolution: ?*?*IQuerySolution,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestatePropertyValueToString: *const fn(
            self: *const IQueryParser,
            pCondition: ?*ICondition,
            fUseEnglish: BOOL,
            ppszPropertyName: ?*?PWSTR,
            ppszQueryString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Parse(self: *const IQueryParser, pszInputString: ?[*:0]const u16, pCustomProperties: ?*IEnumUnknown, ppSolution: ?*?*IQuerySolution) callconv(.Inline) HRESULT {
        return self.vtable.Parse(self, pszInputString, pCustomProperties, ppSolution);
    }
    pub fn SetOption(self: *const IQueryParser, option: STRUCTURED_QUERY_SINGLE_OPTION, pOptionValue: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.SetOption(self, option, pOptionValue);
    }
    pub fn GetOption(self: *const IQueryParser, option: STRUCTURED_QUERY_SINGLE_OPTION, pOptionValue: ?*PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetOption(self, option, pOptionValue);
    }
    pub fn SetMultiOption(self: *const IQueryParser, option: STRUCTURED_QUERY_MULTIOPTION, pszOptionKey: ?[*:0]const u16, pOptionValue: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.SetMultiOption(self, option, pszOptionKey, pOptionValue);
    }
    pub fn GetSchemaProvider(self: *const IQueryParser, ppSchemaProvider: ?*?*ISchemaProvider) callconv(.Inline) HRESULT {
        return self.vtable.GetSchemaProvider(self, ppSchemaProvider);
    }
    pub fn RestateToString(self: *const IQueryParser, pCondition: ?*ICondition, fUseEnglish: BOOL, ppszQueryString: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.RestateToString(self, pCondition, fUseEnglish, ppszQueryString);
    }
    pub fn ParsePropertyValue(self: *const IQueryParser, pszPropertyName: ?[*:0]const u16, pszInputString: ?[*:0]const u16, ppSolution: ?*?*IQuerySolution) callconv(.Inline) HRESULT {
        return self.vtable.ParsePropertyValue(self, pszPropertyName, pszInputString, ppSolution);
    }
    pub fn RestatePropertyValueToString(self: *const IQueryParser, pCondition: ?*ICondition, fUseEnglish: BOOL, ppszPropertyName: ?*?PWSTR, ppszQueryString: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.RestatePropertyValueToString(self, pCondition, fUseEnglish, ppszPropertyName, ppszQueryString);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConditionFactory_Value = Guid.initString("a5efe073-b16f-474f-9f3e-9f8b497a3e08");
pub const IID_IConditionFactory = &IID_IConditionFactory_Value;
pub const IConditionFactory = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MakeNot: *const fn(
            self: *const IConditionFactory,
            pcSub: ?*ICondition,
            fSimplify: BOOL,
            ppcResult: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeAndOr: *const fn(
            self: *const IConditionFactory,
            ct: CONDITION_TYPE,
            peuSubs: ?*IEnumUnknown,
            fSimplify: BOOL,
            ppcResult: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeLeaf: *const fn(
            self: *const IConditionFactory,
            pszPropertyName: ?[*:0]const u16,
            cop: CONDITION_OPERATION,
            pszValueType: ?[*:0]const u16,
            ppropvar: ?*const PROPVARIANT,
            pPropertyNameTerm: ?*IRichChunk,
            pOperationTerm: ?*IRichChunk,
            pValueTerm: ?*IRichChunk,
            fExpand: BOOL,
            ppcResult: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resolve: *const fn(
            self: *const IConditionFactory,
            pc: ?*ICondition,
            sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
            pstReferenceTime: ?*const SYSTEMTIME,
            ppcResolved: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn MakeNot(self: *const IConditionFactory, pcSub: ?*ICondition, fSimplify: BOOL, ppcResult: ?*?*ICondition) callconv(.Inline) HRESULT {
        return self.vtable.MakeNot(self, pcSub, fSimplify, ppcResult);
    }
    pub fn MakeAndOr(self: *const IConditionFactory, ct: CONDITION_TYPE, peuSubs: ?*IEnumUnknown, fSimplify: BOOL, ppcResult: ?*?*ICondition) callconv(.Inline) HRESULT {
        return self.vtable.MakeAndOr(self, ct, peuSubs, fSimplify, ppcResult);
    }
    pub fn MakeLeaf(self: *const IConditionFactory, pszPropertyName: ?[*:0]const u16, cop: CONDITION_OPERATION, pszValueType: ?[*:0]const u16, ppropvar: ?*const PROPVARIANT, pPropertyNameTerm: ?*IRichChunk, pOperationTerm: ?*IRichChunk, pValueTerm: ?*IRichChunk, fExpand: BOOL, ppcResult: ?*?*ICondition) callconv(.Inline) HRESULT {
        return self.vtable.MakeLeaf(self, pszPropertyName, cop, pszValueType, ppropvar, pPropertyNameTerm, pOperationTerm, pValueTerm, fExpand, ppcResult);
    }
    pub fn Resolve(self: *const IConditionFactory, pc: ?*ICondition, sqro: STRUCTURED_QUERY_RESOLVE_OPTION, pstReferenceTime: ?*const SYSTEMTIME, ppcResolved: ?*?*ICondition) callconv(.Inline) HRESULT {
        return self.vtable.Resolve(self, pc, sqro, pstReferenceTime, ppcResolved);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQuerySolution_Value = Guid.initString("d6ebc66b-8921-4193-afdd-a1789fb7ff57");
pub const IID_IQuerySolution = &IID_IQuerySolution_Value;
pub const IQuerySolution = extern union {
    pub const VTable = extern struct {
        base: IConditionFactory.VTable,
        GetQuery: *const fn(
            self: *const IQuerySolution,
            ppQueryNode: ?*?*ICondition,
            ppMainType: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrors: *const fn(
            self: *const IQuerySolution,
            riid: ?*const Guid,
            ppParseErrors: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLexicalData: *const fn(
            self: *const IQuerySolution,
            ppszInputString: ?*?PWSTR,
            ppTokens: ?*?*ITokenCollection,
            plcid: ?*u32,
            ppWordBreaker: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IConditionFactory: IConditionFactory,
    IUnknown: IUnknown,
    pub fn GetQuery(self: *const IQuerySolution, ppQueryNode: ?*?*ICondition, ppMainType: ?*?*IEntity) callconv(.Inline) HRESULT {
        return self.vtable.GetQuery(self, ppQueryNode, ppMainType);
    }
    pub fn GetErrors(self: *const IQuerySolution, riid: ?*const Guid, ppParseErrors: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetErrors(self, riid, ppParseErrors);
    }
    pub fn GetLexicalData(self: *const IQuerySolution, ppszInputString: ?*?PWSTR, ppTokens: ?*?*ITokenCollection, plcid: ?*u32, ppWordBreaker: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetLexicalData(self, ppszInputString, ppTokens, plcid, ppWordBreaker);
    }
};

pub const CONDITION_CREATION_OPTIONS = packed struct(u32) {
    SIMPLIFY: u1 = 0,
    VECTOR_AND: u1 = 0,
    VECTOR_OR: u1 = 0,
    VECTOR_LEAF: u1 = 0,
    USE_CONTENT_LOCALE: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CONDITION_CREATION_DEFAULT = CONDITION_CREATION_OPTIONS{ };
pub const CONDITION_CREATION_NONE = CONDITION_CREATION_OPTIONS{ };
pub const CONDITION_CREATION_SIMPLIFY = CONDITION_CREATION_OPTIONS{ .SIMPLIFY = 1 };
pub const CONDITION_CREATION_VECTOR_AND = CONDITION_CREATION_OPTIONS{ .VECTOR_AND = 1 };
pub const CONDITION_CREATION_VECTOR_OR = CONDITION_CREATION_OPTIONS{ .VECTOR_OR = 1 };
pub const CONDITION_CREATION_VECTOR_LEAF = CONDITION_CREATION_OPTIONS{ .VECTOR_LEAF = 1 };
pub const CONDITION_CREATION_USE_CONTENT_LOCALE = CONDITION_CREATION_OPTIONS{ .USE_CONTENT_LOCALE = 1 };

// TODO: this type is limited to platform 'windows6.1'
const IID_IConditionFactory2_Value = Guid.initString("71d222e1-432f-429e-8c13-b6dafde5077a");
pub const IID_IConditionFactory2 = &IID_IConditionFactory2_Value;
pub const IConditionFactory2 = extern union {
    pub const VTable = extern struct {
        base: IConditionFactory.VTable,
        CreateTrueFalse: *const fn(
            self: *const IConditionFactory2,
            fVal: BOOL,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateNegation: *const fn(
            self: *const IConditionFactory2,
            pcSub: ?*ICondition,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCompoundFromObjectArray: *const fn(
            self: *const IConditionFactory2,
            ct: CONDITION_TYPE,
            poaSubs: ?*IObjectArray,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCompoundFromArray: *const fn(
            self: *const IConditionFactory2,
            ct: CONDITION_TYPE,
            ppcondSubs: [*]?*ICondition,
            cSubs: u32,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStringLeaf: *const fn(
            self: *const IConditionFactory2,
            propkey: ?*const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            pszValue: ?[*:0]const u16,
            pszLocaleName: ?[*:0]const u16,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateIntegerLeaf: *const fn(
            self: *const IConditionFactory2,
            propkey: ?*const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            lValue: i32,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBooleanLeaf: *const fn(
            self: *const IConditionFactory2,
            propkey: ?*const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            fValue: BOOL,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateLeaf: *const fn(
            self: *const IConditionFactory2,
            propkey: ?*const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            propvar: ?*const PROPVARIANT,
            pszSemanticType: ?[*:0]const u16,
            pszLocaleName: ?[*:0]const u16,
            pPropertyNameTerm: ?*IRichChunk,
            pOperationTerm: ?*IRichChunk,
            pValueTerm: ?*IRichChunk,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveCondition: *const fn(
            self: *const IConditionFactory2,
            pc: ?*ICondition,
            sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
            pstReferenceTime: ?*const SYSTEMTIME,
            riid: ?*const Guid,
            ppv: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IConditionFactory: IConditionFactory,
    IUnknown: IUnknown,
    pub fn CreateTrueFalse(self: *const IConditionFactory2, fVal: BOOL, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateTrueFalse(self, fVal, cco, riid, ppv);
    }
    pub fn CreateNegation(self: *const IConditionFactory2, pcSub: ?*ICondition, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateNegation(self, pcSub, cco, riid, ppv);
    }
    pub fn CreateCompoundFromObjectArray(self: *const IConditionFactory2, ct: CONDITION_TYPE, poaSubs: ?*IObjectArray, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateCompoundFromObjectArray(self, ct, poaSubs, cco, riid, ppv);
    }
    pub fn CreateCompoundFromArray(self: *const IConditionFactory2, ct: CONDITION_TYPE, ppcondSubs: [*]?*ICondition, cSubs: u32, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateCompoundFromArray(self, ct, ppcondSubs, cSubs, cco, riid, ppv);
    }
    pub fn CreateStringLeaf(self: *const IConditionFactory2, propkey: ?*const PROPERTYKEY, cop: CONDITION_OPERATION, pszValue: ?[*:0]const u16, pszLocaleName: ?[*:0]const u16, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateStringLeaf(self, propkey, cop, pszValue, pszLocaleName, cco, riid, ppv);
    }
    pub fn CreateIntegerLeaf(self: *const IConditionFactory2, propkey: ?*const PROPERTYKEY, cop: CONDITION_OPERATION, lValue: i32, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateIntegerLeaf(self, propkey, cop, lValue, cco, riid, ppv);
    }
    pub fn CreateBooleanLeaf(self: *const IConditionFactory2, propkey: ?*const PROPERTYKEY, cop: CONDITION_OPERATION, fValue: BOOL, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateBooleanLeaf(self, propkey, cop, fValue, cco, riid, ppv);
    }
    pub fn CreateLeaf(self: *const IConditionFactory2, propkey: ?*const PROPERTYKEY, cop: CONDITION_OPERATION, propvar: ?*const PROPVARIANT, pszSemanticType: ?[*:0]const u16, pszLocaleName: ?[*:0]const u16, pPropertyNameTerm: ?*IRichChunk, pOperationTerm: ?*IRichChunk, pValueTerm: ?*IRichChunk, cco: CONDITION_CREATION_OPTIONS, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateLeaf(self, propkey, cop, propvar, pszSemanticType, pszLocaleName, pPropertyNameTerm, pOperationTerm, pValueTerm, cco, riid, ppv);
    }
    pub fn ResolveCondition(self: *const IConditionFactory2, pc: ?*ICondition, sqro: STRUCTURED_QUERY_RESOLVE_OPTION, pstReferenceTime: ?*const SYSTEMTIME, riid: ?*const Guid, ppv: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.ResolveCondition(self, pc, sqro, pstReferenceTime, riid, ppv);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConditionGenerator_Value = Guid.initString("92d2cc58-4386-45a3-b98c-7e0ce64a4117");
pub const IID_IConditionGenerator = &IID_IConditionGenerator_Value;
pub const IConditionGenerator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn(
            self: *const IConditionGenerator,
            pSchemaProvider: ?*ISchemaProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecognizeNamedEntities: *const fn(
            self: *const IConditionGenerator,
            pszInputString: ?[*:0]const u16,
            lcidUserLocale: u32,
            pTokenCollection: ?*ITokenCollection,
            pNamedEntities: ?*INamedEntityCollector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateForLeaf: *const fn(
            self: *const IConditionGenerator,
            pConditionFactory: ?*IConditionFactory,
            pszPropertyName: ?[*:0]const u16,
            cop: CONDITION_OPERATION,
            pszValueType: ?[*:0]const u16,
            pszValue: ?[*:0]const u16,
            pszValue2: ?[*:0]const u16,
            pPropertyNameTerm: ?*IRichChunk,
            pOperationTerm: ?*IRichChunk,
            pValueTerm: ?*IRichChunk,
            automaticWildcard: BOOL,
            pNoStringQuery: ?*BOOL,
            ppQueryExpression: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: *const fn(
            self: *const IConditionGenerator,
            pszValueType: ?[*:0]const u16,
            ppropvar: ?*const PROPVARIANT,
            fUseEnglish: BOOL,
            ppszPhrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Initialize(self: *const IConditionGenerator, pSchemaProvider: ?*ISchemaProvider) callconv(.Inline) HRESULT {
        return self.vtable.Initialize(self, pSchemaProvider);
    }
    pub fn RecognizeNamedEntities(self: *const IConditionGenerator, pszInputString: ?[*:0]const u16, lcidUserLocale: u32, pTokenCollection: ?*ITokenCollection, pNamedEntities: ?*INamedEntityCollector) callconv(.Inline) HRESULT {
        return self.vtable.RecognizeNamedEntities(self, pszInputString, lcidUserLocale, pTokenCollection, pNamedEntities);
    }
    pub fn GenerateForLeaf(self: *const IConditionGenerator, pConditionFactory: ?*IConditionFactory, pszPropertyName: ?[*:0]const u16, cop: CONDITION_OPERATION, pszValueType: ?[*:0]const u16, pszValue: ?[*:0]const u16, pszValue2: ?[*:0]const u16, pPropertyNameTerm: ?*IRichChunk, pOperationTerm: ?*IRichChunk, pValueTerm: ?*IRichChunk, automaticWildcard: BOOL, pNoStringQuery: ?*BOOL, ppQueryExpression: ?*?*ICondition) callconv(.Inline) HRESULT {
        return self.vtable.GenerateForLeaf(self, pConditionFactory, pszPropertyName, cop, pszValueType, pszValue, pszValue2, pPropertyNameTerm, pOperationTerm, pValueTerm, automaticWildcard, pNoStringQuery, ppQueryExpression);
    }
    pub fn DefaultPhrase(self: *const IConditionGenerator, pszValueType: ?[*:0]const u16, ppropvar: ?*const PROPVARIANT, fUseEnglish: BOOL, ppszPhrase: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.DefaultPhrase(self, pszValueType, ppropvar, fUseEnglish, ppszPhrase);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInterval_Value = Guid.initString("6bf0a714-3c18-430b-8b5d-83b1c234d3db");
pub const IID_IInterval = &IID_IInterval_Value;
pub const IInterval = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLimits: *const fn(
            self: *const IInterval,
            pilkLower: ?*INTERVAL_LIMIT_KIND,
            ppropvarLower: ?*PROPVARIANT,
            pilkUpper: ?*INTERVAL_LIMIT_KIND,
            ppropvarUpper: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetLimits(self: *const IInterval, pilkLower: ?*INTERVAL_LIMIT_KIND, ppropvarLower: ?*PROPVARIANT, pilkUpper: ?*INTERVAL_LIMIT_KIND, ppropvarUpper: ?*PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetLimits(self, pilkLower, ppropvarLower, pilkUpper, ppropvarUpper);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMetaData_Value = Guid.initString("780102b0-c43b-4876-bc7b-5e9ba5c88794");
pub const IID_IMetaData = &IID_IMetaData_Value;
pub const IMetaData = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: *const fn(
            self: *const IMetaData,
            ppszKey: ?*?PWSTR,
            ppszValue: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetData(self: *const IMetaData, ppszKey: ?*?PWSTR, ppszValue: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetData(self, ppszKey, ppszValue);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEntity_Value = Guid.initString("24264891-e80b-4fd3-b7ce-4ff2fae8931f");
pub const IID_IEntity = &IID_IEntity_Value;
pub const IEntity = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Name: *const fn(
            self: *const IEntity,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Base: *const fn(
            self: *const IEntity,
            pBaseEntity: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Relationships: *const fn(
            self: *const IEntity,
            riid: ?*const Guid,
            pRelationships: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelationship: *const fn(
            self: *const IEntity,
            pszRelationName: ?[*:0]const u16,
            pRelationship: ?*?*IRelationship,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MetaData: *const fn(
            self: *const IEntity,
            riid: ?*const Guid,
            pMetaData: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NamedEntities: *const fn(
            self: *const IEntity,
            riid: ?*const Guid,
            pNamedEntities: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamedEntity: *const fn(
            self: *const IEntity,
            pszValue: ?[*:0]const u16,
            ppNamedEntity: ?*?*INamedEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: *const fn(
            self: *const IEntity,
            ppszPhrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Name(self: *const IEntity, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.Name(self, ppszName);
    }
    pub fn Base(self: *const IEntity, pBaseEntity: ?*?*IEntity) callconv(.Inline) HRESULT {
        return self.vtable.Base(self, pBaseEntity);
    }
    pub fn Relationships(self: *const IEntity, riid: ?*const Guid, pRelationships: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.Relationships(self, riid, pRelationships);
    }
    pub fn GetRelationship(self: *const IEntity, pszRelationName: ?[*:0]const u16, pRelationship: ?*?*IRelationship) callconv(.Inline) HRESULT {
        return self.vtable.GetRelationship(self, pszRelationName, pRelationship);
    }
    pub fn MetaData(self: *const IEntity, riid: ?*const Guid, pMetaData: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.MetaData(self, riid, pMetaData);
    }
    pub fn NamedEntities(self: *const IEntity, riid: ?*const Guid, pNamedEntities: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.NamedEntities(self, riid, pNamedEntities);
    }
    pub fn GetNamedEntity(self: *const IEntity, pszValue: ?[*:0]const u16, ppNamedEntity: ?*?*INamedEntity) callconv(.Inline) HRESULT {
        return self.vtable.GetNamedEntity(self, pszValue, ppNamedEntity);
    }
    pub fn DefaultPhrase(self: *const IEntity, ppszPhrase: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.DefaultPhrase(self, ppszPhrase);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRelationship_Value = Guid.initString("2769280b-5108-498c-9c7f-a51239b63147");
pub const IID_IRelationship = &IID_IRelationship_Value;
pub const IRelationship = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Name: *const fn(
            self: *const IRelationship,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsReal: *const fn(
            self: *const IRelationship,
            pIsReal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Destination: *const fn(
            self: *const IRelationship,
            pDestinationEntity: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MetaData: *const fn(
            self: *const IRelationship,
            riid: ?*const Guid,
            pMetaData: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: *const fn(
            self: *const IRelationship,
            ppszPhrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Name(self: *const IRelationship, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.Name(self, ppszName);
    }
    pub fn IsReal(self: *const IRelationship, pIsReal: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.IsReal(self, pIsReal);
    }
    pub fn Destination(self: *const IRelationship, pDestinationEntity: ?*?*IEntity) callconv(.Inline) HRESULT {
        return self.vtable.Destination(self, pDestinationEntity);
    }
    pub fn MetaData(self: *const IRelationship, riid: ?*const Guid, pMetaData: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.MetaData(self, riid, pMetaData);
    }
    pub fn DefaultPhrase(self: *const IRelationship, ppszPhrase: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.DefaultPhrase(self, ppszPhrase);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamedEntity_Value = Guid.initString("abdbd0b1-7d54-49fb-ab5c-bff4130004cd");
pub const IID_INamedEntity = &IID_INamedEntity_Value;
pub const INamedEntity = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: *const fn(
            self: *const INamedEntity,
            ppszValue: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: *const fn(
            self: *const INamedEntity,
            ppszPhrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetValue(self: *const INamedEntity, ppszValue: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetValue(self, ppszValue);
    }
    pub fn DefaultPhrase(self: *const INamedEntity, ppszPhrase: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.DefaultPhrase(self, ppszPhrase);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISchemaProvider_Value = Guid.initString("8cf89bcb-394c-49b2-ae28-a59dd4ed7f68");
pub const IID_ISchemaProvider = &IID_ISchemaProvider_Value;
pub const ISchemaProvider = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Entities: *const fn(
            self: *const ISchemaProvider,
            riid: ?*const Guid,
            pEntities: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RootEntity: *const fn(
            self: *const ISchemaProvider,
            pRootEntity: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntity: *const fn(
            self: *const ISchemaProvider,
            pszEntityName: ?[*:0]const u16,
            pEntity: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MetaData: *const fn(
            self: *const ISchemaProvider,
            riid: ?*const Guid,
            pMetaData: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Localize: *const fn(
            self: *const ISchemaProvider,
            lcid: u32,
            pSchemaLocalizerSupport: ?*ISchemaLocalizerSupport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveBinary: *const fn(
            self: *const ISchemaProvider,
            pszSchemaBinaryPath: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupAuthoredNamedEntity: *const fn(
            self: *const ISchemaProvider,
            pEntity: ?*IEntity,
            pszInputString: ?[*:0]const u16,
            pTokenCollection: ?*ITokenCollection,
            cTokensBegin: u32,
            pcTokensLength: ?*u32,
            ppszValue: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Entities(self: *const ISchemaProvider, riid: ?*const Guid, pEntities: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.Entities(self, riid, pEntities);
    }
    pub fn RootEntity(self: *const ISchemaProvider, pRootEntity: ?*?*IEntity) callconv(.Inline) HRESULT {
        return self.vtable.RootEntity(self, pRootEntity);
    }
    pub fn GetEntity(self: *const ISchemaProvider, pszEntityName: ?[*:0]const u16, pEntity: ?*?*IEntity) callconv(.Inline) HRESULT {
        return self.vtable.GetEntity(self, pszEntityName, pEntity);
    }
    pub fn MetaData(self: *const ISchemaProvider, riid: ?*const Guid, pMetaData: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.MetaData(self, riid, pMetaData);
    }
    pub fn Localize(self: *const ISchemaProvider, lcid: u32, pSchemaLocalizerSupport: ?*ISchemaLocalizerSupport) callconv(.Inline) HRESULT {
        return self.vtable.Localize(self, lcid, pSchemaLocalizerSupport);
    }
    pub fn SaveBinary(self: *const ISchemaProvider, pszSchemaBinaryPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.SaveBinary(self, pszSchemaBinaryPath);
    }
    pub fn LookupAuthoredNamedEntity(self: *const ISchemaProvider, pEntity: ?*IEntity, pszInputString: ?[*:0]const u16, pTokenCollection: ?*ITokenCollection, cTokensBegin: u32, pcTokensLength: ?*u32, ppszValue: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.LookupAuthoredNamedEntity(self, pEntity, pszInputString, pTokenCollection, cTokensBegin, pcTokensLength, ppszValue);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITokenCollection_Value = Guid.initString("22d8b4f2-f577-4adb-a335-c2ae88416fab");
pub const IID_ITokenCollection = &IID_ITokenCollection_Value;
pub const ITokenCollection = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NumberOfTokens: *const fn(
            self: *const ITokenCollection,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetToken: *const fn(
            self: *const ITokenCollection,
            i: u32,
            pBegin: ?*u32,
            pLength: ?*u32,
            ppsz: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn NumberOfTokens(self: *const ITokenCollection, pCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.NumberOfTokens(self, pCount);
    }
    pub fn GetToken(self: *const ITokenCollection, i: u32, pBegin: ?*u32, pLength: ?*u32, ppsz: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetToken(self, i, pBegin, pLength, ppsz);
    }
};

pub const NAMED_ENTITY_CERTAINTY = enum(i32) {
    LOW = 0,
    MEDIUM = 1,
    HIGH = 2,
};
pub const NEC_LOW = NAMED_ENTITY_CERTAINTY.LOW;
pub const NEC_MEDIUM = NAMED_ENTITY_CERTAINTY.MEDIUM;
pub const NEC_HIGH = NAMED_ENTITY_CERTAINTY.HIGH;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamedEntityCollector_Value = Guid.initString("af2440f6-8afc-47d0-9a7f-396a0acfb43d");
pub const IID_INamedEntityCollector = &IID_INamedEntityCollector_Value;
pub const INamedEntityCollector = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: *const fn(
            self: *const INamedEntityCollector,
            beginSpan: u32,
            endSpan: u32,
            beginActual: u32,
            endActual: u32,
            pType: ?*IEntity,
            pszValue: ?[*:0]const u16,
            certainty: NAMED_ENTITY_CERTAINTY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Add(self: *const INamedEntityCollector, beginSpan: u32, endSpan: u32, beginActual: u32, endActual: u32, pType: ?*IEntity, pszValue: ?[*:0]const u16, certainty: NAMED_ENTITY_CERTAINTY) callconv(.Inline) HRESULT {
        return self.vtable.Add(self, beginSpan, endSpan, beginActual, endActual, pType, pszValue, certainty);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISchemaLocalizerSupport_Value = Guid.initString("ca3fdca2-bfbe-4eed-90d7-0caef0a1bda1");
pub const IID_ISchemaLocalizerSupport = &IID_ISchemaLocalizerSupport_Value;
pub const ISchemaLocalizerSupport = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Localize: *const fn(
            self: *const ISchemaLocalizerSupport,
            pszGlobalString: ?[*:0]const u16,
            ppszLocalString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Localize(self: *const ISchemaLocalizerSupport, pszGlobalString: ?[*:0]const u16, ppszLocalString: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.Localize(self, pszGlobalString, ppszLocalString);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryParserManager_Value = Guid.initString("a879e3c4-af77-44fb-8f37-ebd1487cf920");
pub const IID_IQueryParserManager = &IID_IQueryParserManager_Value;
pub const IQueryParserManager = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateLoadedParser: *const fn(
            self: *const IQueryParserManager,
            pszCatalog: ?[*:0]const u16,
            langidForKeywords: u16,
            riid: ?*const Guid,
            ppQueryParser: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeOptions: *const fn(
            self: *const IQueryParserManager,
            fUnderstandNQS: BOOL,
            fAutoWildCard: BOOL,
            pQueryParser: ?*IQueryParser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOption: *const fn(
            self: *const IQueryParserManager,
            option: QUERY_PARSER_MANAGER_OPTION,
            pOptionValue: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateLoadedParser(self: *const IQueryParserManager, pszCatalog: ?[*:0]const u16, langidForKeywords: u16, riid: ?*const Guid, ppQueryParser: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateLoadedParser(self, pszCatalog, langidForKeywords, riid, ppQueryParser);
    }
    pub fn InitializeOptions(self: *const IQueryParserManager, fUnderstandNQS: BOOL, fAutoWildCard: BOOL, pQueryParser: ?*IQueryParser) callconv(.Inline) HRESULT {
        return self.vtable.InitializeOptions(self, fUnderstandNQS, fAutoWildCard, pQueryParser);
    }
    pub fn SetOption(self: *const IQueryParserManager, option: QUERY_PARSER_MANAGER_OPTION, pOptionValue: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.SetOption(self, option, pOptionValue);
    }
};

pub const HITRANGE = extern struct {
    iPosition: u32,
    cLength: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUrlAccessor_Value = Guid.initString("0b63e318-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IUrlAccessor = &IID_IUrlAccessor_Value;
pub const IUrlAccessor = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRequestParameter: *const fn(
            self: *const IUrlAccessor,
            pSpec: ?*PROPSPEC,
            pVar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocFormat: *const fn(
            self: *const IUrlAccessor,
            wszDocFormat: [*:0]u16,
            dwSize: u32,
            pdwLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCLSID: *const fn(
            self: *const IUrlAccessor,
            pClsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHost: *const fn(
            self: *const IUrlAccessor,
            wszHost: [*:0]u16,
            dwSize: u32,
            pdwLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDirectory: *const fn(
            self: *const IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: *const fn(
            self: *const IUrlAccessor,
            pllSize: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastModified: *const fn(
            self: *const IUrlAccessor,
            pftLastModified: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: *const fn(
            self: *const IUrlAccessor,
            wszFileName: [*:0]u16,
            dwSize: u32,
            pdwLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityDescriptor: *const fn(
            self: *const IUrlAccessor,
            pSD: [*:0]u8,
            dwSize: u32,
            pdwLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRedirectedURL: *const fn(
            self: *const IUrlAccessor,
            wszRedirectedURL: [*:0]u16,
            dwSize: u32,
            pdwLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityProvider: *const fn(
            self: *const IUrlAccessor,
            pSPClsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToStream: *const fn(
            self: *const IUrlAccessor,
            ppStream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToFilter: *const fn(
            self: *const IUrlAccessor,
            ppFilter: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn AddRequestParameter(self: *const IUrlAccessor, pSpec: ?*PROPSPEC, pVar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.AddRequestParameter(self, pSpec, pVar);
    }
    pub fn GetDocFormat(self: *const IUrlAccessor, wszDocFormat: [*:0]u16, dwSize: u32, pdwLength: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetDocFormat(self, wszDocFormat, dwSize, pdwLength);
    }
    pub fn GetCLSID(self: *const IUrlAccessor, pClsid: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.GetCLSID(self, pClsid);
    }
    pub fn GetHost(self: *const IUrlAccessor, wszHost: [*:0]u16, dwSize: u32, pdwLength: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetHost(self, wszHost, dwSize, pdwLength);
    }
    pub fn IsDirectory(self: *const IUrlAccessor) callconv(.Inline) HRESULT {
        return self.vtable.IsDirectory(self);
    }
    pub fn GetSize(self: *const IUrlAccessor, pllSize: ?*u64) callconv(.Inline) HRESULT {
        return self.vtable.GetSize(self, pllSize);
    }
    pub fn GetLastModified(self: *const IUrlAccessor, pftLastModified: ?*FILETIME) callconv(.Inline) HRESULT {
        return self.vtable.GetLastModified(self, pftLastModified);
    }
    pub fn GetFileName(self: *const IUrlAccessor, wszFileName: [*:0]u16, dwSize: u32, pdwLength: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetFileName(self, wszFileName, dwSize, pdwLength);
    }
    pub fn GetSecurityDescriptor(self: *const IUrlAccessor, pSD: [*:0]u8, dwSize: u32, pdwLength: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetSecurityDescriptor(self, pSD, dwSize, pdwLength);
    }
    pub fn GetRedirectedURL(self: *const IUrlAccessor, wszRedirectedURL: [*:0]u16, dwSize: u32, pdwLength: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetRedirectedURL(self, wszRedirectedURL, dwSize, pdwLength);
    }
    pub fn GetSecurityProvider(self: *const IUrlAccessor, pSPClsid: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.GetSecurityProvider(self, pSPClsid);
    }
    pub fn BindToStream(self: *const IUrlAccessor, ppStream: ?*?*IStream) callconv(.Inline) HRESULT {
        return self.vtable.BindToStream(self, ppStream);
    }
    pub fn BindToFilter(self: *const IUrlAccessor, ppFilter: ?*?*IFilter) callconv(.Inline) HRESULT {
        return self.vtable.BindToFilter(self, ppFilter);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUrlAccessor2_Value = Guid.initString("c7310734-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_IUrlAccessor2 = &IID_IUrlAccessor2_Value;
pub const IUrlAccessor2 = extern union {
    pub const VTable = extern struct {
        base: IUrlAccessor.VTable,
        GetDisplayUrl: *const fn(
            self: *const IUrlAccessor2,
            wszDocUrl: [*:0]u16,
            dwSize: u32,
            pdwLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDocument: *const fn(
            self: *const IUrlAccessor2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePage: *const fn(
            self: *const IUrlAccessor2,
            wszCodePage: [*:0]u16,
            dwSize: u32,
            pdwLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUrlAccessor: IUrlAccessor,
    IUnknown: IUnknown,
    pub fn GetDisplayUrl(self: *const IUrlAccessor2, wszDocUrl: [*:0]u16, dwSize: u32, pdwLength: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetDisplayUrl(self, wszDocUrl, dwSize, pdwLength);
    }
    pub fn IsDocument(self: *const IUrlAccessor2) callconv(.Inline) HRESULT {
        return self.vtable.IsDocument(self);
    }
    pub fn GetCodePage(self: *const IUrlAccessor2, wszCodePage: [*:0]u16, dwSize: u32, pdwLength: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetCodePage(self, wszCodePage, dwSize, pdwLength);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUrlAccessor3_Value = Guid.initString("6fbc7005-0455-4874-b8ff-7439450241a3");
pub const IID_IUrlAccessor3 = &IID_IUrlAccessor3_Value;
pub const IUrlAccessor3 = extern union {
    pub const VTable = extern struct {
        base: IUrlAccessor2.VTable,
        GetImpersonationSidBlobs: *const fn(
            self: *const IUrlAccessor3,
            pcwszURL: ?[*:0]const u16,
            pcSidCount: ?*u32,
            ppSidBlobs: ?*?*BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUrlAccessor2: IUrlAccessor2,
    IUrlAccessor: IUrlAccessor,
    IUnknown: IUnknown,
    pub fn GetImpersonationSidBlobs(self: *const IUrlAccessor3, pcwszURL: ?[*:0]const u16, pcSidCount: ?*u32, ppSidBlobs: ?*?*BLOB) callconv(.Inline) HRESULT {
        return self.vtable.GetImpersonationSidBlobs(self, pcwszURL, pcSidCount, ppSidBlobs);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUrlAccessor4_Value = Guid.initString("5cc51041-c8d2-41d7-bca3-9e9e286297dc");
pub const IID_IUrlAccessor4 = &IID_IUrlAccessor4_Value;
pub const IUrlAccessor4 = extern union {
    pub const VTable = extern struct {
        base: IUrlAccessor3.VTable,
        ShouldIndexItemContent: *const fn(
            self: *const IUrlAccessor4,
            pfIndexContent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShouldIndexProperty: *const fn(
            self: *const IUrlAccessor4,
            key: ?*const PROPERTYKEY,
            pfIndexProperty: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUrlAccessor3: IUrlAccessor3,
    IUrlAccessor2: IUrlAccessor2,
    IUrlAccessor: IUrlAccessor,
    IUnknown: IUnknown,
    pub fn ShouldIndexItemContent(self: *const IUrlAccessor4, pfIndexContent: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.ShouldIndexItemContent(self, pfIndexContent);
    }
    pub fn ShouldIndexProperty(self: *const IUrlAccessor4, key: ?*const PROPERTYKEY, pfIndexProperty: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.ShouldIndexProperty(self, key, pfIndexProperty);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IOpLockStatus_Value = Guid.initString("c731065d-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_IOpLockStatus = &IID_IOpLockStatus_Value;
pub const IOpLockStatus = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsOplockValid: *const fn(
            self: *const IOpLockStatus,
            pfIsOplockValid: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsOplockBroken: *const fn(
            self: *const IOpLockStatus,
            pfIsOplockBroken: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOplockEventHandle: *const fn(
            self: *const IOpLockStatus,
            phOplockEv: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn IsOplockValid(self: *const IOpLockStatus, pfIsOplockValid: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.IsOplockValid(self, pfIsOplockValid);
    }
    pub fn IsOplockBroken(self: *const IOpLockStatus, pfIsOplockBroken: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.IsOplockBroken(self, pfIsOplockBroken);
    }
    pub fn GetOplockEventHandle(self: *const IOpLockStatus, phOplockEv: ?*?HANDLE) callconv(.Inline) HRESULT {
        return self.vtable.GetOplockEventHandle(self, phOplockEv);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchProtocolThreadContext_Value = Guid.initString("c73106e1-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_ISearchProtocolThreadContext = &IID_ISearchProtocolThreadContext_Value;
pub const ISearchProtocolThreadContext = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadInit: *const fn(
            self: *const ISearchProtocolThreadContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ThreadShutdown: *const fn(
            self: *const ISearchProtocolThreadContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ThreadIdle: *const fn(
            self: *const ISearchProtocolThreadContext,
            dwTimeElaspedSinceLastCallInMS: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn ThreadInit(self: *const ISearchProtocolThreadContext) callconv(.Inline) HRESULT {
        return self.vtable.ThreadInit(self);
    }
    pub fn ThreadShutdown(self: *const ISearchProtocolThreadContext) callconv(.Inline) HRESULT {
        return self.vtable.ThreadShutdown(self);
    }
    pub fn ThreadIdle(self: *const ISearchProtocolThreadContext, dwTimeElaspedSinceLastCallInMS: u32) callconv(.Inline) HRESULT {
        return self.vtable.ThreadIdle(self, dwTimeElaspedSinceLastCallInMS);
    }
};

pub const TIMEOUT_INFO = extern struct {
    dwSize: u32,
    dwConnectTimeout: u32,
    dwDataTimeout: u32,
};

pub const PROXY_ACCESS = enum(i32) {
    PRECONFIG = 0,
    DIRECT = 1,
    PROXY = 2,
};
pub const PROXY_ACCESS_PRECONFIG = PROXY_ACCESS.PRECONFIG;
pub const PROXY_ACCESS_DIRECT = PROXY_ACCESS.DIRECT;
pub const PROXY_ACCESS_PROXY = PROXY_ACCESS.PROXY;

pub const PROXY_INFO = extern struct {
    dwSize: u32,
    pcwszUserAgent: ?[*:0]const u16,
    paUseProxy: PROXY_ACCESS,
    fLocalBypass: BOOL,
    dwPortNumber: u32,
    pcwszProxyName: ?[*:0]const u16,
    pcwszBypassList: ?[*:0]const u16,
};

pub const AUTH_TYPE = enum(i32) {
    ANONYMOUS = 0,
    NTLM = 1,
    BASIC = 2,
};
pub const eAUTH_TYPE_ANONYMOUS = AUTH_TYPE.ANONYMOUS;
pub const eAUTH_TYPE_NTLM = AUTH_TYPE.NTLM;
pub const eAUTH_TYPE_BASIC = AUTH_TYPE.BASIC;

pub const AUTHENTICATION_INFO = extern struct {
    dwSize: u32,
    atAuthenticationType: AUTH_TYPE,
    pcwszUser: ?[*:0]const u16,
    pcwszPassword: ?[*:0]const u16,
};

pub const INCREMENTAL_ACCESS_INFO = extern struct {
    dwSize: u32,
    ftLastModifiedTime: FILETIME,
};

pub const ITEM_INFO = extern struct {
    dwSize: u32,
    pcwszFromEMail: ?[*:0]const u16,
    pcwszApplicationName: ?[*:0]const u16,
    pcwszCatalogName: ?[*:0]const u16,
    pcwszContentClass: ?[*:0]const u16,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchProtocol_Value = Guid.initString("c73106ba-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_ISearchProtocol = &IID_ISearchProtocol_Value;
pub const ISearchProtocol = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn(
            self: *const ISearchProtocol,
            pTimeoutInfo: ?*TIMEOUT_INFO,
            pProtocolHandlerSite: ?*IProtocolHandlerSite,
            pProxyInfo: ?*PROXY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAccessor: *const fn(
            self: *const ISearchProtocol,
            pcwszURL: ?[*:0]const u16,
            pAuthenticationInfo: ?*AUTHENTICATION_INFO,
            pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO,
            pItemInfo: ?*ITEM_INFO,
            ppAccessor: ?*?*IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseAccessor: *const fn(
            self: *const ISearchProtocol,
            pAccessor: ?*IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShutDown: *const fn(
            self: *const ISearchProtocol,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Init(self: *const ISearchProtocol, pTimeoutInfo: ?*TIMEOUT_INFO, pProtocolHandlerSite: ?*IProtocolHandlerSite, pProxyInfo: ?*PROXY_INFO) callconv(.Inline) HRESULT {
        return self.vtable.Init(self, pTimeoutInfo, pProtocolHandlerSite, pProxyInfo);
    }
    pub fn CreateAccessor(self: *const ISearchProtocol, pcwszURL: ?[*:0]const u16, pAuthenticationInfo: ?*AUTHENTICATION_INFO, pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO, pItemInfo: ?*ITEM_INFO, ppAccessor: ?*?*IUrlAccessor) callconv(.Inline) HRESULT {
        return self.vtable.CreateAccessor(self, pcwszURL, pAuthenticationInfo, pIncrementalAccessInfo, pItemInfo, ppAccessor);
    }
    pub fn CloseAccessor(self: *const ISearchProtocol, pAccessor: ?*IUrlAccessor) callconv(.Inline) HRESULT {
        return self.vtable.CloseAccessor(self, pAccessor);
    }
    pub fn ShutDown(self: *const ISearchProtocol) callconv(.Inline) HRESULT {
        return self.vtable.ShutDown(self);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchProtocol2_Value = Guid.initString("7789f0b2-b5b2-4722-8b65-5dbd150697a9");
pub const IID_ISearchProtocol2 = &IID_ISearchProtocol2_Value;
pub const ISearchProtocol2 = extern union {
    pub const VTable = extern struct {
        base: ISearchProtocol.VTable,
        CreateAccessorEx: *const fn(
            self: *const ISearchProtocol2,
            pcwszURL: ?[*:0]const u16,
            pAuthenticationInfo: ?*AUTHENTICATION_INFO,
            pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO,
            pItemInfo: ?*ITEM_INFO,
            pUserData: ?*const BLOB,
            ppAccessor: ?*?*IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ISearchProtocol: ISearchProtocol,
    IUnknown: IUnknown,
    pub fn CreateAccessorEx(self: *const ISearchProtocol2, pcwszURL: ?[*:0]const u16, pAuthenticationInfo: ?*AUTHENTICATION_INFO, pIncrementalAccessInfo: ?*INCREMENTAL_ACCESS_INFO, pItemInfo: ?*ITEM_INFO, pUserData: ?*const BLOB, ppAccessor: ?*?*IUrlAccessor) callconv(.Inline) HRESULT {
        return self.vtable.CreateAccessorEx(self, pcwszURL, pAuthenticationInfo, pIncrementalAccessInfo, pItemInfo, pUserData, ppAccessor);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IProtocolHandlerSite_Value = Guid.initString("0b63e385-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IProtocolHandlerSite = &IID_IProtocolHandlerSite_Value;
pub const IProtocolHandlerSite = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilter: *const fn(
            self: *const IProtocolHandlerSite,
            pclsidObj: ?*Guid,
            pcwszContentType: ?[*:0]const u16,
            pcwszExtension: ?[*:0]const u16,
            ppFilter: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetFilter(self: *const IProtocolHandlerSite, pclsidObj: ?*Guid, pcwszContentType: ?[*:0]const u16, pcwszExtension: ?[*:0]const u16, ppFilter: ?*?*IFilter) callconv(.Inline) HRESULT {
        return self.vtable.GetFilter(self, pclsidObj, pcwszContentType, pcwszExtension, ppFilter);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchRoot_Value = Guid.initString("04c18ccf-1f57-4cbd-88cc-3900f5195ce3");
pub const IID_ISearchRoot = &IID_ISearchRoot_Value;
pub const ISearchRoot = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Schedule: *const fn(
            self: *const ISearchRoot,
            pszTaskArg: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Schedule: *const fn(
            self: *const ISearchRoot,
            ppszTaskArg: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootURL: *const fn(
            self: *const ISearchRoot,
            pszURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootURL: *const fn(
            self: *const ISearchRoot,
            ppszURL: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsHierarchical: *const fn(
            self: *const ISearchRoot,
            fIsHierarchical: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsHierarchical: *const fn(
            self: *const ISearchRoot,
            pfIsHierarchical: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProvidesNotifications: *const fn(
            self: *const ISearchRoot,
            fProvidesNotifications: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProvidesNotifications: *const fn(
            self: *const ISearchRoot,
            pfProvidesNotifications: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseNotificationsOnly: *const fn(
            self: *const ISearchRoot,
            fUseNotificationsOnly: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseNotificationsOnly: *const fn(
            self: *const ISearchRoot,
            pfUseNotificationsOnly: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnumerationDepth: *const fn(
            self: *const ISearchRoot,
            dwDepth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumerationDepth: *const fn(
            self: *const ISearchRoot,
            pdwDepth: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HostDepth: *const fn(
            self: *const ISearchRoot,
            dwDepth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HostDepth: *const fn(
            self: *const ISearchRoot,
            pdwDepth: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FollowDirectories: *const fn(
            self: *const ISearchRoot,
            fFollowDirectories: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FollowDirectories: *const fn(
            self: *const ISearchRoot,
            pfFollowDirectories: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AuthenticationType: *const fn(
            self: *const ISearchRoot,
            authType: AUTH_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthenticationType: *const fn(
            self: *const ISearchRoot,
            pAuthType: ?*AUTH_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_User: *const fn(
            self: *const ISearchRoot,
            pszUser: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_User: *const fn(
            self: *const ISearchRoot,
            ppszUser: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Password: *const fn(
            self: *const ISearchRoot,
            pszPassword: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Password: *const fn(
            self: *const ISearchRoot,
            ppszPassword: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn put_Schedule(self: *const ISearchRoot, pszTaskArg: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.put_Schedule(self, pszTaskArg);
    }
    pub fn get_Schedule(self: *const ISearchRoot, ppszTaskArg: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Schedule(self, ppszTaskArg);
    }
    pub fn put_RootURL(self: *const ISearchRoot, pszURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.put_RootURL(self, pszURL);
    }
    pub fn get_RootURL(self: *const ISearchRoot, ppszURL: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_RootURL(self, ppszURL);
    }
    pub fn put_IsHierarchical(self: *const ISearchRoot, fIsHierarchical: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.put_IsHierarchical(self, fIsHierarchical);
    }
    pub fn get_IsHierarchical(self: *const ISearchRoot, pfIsHierarchical: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsHierarchical(self, pfIsHierarchical);
    }
    pub fn put_ProvidesNotifications(self: *const ISearchRoot, fProvidesNotifications: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.put_ProvidesNotifications(self, fProvidesNotifications);
    }
    pub fn get_ProvidesNotifications(self: *const ISearchRoot, pfProvidesNotifications: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_ProvidesNotifications(self, pfProvidesNotifications);
    }
    pub fn put_UseNotificationsOnly(self: *const ISearchRoot, fUseNotificationsOnly: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.put_UseNotificationsOnly(self, fUseNotificationsOnly);
    }
    pub fn get_UseNotificationsOnly(self: *const ISearchRoot, pfUseNotificationsOnly: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_UseNotificationsOnly(self, pfUseNotificationsOnly);
    }
    pub fn put_EnumerationDepth(self: *const ISearchRoot, dwDepth: u32) callconv(.Inline) HRESULT {
        return self.vtable.put_EnumerationDepth(self, dwDepth);
    }
    pub fn get_EnumerationDepth(self: *const ISearchRoot, pdwDepth: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_EnumerationDepth(self, pdwDepth);
    }
    pub fn put_HostDepth(self: *const ISearchRoot, dwDepth: u32) callconv(.Inline) HRESULT {
        return self.vtable.put_HostDepth(self, dwDepth);
    }
    pub fn get_HostDepth(self: *const ISearchRoot, pdwDepth: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_HostDepth(self, pdwDepth);
    }
    pub fn put_FollowDirectories(self: *const ISearchRoot, fFollowDirectories: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.put_FollowDirectories(self, fFollowDirectories);
    }
    pub fn get_FollowDirectories(self: *const ISearchRoot, pfFollowDirectories: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_FollowDirectories(self, pfFollowDirectories);
    }
    pub fn put_AuthenticationType(self: *const ISearchRoot, authType: AUTH_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.put_AuthenticationType(self, authType);
    }
    pub fn get_AuthenticationType(self: *const ISearchRoot, pAuthType: ?*AUTH_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.get_AuthenticationType(self, pAuthType);
    }
    pub fn put_User(self: *const ISearchRoot, pszUser: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.put_User(self, pszUser);
    }
    pub fn get_User(self: *const ISearchRoot, ppszUser: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_User(self, ppszUser);
    }
    pub fn put_Password(self: *const ISearchRoot, pszPassword: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.put_Password(self, pszPassword);
    }
    pub fn get_Password(self: *const ISearchRoot, ppszPassword: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Password(self, ppszPassword);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumSearchRoots_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef52");
pub const IID_IEnumSearchRoots = &IID_IEnumSearchRoots_Value;
pub const IEnumSearchRoots = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn(
            self: *const IEnumSearchRoots,
            celt: u32,
            rgelt: [*]?*ISearchRoot,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn(
            self: *const IEnumSearchRoots,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn(
            self: *const IEnumSearchRoots,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn(
            self: *const IEnumSearchRoots,
            ppenum: ?*?*IEnumSearchRoots,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Next(self: *const IEnumSearchRoots, celt: u32, rgelt: [*]?*ISearchRoot, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Next(self, celt, rgelt, pceltFetched);
    }
    pub fn Skip(self: *const IEnumSearchRoots, celt: u32) callconv(.Inline) HRESULT {
        return self.vtable.Skip(self, celt);
    }
    pub fn Reset(self: *const IEnumSearchRoots) callconv(.Inline) HRESULT {
        return self.vtable.Reset(self);
    }
    pub fn Clone(self: *const IEnumSearchRoots, ppenum: ?*?*IEnumSearchRoots) callconv(.Inline) HRESULT {
        return self.vtable.Clone(self, ppenum);
    }
};

pub const FOLLOW_FLAGS = enum(i32) {
    INDEXCOMPLEXURLS = 1,
    SUPPRESSINDEXING = 2,
};
pub const FF_INDEXCOMPLEXURLS = FOLLOW_FLAGS.INDEXCOMPLEXURLS;
pub const FF_SUPPRESSINDEXING = FOLLOW_FLAGS.SUPPRESSINDEXING;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchScopeRule_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef53");
pub const IID_ISearchScopeRule = &IID_ISearchScopeRule_Value;
pub const ISearchScopeRule = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PatternOrURL: *const fn(
            self: *const ISearchScopeRule,
            ppszPatternOrURL: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsIncluded: *const fn(
            self: *const ISearchScopeRule,
            pfIsIncluded: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDefault: *const fn(
            self: *const ISearchScopeRule,
            pfIsDefault: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FollowFlags: *const fn(
            self: *const ISearchScopeRule,
            pFollowFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_PatternOrURL(self: *const ISearchScopeRule, ppszPatternOrURL: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_PatternOrURL(self, ppszPatternOrURL);
    }
    pub fn get_IsIncluded(self: *const ISearchScopeRule, pfIsIncluded: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsIncluded(self, pfIsIncluded);
    }
    pub fn get_IsDefault(self: *const ISearchScopeRule, pfIsDefault: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsDefault(self, pfIsDefault);
    }
    pub fn get_FollowFlags(self: *const ISearchScopeRule, pFollowFlags: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_FollowFlags(self, pFollowFlags);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumSearchScopeRules_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef54");
pub const IID_IEnumSearchScopeRules = &IID_IEnumSearchScopeRules_Value;
pub const IEnumSearchScopeRules = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn(
            self: *const IEnumSearchScopeRules,
            celt: u32,
            pprgelt: [*]?*ISearchScopeRule,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn(
            self: *const IEnumSearchScopeRules,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn(
            self: *const IEnumSearchScopeRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn(
            self: *const IEnumSearchScopeRules,
            ppenum: ?*?*IEnumSearchScopeRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Next(self: *const IEnumSearchScopeRules, celt: u32, pprgelt: [*]?*ISearchScopeRule, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Next(self, celt, pprgelt, pceltFetched);
    }
    pub fn Skip(self: *const IEnumSearchScopeRules, celt: u32) callconv(.Inline) HRESULT {
        return self.vtable.Skip(self, celt);
    }
    pub fn Reset(self: *const IEnumSearchScopeRules) callconv(.Inline) HRESULT {
        return self.vtable.Reset(self);
    }
    pub fn Clone(self: *const IEnumSearchScopeRules, ppenum: ?*?*IEnumSearchScopeRules) callconv(.Inline) HRESULT {
        return self.vtable.Clone(self, ppenum);
    }
};

pub const CLUSION_REASON = enum(i32) {
    UNKNOWNSCOPE = 0,
    DEFAULT = 1,
    USER = 2,
    GROUPPOLICY = 3,
};
pub const CLUSIONREASON_UNKNOWNSCOPE = CLUSION_REASON.UNKNOWNSCOPE;
pub const CLUSIONREASON_DEFAULT = CLUSION_REASON.DEFAULT;
pub const CLUSIONREASON_USER = CLUSION_REASON.USER;
pub const CLUSIONREASON_GROUPPOLICY = CLUSION_REASON.GROUPPOLICY;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCrawlScopeManager_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef55");
pub const IID_ISearchCrawlScopeManager = &IID_ISearchCrawlScopeManager_Value;
pub const ISearchCrawlScopeManager = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDefaultScopeRule: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
            fInclude: BOOL,
            fFollowFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRoot: *const fn(
            self: *const ISearchCrawlScopeManager,
            pSearchRoot: ?*ISearchRoot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveRoot: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateRoots: *const fn(
            self: *const ISearchCrawlScopeManager,
            ppSearchRoots: ?*?*IEnumSearchRoots,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddHierarchicalScope: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
            fInclude: BOOL,
            fDefault: BOOL,
            fOverrideChildren: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUserScopeRule: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
            fInclude: BOOL,
            fOverrideChildren: BOOL,
            fFollowFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveScopeRule: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszRule: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateScopeRules: *const fn(
            self: *const ISearchCrawlScopeManager,
            ppSearchScopeRules: ?*?*IEnumSearchScopeRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasParentScopeRule: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
            pfHasParentRule: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasChildScopeRule: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
            pfHasChildRule: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IncludedInCrawlScope: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
            pfIsIncluded: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IncludedInCrawlScopeEx: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
            pfIsIncluded: ?*BOOL,
            pReason: ?*CLUSION_REASON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevertToDefaultScopes: *const fn(
            self: *const ISearchCrawlScopeManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAll: *const fn(
            self: *const ISearchCrawlScopeManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentScopeVersionId: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
            plScopeId: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveDefaultScopeRule: *const fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn AddDefaultScopeRule(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16, fInclude: BOOL, fFollowFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.AddDefaultScopeRule(self, pszURL, fInclude, fFollowFlags);
    }
    pub fn AddRoot(self: *const ISearchCrawlScopeManager, pSearchRoot: ?*ISearchRoot) callconv(.Inline) HRESULT {
        return self.vtable.AddRoot(self, pSearchRoot);
    }
    pub fn RemoveRoot(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.RemoveRoot(self, pszURL);
    }
    pub fn EnumerateRoots(self: *const ISearchCrawlScopeManager, ppSearchRoots: ?*?*IEnumSearchRoots) callconv(.Inline) HRESULT {
        return self.vtable.EnumerateRoots(self, ppSearchRoots);
    }
    pub fn AddHierarchicalScope(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16, fInclude: BOOL, fDefault: BOOL, fOverrideChildren: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.AddHierarchicalScope(self, pszURL, fInclude, fDefault, fOverrideChildren);
    }
    pub fn AddUserScopeRule(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16, fInclude: BOOL, fOverrideChildren: BOOL, fFollowFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.AddUserScopeRule(self, pszURL, fInclude, fOverrideChildren, fFollowFlags);
    }
    pub fn RemoveScopeRule(self: *const ISearchCrawlScopeManager, pszRule: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.RemoveScopeRule(self, pszRule);
    }
    pub fn EnumerateScopeRules(self: *const ISearchCrawlScopeManager, ppSearchScopeRules: ?*?*IEnumSearchScopeRules) callconv(.Inline) HRESULT {
        return self.vtable.EnumerateScopeRules(self, ppSearchScopeRules);
    }
    pub fn HasParentScopeRule(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16, pfHasParentRule: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.HasParentScopeRule(self, pszURL, pfHasParentRule);
    }
    pub fn HasChildScopeRule(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16, pfHasChildRule: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.HasChildScopeRule(self, pszURL, pfHasChildRule);
    }
    pub fn IncludedInCrawlScope(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16, pfIsIncluded: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.IncludedInCrawlScope(self, pszURL, pfIsIncluded);
    }
    pub fn IncludedInCrawlScopeEx(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16, pfIsIncluded: ?*BOOL, pReason: ?*CLUSION_REASON) callconv(.Inline) HRESULT {
        return self.vtable.IncludedInCrawlScopeEx(self, pszURL, pfIsIncluded, pReason);
    }
    pub fn RevertToDefaultScopes(self: *const ISearchCrawlScopeManager) callconv(.Inline) HRESULT {
        return self.vtable.RevertToDefaultScopes(self);
    }
    pub fn SaveAll(self: *const ISearchCrawlScopeManager) callconv(.Inline) HRESULT {
        return self.vtable.SaveAll(self);
    }
    pub fn GetParentScopeVersionId(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16, plScopeId: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.GetParentScopeVersionId(self, pszURL, plScopeId);
    }
    pub fn RemoveDefaultScopeRule(self: *const ISearchCrawlScopeManager, pszURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.RemoveDefaultScopeRule(self, pszURL);
    }
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISearchCrawlScopeManager2_Value = Guid.initString("6292f7ad-4e19-4717-a534-8fc22bcd5ccd");
pub const IID_ISearchCrawlScopeManager2 = &IID_ISearchCrawlScopeManager2_Value;
pub const ISearchCrawlScopeManager2 = extern union {
    pub const VTable = extern struct {
        base: ISearchCrawlScopeManager.VTable,
        GetVersion: *const fn(
            self: *const ISearchCrawlScopeManager2,
            plVersion: ?*?*i32,
            phFileMapping: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ISearchCrawlScopeManager: ISearchCrawlScopeManager,
    IUnknown: IUnknown,
    pub fn GetVersion(self: *const ISearchCrawlScopeManager2, plVersion: ?*?*i32, phFileMapping: ?*?HANDLE) callconv(.Inline) HRESULT {
        return self.vtable.GetVersion(self, plVersion, phFileMapping);
    }
};

pub const SEARCH_KIND_OF_CHANGE = enum(i32) {
    ADD = 0,
    DELETE = 1,
    MODIFY = 2,
    MOVE_RENAME = 3,
    SEMANTICS_DIRECTORY = 262144,
    SEMANTICS_SHALLOW = 524288,
    SEMANTICS_UPDATE_SECURITY = 4194304,
};
pub const SEARCH_CHANGE_ADD = SEARCH_KIND_OF_CHANGE.ADD;
pub const SEARCH_CHANGE_DELETE = SEARCH_KIND_OF_CHANGE.DELETE;
pub const SEARCH_CHANGE_MODIFY = SEARCH_KIND_OF_CHANGE.MODIFY;
pub const SEARCH_CHANGE_MOVE_RENAME = SEARCH_KIND_OF_CHANGE.MOVE_RENAME;
pub const SEARCH_CHANGE_SEMANTICS_DIRECTORY = SEARCH_KIND_OF_CHANGE.SEMANTICS_DIRECTORY;
pub const SEARCH_CHANGE_SEMANTICS_SHALLOW = SEARCH_KIND_OF_CHANGE.SEMANTICS_SHALLOW;
pub const SEARCH_CHANGE_SEMANTICS_UPDATE_SECURITY = SEARCH_KIND_OF_CHANGE.SEMANTICS_UPDATE_SECURITY;

pub const SEARCH_NOTIFICATION_PRIORITY = enum(i32) {
    NORMAL_PRIORITY = 0,
    HIGH_PRIORITY = 1,
};
pub const SEARCH_NORMAL_PRIORITY = SEARCH_NOTIFICATION_PRIORITY.NORMAL_PRIORITY;
pub const SEARCH_HIGH_PRIORITY = SEARCH_NOTIFICATION_PRIORITY.HIGH_PRIORITY;

pub const SEARCH_ITEM_CHANGE = extern struct {
    Change: SEARCH_KIND_OF_CHANGE,
    Priority: SEARCH_NOTIFICATION_PRIORITY,
    pUserData: ?*BLOB,
    lpwszURL: ?PWSTR,
    lpwszOldURL: ?PWSTR,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchItemsChangedSink_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef58");
pub const IID_ISearchItemsChangedSink = &IID_ISearchItemsChangedSink_Value;
pub const ISearchItemsChangedSink = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartedMonitoringScope: *const fn(
            self: *const ISearchItemsChangedSink,
            pszURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoppedMonitoringScope: *const fn(
            self: *const ISearchItemsChangedSink,
            pszURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemsChanged: *const fn(
            self: *const ISearchItemsChangedSink,
            dwNumberOfChanges: u32,
            rgDataChangeEntries: [*]SEARCH_ITEM_CHANGE,
            rgdwDocIds: [*]u32,
            rghrCompletionCodes: [*]HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn StartedMonitoringScope(self: *const ISearchItemsChangedSink, pszURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.StartedMonitoringScope(self, pszURL);
    }
    pub fn StoppedMonitoringScope(self: *const ISearchItemsChangedSink, pszURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.StoppedMonitoringScope(self, pszURL);
    }
    pub fn OnItemsChanged(self: *const ISearchItemsChangedSink, dwNumberOfChanges: u32, rgDataChangeEntries: [*]SEARCH_ITEM_CHANGE, rgdwDocIds: [*]u32, rghrCompletionCodes: [*]HRESULT) callconv(.Inline) HRESULT {
        return self.vtable.OnItemsChanged(self, dwNumberOfChanges, rgDataChangeEntries, rgdwDocIds, rghrCompletionCodes);
    }
};

pub const SEARCH_ITEM_PERSISTENT_CHANGE = extern struct {
    Change: SEARCH_KIND_OF_CHANGE,
    URL: ?PWSTR,
    OldURL: ?PWSTR,
    Priority: SEARCH_NOTIFICATION_PRIORITY,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchPersistentItemsChangedSink_Value = Guid.initString("a2ffdf9b-4758-4f84-b729-df81a1a0612f");
pub const IID_ISearchPersistentItemsChangedSink = &IID_ISearchPersistentItemsChangedSink_Value;
pub const ISearchPersistentItemsChangedSink = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartedMonitoringScope: *const fn(
            self: *const ISearchPersistentItemsChangedSink,
            pszURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoppedMonitoringScope: *const fn(
            self: *const ISearchPersistentItemsChangedSink,
            pszURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemsChanged: *const fn(
            self: *const ISearchPersistentItemsChangedSink,
            dwNumberOfChanges: u32,
            DataChangeEntries: [*]SEARCH_ITEM_PERSISTENT_CHANGE,
            hrCompletionCodes: [*]HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn StartedMonitoringScope(self: *const ISearchPersistentItemsChangedSink, pszURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.StartedMonitoringScope(self, pszURL);
    }
    pub fn StoppedMonitoringScope(self: *const ISearchPersistentItemsChangedSink, pszURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.StoppedMonitoringScope(self, pszURL);
    }
    pub fn OnItemsChanged(self: *const ISearchPersistentItemsChangedSink, dwNumberOfChanges: u32, DataChangeEntries: [*]SEARCH_ITEM_PERSISTENT_CHANGE, hrCompletionCodes: [*]HRESULT) callconv(.Inline) HRESULT {
        return self.vtable.OnItemsChanged(self, dwNumberOfChanges, DataChangeEntries, hrCompletionCodes);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchViewChangedSink_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef65");
pub const IID_ISearchViewChangedSink = &IID_ISearchViewChangedSink_Value;
pub const ISearchViewChangedSink = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: *const fn(
            self: *const ISearchViewChangedSink,
            pdwDocID: ?*i32,
            pChange: ?*SEARCH_ITEM_CHANGE,
            pfInView: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OnChange(self: *const ISearchViewChangedSink, pdwDocID: ?*i32, pChange: ?*SEARCH_ITEM_CHANGE, pfInView: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.OnChange(self, pdwDocID, pChange, pfInView);
    }
};

pub const SEARCH_INDEXING_PHASE = enum(i32) {
    GATHERER = 0,
    QUERYABLE = 1,
    PERSISTED = 2,
};
pub const SEARCH_INDEXING_PHASE_GATHERER = SEARCH_INDEXING_PHASE.GATHERER;
pub const SEARCH_INDEXING_PHASE_QUERYABLE = SEARCH_INDEXING_PHASE.QUERYABLE;
pub const SEARCH_INDEXING_PHASE_PERSISTED = SEARCH_INDEXING_PHASE.PERSISTED;

pub const SEARCH_ITEM_INDEXING_STATUS = extern struct {
    dwDocID: u32,
    hrIndexingStatus: HRESULT,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchNotifyInlineSite_Value = Guid.initString("b5702e61-e75c-4b64-82a1-6cb4f832fccf");
pub const IID_ISearchNotifyInlineSite = &IID_ISearchNotifyInlineSite_Value;
pub const ISearchNotifyInlineSite = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnItemIndexedStatusChange: *const fn(
            self: *const ISearchNotifyInlineSite,
            sipStatus: SEARCH_INDEXING_PHASE,
            dwNumEntries: u32,
            rgItemStatusEntries: [*]SEARCH_ITEM_INDEXING_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCatalogStatusChange: *const fn(
            self: *const ISearchNotifyInlineSite,
            guidCatalogResetSignature: ?*const Guid,
            guidCheckPointSignature: ?*const Guid,
            dwLastCheckPointNumber: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OnItemIndexedStatusChange(self: *const ISearchNotifyInlineSite, sipStatus: SEARCH_INDEXING_PHASE, dwNumEntries: u32, rgItemStatusEntries: [*]SEARCH_ITEM_INDEXING_STATUS) callconv(.Inline) HRESULT {
        return self.vtable.OnItemIndexedStatusChange(self, sipStatus, dwNumEntries, rgItemStatusEntries);
    }
    pub fn OnCatalogStatusChange(self: *const ISearchNotifyInlineSite, guidCatalogResetSignature: ?*const Guid, guidCheckPointSignature: ?*const Guid, dwLastCheckPointNumber: u32) callconv(.Inline) HRESULT {
        return self.vtable.OnCatalogStatusChange(self, guidCatalogResetSignature, guidCheckPointSignature, dwLastCheckPointNumber);
    }
};

pub const CatalogStatus = enum(i32) {
    IDLE = 0,
    PAUSED = 1,
    RECOVERING = 2,
    FULL_CRAWL = 3,
    INCREMENTAL_CRAWL = 4,
    PROCESSING_NOTIFICATIONS = 5,
    SHUTTING_DOWN = 6,
};
pub const CATALOG_STATUS_IDLE = CatalogStatus.IDLE;
pub const CATALOG_STATUS_PAUSED = CatalogStatus.PAUSED;
pub const CATALOG_STATUS_RECOVERING = CatalogStatus.RECOVERING;
pub const CATALOG_STATUS_FULL_CRAWL = CatalogStatus.FULL_CRAWL;
pub const CATALOG_STATUS_INCREMENTAL_CRAWL = CatalogStatus.INCREMENTAL_CRAWL;
pub const CATALOG_STATUS_PROCESSING_NOTIFICATIONS = CatalogStatus.PROCESSING_NOTIFICATIONS;
pub const CATALOG_STATUS_SHUTTING_DOWN = CatalogStatus.SHUTTING_DOWN;

pub const CatalogPausedReason = enum(i32) {
    NONE = 0,
    HIGH_IO = 1,
    HIGH_CPU = 2,
    HIGH_NTF_RATE = 3,
    LOW_BATTERY = 4,
    LOW_MEMORY = 5,
    LOW_DISK = 6,
    DELAYED_RECOVERY = 7,
    USER_ACTIVE = 8,
    EXTERNAL = 9,
    UPGRADING = 10,
};
pub const CATALOG_PAUSED_REASON_NONE = CatalogPausedReason.NONE;
pub const CATALOG_PAUSED_REASON_HIGH_IO = CatalogPausedReason.HIGH_IO;
pub const CATALOG_PAUSED_REASON_HIGH_CPU = CatalogPausedReason.HIGH_CPU;
pub const CATALOG_PAUSED_REASON_HIGH_NTF_RATE = CatalogPausedReason.HIGH_NTF_RATE;
pub const CATALOG_PAUSED_REASON_LOW_BATTERY = CatalogPausedReason.LOW_BATTERY;
pub const CATALOG_PAUSED_REASON_LOW_MEMORY = CatalogPausedReason.LOW_MEMORY;
pub const CATALOG_PAUSED_REASON_LOW_DISK = CatalogPausedReason.LOW_DISK;
pub const CATALOG_PAUSED_REASON_DELAYED_RECOVERY = CatalogPausedReason.DELAYED_RECOVERY;
pub const CATALOG_PAUSED_REASON_USER_ACTIVE = CatalogPausedReason.USER_ACTIVE;
pub const CATALOG_PAUSED_REASON_EXTERNAL = CatalogPausedReason.EXTERNAL;
pub const CATALOG_PAUSED_REASON_UPGRADING = CatalogPausedReason.UPGRADING;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCatalogManager_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef50");
pub const IID_ISearchCatalogManager = &IID_ISearchCatalogManager_Value;
pub const ISearchCatalogManager = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn(
            self: *const ISearchCatalogManager,
            pszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameter: *const fn(
            self: *const ISearchCatalogManager,
            pszName: ?[*:0]const u16,
            ppValue: ?*?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameter: *const fn(
            self: *const ISearchCatalogManager,
            pszName: ?[*:0]const u16,
            pValue: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCatalogStatus: *const fn(
            self: *const ISearchCatalogManager,
            pStatus: ?*CatalogStatus,
            pPausedReason: ?*CatalogPausedReason,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn(
            self: *const ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reindex: *const fn(
            self: *const ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReindexMatchingURLs: *const fn(
            self: *const ISearchCatalogManager,
            pszPattern: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReindexSearchRoot: *const fn(
            self: *const ISearchCatalogManager,
            pszRootURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectTimeout: *const fn(
            self: *const ISearchCatalogManager,
            dwConnectTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectTimeout: *const fn(
            self: *const ISearchCatalogManager,
            pdwConnectTimeout: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DataTimeout: *const fn(
            self: *const ISearchCatalogManager,
            dwDataTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataTimeout: *const fn(
            self: *const ISearchCatalogManager,
            pdwDataTimeout: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NumberOfItems: *const fn(
            self: *const ISearchCatalogManager,
            plCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NumberOfItemsToIndex: *const fn(
            self: *const ISearchCatalogManager,
            plIncrementalCount: ?*i32,
            plNotificationQueue: ?*i32,
            plHighPriorityQueue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        URLBeingIndexed: *const fn(
            self: *const ISearchCatalogManager,
            pszUrl: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURLIndexingState: *const fn(
            self: *const ISearchCatalogManager,
            pszURL: ?[*:0]const u16,
            pdwState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPersistentItemsChangedSink: *const fn(
            self: *const ISearchCatalogManager,
            ppISearchPersistentItemsChangedSink: ?*?*ISearchPersistentItemsChangedSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterViewForNotification: *const fn(
            self: *const ISearchCatalogManager,
            pszView: ?[*:0]const u16,
            pViewChangedSink: ?*ISearchViewChangedSink,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemsChangedSink: *const fn(
            self: *const ISearchCatalogManager,
            pISearchNotifyInlineSite: ?*ISearchNotifyInlineSite,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
            pGUIDCatalogResetSignature: ?*Guid,
            pGUIDCheckPointSignature: ?*Guid,
            pdwLastCheckPointNumber: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterViewForNotification: *const fn(
            self: *const ISearchCatalogManager,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExtensionClusion: *const fn(
            self: *const ISearchCatalogManager,
            pszExtension: ?[*:0]const u16,
            fExclude: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateExcludedExtensions: *const fn(
            self: *const ISearchCatalogManager,
            ppExtensions: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQueryHelper: *const fn(
            self: *const ISearchCatalogManager,
            ppSearchQueryHelper: ?*?*ISearchQueryHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiacriticSensitivity: *const fn(
            self: *const ISearchCatalogManager,
            fDiacriticSensitive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiacriticSensitivity: *const fn(
            self: *const ISearchCatalogManager,
            pfDiacriticSensitive: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCrawlScopeManager: *const fn(
            self: *const ISearchCatalogManager,
            ppCrawlScopeManager: ?*?*ISearchCrawlScopeManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Name(self: *const ISearchCatalogManager, pszName: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Name(self, pszName);
    }
    pub fn GetParameter(self: *const ISearchCatalogManager, pszName: ?[*:0]const u16, ppValue: ?*?*PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetParameter(self, pszName, ppValue);
    }
    pub fn SetParameter(self: *const ISearchCatalogManager, pszName: ?[*:0]const u16, pValue: ?*PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.SetParameter(self, pszName, pValue);
    }
    pub fn GetCatalogStatus(self: *const ISearchCatalogManager, pStatus: ?*CatalogStatus, pPausedReason: ?*CatalogPausedReason) callconv(.Inline) HRESULT {
        return self.vtable.GetCatalogStatus(self, pStatus, pPausedReason);
    }
    pub fn Reset(self: *const ISearchCatalogManager) callconv(.Inline) HRESULT {
        return self.vtable.Reset(self);
    }
    pub fn Reindex(self: *const ISearchCatalogManager) callconv(.Inline) HRESULT {
        return self.vtable.Reindex(self);
    }
    pub fn ReindexMatchingURLs(self: *const ISearchCatalogManager, pszPattern: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.ReindexMatchingURLs(self, pszPattern);
    }
    pub fn ReindexSearchRoot(self: *const ISearchCatalogManager, pszRootURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.ReindexSearchRoot(self, pszRootURL);
    }
    pub fn put_ConnectTimeout(self: *const ISearchCatalogManager, dwConnectTimeout: u32) callconv(.Inline) HRESULT {
        return self.vtable.put_ConnectTimeout(self, dwConnectTimeout);
    }
    pub fn get_ConnectTimeout(self: *const ISearchCatalogManager, pdwConnectTimeout: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_ConnectTimeout(self, pdwConnectTimeout);
    }
    pub fn put_DataTimeout(self: *const ISearchCatalogManager, dwDataTimeout: u32) callconv(.Inline) HRESULT {
        return self.vtable.put_DataTimeout(self, dwDataTimeout);
    }
    pub fn get_DataTimeout(self: *const ISearchCatalogManager, pdwDataTimeout: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_DataTimeout(self, pdwDataTimeout);
    }
    pub fn NumberOfItems(self: *const ISearchCatalogManager, plCount: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.NumberOfItems(self, plCount);
    }
    pub fn NumberOfItemsToIndex(self: *const ISearchCatalogManager, plIncrementalCount: ?*i32, plNotificationQueue: ?*i32, plHighPriorityQueue: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.NumberOfItemsToIndex(self, plIncrementalCount, plNotificationQueue, plHighPriorityQueue);
    }
    pub fn URLBeingIndexed(self: *const ISearchCatalogManager, pszUrl: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.URLBeingIndexed(self, pszUrl);
    }
    pub fn GetURLIndexingState(self: *const ISearchCatalogManager, pszURL: ?[*:0]const u16, pdwState: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetURLIndexingState(self, pszURL, pdwState);
    }
    pub fn GetPersistentItemsChangedSink(self: *const ISearchCatalogManager, ppISearchPersistentItemsChangedSink: ?*?*ISearchPersistentItemsChangedSink) callconv(.Inline) HRESULT {
        return self.vtable.GetPersistentItemsChangedSink(self, ppISearchPersistentItemsChangedSink);
    }
    pub fn RegisterViewForNotification(self: *const ISearchCatalogManager, pszView: ?[*:0]const u16, pViewChangedSink: ?*ISearchViewChangedSink, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.RegisterViewForNotification(self, pszView, pViewChangedSink, pdwCookie);
    }
    pub fn GetItemsChangedSink(self: *const ISearchCatalogManager, pISearchNotifyInlineSite: ?*ISearchNotifyInlineSite, riid: ?*const Guid, ppv: ?*?*anyopaque, pGUIDCatalogResetSignature: ?*Guid, pGUIDCheckPointSignature: ?*Guid, pdwLastCheckPointNumber: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetItemsChangedSink(self, pISearchNotifyInlineSite, riid, ppv, pGUIDCatalogResetSignature, pGUIDCheckPointSignature, pdwLastCheckPointNumber);
    }
    pub fn UnregisterViewForNotification(self: *const ISearchCatalogManager, dwCookie: u32) callconv(.Inline) HRESULT {
        return self.vtable.UnregisterViewForNotification(self, dwCookie);
    }
    pub fn SetExtensionClusion(self: *const ISearchCatalogManager, pszExtension: ?[*:0]const u16, fExclude: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.SetExtensionClusion(self, pszExtension, fExclude);
    }
    pub fn EnumerateExcludedExtensions(self: *const ISearchCatalogManager, ppExtensions: ?*?*IEnumString) callconv(.Inline) HRESULT {
        return self.vtable.EnumerateExcludedExtensions(self, ppExtensions);
    }
    pub fn GetQueryHelper(self: *const ISearchCatalogManager, ppSearchQueryHelper: ?*?*ISearchQueryHelper) callconv(.Inline) HRESULT {
        return self.vtable.GetQueryHelper(self, ppSearchQueryHelper);
    }
    pub fn put_DiacriticSensitivity(self: *const ISearchCatalogManager, fDiacriticSensitive: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.put_DiacriticSensitivity(self, fDiacriticSensitive);
    }
    pub fn get_DiacriticSensitivity(self: *const ISearchCatalogManager, pfDiacriticSensitive: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_DiacriticSensitivity(self, pfDiacriticSensitive);
    }
    pub fn GetCrawlScopeManager(self: *const ISearchCatalogManager, ppCrawlScopeManager: ?*?*ISearchCrawlScopeManager) callconv(.Inline) HRESULT {
        return self.vtable.GetCrawlScopeManager(self, ppCrawlScopeManager);
    }
};

pub const PRIORITIZE_FLAGS = enum(i32) {
    RETRYFAILEDITEMS = 1,
    IGNOREFAILURECOUNT = 2,
};
pub const PRIORITIZE_FLAG_RETRYFAILEDITEMS = PRIORITIZE_FLAGS.RETRYFAILEDITEMS;
pub const PRIORITIZE_FLAG_IGNOREFAILURECOUNT = PRIORITIZE_FLAGS.IGNOREFAILURECOUNT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCatalogManager2_Value = Guid.initString("7ac3286d-4d1d-4817-84fc-c1c85e3af0d9");
pub const IID_ISearchCatalogManager2 = &IID_ISearchCatalogManager2_Value;
pub const ISearchCatalogManager2 = extern union {
    pub const VTable = extern struct {
        base: ISearchCatalogManager.VTable,
        PrioritizeMatchingURLs: *const fn(
            self: *const ISearchCatalogManager2,
            pszPattern: ?[*:0]const u16,
            dwPrioritizeFlags: PRIORITIZE_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ISearchCatalogManager: ISearchCatalogManager,
    IUnknown: IUnknown,
    pub fn PrioritizeMatchingURLs(self: *const ISearchCatalogManager2, pszPattern: ?[*:0]const u16, dwPrioritizeFlags: PRIORITIZE_FLAGS) callconv(.Inline) HRESULT {
        return self.vtable.PrioritizeMatchingURLs(self, pszPattern, dwPrioritizeFlags);
    }
};

pub const SEARCH_TERM_EXPANSION = enum(i32) {
    NO_EXPANSION = 0,
    PREFIX_ALL = 1,
    STEM_ALL = 2,
};
pub const SEARCH_TERM_NO_EXPANSION = SEARCH_TERM_EXPANSION.NO_EXPANSION;
pub const SEARCH_TERM_PREFIX_ALL = SEARCH_TERM_EXPANSION.PREFIX_ALL;
pub const SEARCH_TERM_STEM_ALL = SEARCH_TERM_EXPANSION.STEM_ALL;

pub const SEARCH_QUERY_SYNTAX = enum(i32) {
    NO_QUERY_SYNTAX = 0,
    ADVANCED_QUERY_SYNTAX = 1,
    NATURAL_QUERY_SYNTAX = 2,
};
pub const SEARCH_NO_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.NO_QUERY_SYNTAX;
pub const SEARCH_ADVANCED_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.ADVANCED_QUERY_SYNTAX;
pub const SEARCH_NATURAL_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.NATURAL_QUERY_SYNTAX;

pub const SEARCH_COLUMN_PROPERTIES = extern struct {
    Value: PROPVARIANT,
    lcid: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchQueryHelper_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef63");
pub const IID_ISearchQueryHelper = &IID_ISearchQueryHelper_Value;
pub const ISearchQueryHelper = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionString: *const fn(
            self: *const ISearchQueryHelper,
            pszConnectionString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryContentLocale: *const fn(
            self: *const ISearchQueryHelper,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryContentLocale: *const fn(
            self: *const ISearchQueryHelper,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryKeywordLocale: *const fn(
            self: *const ISearchQueryHelper,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryKeywordLocale: *const fn(
            self: *const ISearchQueryHelper,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryTermExpansion: *const fn(
            self: *const ISearchQueryHelper,
            expandTerms: SEARCH_TERM_EXPANSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryTermExpansion: *const fn(
            self: *const ISearchQueryHelper,
            pExpandTerms: ?*SEARCH_TERM_EXPANSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuerySyntax: *const fn(
            self: *const ISearchQueryHelper,
            querySyntax: SEARCH_QUERY_SYNTAX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuerySyntax: *const fn(
            self: *const ISearchQueryHelper,
            pQuerySyntax: ?*SEARCH_QUERY_SYNTAX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryContentProperties: *const fn(
            self: *const ISearchQueryHelper,
            pszContentProperties: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryContentProperties: *const fn(
            self: *const ISearchQueryHelper,
            ppszContentProperties: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuerySelectColumns: *const fn(
            self: *const ISearchQueryHelper,
            pszSelectColumns: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuerySelectColumns: *const fn(
            self: *const ISearchQueryHelper,
            ppszSelectColumns: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryWhereRestrictions: *const fn(
            self: *const ISearchQueryHelper,
            pszRestrictions: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryWhereRestrictions: *const fn(
            self: *const ISearchQueryHelper,
            ppszRestrictions: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuerySorting: *const fn(
            self: *const ISearchQueryHelper,
            pszSorting: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuerySorting: *const fn(
            self: *const ISearchQueryHelper,
            ppszSorting: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateSQLFromUserQuery: *const fn(
            self: *const ISearchQueryHelper,
            pszQuery: ?[*:0]const u16,
            ppszSQL: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProperties: *const fn(
            self: *const ISearchQueryHelper,
            itemID: i32,
            dwNumberOfColumns: u32,
            pColumns: [*]PROPERTYKEY,
            pValues: [*]SEARCH_COLUMN_PROPERTIES,
            pftGatherModifiedTime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryMaxResults: *const fn(
            self: *const ISearchQueryHelper,
            cMaxResults: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryMaxResults: *const fn(
            self: *const ISearchQueryHelper,
            pcMaxResults: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_ConnectionString(self: *const ISearchQueryHelper, pszConnectionString: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ConnectionString(self, pszConnectionString);
    }
    pub fn put_QueryContentLocale(self: *const ISearchQueryHelper, lcid: u32) callconv(.Inline) HRESULT {
        return self.vtable.put_QueryContentLocale(self, lcid);
    }
    pub fn get_QueryContentLocale(self: *const ISearchQueryHelper, plcid: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_QueryContentLocale(self, plcid);
    }
    pub fn put_QueryKeywordLocale(self: *const ISearchQueryHelper, lcid: u32) callconv(.Inline) HRESULT {
        return self.vtable.put_QueryKeywordLocale(self, lcid);
    }
    pub fn get_QueryKeywordLocale(self: *const ISearchQueryHelper, plcid: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_QueryKeywordLocale(self, plcid);
    }
    pub fn put_QueryTermExpansion(self: *const ISearchQueryHelper, expandTerms: SEARCH_TERM_EXPANSION) callconv(.Inline) HRESULT {
        return self.vtable.put_QueryTermExpansion(self, expandTerms);
    }
    pub fn get_QueryTermExpansion(self: *const ISearchQueryHelper, pExpandTerms: ?*SEARCH_TERM_EXPANSION) callconv(.Inline) HRESULT {
        return self.vtable.get_QueryTermExpansion(self, pExpandTerms);
    }
    pub fn put_QuerySyntax(self: *const ISearchQueryHelper, querySyntax: SEARCH_QUERY_SYNTAX) callconv(.Inline) HRESULT {
        return self.vtable.put_QuerySyntax(self, querySyntax);
    }
    pub fn get_QuerySyntax(self: *const ISearchQueryHelper, pQuerySyntax: ?*SEARCH_QUERY_SYNTAX) callconv(.Inline) HRESULT {
        return self.vtable.get_QuerySyntax(self, pQuerySyntax);
    }
    pub fn put_QueryContentProperties(self: *const ISearchQueryHelper, pszContentProperties: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.put_QueryContentProperties(self, pszContentProperties);
    }
    pub fn get_QueryContentProperties(self: *const ISearchQueryHelper, ppszContentProperties: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_QueryContentProperties(self, ppszContentProperties);
    }
    pub fn put_QuerySelectColumns(self: *const ISearchQueryHelper, pszSelectColumns: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.put_QuerySelectColumns(self, pszSelectColumns);
    }
    pub fn get_QuerySelectColumns(self: *const ISearchQueryHelper, ppszSelectColumns: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_QuerySelectColumns(self, ppszSelectColumns);
    }
    pub fn put_QueryWhereRestrictions(self: *const ISearchQueryHelper, pszRestrictions: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.put_QueryWhereRestrictions(self, pszRestrictions);
    }
    pub fn get_QueryWhereRestrictions(self: *const ISearchQueryHelper, ppszRestrictions: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_QueryWhereRestrictions(self, ppszRestrictions);
    }
    pub fn put_QuerySorting(self: *const ISearchQueryHelper, pszSorting: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.put_QuerySorting(self, pszSorting);
    }
    pub fn get_QuerySorting(self: *const ISearchQueryHelper, ppszSorting: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_QuerySorting(self, ppszSorting);
    }
    pub fn GenerateSQLFromUserQuery(self: *const ISearchQueryHelper, pszQuery: ?[*:0]const u16, ppszSQL: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GenerateSQLFromUserQuery(self, pszQuery, ppszSQL);
    }
    pub fn WriteProperties(self: *const ISearchQueryHelper, itemID: i32, dwNumberOfColumns: u32, pColumns: [*]PROPERTYKEY, pValues: [*]SEARCH_COLUMN_PROPERTIES, pftGatherModifiedTime: ?*FILETIME) callconv(.Inline) HRESULT {
        return self.vtable.WriteProperties(self, itemID, dwNumberOfColumns, pColumns, pValues, pftGatherModifiedTime);
    }
    pub fn put_QueryMaxResults(self: *const ISearchQueryHelper, cMaxResults: i32) callconv(.Inline) HRESULT {
        return self.vtable.put_QueryMaxResults(self, cMaxResults);
    }
    pub fn get_QueryMaxResults(self: *const ISearchQueryHelper, pcMaxResults: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_QueryMaxResults(self, pcMaxResults);
    }
};

pub const PRIORITY_LEVEL = enum(i32) {
    FOREGROUND = 0,
    HIGH = 1,
    LOW = 2,
    DEFAULT = 3,
};
pub const PRIORITY_LEVEL_FOREGROUND = PRIORITY_LEVEL.FOREGROUND;
pub const PRIORITY_LEVEL_HIGH = PRIORITY_LEVEL.HIGH;
pub const PRIORITY_LEVEL_LOW = PRIORITY_LEVEL.LOW;
pub const PRIORITY_LEVEL_DEFAULT = PRIORITY_LEVEL.DEFAULT;

// TODO: this type is limited to platform 'windows6.1'
const IID_IRowsetPrioritization_Value = Guid.initString("42811652-079d-481b-87a2-09a69ecc5f44");
pub const IID_IRowsetPrioritization = &IID_IRowsetPrioritization_Value;
pub const IRowsetPrioritization = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetScopePriority: *const fn(
            self: *const IRowsetPrioritization,
            priority: PRIORITY_LEVEL,
            scopeStatisticsEventFrequency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopePriority: *const fn(
            self: *const IRowsetPrioritization,
            priority: ?*PRIORITY_LEVEL,
            scopeStatisticsEventFrequency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeStatistics: *const fn(
            self: *const IRowsetPrioritization,
            indexedDocumentCount: ?*u32,
            oustandingAddCount: ?*u32,
            oustandingModifyCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn SetScopePriority(self: *const IRowsetPrioritization, priority: PRIORITY_LEVEL, scopeStatisticsEventFrequency: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetScopePriority(self, priority, scopeStatisticsEventFrequency);
    }
    pub fn GetScopePriority(self: *const IRowsetPrioritization, priority: ?*PRIORITY_LEVEL, scopeStatisticsEventFrequency: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetScopePriority(self, priority, scopeStatisticsEventFrequency);
    }
    pub fn GetScopeStatistics(self: *const IRowsetPrioritization, indexedDocumentCount: ?*u32, oustandingAddCount: ?*u32, oustandingModifyCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetScopeStatistics(self, indexedDocumentCount, oustandingAddCount, oustandingModifyCount);
    }
};

pub const ROWSETEVENT_ITEMSTATE = enum(i32) {
    NOTINROWSET = 0,
    INROWSET = 1,
    UNKNOWN = 2,
};
pub const ROWSETEVENT_ITEMSTATE_NOTINROWSET = ROWSETEVENT_ITEMSTATE.NOTINROWSET;
pub const ROWSETEVENT_ITEMSTATE_INROWSET = ROWSETEVENT_ITEMSTATE.INROWSET;
pub const ROWSETEVENT_ITEMSTATE_UNKNOWN = ROWSETEVENT_ITEMSTATE.UNKNOWN;

pub const ROWSETEVENT_TYPE = enum(i32) {
    DATAEXPIRED = 0,
    FOREGROUNDLOST = 1,
    SCOPESTATISTICS = 2,
};
pub const ROWSETEVENT_TYPE_DATAEXPIRED = ROWSETEVENT_TYPE.DATAEXPIRED;
pub const ROWSETEVENT_TYPE_FOREGROUNDLOST = ROWSETEVENT_TYPE.FOREGROUNDLOST;
pub const ROWSETEVENT_TYPE_SCOPESTATISTICS = ROWSETEVENT_TYPE.SCOPESTATISTICS;

// TODO: this type is limited to platform 'windows6.1'
const IID_IRowsetEvents_Value = Guid.initString("1551aea5-5d66-4b11-86f5-d5634cb211b9");
pub const IID_IRowsetEvents = &IID_IRowsetEvents_Value;
pub const IRowsetEvents = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNewItem: *const fn(
            self: *const IRowsetEvents,
            itemID: ?*const PROPVARIANT,
            newItemState: ROWSETEVENT_ITEMSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnChangedItem: *const fn(
            self: *const IRowsetEvents,
            itemID: ?*const PROPVARIANT,
            rowsetItemState: ROWSETEVENT_ITEMSTATE,
            changedItemState: ROWSETEVENT_ITEMSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDeletedItem: *const fn(
            self: *const IRowsetEvents,
            itemID: ?*const PROPVARIANT,
            deletedItemState: ROWSETEVENT_ITEMSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRowsetEvent: *const fn(
            self: *const IRowsetEvents,
            eventType: ROWSETEVENT_TYPE,
            eventData: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OnNewItem(self: *const IRowsetEvents, itemID: ?*const PROPVARIANT, newItemState: ROWSETEVENT_ITEMSTATE) callconv(.Inline) HRESULT {
        return self.vtable.OnNewItem(self, itemID, newItemState);
    }
    pub fn OnChangedItem(self: *const IRowsetEvents, itemID: ?*const PROPVARIANT, rowsetItemState: ROWSETEVENT_ITEMSTATE, changedItemState: ROWSETEVENT_ITEMSTATE) callconv(.Inline) HRESULT {
        return self.vtable.OnChangedItem(self, itemID, rowsetItemState, changedItemState);
    }
    pub fn OnDeletedItem(self: *const IRowsetEvents, itemID: ?*const PROPVARIANT, deletedItemState: ROWSETEVENT_ITEMSTATE) callconv(.Inline) HRESULT {
        return self.vtable.OnDeletedItem(self, itemID, deletedItemState);
    }
    pub fn OnRowsetEvent(self: *const IRowsetEvents, eventType: ROWSETEVENT_TYPE, eventData: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.OnRowsetEvent(self, eventType, eventData);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchManager_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef69");
pub const IID_ISearchManager = &IID_ISearchManager_Value;
pub const ISearchManager = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIndexerVersionStr: *const fn(
            self: *const ISearchManager,
            ppszVersionString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexerVersion: *const fn(
            self: *const ISearchManager,
            pdwMajor: ?*u32,
            pdwMinor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameter: *const fn(
            self: *const ISearchManager,
            pszName: ?[*:0]const u16,
            ppValue: ?*?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameter: *const fn(
            self: *const ISearchManager,
            pszName: ?[*:0]const u16,
            pValue: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProxyName: *const fn(
            self: *const ISearchManager,
            ppszProxyName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BypassList: *const fn(
            self: *const ISearchManager,
            ppszBypassList: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProxy: *const fn(
            self: *const ISearchManager,
            sUseProxy: PROXY_ACCESS,
            fLocalByPassProxy: BOOL,
            dwPortNumber: u32,
            pszProxyName: ?[*:0]const u16,
            pszByPassList: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCatalog: *const fn(
            self: *const ISearchManager,
            pszCatalog: ?[*:0]const u16,
            ppCatalogManager: ?*?*ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAgent: *const fn(
            self: *const ISearchManager,
            ppszUserAgent: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserAgent: *const fn(
            self: *const ISearchManager,
            pszUserAgent: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseProxy: *const fn(
            self: *const ISearchManager,
            pUseProxy: ?*PROXY_ACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalBypass: *const fn(
            self: *const ISearchManager,
            pfLocalBypass: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PortNumber: *const fn(
            self: *const ISearchManager,
            pdwPortNumber: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetIndexerVersionStr(self: *const ISearchManager, ppszVersionString: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetIndexerVersionStr(self, ppszVersionString);
    }
    pub fn GetIndexerVersion(self: *const ISearchManager, pdwMajor: ?*u32, pdwMinor: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetIndexerVersion(self, pdwMajor, pdwMinor);
    }
    pub fn GetParameter(self: *const ISearchManager, pszName: ?[*:0]const u16, ppValue: ?*?*PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetParameter(self, pszName, ppValue);
    }
    pub fn SetParameter(self: *const ISearchManager, pszName: ?[*:0]const u16, pValue: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
        return self.vtable.SetParameter(self, pszName, pValue);
    }
    pub fn get_ProxyName(self: *const ISearchManager, ppszProxyName: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ProxyName(self, ppszProxyName);
    }
    pub fn get_BypassList(self: *const ISearchManager, ppszBypassList: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_BypassList(self, ppszBypassList);
    }
    pub fn SetProxy(self: *const ISearchManager, sUseProxy: PROXY_ACCESS, fLocalByPassProxy: BOOL, dwPortNumber: u32, pszProxyName: ?[*:0]const u16, pszByPassList: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.SetProxy(self, sUseProxy, fLocalByPassProxy, dwPortNumber, pszProxyName, pszByPassList);
    }
    pub fn GetCatalog(self: *const ISearchManager, pszCatalog: ?[*:0]const u16, ppCatalogManager: ?*?*ISearchCatalogManager) callconv(.Inline) HRESULT {
        return self.vtable.GetCatalog(self, pszCatalog, ppCatalogManager);
    }
    pub fn get_UserAgent(self: *const ISearchManager, ppszUserAgent: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_UserAgent(self, ppszUserAgent);
    }
    pub fn put_UserAgent(self: *const ISearchManager, pszUserAgent: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.put_UserAgent(self, pszUserAgent);
    }
    pub fn get_UseProxy(self: *const ISearchManager, pUseProxy: ?*PROXY_ACCESS) callconv(.Inline) HRESULT {
        return self.vtable.get_UseProxy(self, pUseProxy);
    }
    pub fn get_LocalBypass(self: *const ISearchManager, pfLocalBypass: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_LocalBypass(self, pfLocalBypass);
    }
    pub fn get_PortNumber(self: *const ISearchManager, pdwPortNumber: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_PortNumber(self, pdwPortNumber);
    }
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISearchManager2_Value = Guid.initString("dbab3f73-db19-4a79-bfc0-a61a93886ddf");
pub const IID_ISearchManager2 = &IID_ISearchManager2_Value;
pub const ISearchManager2 = extern union {
    pub const VTable = extern struct {
        base: ISearchManager.VTable,
        CreateCatalog: *const fn(
            self: *const ISearchManager2,
            pszCatalog: ?[*:0]const u16,
            ppCatalogManager: ?*?*ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteCatalog: *const fn(
            self: *const ISearchManager2,
            pszCatalog: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ISearchManager: ISearchManager,
    IUnknown: IUnknown,
    pub fn CreateCatalog(self: *const ISearchManager2, pszCatalog: ?[*:0]const u16, ppCatalogManager: ?*?*ISearchCatalogManager) callconv(.Inline) HRESULT {
        return self.vtable.CreateCatalog(self, pszCatalog, ppCatalogManager);
    }
    pub fn DeleteCatalog(self: *const ISearchManager2, pszCatalog: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.DeleteCatalog(self, pszCatalog);
    }
};

const CLSID_CSearchLanguageSupport_Value = Guid.initString("6a68cc80-4337-4dbc-bd27-fbfb1053820b");
pub const CLSID_CSearchLanguageSupport = &CLSID_CSearchLanguageSupport_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchLanguageSupport_Value = Guid.initString("24c3cbaa-ebc1-491a-9ef1-9f6d8deb1b8f");
pub const IID_ISearchLanguageSupport = &IID_ISearchLanguageSupport_Value;
pub const ISearchLanguageSupport = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDiacriticSensitivity: *const fn(
            self: *const ISearchLanguageSupport,
            fDiacriticSensitive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDiacriticSensitivity: *const fn(
            self: *const ISearchLanguageSupport,
            pfDiacriticSensitive: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadWordBreaker: *const fn(
            self: *const ISearchLanguageSupport,
            lcid: u32,
            riid: ?*const Guid,
            ppWordBreaker: ?*?*anyopaque,
            pLcidUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadStemmer: *const fn(
            self: *const ISearchLanguageSupport,
            lcid: u32,
            riid: ?*const Guid,
            ppStemmer: ?*?*anyopaque,
            pLcidUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPrefixNormalized: *const fn(
            self: *const ISearchLanguageSupport,
            pwcsQueryToken: [*:0]const u16,
            cwcQueryToken: u32,
            pwcsDocumentToken: [*:0]const u16,
            cwcDocumentToken: u32,
            pulPrefixLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn SetDiacriticSensitivity(self: *const ISearchLanguageSupport, fDiacriticSensitive: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.SetDiacriticSensitivity(self, fDiacriticSensitive);
    }
    pub fn GetDiacriticSensitivity(self: *const ISearchLanguageSupport, pfDiacriticSensitive: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.GetDiacriticSensitivity(self, pfDiacriticSensitive);
    }
    pub fn LoadWordBreaker(self: *const ISearchLanguageSupport, lcid: u32, riid: ?*const Guid, ppWordBreaker: ?*?*anyopaque, pLcidUsed: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.LoadWordBreaker(self, lcid, riid, ppWordBreaker, pLcidUsed);
    }
    pub fn LoadStemmer(self: *const ISearchLanguageSupport, lcid: u32, riid: ?*const Guid, ppStemmer: ?*?*anyopaque, pLcidUsed: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.LoadStemmer(self, lcid, riid, ppStemmer, pLcidUsed);
    }
    pub fn IsPrefixNormalized(self: *const ISearchLanguageSupport, pwcsQueryToken: [*:0]const u16, cwcQueryToken: u32, pwcsDocumentToken: [*:0]const u16, cwcDocumentToken: u32, pulPrefixLength: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.IsPrefixNormalized(self, pwcsQueryToken, cwcQueryToken, pwcsDocumentToken, cwcDocumentToken, pulPrefixLength);
    }
};

const CLSID_SubscriptionMgr_Value = Guid.initString("abbe31d0-6dae-11d0-beca-00c04fd940be");
pub const CLSID_SubscriptionMgr = &CLSID_SubscriptionMgr_Value;

pub const ITEMPROP = extern struct {
    variantValue: VARIANT,
    pwszName: ?PWSTR,
};

const IID_IEnumItemProperties_Value = Guid.initString("f72c8d96-6dbd-11d1-a1e8-00c04fc2fbe1");
pub const IID_IEnumItemProperties = &IID_IEnumItemProperties_Value;
pub const IEnumItemProperties = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn(
            self: *const IEnumItemProperties,
            celt: u32,
            rgelt: [*]ITEMPROP,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn(
            self: *const IEnumItemProperties,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn(
            self: *const IEnumItemProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn(
            self: *const IEnumItemProperties,
            ppenum: ?*?*IEnumItemProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: *const fn(
            self: *const IEnumItemProperties,
            pnCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Next(self: *const IEnumItemProperties, celt: u32, rgelt: [*]ITEMPROP, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Next(self, celt, rgelt, pceltFetched);
    }
    pub fn Skip(self: *const IEnumItemProperties, celt: u32) callconv(.Inline) HRESULT {
        return self.vtable.Skip(self, celt);
    }
    pub fn Reset(self: *const IEnumItemProperties) callconv(.Inline) HRESULT {
        return self.vtable.Reset(self);
    }
    pub fn Clone(self: *const IEnumItemProperties, ppenum: ?*?*IEnumItemProperties) callconv(.Inline) HRESULT {
        return self.vtable.Clone(self, ppenum);
    }
    pub fn GetCount(self: *const IEnumItemProperties, pnCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetCount(self, pnCount);
    }
};

pub const SUBSCRIPTIONITEMINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwPriority: u32,
    ScheduleGroup: Guid,
    clsidAgent: Guid,
};

const IID_ISubscriptionItem_Value = Guid.initString("a97559f8-6c4a-11d1-a1e8-00c04fc2fbe1");
pub const IID_ISubscriptionItem = &IID_ISubscriptionItem_Value;
pub const ISubscriptionItem = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCookie: *const fn(
            self: *const ISubscriptionItem,
            pCookie: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscriptionItemInfo: *const fn(
            self: *const ISubscriptionItem,
            pSubscriptionItemInfo: ?*SUBSCRIPTIONITEMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubscriptionItemInfo: *const fn(
            self: *const ISubscriptionItem,
            pSubscriptionItemInfo: ?*const SUBSCRIPTIONITEMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadProperties: *const fn(
            self: *const ISubscriptionItem,
            nCount: u32,
            rgwszName: [*]const ?[*:0]const u16,
            rgValue: [*]VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProperties: *const fn(
            self: *const ISubscriptionItem,
            nCount: u32,
            rgwszName: [*]const ?[*:0]const u16,
            rgValue: [*]const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumProperties: *const fn(
            self: *const ISubscriptionItem,
            ppEnumItemProperties: ?*?*IEnumItemProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyChanged: *const fn(
            self: *const ISubscriptionItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetCookie(self: *const ISubscriptionItem, pCookie: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.GetCookie(self, pCookie);
    }
    pub fn GetSubscriptionItemInfo(self: *const ISubscriptionItem, pSubscriptionItemInfo: ?*SUBSCRIPTIONITEMINFO) callconv(.Inline) HRESULT {
        return self.vtable.GetSubscriptionItemInfo(self, pSubscriptionItemInfo);
    }
    pub fn SetSubscriptionItemInfo(self: *const ISubscriptionItem, pSubscriptionItemInfo: ?*const SUBSCRIPTIONITEMINFO) callconv(.Inline) HRESULT {
        return self.vtable.SetSubscriptionItemInfo(self, pSubscriptionItemInfo);
    }
    pub fn ReadProperties(self: *const ISubscriptionItem, nCount: u32, rgwszName: [*]const ?[*:0]const u16, rgValue: [*]VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.ReadProperties(self, nCount, rgwszName, rgValue);
    }
    pub fn WriteProperties(self: *const ISubscriptionItem, nCount: u32, rgwszName: [*]const ?[*:0]const u16, rgValue: [*]const VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.WriteProperties(self, nCount, rgwszName, rgValue);
    }
    pub fn EnumProperties(self: *const ISubscriptionItem, ppEnumItemProperties: ?*?*IEnumItemProperties) callconv(.Inline) HRESULT {
        return self.vtable.EnumProperties(self, ppEnumItemProperties);
    }
    pub fn NotifyChanged(self: *const ISubscriptionItem) callconv(.Inline) HRESULT {
        return self.vtable.NotifyChanged(self);
    }
};

const IID_IEnumSubscription_Value = Guid.initString("f72c8d97-6dbd-11d1-a1e8-00c04fc2fbe1");
pub const IID_IEnumSubscription = &IID_IEnumSubscription_Value;
pub const IEnumSubscription = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn(
            self: *const IEnumSubscription,
            celt: u32,
            rgelt: [*]Guid,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn(
            self: *const IEnumSubscription,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn(
            self: *const IEnumSubscription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn(
            self: *const IEnumSubscription,
            ppenum: ?*?*IEnumSubscription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: *const fn(
            self: *const IEnumSubscription,
            pnCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Next(self: *const IEnumSubscription, celt: u32, rgelt: [*]Guid, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Next(self, celt, rgelt, pceltFetched);
    }
    pub fn Skip(self: *const IEnumSubscription, celt: u32) callconv(.Inline) HRESULT {
        return self.vtable.Skip(self, celt);
    }
    pub fn Reset(self: *const IEnumSubscription) callconv(.Inline) HRESULT {
        return self.vtable.Reset(self);
    }
    pub fn Clone(self: *const IEnumSubscription, ppenum: ?*?*IEnumSubscription) callconv(.Inline) HRESULT {
        return self.vtable.Clone(self, ppenum);
    }
    pub fn GetCount(self: *const IEnumSubscription, pnCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetCount(self, pnCount);
    }
};

pub const SUBSCRIPTIONTYPE = enum(i32) {
    URL = 0,
    CHANNEL = 1,
    DESKTOPURL = 2,
    EXTERNAL = 3,
    DESKTOPCHANNEL = 4,
};
pub const SUBSTYPE_URL = SUBSCRIPTIONTYPE.URL;
pub const SUBSTYPE_CHANNEL = SUBSCRIPTIONTYPE.CHANNEL;
pub const SUBSTYPE_DESKTOPURL = SUBSCRIPTIONTYPE.DESKTOPURL;
pub const SUBSTYPE_EXTERNAL = SUBSCRIPTIONTYPE.EXTERNAL;
pub const SUBSTYPE_DESKTOPCHANNEL = SUBSCRIPTIONTYPE.DESKTOPCHANNEL;

pub const SUBSCRIPTIONINFOFLAGS = enum(i32) {
    SCHEDULE = 1,
    RECURSE = 2,
    WEBCRAWL = 4,
    MAILNOT = 8,
    MAXSIZEKB = 16,
    USER = 32,
    PASSWORD = 64,
    TASKFLAGS = 256,
    GLEAM = 512,
    CHANGESONLY = 1024,
    CHANNELFLAGS = 2048,
    FRIENDLYNAME = 8192,
    NEEDPASSWORD = 16384,
    TYPE = 32768,
};
pub const SUBSINFO_SCHEDULE = SUBSCRIPTIONINFOFLAGS.SCHEDULE;
pub const SUBSINFO_RECURSE = SUBSCRIPTIONINFOFLAGS.RECURSE;
pub const SUBSINFO_WEBCRAWL = SUBSCRIPTIONINFOFLAGS.WEBCRAWL;
pub const SUBSINFO_MAILNOT = SUBSCRIPTIONINFOFLAGS.MAILNOT;
pub const SUBSINFO_MAXSIZEKB = SUBSCRIPTIONINFOFLAGS.MAXSIZEKB;
pub const SUBSINFO_USER = SUBSCRIPTIONINFOFLAGS.USER;
pub const SUBSINFO_PASSWORD = SUBSCRIPTIONINFOFLAGS.PASSWORD;
pub const SUBSINFO_TASKFLAGS = SUBSCRIPTIONINFOFLAGS.TASKFLAGS;
pub const SUBSINFO_GLEAM = SUBSCRIPTIONINFOFLAGS.GLEAM;
pub const SUBSINFO_CHANGESONLY = SUBSCRIPTIONINFOFLAGS.CHANGESONLY;
pub const SUBSINFO_CHANNELFLAGS = SUBSCRIPTIONINFOFLAGS.CHANNELFLAGS;
pub const SUBSINFO_FRIENDLYNAME = SUBSCRIPTIONINFOFLAGS.FRIENDLYNAME;
pub const SUBSINFO_NEEDPASSWORD = SUBSCRIPTIONINFOFLAGS.NEEDPASSWORD;
pub const SUBSINFO_TYPE = SUBSCRIPTIONINFOFLAGS.TYPE;

pub const CREATESUBSCRIPTIONFLAGS = enum(i32) {
    ADDTOFAVORITES = 1,
    FROMFAVORITES = 2,
    NOUI = 4,
    NOSAVE = 8,
    SOFTWAREUPDATE = 16,
};
pub const CREATESUBS_ADDTOFAVORITES = CREATESUBSCRIPTIONFLAGS.ADDTOFAVORITES;
pub const CREATESUBS_FROMFAVORITES = CREATESUBSCRIPTIONFLAGS.FROMFAVORITES;
pub const CREATESUBS_NOUI = CREATESUBSCRIPTIONFLAGS.NOUI;
pub const CREATESUBS_NOSAVE = CREATESUBSCRIPTIONFLAGS.NOSAVE;
pub const CREATESUBS_SOFTWAREUPDATE = CREATESUBSCRIPTIONFLAGS.SOFTWAREUPDATE;

pub const SUBSCRIPTIONSCHEDULE = enum(i32) {
    AUTO = 0,
    DAILY = 1,
    WEEKLY = 2,
    CUSTOM = 3,
    MANUAL = 4,
};
pub const SUBSSCHED_AUTO = SUBSCRIPTIONSCHEDULE.AUTO;
pub const SUBSSCHED_DAILY = SUBSCRIPTIONSCHEDULE.DAILY;
pub const SUBSSCHED_WEEKLY = SUBSCRIPTIONSCHEDULE.WEEKLY;
pub const SUBSSCHED_CUSTOM = SUBSCRIPTIONSCHEDULE.CUSTOM;
pub const SUBSSCHED_MANUAL = SUBSCRIPTIONSCHEDULE.MANUAL;

pub const SUBSCRIPTIONINFO = extern struct {
    cbSize: u32,
    fUpdateFlags: u32,
    schedule: SUBSCRIPTIONSCHEDULE,
    customGroupCookie: Guid,
    pTrigger: ?*anyopaque,
    dwRecurseLevels: u32,
    fWebcrawlerFlags: u32,
    bMailNotification: BOOL,
    bGleam: BOOL,
    bChangesOnly: BOOL,
    bNeedPassword: BOOL,
    fChannelFlags: u32,
    bstrUserName: ?BSTR,
    bstrPassword: ?BSTR,
    bstrFriendlyName: ?BSTR,
    dwMaxSizeKB: u32,
    subType: SUBSCRIPTIONTYPE,
    fTaskFlags: u32,
    dwReserved: u32,
};

const IID_ISubscriptionMgr_Value = Guid.initString("085fb2c0-0df8-11d1-8f4b-00a0c905413f");
pub const IID_ISubscriptionMgr = &IID_ISubscriptionMgr_Value;
pub const ISubscriptionMgr = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteSubscription: *const fn(
            self: *const ISubscriptionMgr,
            pwszURL: ?[*:0]const u16,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateSubscription: *const fn(
            self: *const ISubscriptionMgr,
            pwszURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAll: *const fn(
            self: *const ISubscriptionMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubscribed: *const fn(
            self: *const ISubscriptionMgr,
            pwszURL: ?[*:0]const u16,
            pfSubscribed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscriptionInfo: *const fn(
            self: *const ISubscriptionMgr,
            pwszURL: ?[*:0]const u16,
            pInfo: ?*SUBSCRIPTIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultInfo: *const fn(
            self: *const ISubscriptionMgr,
            subType: SUBSCRIPTIONTYPE,
            pInfo: ?*SUBSCRIPTIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowSubscriptionProperties: *const fn(
            self: *const ISubscriptionMgr,
            pwszURL: ?[*:0]const u16,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSubscription: *const fn(
            self: *const ISubscriptionMgr,
            hwnd: ?HWND,
            pwszURL: ?[*:0]const u16,
            pwszFriendlyName: ?[*:0]const u16,
            dwFlags: u32,
            subsType: SUBSCRIPTIONTYPE,
            pInfo: ?*SUBSCRIPTIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn DeleteSubscription(self: *const ISubscriptionMgr, pwszURL: ?[*:0]const u16, hwnd: ?HWND) callconv(.Inline) HRESULT {
        return self.vtable.DeleteSubscription(self, pwszURL, hwnd);
    }
    pub fn UpdateSubscription(self: *const ISubscriptionMgr, pwszURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.UpdateSubscription(self, pwszURL);
    }
    pub fn UpdateAll(self: *const ISubscriptionMgr) callconv(.Inline) HRESULT {
        return self.vtable.UpdateAll(self);
    }
    pub fn IsSubscribed(self: *const ISubscriptionMgr, pwszURL: ?[*:0]const u16, pfSubscribed: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.IsSubscribed(self, pwszURL, pfSubscribed);
    }
    pub fn GetSubscriptionInfo(self: *const ISubscriptionMgr, pwszURL: ?[*:0]const u16, pInfo: ?*SUBSCRIPTIONINFO) callconv(.Inline) HRESULT {
        return self.vtable.GetSubscriptionInfo(self, pwszURL, pInfo);
    }
    pub fn GetDefaultInfo(self: *const ISubscriptionMgr, subType: SUBSCRIPTIONTYPE, pInfo: ?*SUBSCRIPTIONINFO) callconv(.Inline) HRESULT {
        return self.vtable.GetDefaultInfo(self, subType, pInfo);
    }
    pub fn ShowSubscriptionProperties(self: *const ISubscriptionMgr, pwszURL: ?[*:0]const u16, hwnd: ?HWND) callconv(.Inline) HRESULT {
        return self.vtable.ShowSubscriptionProperties(self, pwszURL, hwnd);
    }
    pub fn CreateSubscription(self: *const ISubscriptionMgr, hwnd: ?HWND, pwszURL: ?[*:0]const u16, pwszFriendlyName: ?[*:0]const u16, dwFlags: u32, subsType: SUBSCRIPTIONTYPE, pInfo: ?*SUBSCRIPTIONINFO) callconv(.Inline) HRESULT {
        return self.vtable.CreateSubscription(self, hwnd, pwszURL, pwszFriendlyName, dwFlags, subsType, pInfo);
    }
};

const IID_ISubscriptionMgr2_Value = Guid.initString("614bc270-aedf-11d1-a1f9-00c04fc2fbe1");
pub const IID_ISubscriptionMgr2 = &IID_ISubscriptionMgr2_Value;
pub const ISubscriptionMgr2 = extern union {
    pub const VTable = extern struct {
        base: ISubscriptionMgr.VTable,
        GetItemFromURL: *const fn(
            self: *const ISubscriptionMgr2,
            pwszURL: ?[*:0]const u16,
            ppSubscriptionItem: ?*?*ISubscriptionItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFromCookie: *const fn(
            self: *const ISubscriptionMgr2,
            pSubscriptionCookie: ?*const Guid,
            ppSubscriptionItem: ?*?*ISubscriptionItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscriptionRunState: *const fn(
            self: *const ISubscriptionMgr2,
            dwNumCookies: u32,
            pCookies: [*]const Guid,
            pdwRunState: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumSubscriptions: *const fn(
            self: *const ISubscriptionMgr2,
            dwFlags: u32,
            ppEnumSubscriptions: ?*?*IEnumSubscription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateItems: *const fn(
            self: *const ISubscriptionMgr2,
            dwFlags: u32,
            dwNumCookies: u32,
            pCookies: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortItems: *const fn(
            self: *const ISubscriptionMgr2,
            dwNumCookies: u32,
            pCookies: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortAll: *const fn(
            self: *const ISubscriptionMgr2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    ISubscriptionMgr: ISubscriptionMgr,
    IUnknown: IUnknown,
    pub fn GetItemFromURL(self: *const ISubscriptionMgr2, pwszURL: ?[*:0]const u16, ppSubscriptionItem: ?*?*ISubscriptionItem) callconv(.Inline) HRESULT {
        return self.vtable.GetItemFromURL(self, pwszURL, ppSubscriptionItem);
    }
    pub fn GetItemFromCookie(self: *const ISubscriptionMgr2, pSubscriptionCookie: ?*const Guid, ppSubscriptionItem: ?*?*ISubscriptionItem) callconv(.Inline) HRESULT {
        return self.vtable.GetItemFromCookie(self, pSubscriptionCookie, ppSubscriptionItem);
    }
    pub fn GetSubscriptionRunState(self: *const ISubscriptionMgr2, dwNumCookies: u32, pCookies: [*]const Guid, pdwRunState: [*]u32) callconv(.Inline) HRESULT {
        return self.vtable.GetSubscriptionRunState(self, dwNumCookies, pCookies, pdwRunState);
    }
    pub fn EnumSubscriptions(self: *const ISubscriptionMgr2, dwFlags: u32, ppEnumSubscriptions: ?*?*IEnumSubscription) callconv(.Inline) HRESULT {
        return self.vtable.EnumSubscriptions(self, dwFlags, ppEnumSubscriptions);
    }
    pub fn UpdateItems(self: *const ISubscriptionMgr2, dwFlags: u32, dwNumCookies: u32, pCookies: [*]const Guid) callconv(.Inline) HRESULT {
        return self.vtable.UpdateItems(self, dwFlags, dwNumCookies, pCookies);
    }
    pub fn AbortItems(self: *const ISubscriptionMgr2, dwNumCookies: u32, pCookies: [*]const Guid) callconv(.Inline) HRESULT {
        return self.vtable.AbortItems(self, dwNumCookies, pCookies);
    }
    pub fn AbortAll(self: *const ISubscriptionMgr2) callconv(.Inline) HRESULT {
        return self.vtable.AbortAll(self);
    }
};

pub const DELIVERY_AGENT_FLAGS = enum(i32) {
    NO_BROADCAST = 4,
    NO_RESTRICTIONS = 8,
    SILENT_DIAL = 16,
};
pub const DELIVERY_AGENT_FLAG_NO_BROADCAST = DELIVERY_AGENT_FLAGS.NO_BROADCAST;
pub const DELIVERY_AGENT_FLAG_NO_RESTRICTIONS = DELIVERY_AGENT_FLAGS.NO_RESTRICTIONS;
pub const DELIVERY_AGENT_FLAG_SILENT_DIAL = DELIVERY_AGENT_FLAGS.SILENT_DIAL;

pub const WEBCRAWL_RECURSEFLAGS = enum(i32) {
    DONT_MAKE_STICKY = 1,
    GET_IMAGES = 2,
    GET_VIDEOS = 4,
    GET_BGSOUNDS = 8,
    GET_CONTROLS = 16,
    LINKS_ELSEWHERE = 32,
    IGNORE_ROBOTSTXT = 128,
    ONLY_LINKS_TO_HTML = 256,
};
pub const WEBCRAWL_DONT_MAKE_STICKY = WEBCRAWL_RECURSEFLAGS.DONT_MAKE_STICKY;
pub const WEBCRAWL_GET_IMAGES = WEBCRAWL_RECURSEFLAGS.GET_IMAGES;
pub const WEBCRAWL_GET_VIDEOS = WEBCRAWL_RECURSEFLAGS.GET_VIDEOS;
pub const WEBCRAWL_GET_BGSOUNDS = WEBCRAWL_RECURSEFLAGS.GET_BGSOUNDS;
pub const WEBCRAWL_GET_CONTROLS = WEBCRAWL_RECURSEFLAGS.GET_CONTROLS;
pub const WEBCRAWL_LINKS_ELSEWHERE = WEBCRAWL_RECURSEFLAGS.LINKS_ELSEWHERE;
pub const WEBCRAWL_IGNORE_ROBOTSTXT = WEBCRAWL_RECURSEFLAGS.IGNORE_ROBOTSTXT;
pub const WEBCRAWL_ONLY_LINKS_TO_HTML = WEBCRAWL_RECURSEFLAGS.ONLY_LINKS_TO_HTML;

pub const CHANNEL_AGENT_FLAGS = enum(i32) {
    DYNAMIC_SCHEDULE = 1,
    PRECACHE_SOME = 2,
    PRECACHE_ALL = 4,
    PRECACHE_SCRNSAVER = 8,
};
pub const CHANNEL_AGENT_DYNAMIC_SCHEDULE = CHANNEL_AGENT_FLAGS.DYNAMIC_SCHEDULE;
pub const CHANNEL_AGENT_PRECACHE_SOME = CHANNEL_AGENT_FLAGS.PRECACHE_SOME;
pub const CHANNEL_AGENT_PRECACHE_ALL = CHANNEL_AGENT_FLAGS.PRECACHE_ALL;
pub const CHANNEL_AGENT_PRECACHE_SCRNSAVER = CHANNEL_AGENT_FLAGS.PRECACHE_SCRNSAVER;

pub const DBDATACONVERTENUM = enum(i32) {
    DEFAULT = 0,
    SETDATABEHAVIOR = 1,
    LENGTHFROMNTS = 2,
    DSTISFIXEDLENGTH = 4,
    DECIMALSCALE = 8,
};
pub const DBDATACONVERT_DEFAULT = DBDATACONVERTENUM.DEFAULT;
pub const DBDATACONVERT_SETDATABEHAVIOR = DBDATACONVERTENUM.SETDATABEHAVIOR;
pub const DBDATACONVERT_LENGTHFROMNTS = DBDATACONVERTENUM.LENGTHFROMNTS;
pub const DBDATACONVERT_DSTISFIXEDLENGTH = DBDATACONVERTENUM.DSTISFIXEDLENGTH;
pub const DBDATACONVERT_DECIMALSCALE = DBDATACONVERTENUM.DECIMALSCALE;

const IID_IDataConvert_Value = Guid.initString("0c733a8d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDataConvert = &IID_IDataConvert_Value;
pub const IDataConvert = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DataConvert: *const fn(
            self: *const IDataConvert,
            wSrcType: u16,
            wDstType: u16,
            cbSrcLength: usize,
            pcbDstLength: ?*usize,
            // TODO: what to do with BytesParamIndex 2?
            pSrc: ?*anyopaque,
            pDst: ?*anyopaque,
            cbDstMaxLength: usize,
            dbsSrcStatus: u32,
            pdbsStatus: ?*u32,
            bPrecision: u8,
            bScale: u8,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanConvert: *const fn(
            self: *const IDataConvert,
            wSrcType: u16,
            wDstType: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionSize: *const fn(
            self: *const IDataConvert,
            wSrcType: u16,
            wDstType: u16,
            pcbSrcLength: ?*usize,
            pcbDstLength: ?*usize,
            // TODO: what to do with BytesParamIndex 2?
            pSrc: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn DataConvert(self: *const IDataConvert, wSrcType: u16, wDstType: u16, cbSrcLength: usize, pcbDstLength: ?*usize, pSrc: ?*anyopaque, pDst: ?*anyopaque, cbDstMaxLength: usize, dbsSrcStatus: u32, pdbsStatus: ?*u32, bPrecision: u8, bScale: u8, dwFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.DataConvert(self, wSrcType, wDstType, cbSrcLength, pcbDstLength, pSrc, pDst, cbDstMaxLength, dbsSrcStatus, pdbsStatus, bPrecision, bScale, dwFlags);
    }
    pub fn CanConvert(self: *const IDataConvert, wSrcType: u16, wDstType: u16) callconv(.Inline) HRESULT {
        return self.vtable.CanConvert(self, wSrcType, wDstType);
    }
    pub fn GetConversionSize(self: *const IDataConvert, wSrcType: u16, wDstType: u16, pcbSrcLength: ?*usize, pcbDstLength: ?*usize, pSrc: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetConversionSize(self, wSrcType, wDstType, pcbSrcLength, pcbDstLength, pSrc);
    }
};

pub const DCINFOTYPEENUM = enum(i32) {
    N = 1,
};
pub const DCINFOTYPE_VERSION = DCINFOTYPEENUM.N;

pub const DCINFO = extern struct {
    eInfoType: u32,
    vData: VARIANT,
};

const IID_IDCInfo_Value = Guid.initString("0c733a9c-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDCInfo = &IID_IDCInfo_Value;
pub const IDCInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: *const fn(
            self: *const IDCInfo,
            cInfo: u32,
            rgeInfoType: [*]u32,
            prgInfo: [*]?*DCINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInfo: *const fn(
            self: *const IDCInfo,
            cInfo: u32,
            rgInfo: [*]DCINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetInfo(self: *const IDCInfo, cInfo: u32, rgeInfoType: [*]u32, prgInfo: [*]?*DCINFO) callconv(.Inline) HRESULT {
        return self.vtable.GetInfo(self, cInfo, rgeInfoType, prgInfo);
    }
    pub fn SetInfo(self: *const IDCInfo, cInfo: u32, rgInfo: [*]DCINFO) callconv(.Inline) HRESULT {
        return self.vtable.SetInfo(self, cInfo, rgInfo);
    }
};

const CLSID_MSDAORA_Value = Guid.initString("e8cc4cbe-fdff-11d0-b865-00a0c9081c1d");
pub const CLSID_MSDAORA = &CLSID_MSDAORA_Value;

const CLSID_MSDAORA_ERROR_Value = Guid.initString("e8cc4cbf-fdff-11d0-b865-00a0c9081c1d");
pub const CLSID_MSDAORA_ERROR = &CLSID_MSDAORA_ERROR_Value;

const CLSID_MSDAORA8_Value = Guid.initString("7f06a373-dd6a-43db-b4e0-1fc121e5e62b");
pub const CLSID_MSDAORA8 = &CLSID_MSDAORA8_Value;

const CLSID_MSDAORA8_ERROR_Value = Guid.initString("7f06a374-dd6a-43db-b4e0-1fc121e5e62b");
pub const CLSID_MSDAORA8_ERROR = &CLSID_MSDAORA8_ERROR_Value;

const IID_DataSourceListener_Value = Guid.initString("7c0ffab2-cd84-11d0-949a-00a0c91110ed");
pub const IID_DataSourceListener = &IID_DataSourceListener_Value;
pub const DataSourceListener = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        dataMemberChanged: *const fn(
            self: *const DataSourceListener,
            bstrDM: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        dataMemberAdded: *const fn(
            self: *const DataSourceListener,
            bstrDM: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        dataMemberRemoved: *const fn(
            self: *const DataSourceListener,
            bstrDM: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn dataMemberChanged(self: *const DataSourceListener, bstrDM: ?*u16) callconv(.Inline) HRESULT {
        return self.vtable.dataMemberChanged(self, bstrDM);
    }
    pub fn dataMemberAdded(self: *const DataSourceListener, bstrDM: ?*u16) callconv(.Inline) HRESULT {
        return self.vtable.dataMemberAdded(self, bstrDM);
    }
    pub fn dataMemberRemoved(self: *const DataSourceListener, bstrDM: ?*u16) callconv(.Inline) HRESULT {
        return self.vtable.dataMemberRemoved(self, bstrDM);
    }
};

const IID_DataSource_Value = Guid.initString("7c0ffab3-cd84-11d0-949a-00a0c91110ed");
pub const IID_DataSource = &IID_DataSource_Value;
pub const DataSource = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getDataMember: *const fn(
            self: *const DataSource,
            bstrDM: ?*u16,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDataMemberName: *const fn(
            self: *const DataSource,
            lIndex: i32,
            pbstrDM: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDataMemberCount: *const fn(
            self: *const DataSource,
            plCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addDataSourceListener: *const fn(
            self: *const DataSource,
            pDSL: ?*DataSourceListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeDataSourceListener: *const fn(
            self: *const DataSource,
            pDSL: ?*DataSourceListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn getDataMember(self: *const DataSource, bstrDM: ?*u16, riid: ?*const Guid, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.getDataMember(self, bstrDM, riid, ppunk);
    }
    pub fn getDataMemberName(self: *const DataSource, lIndex: i32, pbstrDM: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.getDataMemberName(self, lIndex, pbstrDM);
    }
    pub fn getDataMemberCount(self: *const DataSource, plCount: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.getDataMemberCount(self, plCount);
    }
    pub fn addDataSourceListener(self: *const DataSource, pDSL: ?*DataSourceListener) callconv(.Inline) HRESULT {
        return self.vtable.addDataSourceListener(self, pDSL);
    }
    pub fn removeDataSourceListener(self: *const DataSource, pDSL: ?*DataSourceListener) callconv(.Inline) HRESULT {
        return self.vtable.removeDataSourceListener(self, pDSL);
    }
};

pub const OSPFORMAT = enum(i32) {
    RAW = 0,
    FORMATTED = 1,
    HTML = 2,
    pub const DEFAULT = .RAW;
};
pub const OSPFORMAT_RAW = OSPFORMAT.RAW;
pub const OSPFORMAT_DEFAULT = OSPFORMAT.RAW;
pub const OSPFORMAT_FORMATTED = OSPFORMAT.FORMATTED;
pub const OSPFORMAT_HTML = OSPFORMAT.HTML;

pub const OSPRW = enum(i32) {
    DEFAULT = 1,
    READONLY = 0,
    MIXED = 2,
    pub const READWRITE = .DEFAULT;
};
pub const OSPRW_DEFAULT = OSPRW.DEFAULT;
pub const OSPRW_READONLY = OSPRW.READONLY;
pub const OSPRW_READWRITE = OSPRW.DEFAULT;
pub const OSPRW_MIXED = OSPRW.MIXED;

pub const OSPFIND = enum(i32) {
    DEFAULT = 0,
    UP = 1,
    CASESENSITIVE = 2,
    UPCASESENSITIVE = 3,
};
pub const OSPFIND_DEFAULT = OSPFIND.DEFAULT;
pub const OSPFIND_UP = OSPFIND.UP;
pub const OSPFIND_CASESENSITIVE = OSPFIND.CASESENSITIVE;
pub const OSPFIND_UPCASESENSITIVE = OSPFIND.UPCASESENSITIVE;

pub const OSPCOMP = enum(i32) {
    EQ = 1,
    LT = 2,
    LE = 3,
    GE = 4,
    GT = 5,
    NE = 6,
    pub const DEFAULT = .EQ;
};
pub const OSPCOMP_EQ = OSPCOMP.EQ;
pub const OSPCOMP_DEFAULT = OSPCOMP.EQ;
pub const OSPCOMP_LT = OSPCOMP.LT;
pub const OSPCOMP_LE = OSPCOMP.LE;
pub const OSPCOMP_GE = OSPCOMP.GE;
pub const OSPCOMP_GT = OSPCOMP.GT;
pub const OSPCOMP_NE = OSPCOMP.NE;

pub const OSPXFER = enum(i32) {
    COMPLETE = 0,
    ABORT = 1,
    ERROR = 2,
};
pub const OSPXFER_COMPLETE = OSPXFER.COMPLETE;
pub const OSPXFER_ABORT = OSPXFER.ABORT;
pub const OSPXFER_ERROR = OSPXFER.ERROR;

const IID_OLEDBSimpleProviderListener_Value = Guid.initString("e0e270c1-c0be-11d0-8fe4-00a0c90a6341");
pub const IID_OLEDBSimpleProviderListener = &IID_OLEDBSimpleProviderListener_Value;
pub const OLEDBSimpleProviderListener = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        aboutToChangeCell: *const fn(
            self: *const OLEDBSimpleProviderListener,
            iRow: isize,
            iColumn: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cellChanged: *const fn(
            self: *const OLEDBSimpleProviderListener,
            iRow: isize,
            iColumn: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        aboutToDeleteRows: *const fn(
            self: *const OLEDBSimpleProviderListener,
            iRow: isize,
            cRows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deletedRows: *const fn(
            self: *const OLEDBSimpleProviderListener,
            iRow: isize,
            cRows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        aboutToInsertRows: *const fn(
            self: *const OLEDBSimpleProviderListener,
            iRow: isize,
            cRows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertedRows: *const fn(
            self: *const OLEDBSimpleProviderListener,
            iRow: isize,
            cRows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rowsAvailable: *const fn(
            self: *const OLEDBSimpleProviderListener,
            iRow: isize,
            cRows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        transferComplete: *const fn(
            self: *const OLEDBSimpleProviderListener,
            xfer: OSPXFER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn aboutToChangeCell(self: *const OLEDBSimpleProviderListener, iRow: isize, iColumn: isize) callconv(.Inline) HRESULT {
        return self.vtable.aboutToChangeCell(self, iRow, iColumn);
    }
    pub fn cellChanged(self: *const OLEDBSimpleProviderListener, iRow: isize, iColumn: isize) callconv(.Inline) HRESULT {
        return self.vtable.cellChanged(self, iRow, iColumn);
    }
    pub fn aboutToDeleteRows(self: *const OLEDBSimpleProviderListener, iRow: isize, cRows: isize) callconv(.Inline) HRESULT {
        return self.vtable.aboutToDeleteRows(self, iRow, cRows);
    }
    pub fn deletedRows(self: *const OLEDBSimpleProviderListener, iRow: isize, cRows: isize) callconv(.Inline) HRESULT {
        return self.vtable.deletedRows(self, iRow, cRows);
    }
    pub fn aboutToInsertRows(self: *const OLEDBSimpleProviderListener, iRow: isize, cRows: isize) callconv(.Inline) HRESULT {
        return self.vtable.aboutToInsertRows(self, iRow, cRows);
    }
    pub fn insertedRows(self: *const OLEDBSimpleProviderListener, iRow: isize, cRows: isize) callconv(.Inline) HRESULT {
        return self.vtable.insertedRows(self, iRow, cRows);
    }
    pub fn rowsAvailable(self: *const OLEDBSimpleProviderListener, iRow: isize, cRows: isize) callconv(.Inline) HRESULT {
        return self.vtable.rowsAvailable(self, iRow, cRows);
    }
    pub fn transferComplete(self: *const OLEDBSimpleProviderListener, xfer: OSPXFER) callconv(.Inline) HRESULT {
        return self.vtable.transferComplete(self, xfer);
    }
};

const IID_OLEDBSimpleProvider_Value = Guid.initString("e0e270c0-c0be-11d0-8fe4-00a0c90a6341");
pub const IID_OLEDBSimpleProvider = &IID_OLEDBSimpleProvider_Value;
pub const OLEDBSimpleProvider = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getRowCount: *const fn(
            self: *const OLEDBSimpleProvider,
            pcRows: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getColumnCount: *const fn(
            self: *const OLEDBSimpleProvider,
            pcColumns: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRWStatus: *const fn(
            self: *const OLEDBSimpleProvider,
            iRow: isize,
            iColumn: isize,
            prwStatus: ?*OSPRW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getVariant: *const fn(
            self: *const OLEDBSimpleProvider,
            iRow: isize,
            iColumn: isize,
            format: OSPFORMAT,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setVariant: *const fn(
            self: *const OLEDBSimpleProvider,
            iRow: isize,
            iColumn: isize,
            format: OSPFORMAT,
            Var: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getLocale: *const fn(
            self: *const OLEDBSimpleProvider,
            pbstrLocale: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRows: *const fn(
            self: *const OLEDBSimpleProvider,
            iRow: isize,
            cRows: isize,
            pcRowsDeleted: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRows: *const fn(
            self: *const OLEDBSimpleProvider,
            iRow: isize,
            cRows: isize,
            pcRowsInserted: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        find: *const fn(
            self: *const OLEDBSimpleProvider,
            iRowStart: isize,
            iColumn: isize,
            val: VARIANT,
            findFlags: OSPFIND,
            compType: OSPCOMP,
            piRowFound: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addOLEDBSimpleProviderListener: *const fn(
            self: *const OLEDBSimpleProvider,
            pospIListener: ?*OLEDBSimpleProviderListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeOLEDBSimpleProviderListener: *const fn(
            self: *const OLEDBSimpleProvider,
            pospIListener: ?*OLEDBSimpleProviderListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isAsync: *const fn(
            self: *const OLEDBSimpleProvider,
            pbAsynch: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getEstimatedRows: *const fn(
            self: *const OLEDBSimpleProvider,
            piRows: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stopTransfer: *const fn(
            self: *const OLEDBSimpleProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn getRowCount(self: *const OLEDBSimpleProvider, pcRows: ?*isize) callconv(.Inline) HRESULT {
        return self.vtable.getRowCount(self, pcRows);
    }
    pub fn getColumnCount(self: *const OLEDBSimpleProvider, pcColumns: ?*isize) callconv(.Inline) HRESULT {
        return self.vtable.getColumnCount(self, pcColumns);
    }
    pub fn getRWStatus(self: *const OLEDBSimpleProvider, iRow: isize, iColumn: isize, prwStatus: ?*OSPRW) callconv(.Inline) HRESULT {
        return self.vtable.getRWStatus(self, iRow, iColumn, prwStatus);
    }
    pub fn getVariant(self: *const OLEDBSimpleProvider, iRow: isize, iColumn: isize, format: OSPFORMAT, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.getVariant(self, iRow, iColumn, format, pVar);
    }
    pub fn setVariant(self: *const OLEDBSimpleProvider, iRow: isize, iColumn: isize, format: OSPFORMAT, Var: VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.setVariant(self, iRow, iColumn, format, Var);
    }
    pub fn getLocale(self: *const OLEDBSimpleProvider, pbstrLocale: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.getLocale(self, pbstrLocale);
    }
    pub fn deleteRows(self: *const OLEDBSimpleProvider, iRow: isize, cRows: isize, pcRowsDeleted: ?*isize) callconv(.Inline) HRESULT {
        return self.vtable.deleteRows(self, iRow, cRows, pcRowsDeleted);
    }
    pub fn insertRows(self: *const OLEDBSimpleProvider, iRow: isize, cRows: isize, pcRowsInserted: ?*isize) callconv(.Inline) HRESULT {
        return self.vtable.insertRows(self, iRow, cRows, pcRowsInserted);
    }
    pub fn find(self: *const OLEDBSimpleProvider, iRowStart: isize, iColumn: isize, val: VARIANT, findFlags: OSPFIND, compType: OSPCOMP, piRowFound: ?*isize) callconv(.Inline) HRESULT {
        return self.vtable.find(self, iRowStart, iColumn, val, findFlags, compType, piRowFound);
    }
    pub fn addOLEDBSimpleProviderListener(self: *const OLEDBSimpleProvider, pospIListener: ?*OLEDBSimpleProviderListener) callconv(.Inline) HRESULT {
        return self.vtable.addOLEDBSimpleProviderListener(self, pospIListener);
    }
    pub fn removeOLEDBSimpleProviderListener(self: *const OLEDBSimpleProvider, pospIListener: ?*OLEDBSimpleProviderListener) callconv(.Inline) HRESULT {
        return self.vtable.removeOLEDBSimpleProviderListener(self, pospIListener);
    }
    pub fn isAsync(self: *const OLEDBSimpleProvider, pbAsynch: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.isAsync(self, pbAsynch);
    }
    pub fn getEstimatedRows(self: *const OLEDBSimpleProvider, piRows: ?*isize) callconv(.Inline) HRESULT {
        return self.vtable.getEstimatedRows(self, piRows);
    }
    pub fn stopTransfer(self: *const OLEDBSimpleProvider) callconv(.Inline) HRESULT {
        return self.vtable.stopTransfer(self);
    }
};

const IID_DataSourceObject_Value = Guid.initString("0ae9a4e4-18d4-11d1-b3b3-00aa00c1a924");
pub const IID_DataSourceObject = &IID_DataSourceObject_Value;
pub const DataSourceObject = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
};

const CLSID_DataLinks_Value = Guid.initString("2206cdb2-19c1-11d1-89e0-00c04fd7a829");
pub const CLSID_DataLinks = &CLSID_DataLinks_Value;

const CLSID_MSDAINITIALIZE_Value = Guid.initString("2206cdb0-19c1-11d1-89e0-00c04fd7a829");
pub const CLSID_MSDAINITIALIZE = &CLSID_MSDAINITIALIZE_Value;

const CLSID_PDPO_Value = Guid.initString("ccb4ec60-b9dc-11d1-ac80-00a0c9034873");
pub const CLSID_PDPO = &CLSID_PDPO_Value;

const CLSID_RootBinder_Value = Guid.initString("ff151822-b0bf-11d1-a80d-000000000000");
pub const CLSID_RootBinder = &CLSID_RootBinder_Value;

pub const EBindInfoOptions = enum(i32) {
    R = 1,
};
pub const BIO_BINDER = EBindInfoOptions.R;

const IID_IService_Value = Guid.initString("06210e88-01f5-11d1-b512-0080c781c384");
pub const IID_IService = &IID_IService_Value;
pub const IService = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvokeService: *const fn(
            self: *const IService,
            pUnkInner: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn InvokeService(self: *const IService, pUnkInner: ?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.InvokeService(self, pUnkInner);
    }
};

pub const DBPROMPTOPTIONSENUM = enum(i32) {
    NONE = 0,
    WIZARDSHEET = 1,
    PROPERTYSHEET = 2,
    BROWSEONLY = 8,
    DISABLE_PROVIDER_SELECTION = 16,
    DISABLESAVEPASSWORD = 32,
};
pub const DBPROMPTOPTIONS_NONE = DBPROMPTOPTIONSENUM.NONE;
pub const DBPROMPTOPTIONS_WIZARDSHEET = DBPROMPTOPTIONSENUM.WIZARDSHEET;
pub const DBPROMPTOPTIONS_PROPERTYSHEET = DBPROMPTOPTIONSENUM.PROPERTYSHEET;
pub const DBPROMPTOPTIONS_BROWSEONLY = DBPROMPTOPTIONSENUM.BROWSEONLY;
pub const DBPROMPTOPTIONS_DISABLE_PROVIDER_SELECTION = DBPROMPTOPTIONSENUM.DISABLE_PROVIDER_SELECTION;
pub const DBPROMPTOPTIONS_DISABLESAVEPASSWORD = DBPROMPTOPTIONSENUM.DISABLESAVEPASSWORD;

const IID_IDBPromptInitialize_Value = Guid.initString("2206ccb0-19c1-11d1-89e0-00c04fd7a829");
pub const IID_IDBPromptInitialize = &IID_IDBPromptInitialize_Value;
pub const IDBPromptInitialize = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PromptDataSource: *const fn(
            self: *const IDBPromptInitialize,
            pUnkOuter: ?*IUnknown,
            hWndParent: ?HWND,
            dwPromptOptions: u32,
            cSourceTypeFilter: u32,
            rgSourceTypeFilter: ?[*]u32,
            pwszszzProviderFilter: ?[*:0]const u16,
            riid: ?*const Guid,
            ppDataSource: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PromptFileName: *const fn(
            self: *const IDBPromptInitialize,
            hWndParent: ?HWND,
            dwPromptOptions: u32,
            pwszInitialDirectory: ?[*:0]const u16,
            pwszInitialFile: ?[*:0]const u16,
            ppwszSelectedFile: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn PromptDataSource(self: *const IDBPromptInitialize, pUnkOuter: ?*IUnknown, hWndParent: ?HWND, dwPromptOptions: u32, cSourceTypeFilter: u32, rgSourceTypeFilter: ?[*]u32, pwszszzProviderFilter: ?[*:0]const u16, riid: ?*const Guid, ppDataSource: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.PromptDataSource(self, pUnkOuter, hWndParent, dwPromptOptions, cSourceTypeFilter, rgSourceTypeFilter, pwszszzProviderFilter, riid, ppDataSource);
    }
    pub fn PromptFileName(self: *const IDBPromptInitialize, hWndParent: ?HWND, dwPromptOptions: u32, pwszInitialDirectory: ?[*:0]const u16, pwszInitialFile: ?[*:0]const u16, ppwszSelectedFile: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.PromptFileName(self, hWndParent, dwPromptOptions, pwszInitialDirectory, pwszInitialFile, ppwszSelectedFile);
    }
};

const IID_IDataInitialize_Value = Guid.initString("2206ccb1-19c1-11d1-89e0-00c04fd7a829");
pub const IID_IDataInitialize = &IID_IDataInitialize_Value;
pub const IDataInitialize = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataSource: *const fn(
            self: *const IDataInitialize,
            pUnkOuter: ?*IUnknown,
            dwClsCtx: u32,
            pwszInitializationString: ?[*:0]const u16,
            riid: ?*const Guid,
            ppDataSource: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInitializationString: *const fn(
            self: *const IDataInitialize,
            pDataSource: ?*IUnknown,
            fIncludePassword: u8,
            ppwszInitString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDBInstance: *const fn(
            self: *const IDataInitialize,
            clsidProvider: ?*const Guid,
            pUnkOuter: ?*IUnknown,
            dwClsCtx: u32,
            pwszReserved: ?PWSTR,
            riid: ?*const Guid,
            ppDataSource: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDBInstanceEx: *const fn(
            self: *const IDataInitialize,
            clsidProvider: ?*const Guid,
            pUnkOuter: ?*IUnknown,
            dwClsCtx: u32,
            pwszReserved: ?PWSTR,
            pServerInfo: ?*COSERVERINFO,
            cmq: u32,
            rgmqResults: [*]MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadStringFromStorage: *const fn(
            self: *const IDataInitialize,
            pwszFileName: ?[*:0]const u16,
            ppwszInitializationString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStringToStorage: *const fn(
            self: *const IDataInitialize,
            pwszFileName: ?[*:0]const u16,
            pwszInitializationString: ?[*:0]const u16,
            dwCreationDisposition: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetDataSource(self: *const IDataInitialize, pUnkOuter: ?*IUnknown, dwClsCtx: u32, pwszInitializationString: ?[*:0]const u16, riid: ?*const Guid, ppDataSource: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetDataSource(self, pUnkOuter, dwClsCtx, pwszInitializationString, riid, ppDataSource);
    }
    pub fn GetInitializationString(self: *const IDataInitialize, pDataSource: ?*IUnknown, fIncludePassword: u8, ppwszInitString: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetInitializationString(self, pDataSource, fIncludePassword, ppwszInitString);
    }
    pub fn CreateDBInstance(self: *const IDataInitialize, clsidProvider: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsCtx: u32, pwszReserved: ?PWSTR, riid: ?*const Guid, ppDataSource: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.CreateDBInstance(self, clsidProvider, pUnkOuter, dwClsCtx, pwszReserved, riid, ppDataSource);
    }
    pub fn CreateDBInstanceEx(self: *const IDataInitialize, clsidProvider: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsCtx: u32, pwszReserved: ?PWSTR, pServerInfo: ?*COSERVERINFO, cmq: u32, rgmqResults: [*]MULTI_QI) callconv(.Inline) HRESULT {
        return self.vtable.CreateDBInstanceEx(self, clsidProvider, pUnkOuter, dwClsCtx, pwszReserved, pServerInfo, cmq, rgmqResults);
    }
    pub fn LoadStringFromStorage(self: *const IDataInitialize, pwszFileName: ?[*:0]const u16, ppwszInitializationString: ?*?PWSTR) callconv(.Inline) HRESULT {
        return self.vtable.LoadStringFromStorage(self, pwszFileName, ppwszInitializationString);
    }
    pub fn WriteStringToStorage(self: *const IDataInitialize, pwszFileName: ?[*:0]const u16, pwszInitializationString: ?[*:0]const u16, dwCreationDisposition: u32) callconv(.Inline) HRESULT {
        return self.vtable.WriteStringToStorage(self, pwszFileName, pwszInitializationString, dwCreationDisposition);
    }
};

const IID_IDataSourceLocator_Value = Guid.initString("2206ccb2-19c1-11d1-89e0-00c04fd7a829");
pub const IID_IDataSourceLocator = &IID_IDataSourceLocator_Value;
pub const IDataSourceLocator = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hWnd: *const fn(
            self: *const IDataSourceLocator,
            phwndParent: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hWnd: *const fn(
            self: *const IDataSourceLocator,
            hwndParent: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PromptNew: *const fn(
            self: *const IDataSourceLocator,
            ppADOConnection: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PromptEdit: *const fn(
            self: *const IDataSourceLocator,
            ppADOConnection: ?*?*IDispatch,
            pbSuccess: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_hWnd(self: *const IDataSourceLocator, phwndParent: ?*i64) callconv(.Inline) HRESULT {
        return self.vtable.get_hWnd(self, phwndParent);
    }
    pub fn put_hWnd(self: *const IDataSourceLocator, hwndParent: i64) callconv(.Inline) HRESULT {
        return self.vtable.put_hWnd(self, hwndParent);
    }
    pub fn PromptNew(self: *const IDataSourceLocator, ppADOConnection: ?*?*IDispatch) callconv(.Inline) HRESULT {
        return self.vtable.PromptNew(self, ppADOConnection);
    }
    pub fn PromptEdit(self: *const IDataSourceLocator, ppADOConnection: ?*?*IDispatch, pbSuccess: ?*i16) callconv(.Inline) HRESULT {
        return self.vtable.PromptEdit(self, ppADOConnection, pbSuccess);
    }
};

pub const KAGREQDIAGFLAGSENUM = enum(i32) {
    HEADER = 1,
    RECORD = 2,
};
pub const KAGREQDIAGFLAGS_HEADER = KAGREQDIAGFLAGSENUM.HEADER;
pub const KAGREQDIAGFLAGS_RECORD = KAGREQDIAGFLAGSENUM.RECORD;

const IID_IRowsetChangeExtInfo_Value = Guid.initString("0c733a8f-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetChangeExtInfo = &IID_IRowsetChangeExtInfo_Value;
pub const IRowsetChangeExtInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOriginalRow: *const fn(
            self: *const IRowsetChangeExtInfo,
            hReserved: usize,
            hRow: usize,
            phRowOriginal: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPendingColumns: *const fn(
            self: *const IRowsetChangeExtInfo,
            hReserved: usize,
            hRow: usize,
            cColumnOrdinals: u32,
            rgiOrdinals: ?*const u32,
            rgColumnStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetOriginalRow(self: *const IRowsetChangeExtInfo, hReserved: usize, hRow: usize, phRowOriginal: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.GetOriginalRow(self, hReserved, hRow, phRowOriginal);
    }
    pub fn GetPendingColumns(self: *const IRowsetChangeExtInfo, hReserved: usize, hRow: usize, cColumnOrdinals: u32, rgiOrdinals: ?*const u32, rgColumnStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetPendingColumns(self, hReserved, hRow, cColumnOrdinals, rgiOrdinals, rgColumnStatus);
    }
};

pub const KAGREQDIAG = extern struct {
    ulDiagFlags: u32,
    vt: u16,
    sDiagField: i16,
};

pub const KAGGETDIAG = extern struct {
    ulSize: u32,
    vDiagInfo: VARIANT,
    sDiagField: i16,
};

const IID_ISQLRequestDiagFields_Value = Guid.initString("228972f0-b5ff-11d0-8a80-00c04fd611cd");
pub const IID_ISQLRequestDiagFields = &IID_ISQLRequestDiagFields_Value;
pub const ISQLRequestDiagFields = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestDiagFields: *const fn(
            self: *const ISQLRequestDiagFields,
            cDiagFields: u32,
            rgDiagFields: [*]KAGREQDIAG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn RequestDiagFields(self: *const ISQLRequestDiagFields, cDiagFields: u32, rgDiagFields: [*]KAGREQDIAG) callconv(.Inline) HRESULT {
        return self.vtable.RequestDiagFields(self, cDiagFields, rgDiagFields);
    }
};

const IID_ISQLGetDiagField_Value = Guid.initString("228972f1-b5ff-11d0-8a80-00c04fd611cd");
pub const IID_ISQLGetDiagField = &IID_ISQLGetDiagField_Value;
pub const ISQLGetDiagField = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDiagField: *const fn(
            self: *const ISQLGetDiagField,
            pDiagInfo: ?*KAGGETDIAG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetDiagField(self: *const ISQLGetDiagField, pDiagInfo: ?*KAGGETDIAG) callconv(.Inline) HRESULT {
        return self.vtable.GetDiagField(self, pDiagInfo);
    }
};

pub const MSDSDBINITPROPENUM = enum(i32) {
    R = 2,
};
pub const DBPROP_MSDS_DBINIT_DATAPROVIDER = MSDSDBINITPROPENUM.R;

pub const MSDSSESSIONPROPENUM = enum(i32) {
    S = 2,
};
pub const DBPROP_MSDS_SESS_UNIQUENAMES = MSDSSESSIONPROPENUM.S;

pub const DATE_STRUCT = extern struct {
    year: i16,
    month: u16,
    day: u16,
};

pub const TIME_STRUCT = extern struct {
    hour: u16,
    minute: u16,
    second: u16,
};

pub const TIMESTAMP_STRUCT = extern struct {
    year: i16,
    month: u16,
    day: u16,
    hour: u16,
    minute: u16,
    second: u16,
    fraction: u32,
};

pub const SQLINTERVAL = enum(i32) {
    YEAR = 1,
    MONTH = 2,
    DAY = 3,
    HOUR = 4,
    MINUTE = 5,
    SECOND = 6,
    YEAR_TO_MONTH = 7,
    DAY_TO_HOUR = 8,
    DAY_TO_MINUTE = 9,
    DAY_TO_SECOND = 10,
    HOUR_TO_MINUTE = 11,
    HOUR_TO_SECOND = 12,
    MINUTE_TO_SECOND = 13,
};
pub const SQL_IS_YEAR = SQLINTERVAL.YEAR;
pub const SQL_IS_MONTH = SQLINTERVAL.MONTH;
pub const SQL_IS_DAY = SQLINTERVAL.DAY;
pub const SQL_IS_HOUR = SQLINTERVAL.HOUR;
pub const SQL_IS_MINUTE = SQLINTERVAL.MINUTE;
pub const SQL_IS_SECOND = SQLINTERVAL.SECOND;
pub const SQL_IS_YEAR_TO_MONTH = SQLINTERVAL.YEAR_TO_MONTH;
pub const SQL_IS_DAY_TO_HOUR = SQLINTERVAL.DAY_TO_HOUR;
pub const SQL_IS_DAY_TO_MINUTE = SQLINTERVAL.DAY_TO_MINUTE;
pub const SQL_IS_DAY_TO_SECOND = SQLINTERVAL.DAY_TO_SECOND;
pub const SQL_IS_HOUR_TO_MINUTE = SQLINTERVAL.HOUR_TO_MINUTE;
pub const SQL_IS_HOUR_TO_SECOND = SQLINTERVAL.HOUR_TO_SECOND;
pub const SQL_IS_MINUTE_TO_SECOND = SQLINTERVAL.MINUTE_TO_SECOND;

pub const tagSQL_YEAR_MONTH = extern struct {
    year: u32,
    month: u32,
};

pub const tagSQL_DAY_SECOND = extern struct {
    day: u32,
    hour: u32,
    minute: u32,
    second: u32,
    fraction: u32,
};

pub const SQL_INTERVAL_STRUCT = extern struct {
    interval_type: SQLINTERVAL,
    interval_sign: i16,
    intval: extern union {
        year_month: tagSQL_YEAR_MONTH,
        day_second: tagSQL_DAY_SECOND,
    },
};

pub const SQL_NUMERIC_STRUCT = extern struct {
    precision: u8,
    scale: i8,
    sign: u8,
    val: [16]u8,
};

pub const dbvarychar = extern struct {
    len: i16,
    str: [8001]i8,
};

pub const dbvarybin = extern struct {
    len: i16,
    array: [8001]u8,
};

pub const dbmoney = extern struct {
    mnyhigh: i32,
    mnylow: u32,
};

pub const dbdatetime = extern struct {
    dtdays: i32,
    dttime: u32,
};

pub const dbdatetime4 = extern struct {
    numdays: u16,
    nummins: u16,
};

pub const sqlperf = extern struct {
    TimerResolution: u32,
    SQLidu: u32,
    SQLiduRows: u32,
    SQLSelects: u32,
    SQLSelectRows: u32,
    Transactions: u32,
    SQLPrepares: u32,
    ExecDirects: u32,
    SQLExecutes: u32,
    CursorOpens: u32,
    CursorSize: u32,
    CursorUsed: u32,
    PercentCursorUsed: f64,
    AvgFetchTime: f64,
    AvgCursorSize: f64,
    AvgCursorUsed: f64,
    SQLFetchTime: u32,
    SQLFetchCount: u32,
    CurrentStmtCount: u32,
    MaxOpenStmt: u32,
    SumOpenStmt: u32,
    CurrentConnectionCount: u32,
    MaxConnectionsOpened: u32,
    SumConnectionsOpened: u32,
    SumConnectiontime: u32,
    AvgTimeOpened: f64,
    ServerRndTrips: u32,
    BuffersSent: u32,
    BuffersRec: u32,
    BytesSent: u32,
    BytesRec: u32,
    msExecutionTime: u32,
    msNetWorkServerTime: u32,
};

pub const DBPROPENUM25_DEPRECATED = enum(i32) {
    CommandCost = 141,
    CommandTree = 142,
    CommandValidate = 143,
    DBSchemaCommand = 144,
    ProvideMoniker = 125,
    Query = 146,
    ReadData = 147,
    RowsetAsynch = 148,
    RowsetCopyRows = 149,
    RowsetKeys = 151,
    RowsetNewRowAfter = 152,
    RowsetNextRowset = 153,
    RowsetWatchAll = 155,
    RowsetWatchNotify = 156,
    RowsetWatchRegion = 157,
    RowsetWithParameters = 158,
};
pub const DBPROP_ICommandCost = DBPROPENUM25_DEPRECATED.CommandCost;
pub const DBPROP_ICommandTree = DBPROPENUM25_DEPRECATED.CommandTree;
pub const DBPROP_ICommandValidate = DBPROPENUM25_DEPRECATED.CommandValidate;
pub const DBPROP_IDBSchemaCommand = DBPROPENUM25_DEPRECATED.DBSchemaCommand;
pub const DBPROP_IProvideMoniker = DBPROPENUM25_DEPRECATED.ProvideMoniker;
pub const DBPROP_IQuery = DBPROPENUM25_DEPRECATED.Query;
pub const DBPROP_IReadData = DBPROPENUM25_DEPRECATED.ReadData;
pub const DBPROP_IRowsetAsynch = DBPROPENUM25_DEPRECATED.RowsetAsynch;
pub const DBPROP_IRowsetCopyRows = DBPROPENUM25_DEPRECATED.RowsetCopyRows;
pub const DBPROP_IRowsetKeys = DBPROPENUM25_DEPRECATED.RowsetKeys;
pub const DBPROP_IRowsetNewRowAfter = DBPROPENUM25_DEPRECATED.RowsetNewRowAfter;
pub const DBPROP_IRowsetNextRowset = DBPROPENUM25_DEPRECATED.RowsetNextRowset;
pub const DBPROP_IRowsetWatchAll = DBPROPENUM25_DEPRECATED.RowsetWatchAll;
pub const DBPROP_IRowsetWatchNotify = DBPROPENUM25_DEPRECATED.RowsetWatchNotify;
pub const DBPROP_IRowsetWatchRegion = DBPROPENUM25_DEPRECATED.RowsetWatchRegion;
pub const DBPROP_IRowsetWithParameters = DBPROPENUM25_DEPRECATED.RowsetWithParameters;

pub const DBREASONENUM25 = enum(i32) {
    ROWSADDED = 19,
    POPULATIONCOMPLETE = 20,
    POPULATIONSTOPPED = 21,
};
pub const DBREASON_ROWSET_ROWSADDED = DBREASONENUM25.ROWSADDED;
pub const DBREASON_ROWSET_POPULATIONCOMPLETE = DBREASONENUM25.POPULATIONCOMPLETE;
pub const DBREASON_ROWSET_POPULATIONSTOPPED = DBREASONENUM25.POPULATIONSTOPPED;

const IID_IRowsetNextRowset_Value = Guid.initString("0c733a72-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetNextRowset = &IID_IRowsetNextRowset_Value;
pub const IRowsetNextRowset = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextRowset: *const fn(
            self: *const IRowsetNextRowset,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppNextRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetNextRowset(self: *const IRowsetNextRowset, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppNextRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.GetNextRowset(self, pUnkOuter, riid, ppNextRowset);
    }
};

const IID_IRowsetNewRowAfter_Value = Guid.initString("0c733a71-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetNewRowAfter = &IID_IRowsetNewRowAfter_Value;
pub const IRowsetNewRowAfter = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNewDataAfter: *const fn(
            self: *const IRowsetNewRowAfter,
            hChapter: usize,
            cbbmPrevious: u32,
            pbmPrevious: ?*const u8,
            hAccessor: usize,
            pData: ?*u8,
            phRow: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn SetNewDataAfter(self: *const IRowsetNewRowAfter, hChapter: usize, cbbmPrevious: u32, pbmPrevious: ?*const u8, hAccessor: usize, pData: ?*u8, phRow: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.SetNewDataAfter(self, hChapter, cbbmPrevious, pbmPrevious, hAccessor, pData, phRow);
    }
};

const IID_IRowsetWithParameters_Value = Guid.initString("0c733a6e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWithParameters = &IID_IRowsetWithParameters_Value;
pub const IRowsetWithParameters = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParameterInfo: *const fn(
            self: *const IRowsetWithParameters,
            pcParams: ?*usize,
            prgParamInfo: ?*?*DBPARAMINFO,
            ppNamesBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Requery: *const fn(
            self: *const IRowsetWithParameters,
            pParams: ?*DBPARAMS,
            pulErrorParam: ?*u32,
            phReserved: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetParameterInfo(self: *const IRowsetWithParameters, pcParams: ?*usize, prgParamInfo: ?*?*DBPARAMINFO, ppNamesBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetParameterInfo(self, pcParams, prgParamInfo, ppNamesBuffer);
    }
    pub fn Requery(self: *const IRowsetWithParameters, pParams: ?*DBPARAMS, pulErrorParam: ?*u32, phReserved: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.Requery(self, pParams, pulErrorParam, phReserved);
    }
};

const IID_IRowsetAsynch_Value = Guid.initString("0c733a0f-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetAsynch = &IID_IRowsetAsynch_Value;
pub const IRowsetAsynch = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RatioFinished: *const fn(
            self: *const IRowsetAsynch,
            pulDenominator: ?*usize,
            pulNumerator: ?*usize,
            pcRows: ?*usize,
            pfNewRows: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn(
            self: *const IRowsetAsynch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn RatioFinished(self: *const IRowsetAsynch, pulDenominator: ?*usize, pulNumerator: ?*usize, pcRows: ?*usize, pfNewRows: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.RatioFinished(self, pulDenominator, pulNumerator, pcRows, pfNewRows);
    }
    pub fn Stop(self: *const IRowsetAsynch) callconv(.Inline) HRESULT {
        return self.vtable.Stop(self);
    }
};

const IID_IRowsetKeys_Value = Guid.initString("0c733a12-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetKeys = &IID_IRowsetKeys_Value;
pub const IRowsetKeys = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ListKeys: *const fn(
            self: *const IRowsetKeys,
            pcColumns: ?*usize,
            prgColumns: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn ListKeys(self: *const IRowsetKeys, pcColumns: ?*usize, prgColumns: ?*?*usize) callconv(.Inline) HRESULT {
        return self.vtable.ListKeys(self, pcColumns, prgColumns);
    }
};

const IID_IRowsetWatchAll_Value = Guid.initString("0c733a73-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWatchAll = &IID_IRowsetWatchAll_Value;
pub const IRowsetWatchAll = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Acknowledge: *const fn(
            self: *const IRowsetWatchAll,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: *const fn(
            self: *const IRowsetWatchAll,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopWatching: *const fn(
            self: *const IRowsetWatchAll,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Acknowledge(self: *const IRowsetWatchAll) callconv(.Inline) HRESULT {
        return self.vtable.Acknowledge(self);
    }
    pub fn Start(self: *const IRowsetWatchAll) callconv(.Inline) HRESULT {
        return self.vtable.Start(self);
    }
    pub fn StopWatching(self: *const IRowsetWatchAll) callconv(.Inline) HRESULT {
        return self.vtable.StopWatching(self);
    }
};

pub const DBWATCHNOTIFYENUM = enum(i32) {
    ROWSCHANGED = 1,
    QUERYDONE = 2,
    QUERYREEXECUTED = 3,
};
pub const DBWATCHNOTIFY_ROWSCHANGED = DBWATCHNOTIFYENUM.ROWSCHANGED;
pub const DBWATCHNOTIFY_QUERYDONE = DBWATCHNOTIFYENUM.QUERYDONE;
pub const DBWATCHNOTIFY_QUERYREEXECUTED = DBWATCHNOTIFYENUM.QUERYREEXECUTED;

const IID_IRowsetWatchNotify_Value = Guid.initString("0c733a44-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWatchNotify = &IID_IRowsetWatchNotify_Value;
pub const IRowsetWatchNotify = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: *const fn(
            self: *const IRowsetWatchNotify,
            pRowset: ?*IRowset,
            eChangeReason: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OnChange(self: *const IRowsetWatchNotify, pRowset: ?*IRowset, eChangeReason: u32) callconv(.Inline) HRESULT {
        return self.vtable.OnChange(self, pRowset, eChangeReason);
    }
};

pub const DBWATCHMODEENUM = enum(i32) {
    ALL = 1,
    EXTEND = 2,
    MOVE = 4,
    COUNT = 8,
};
pub const DBWATCHMODE_ALL = DBWATCHMODEENUM.ALL;
pub const DBWATCHMODE_EXTEND = DBWATCHMODEENUM.EXTEND;
pub const DBWATCHMODE_MOVE = DBWATCHMODEENUM.MOVE;
pub const DBWATCHMODE_COUNT = DBWATCHMODEENUM.COUNT;

pub const DBROWCHANGEKINDENUM = enum(i32) {
    INSERT = 0,
    DELETE = 1,
    UPDATE = 2,
    COUNT = 3,
};
pub const DBROWCHANGEKIND_INSERT = DBROWCHANGEKINDENUM.INSERT;
pub const DBROWCHANGEKIND_DELETE = DBROWCHANGEKINDENUM.DELETE;
pub const DBROWCHANGEKIND_UPDATE = DBROWCHANGEKINDENUM.UPDATE;
pub const DBROWCHANGEKIND_COUNT = DBROWCHANGEKINDENUM.COUNT;


const IID_IRowsetWatchRegion_Value = Guid.initString("0c733a45-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWatchRegion = &IID_IRowsetWatchRegion_Value;
pub const IRowsetWatchRegion = extern union {
    pub const VTable = extern struct {
        base: IRowsetWatchAll.VTable,
        CreateWatchRegion: *const fn(
            self: *const IRowsetWatchRegion,
            dwWatchMode: u32,
            phRegion: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeWatchMode: *const fn(
            self: *const IRowsetWatchRegion,
            hRegion: usize,
            dwWatchMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteWatchRegion: *const fn(
            self: *const IRowsetWatchRegion,
            hRegion: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWatchRegionInfo: *const fn(
            self: *const IRowsetWatchRegion,
            hRegion: usize,
            pdwWatchMode: ?*u32,
            phChapter: ?*usize,
            pcbBookmark: ?*usize,
            ppBookmark: ?*?*u8,
            pcRows: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: *const fn(
            self: *const IRowsetWatchRegion,
            pcChangesObtained: ?*usize,
            prgChanges: ?*?*tagDBROWWATCHRANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShrinkWatchRegion: *const fn(
            self: *const IRowsetWatchRegion,
            hRegion: usize,
            hChapter: usize,
            cbBookmark: usize,
            pBookmark: ?*u8,
            cRows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IRowsetWatchAll: IRowsetWatchAll,
    IUnknown: IUnknown,
    pub fn CreateWatchRegion(self: *const IRowsetWatchRegion, dwWatchMode: u32, phRegion: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.CreateWatchRegion(self, dwWatchMode, phRegion);
    }
    pub fn ChangeWatchMode(self: *const IRowsetWatchRegion, hRegion: usize, dwWatchMode: u32) callconv(.Inline) HRESULT {
        return self.vtable.ChangeWatchMode(self, hRegion, dwWatchMode);
    }
    pub fn DeleteWatchRegion(self: *const IRowsetWatchRegion, hRegion: usize) callconv(.Inline) HRESULT {
        return self.vtable.DeleteWatchRegion(self, hRegion);
    }
    pub fn GetWatchRegionInfo(self: *const IRowsetWatchRegion, hRegion: usize, pdwWatchMode: ?*u32, phChapter: ?*usize, pcbBookmark: ?*usize, ppBookmark: ?*?*u8, pcRows: ?*isize) callconv(.Inline) HRESULT {
        return self.vtable.GetWatchRegionInfo(self, hRegion, pdwWatchMode, phChapter, pcbBookmark, ppBookmark, pcRows);
    }
    pub fn Refresh(self: *const IRowsetWatchRegion, pcChangesObtained: ?*usize, prgChanges: ?*?*tagDBROWWATCHRANGE) callconv(.Inline) HRESULT {
        return self.vtable.Refresh(self, pcChangesObtained, prgChanges);
    }
    pub fn ShrinkWatchRegion(self: *const IRowsetWatchRegion, hRegion: usize, hChapter: usize, cbBookmark: usize, pBookmark: ?*u8, cRows: isize) callconv(.Inline) HRESULT {
        return self.vtable.ShrinkWatchRegion(self, hRegion, hChapter, cbBookmark, pBookmark, cRows);
    }
};

const IID_IRowsetCopyRows_Value = Guid.initString("0c733a6b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetCopyRows = &IID_IRowsetCopyRows_Value;
pub const IRowsetCopyRows = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CloseSource: *const fn(
            self: *const IRowsetCopyRows,
            hSourceID: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyByHROWS: *const fn(
            self: *const IRowsetCopyRows,
            hSourceID: u16,
            hReserved: usize,
            cRows: isize,
            rghRows: ?*const usize,
            bFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyRows: *const fn(
            self: *const IRowsetCopyRows,
            hSourceID: u16,
            hReserved: usize,
            cRows: isize,
            bFlags: u32,
            pcRowsCopied: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineSource: *const fn(
            self: *const IRowsetCopyRows,
            pRowsetSource: ?*IRowset,
            cColIds: usize,
            rgSourceColumns: ?*const isize,
            rgTargetColumns: ?*const isize,
            phSourceID: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CloseSource(self: *const IRowsetCopyRows, hSourceID: u16) callconv(.Inline) HRESULT {
        return self.vtable.CloseSource(self, hSourceID);
    }
    pub fn CopyByHROWS(self: *const IRowsetCopyRows, hSourceID: u16, hReserved: usize, cRows: isize, rghRows: ?*const usize, bFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.CopyByHROWS(self, hSourceID, hReserved, cRows, rghRows, bFlags);
    }
    pub fn CopyRows(self: *const IRowsetCopyRows, hSourceID: u16, hReserved: usize, cRows: isize, bFlags: u32, pcRowsCopied: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.CopyRows(self, hSourceID, hReserved, cRows, bFlags, pcRowsCopied);
    }
    pub fn DefineSource(self: *const IRowsetCopyRows, pRowsetSource: ?*IRowset, cColIds: usize, rgSourceColumns: ?*const isize, rgTargetColumns: ?*const isize, phSourceID: ?*u16) callconv(.Inline) HRESULT {
        return self.vtable.DefineSource(self, pRowsetSource, cColIds, rgSourceColumns, rgTargetColumns, phSourceID);
    }
};

const IID_IReadData_Value = Guid.initString("0c733a6a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IReadData = &IID_IReadData_Value;
pub const IReadData = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadData: *const fn(
            self: *const IReadData,
            hChapter: usize,
            cbBookmark: usize,
            pBookmark: ?*const u8,
            lRowsOffset: isize,
            hAccessor: usize,
            cRows: isize,
            pcRowsObtained: ?*usize,
            ppFixedData: ?*?*u8,
            pcbVariableTotal: ?*usize,
            ppVariableData: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseChapter: *const fn(
            self: *const IReadData,
            hChapter: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn ReadData(self: *const IReadData, hChapter: usize, cbBookmark: usize, pBookmark: ?*const u8, lRowsOffset: isize, hAccessor: usize, cRows: isize, pcRowsObtained: ?*usize, ppFixedData: ?*?*u8, pcbVariableTotal: ?*usize, ppVariableData: ?*?*u8) callconv(.Inline) HRESULT {
        return self.vtable.ReadData(self, hChapter, cbBookmark, pBookmark, lRowsOffset, hAccessor, cRows, pcRowsObtained, ppFixedData, pcbVariableTotal, ppVariableData);
    }
    pub fn ReleaseChapter(self: *const IReadData, hChapter: usize) callconv(.Inline) HRESULT {
        return self.vtable.ReleaseChapter(self, hChapter);
    }
};

pub const DBRESOURCEKINDENUM = enum(i32) {
    INVALID = 0,
    TOTAL = 1,
    CPU = 2,
    MEMORY = 3,
    DISK = 4,
    NETWORK = 5,
    RESPONSE = 6,
    ROWS = 7,
    OTHER = 8,
};
pub const DBRESOURCE_INVALID = DBRESOURCEKINDENUM.INVALID;
pub const DBRESOURCE_TOTAL = DBRESOURCEKINDENUM.TOTAL;
pub const DBRESOURCE_CPU = DBRESOURCEKINDENUM.CPU;
pub const DBRESOURCE_MEMORY = DBRESOURCEKINDENUM.MEMORY;
pub const DBRESOURCE_DISK = DBRESOURCEKINDENUM.DISK;
pub const DBRESOURCE_NETWORK = DBRESOURCEKINDENUM.NETWORK;
pub const DBRESOURCE_RESPONSE = DBRESOURCEKINDENUM.RESPONSE;
pub const DBRESOURCE_ROWS = DBRESOURCEKINDENUM.ROWS;
pub const DBRESOURCE_OTHER = DBRESOURCEKINDENUM.OTHER;

pub const DBCOSTUNITENUM = enum(i32) {
    INVALID = 0,
    WEIGHT = 1,
    PERCENT = 2,
    MAXIMUM = 4,
    MINIMUM = 8,
    MICRO_SECOND = 16,
    MILLI_SECOND = 32,
    SECOND = 64,
    MINUTE = 128,
    HOUR = 256,
    BYTE = 512,
    KILO_BYTE = 1024,
    MEGA_BYTE = 2048,
    GIGA_BYTE = 4096,
    NUM_MSGS = 8192,
    NUM_LOCKS = 16384,
    NUM_ROWS = 32768,
    OTHER = 65536,
};
pub const DBUNIT_INVALID = DBCOSTUNITENUM.INVALID;
pub const DBUNIT_WEIGHT = DBCOSTUNITENUM.WEIGHT;
pub const DBUNIT_PERCENT = DBCOSTUNITENUM.PERCENT;
pub const DBUNIT_MAXIMUM = DBCOSTUNITENUM.MAXIMUM;
pub const DBUNIT_MINIMUM = DBCOSTUNITENUM.MINIMUM;
pub const DBUNIT_MICRO_SECOND = DBCOSTUNITENUM.MICRO_SECOND;
pub const DBUNIT_MILLI_SECOND = DBCOSTUNITENUM.MILLI_SECOND;
pub const DBUNIT_SECOND = DBCOSTUNITENUM.SECOND;
pub const DBUNIT_MINUTE = DBCOSTUNITENUM.MINUTE;
pub const DBUNIT_HOUR = DBCOSTUNITENUM.HOUR;
pub const DBUNIT_BYTE = DBCOSTUNITENUM.BYTE;
pub const DBUNIT_KILO_BYTE = DBCOSTUNITENUM.KILO_BYTE;
pub const DBUNIT_MEGA_BYTE = DBCOSTUNITENUM.MEGA_BYTE;
pub const DBUNIT_GIGA_BYTE = DBCOSTUNITENUM.GIGA_BYTE;
pub const DBUNIT_NUM_MSGS = DBCOSTUNITENUM.NUM_MSGS;
pub const DBUNIT_NUM_LOCKS = DBCOSTUNITENUM.NUM_LOCKS;
pub const DBUNIT_NUM_ROWS = DBCOSTUNITENUM.NUM_ROWS;
pub const DBUNIT_OTHER = DBCOSTUNITENUM.OTHER;


pub const DBEXECLIMITSENUM = enum(i32) {
    ABORT = 1,
    STOP = 2,
    SUSPEND = 3,
};
pub const DBEXECLIMITS_ABORT = DBEXECLIMITSENUM.ABORT;
pub const DBEXECLIMITS_STOP = DBEXECLIMITSENUM.STOP;
pub const DBEXECLIMITS_SUSPEND = DBEXECLIMITSENUM.SUSPEND;

const IID_ICommandCost_Value = Guid.initString("0c733a4e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandCost = &IID_ICommandCost_Value;
pub const ICommandCost = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAccumulatedCost: *const fn(
            self: *const ICommandCost,
            pwszRowsetName: ?[*:0]const u16,
            pcCostLimits: ?*u32,
            prgCostLimits: ?*?*DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCostEstimate: *const fn(
            self: *const ICommandCost,
            pwszRowsetName: ?[*:0]const u16,
            pcCostEstimates: ?*u32,
            prgCostEstimates: ?*DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCostGoals: *const fn(
            self: *const ICommandCost,
            pwszRowsetName: ?[*:0]const u16,
            pcCostGoals: ?*u32,
            prgCostGoals: ?*DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCostLimits: *const fn(
            self: *const ICommandCost,
            pwszRowsetName: ?[*:0]const u16,
            pcCostLimits: ?*u32,
            prgCostLimits: ?*DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCostGoals: *const fn(
            self: *const ICommandCost,
            pwszRowsetName: ?[*:0]const u16,
            cCostGoals: u32,
            rgCostGoals: ?*const DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCostLimits: *const fn(
            self: *const ICommandCost,
            pwszRowsetName: ?[*:0]const u16,
            cCostLimits: u32,
            prgCostLimits: ?*DBCOST,
            dwExecutionFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetAccumulatedCost(self: *const ICommandCost, pwszRowsetName: ?[*:0]const u16, pcCostLimits: ?*u32, prgCostLimits: ?*?*DBCOST) callconv(.Inline) HRESULT {
        return self.vtable.GetAccumulatedCost(self, pwszRowsetName, pcCostLimits, prgCostLimits);
    }
    pub fn GetCostEstimate(self: *const ICommandCost, pwszRowsetName: ?[*:0]const u16, pcCostEstimates: ?*u32, prgCostEstimates: ?*DBCOST) callconv(.Inline) HRESULT {
        return self.vtable.GetCostEstimate(self, pwszRowsetName, pcCostEstimates, prgCostEstimates);
    }
    pub fn GetCostGoals(self: *const ICommandCost, pwszRowsetName: ?[*:0]const u16, pcCostGoals: ?*u32, prgCostGoals: ?*DBCOST) callconv(.Inline) HRESULT {
        return self.vtable.GetCostGoals(self, pwszRowsetName, pcCostGoals, prgCostGoals);
    }
    pub fn GetCostLimits(self: *const ICommandCost, pwszRowsetName: ?[*:0]const u16, pcCostLimits: ?*u32, prgCostLimits: ?*DBCOST) callconv(.Inline) HRESULT {
        return self.vtable.GetCostLimits(self, pwszRowsetName, pcCostLimits, prgCostLimits);
    }
    pub fn SetCostGoals(self: *const ICommandCost, pwszRowsetName: ?[*:0]const u16, cCostGoals: u32, rgCostGoals: ?*const DBCOST) callconv(.Inline) HRESULT {
        return self.vtable.SetCostGoals(self, pwszRowsetName, cCostGoals, rgCostGoals);
    }
    pub fn SetCostLimits(self: *const ICommandCost, pwszRowsetName: ?[*:0]const u16, cCostLimits: u32, prgCostLimits: ?*DBCOST, dwExecutionFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetCostLimits(self, pwszRowsetName, cCostLimits, prgCostLimits, dwExecutionFlags);
    }
};

const IID_ICommandValidate_Value = Guid.initString("0c733a18-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandValidate = &IID_ICommandValidate_Value;
pub const ICommandValidate = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateCompletely: *const fn(
            self: *const ICommandValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateSyntax: *const fn(
            self: *const ICommandValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn ValidateCompletely(self: *const ICommandValidate) callconv(.Inline) HRESULT {
        return self.vtable.ValidateCompletely(self);
    }
    pub fn ValidateSyntax(self: *const ICommandValidate) callconv(.Inline) HRESULT {
        return self.vtable.ValidateSyntax(self);
    }
};

const IID_ITableRename_Value = Guid.initString("0c733a77-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableRename = &IID_ITableRename_Value;
pub const ITableRename = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenameColumn: *const fn(
            self: *const ITableRename,
            pTableId: ?*DBID,
            pOldColumnId: ?*DBID,
            pNewColumnId: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenameTable: *const fn(
            self: *const ITableRename,
            pOldTableId: ?*DBID,
            pOldIndexId: ?*DBID,
            pNewTableId: ?*DBID,
            pNewIndexId: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn RenameColumn(self: *const ITableRename, pTableId: ?*DBID, pOldColumnId: ?*DBID, pNewColumnId: ?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.RenameColumn(self, pTableId, pOldColumnId, pNewColumnId);
    }
    pub fn RenameTable(self: *const ITableRename, pOldTableId: ?*DBID, pOldIndexId: ?*DBID, pNewTableId: ?*DBID, pNewIndexId: ?*DBID) callconv(.Inline) HRESULT {
        return self.vtable.RenameTable(self, pOldTableId, pOldIndexId, pNewTableId, pNewIndexId);
    }
};

const IID_IDBSchemaCommand_Value = Guid.initString("0c733a50-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBSchemaCommand = &IID_IDBSchemaCommand_Value;
pub const IDBSchemaCommand = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCommand: *const fn(
            self: *const IDBSchemaCommand,
            pUnkOuter: ?*IUnknown,
            rguidSchema: ?*const Guid,
            ppCommand: ?*?*ICommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemas: *const fn(
            self: *const IDBSchemaCommand,
            pcSchemas: ?*u32,
            prgSchemas: ?*?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetCommand(self: *const IDBSchemaCommand, pUnkOuter: ?*IUnknown, rguidSchema: ?*const Guid, ppCommand: ?*?*ICommand) callconv(.Inline) HRESULT {
        return self.vtable.GetCommand(self, pUnkOuter, rguidSchema, ppCommand);
    }
    pub fn GetSchemas(self: *const IDBSchemaCommand, pcSchemas: ?*u32, prgSchemas: ?*?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.GetSchemas(self, pcSchemas, prgSchemas);
    }
};

const IID_IProvideMoniker_Value = Guid.initString("0c733a4d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IProvideMoniker = &IID_IProvideMoniker_Value;
pub const IProvideMoniker = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMoniker: *const fn(
            self: *const IProvideMoniker,
            ppIMoniker: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetMoniker(self: *const IProvideMoniker, ppIMoniker: ?*?*IMoniker) callconv(.Inline) HRESULT {
        return self.vtable.GetMoniker(self, ppIMoniker);
    }
};

pub const NOTRESTRICTION = extern struct {
    pRes: ?*RESTRICTION,
};

pub const NODERESTRICTION = extern struct {
    cRes: u32,
    paRes: ?*?*RESTRICTION,
    reserved: u32,
};

pub const VECTORRESTRICTION = extern struct {
    Node: NODERESTRICTION,
    RankMethod: u32,
};

pub const CONTENTRESTRICTION = extern struct {
    prop: FULLPROPSPEC,
    pwcsPhrase: ?PWSTR,
    lcid: u32,
    ulGenerateMethod: u32,
};

pub const NATLANGUAGERESTRICTION = extern struct {
    prop: FULLPROPSPEC,
    pwcsPhrase: ?PWSTR,
    lcid: u32,
};

pub const PROPERTYRESTRICTION = extern struct {
    rel: u32,
    prop: FULLPROPSPEC,
    prval: PROPVARIANT,
};

pub const RESTRICTION = extern struct {
    pub const _URes = extern union {
        ar: NODERESTRICTION,
        orRestriction: NODERESTRICTION,
        pxr: NODERESTRICTION,
        vr: VECTORRESTRICTION,
        nr: NOTRESTRICTION,
        cr: CONTENTRESTRICTION,
        nlr: NATLANGUAGERESTRICTION,
        pr: PROPERTYRESTRICTION,
    };
    rt: u32,
    weight: u32,
    res: _URes,
};

pub const COLUMNSET = extern struct {
    cCol: u32,
    aCol: ?*FULLPROPSPEC,
};

pub const SORTKEY = extern struct {
    propColumn: FULLPROPSPEC,
    dwOrder: u32,
    locale: u32,
};

pub const SORTSET = extern struct {
    cCol: u32,
    aCol: ?*SORTKEY,
};

pub const BUCKETCATEGORIZE = extern struct {
    cBuckets: u32,
    Distribution: u32,
};

pub const RANGECATEGORIZE = extern struct {
    cRange: u32,
    aRangeBegin: ?*PROPVARIANT,
};

pub const CATEGORIZATION = extern struct {
    ulCatType: u32,
    Anonymous: extern union {
        cClusters: u32,
        bucket: BUCKETCATEGORIZE,
        range: RANGECATEGORIZE,
    },
    csColumns: COLUMNSET,
};

pub const CATEGORIZATIONSET = extern struct {
    cCat: u32,
    aCat: ?*CATEGORIZATION,
};

const IID_ISearchQueryHits_Value = Guid.initString("ed8ce7e0-106c-11ce-84e2-00aa004b9986");
pub const IID_ISearchQueryHits = &IID_ISearchQueryHits_Value;
pub const ISearchQueryHits = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn(
            self: *const ISearchQueryHits,
            pflt: ?*IFilter,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        NextHitMoniker: *const fn(
            self: *const ISearchQueryHits,
            pcMnk: ?*u32,
            papMnk: ?*?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        NextHitOffset: *const fn(
            self: *const ISearchQueryHits,
            pcRegion: ?*u32,
            paRegion: ?*?*FILTERREGION,
        ) callconv(@import("std").os.windows.WINAPI) i32,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Init(self: *const ISearchQueryHits, pflt: ?*IFilter, ulFlags: u32) callconv(.Inline) i32 {
        return self.vtable.Init(self, pflt, ulFlags);
    }
    pub fn NextHitMoniker(self: *const ISearchQueryHits, pcMnk: ?*u32, papMnk: ?*?*?*IMoniker) callconv(.Inline) i32 {
        return self.vtable.NextHitMoniker(self, pcMnk, papMnk);
    }
    pub fn NextHitOffset(self: *const ISearchQueryHits, pcRegion: ?*u32, paRegion: ?*?*FILTERREGION) callconv(.Inline) i32 {
        return self.vtable.NextHitOffset(self, pcRegion, paRegion);
    }
};

const IID_IRowsetQueryStatus_Value = Guid.initString("a7ac77ed-f8d7-11ce-a798-0020f8008024");
pub const IID_IRowsetQueryStatus = &IID_IRowsetQueryStatus_Value;
pub const IRowsetQueryStatus = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: *const fn(
            self: *const IRowsetQueryStatus,
            pdwStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatusEx: *const fn(
            self: *const IRowsetQueryStatus,
            pdwStatus: ?*u32,
            pcFilteredDocuments: ?*u32,
            pcDocumentsToFilter: ?*u32,
            pdwRatioFinishedDenominator: ?*usize,
            pdwRatioFinishedNumerator: ?*usize,
            cbBmk: usize,
            pBmk: ?*const u8,
            piRowBmk: ?*usize,
            pcRowsTotal: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetStatus(self: *const IRowsetQueryStatus, pdwStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetStatus(self, pdwStatus);
    }
    pub fn GetStatusEx(self: *const IRowsetQueryStatus, pdwStatus: ?*u32, pcFilteredDocuments: ?*u32, pcDocumentsToFilter: ?*u32, pdwRatioFinishedDenominator: ?*usize, pdwRatioFinishedNumerator: ?*usize, cbBmk: usize, pBmk: ?*const u8, piRowBmk: ?*usize, pcRowsTotal: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.GetStatusEx(self, pdwStatus, pcFilteredDocuments, pcDocumentsToFilter, pdwRatioFinishedDenominator, pdwRatioFinishedNumerator, cbBmk, pBmk, piRowBmk, pcRowsTotal);
    }
};

pub const ODBC_VS_ARGS = extern struct {
    pguidEvent: ?*const Guid,
    dwFlags: u32,
    Anonymous1: extern union {
        wszArg: ?PWSTR,
        szArg: ?PSTR,
    },
    Anonymous2: extern union {
        wszCorrelation: ?PWSTR,
        szCorrelation: ?PSTR,
    },
    RetCode: i16,
};

pub const SQLVARENUM = enum(i32) {
    EMPTY = 0,
    NULL = 1,
    UI1 = 17,
    I2 = 2,
    I4 = 3,
    I8 = 20,
    R4 = 4,
    R8 = 5,
    MONEY = 6,
    SMALLMONEY = 200,
    WSTRING = 201,
    WVARSTRING = 202,
    STRING = 203,
    VARSTRING = 204,
    BIT = 11,
    GUID = 72,
    NUMERIC = 131,
    DECIMAL = 205,
    DATETIME = 135,
    SMALLDATETIME = 206,
    BINARY = 207,
    VARBINARY = 208,
    UNKNOWN = 209,
};
pub const VT_SS_EMPTY = SQLVARENUM.EMPTY;
pub const VT_SS_NULL = SQLVARENUM.NULL;
pub const VT_SS_UI1 = SQLVARENUM.UI1;
pub const VT_SS_I2 = SQLVARENUM.I2;
pub const VT_SS_I4 = SQLVARENUM.I4;
pub const VT_SS_I8 = SQLVARENUM.I8;
pub const VT_SS_R4 = SQLVARENUM.R4;
pub const VT_SS_R8 = SQLVARENUM.R8;
pub const VT_SS_MONEY = SQLVARENUM.MONEY;
pub const VT_SS_SMALLMONEY = SQLVARENUM.SMALLMONEY;
pub const VT_SS_WSTRING = SQLVARENUM.WSTRING;
pub const VT_SS_WVARSTRING = SQLVARENUM.WVARSTRING;
pub const VT_SS_STRING = SQLVARENUM.STRING;
pub const VT_SS_VARSTRING = SQLVARENUM.VARSTRING;
pub const VT_SS_BIT = SQLVARENUM.BIT;
pub const VT_SS_GUID = SQLVARENUM.GUID;
pub const VT_SS_NUMERIC = SQLVARENUM.NUMERIC;
pub const VT_SS_DECIMAL = SQLVARENUM.DECIMAL;
pub const VT_SS_DATETIME = SQLVARENUM.DATETIME;
pub const VT_SS_SMALLDATETIME = SQLVARENUM.SMALLDATETIME;
pub const VT_SS_BINARY = SQLVARENUM.BINARY;
pub const VT_SS_VARBINARY = SQLVARENUM.VARBINARY;
pub const VT_SS_UNKNOWN = SQLVARENUM.UNKNOWN;

pub const SSVARIANT = extern struct {
    vt: u16,
    dwReserved1: u32,
    dwReserved2: u32,
    Anonymous: extern union {
        pub const _UnknownType = extern struct {
            dwActualLength: u32,
            rgMetadata: [16]u8,
            pUnknownData: ?*u8,
        };
        pub const _CharVal = extern struct {
            sActualLength: i16,
            sMaxLength: i16,
            pchCharVal: ?PSTR,
            rgbReserved: [5]u8,
            dwReserved: u32,
            pwchReserved: ?PWSTR,
        };
        pub const _BLOBType = extern struct {
            dbobj: DBOBJECT,
            pUnk: ?*IUnknown,
        };
        pub const _NCharVal = extern struct {
            sActualLength: i16,
            sMaxLength: i16,
            pwchNCharVal: ?PWSTR,
            rgbReserved: [5]u8,
            dwReserved: u32,
            pwchReserved: ?PWSTR,
        };
        pub const _BinaryVal = extern struct {
            sActualLength: i16,
            sMaxLength: i16,
            prgbBinaryVal: ?*u8,
            dwReserved: u32,
        };
        bTinyIntVal: u8,
        sShortIntVal: i16,
        lIntVal: i32,
        llBigIntVal: i64,
        fltRealVal: f32,
        dblFloatVal: f64,
        cyMoneyVal: CY,
        NCharVal: _NCharVal,
        CharVal: _CharVal,
        fBitVal: i16,
        rgbGuidVal: [16]u8,
        numNumericVal: DB_NUMERIC,
        BinaryVal: _BinaryVal,
        tsDateTimeVal: DBTIMESTAMP,
        UnknownType: _UnknownType,
        BLOBType: _BLOBType,
    },
};

const IID_IUMSInitialize_Value = Guid.initString("5cf4ca14-ef21-11d0-97e7-00c04fc2ad98");
pub const IID_IUMSInitialize = &IID_IUMSInitialize_Value;
pub const IUMSInitialize = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn(
            self: *const IUMSInitialize,
            pUMS: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Initialize(self: *const IUMSInitialize, pUMS: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.Initialize(self, pUMS);
    }
};

pub const IUMS = extern union {
    pub const VTable = extern struct {
        SqlUmsSuspend: *const fn(
            self: *const IUMS,
            ticks: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SqlUmsYield: *const fn(
            self: *const IUMS,
            ticks: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SqlUmsSwitchPremptive: *const fn(
            self: *const IUMS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SqlUmsSwitchNonPremptive: *const fn(
            self: *const IUMS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SqlUmsFIsPremptive: *const fn(
            self: *const IUMS,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn SqlUmsSuspend(self: *const IUMS, ticks: u32) callconv(.Inline) void {
        return self.vtable.SqlUmsSuspend(self, ticks);
    }
    pub fn SqlUmsYield(self: *const IUMS, ticks: u32) callconv(.Inline) void {
        return self.vtable.SqlUmsYield(self, ticks);
    }
    pub fn SqlUmsSwitchPremptive(self: *const IUMS) callconv(.Inline) void {
        return self.vtable.SqlUmsSwitchPremptive(self);
    }
    pub fn SqlUmsSwitchNonPremptive(self: *const IUMS) callconv(.Inline) void {
        return self.vtable.SqlUmsSwitchNonPremptive(self);
    }
    pub fn SqlUmsFIsPremptive(self: *const IUMS) callconv(.Inline) BOOL {
        return self.vtable.SqlUmsFIsPremptive(self);
    }
};

pub const tagSSErrorInfo = extern struct {
    pwszMessage: ?PWSTR,
    pwszServer: ?PWSTR,
    pwszProcedure: ?PWSTR,
    lNative: i32,
    bState: u8,
    bClass: u8,
    wLineNumber: u16,
};

const IID_ISQLServerErrorInfo_Value = Guid.initString("5cf4ca12-ef21-11d0-97e7-00c04fc2ad98");
pub const IID_ISQLServerErrorInfo = &IID_ISQLServerErrorInfo_Value;
pub const ISQLServerErrorInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorInfo: *const fn(
            self: *const ISQLServerErrorInfo,
            ppErrorInfo: ?*?*tagSSErrorInfo,
            ppStringsBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetErrorInfo(self: *const ISQLServerErrorInfo, ppErrorInfo: ?*?*tagSSErrorInfo, ppStringsBuffer: ?*?*u16) callconv(.Inline) HRESULT {
        return self.vtable.GetErrorInfo(self, ppErrorInfo, ppStringsBuffer);
    }
};

const IID_IRowsetFastLoad_Value = Guid.initString("5cf4ca13-ef21-11d0-97e7-00c04fc2ad98");
pub const IID_IRowsetFastLoad = &IID_IRowsetFastLoad_Value;
pub const IRowsetFastLoad = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertRow: *const fn(
            self: *const IRowsetFastLoad,
            hAccessor: usize,
            pData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn(
            self: *const IRowsetFastLoad,
            fDone: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn InsertRow(self: *const IRowsetFastLoad, hAccessor: usize, pData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.InsertRow(self, hAccessor, pData);
    }
    pub fn Commit(self: *const IRowsetFastLoad, fDone: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.Commit(self, fDone);
    }
};

pub const LOCKMODEENUM = enum(i32) {
    INVALID = 0,
    EXCLUSIVE = 1,
    SHARED = 2,
};
pub const LOCKMODE_INVALID = LOCKMODEENUM.INVALID;
pub const LOCKMODE_EXCLUSIVE = LOCKMODEENUM.EXCLUSIVE;
pub const LOCKMODE_SHARED = LOCKMODEENUM.SHARED;

const IID_ISchemaLock_Value = Guid.initString("4c2389fb-2511-11d4-b258-00c04f7971ce");
pub const IID_ISchemaLock = &IID_ISchemaLock_Value;
pub const ISchemaLock = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSchemaLock: *const fn(
            self: *const ISchemaLock,
            pTableID: ?*DBID,
            lmMode: u32,
            phLockHandle: ?*?HANDLE,
            pTableVersion: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseSchemaLock: *const fn(
            self: *const ISchemaLock,
            hLockHandle: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetSchemaLock(self: *const ISchemaLock, pTableID: ?*DBID, lmMode: u32, phLockHandle: ?*?HANDLE, pTableVersion: ?*u64) callconv(.Inline) HRESULT {
        return self.vtable.GetSchemaLock(self, pTableID, lmMode, phLockHandle, pTableVersion);
    }
    pub fn ReleaseSchemaLock(self: *const ISchemaLock, hLockHandle: ?HANDLE) callconv(.Inline) HRESULT {
        return self.vtable.ReleaseSchemaLock(self, hLockHandle);
    }
};

pub const SQL_ASYNC_NOTIFICATION_CALLBACK = *const fn(
    pContext: ?*anyopaque,
    fLast: BOOL,
) callconv(@import("std").os.windows.WINAPI) i16;





























pub const DBVECTOR = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        size: usize,
        ptr: ?*anyopaque,
    },
    .X86 => extern struct {
        size: usize align(2),
        ptr: ?*anyopaque align(2),
    },
};
pub const DBTIMESTAMP = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        year: i16,
        month: u16,
        day: u16,
        hour: u16,
        minute: u16,
        second: u16,
        fraction: u32,
    },
    .X86 => extern struct {
        year: i16 align(2),
        month: u16 align(2),
        day: u16 align(2),
        hour: u16 align(2),
        minute: u16 align(2),
        second: u16 align(2),
        fraction: u32 align(2),
    },
};
pub const SEC_OBJECT_ELEMENT = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        guidObjectType: Guid,
        ObjectID: DBID,
    },
    .X86 => extern struct {
        guidObjectType: Guid align(2),
        ObjectID: DBID align(2),
    },
};
pub const SEC_OBJECT = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cObjects: u32,
        prgObjects: ?*SEC_OBJECT_ELEMENT,
    },
    .X86 => extern struct {
        cObjects: u32 align(2),
        prgObjects: ?*SEC_OBJECT_ELEMENT align(2),
    },
};
pub const DBIMPLICITSESSION = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pUnkOuter: ?*IUnknown,
        piid: ?*Guid,
        pSession: ?*IUnknown,
    },
    .X86 => extern struct {
        pUnkOuter: ?*IUnknown align(2),
        piid: ?*Guid align(2),
        pSession: ?*IUnknown align(2),
    },
};
pub const DBOBJECT = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwFlags: u32,
        iid: Guid,
    },
    .X86 => extern struct {
        dwFlags: u32 align(2),
        iid: Guid align(2),
    },
};
pub const DBBINDEXT = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pExtension: ?*u8,
        ulExtension: usize,
    },
    .X86 => extern struct {
        pExtension: ?*u8 align(2),
        ulExtension: usize align(2),
    },
};
pub const DBBINDING = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        iOrdinal: usize,
        obValue: usize,
        obLength: usize,
        obStatus: usize,
        pTypeInfo: ?*ITypeInfo,
        pObject: ?*DBOBJECT,
        pBindExt: ?*DBBINDEXT,
        dwPart: u32,
        dwMemOwner: u32,
        eParamIO: u32,
        cbMaxLen: usize,
        dwFlags: u32,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        iOrdinal: usize align(2),
        obValue: usize align(2),
        obLength: usize align(2),
        obStatus: usize align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        pObject: ?*DBOBJECT align(2),
        pBindExt: ?*DBBINDEXT align(2),
        dwPart: u32 align(2),
        dwMemOwner: u32 align(2),
        eParamIO: u32 align(2),
        cbMaxLen: usize align(2),
        dwFlags: u32 align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBFAILUREINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hRow: usize,
        iColumn: usize,
        failure: HRESULT,
    },
    .X86 => extern struct {
        hRow: usize align(2),
        iColumn: usize align(2),
        failure: HRESULT align(2),
    },
};
pub const DBCOLUMNINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszName: ?PWSTR,
        pTypeInfo: ?*ITypeInfo,
        iOrdinal: usize,
        dwFlags: u32,
        ulColumnSize: usize,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
        columnid: DBID,
    },
    .X86 => extern struct {
        pwszName: ?PWSTR align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        iOrdinal: usize align(2),
        dwFlags: u32 align(2),
        ulColumnSize: usize align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
        columnid: DBID align(2),
    },
};
pub const DBPARAMS = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pData: ?*anyopaque,
        cParamSets: usize,
        hAccessor: usize,
    },
    .X86 => extern struct {
        pData: ?*anyopaque align(2),
        cParamSets: usize align(2),
        hAccessor: usize align(2),
    },
};
pub const DBPARAMINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwFlags: u32,
        iOrdinal: usize,
        pwszName: ?PWSTR,
        pTypeInfo: ?*ITypeInfo,
        ulParamSize: usize,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        dwFlags: u32 align(2),
        iOrdinal: usize align(2),
        pwszName: ?PWSTR align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        ulParamSize: usize align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBPROPIDSET = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rgPropertyIDs: ?*u32,
        cPropertyIDs: u32,
        guidPropertySet: Guid,
    },
    .X86 => extern struct {
        rgPropertyIDs: ?*u32 align(2),
        cPropertyIDs: u32 align(2),
        guidPropertySet: Guid align(2),
    },
};
pub const DBPROPINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszDescription: ?PWSTR,
        dwPropertyID: u32,
        dwFlags: u32,
        vtType: u16,
        vValues: VARIANT,
    },
    .X86 => extern struct {
        pwszDescription: ?PWSTR align(2),
        dwPropertyID: u32 align(2),
        dwFlags: u32 align(2),
        vtType: u16 align(2),
        vValues: VARIANT align(2),
    },
};
pub const DBPROPINFOSET = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rgPropertyInfos: ?*DBPROPINFO,
        cPropertyInfos: u32,
        guidPropertySet: Guid,
    },
    .X86 => extern struct {
        rgPropertyInfos: ?*DBPROPINFO align(2),
        cPropertyInfos: u32 align(2),
        guidPropertySet: Guid align(2),
    },
};
pub const DBPROP = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwPropertyID: u32,
        dwOptions: u32,
        dwStatus: u32,
        colid: DBID,
        vValue: VARIANT,
    },
    .X86 => extern struct {
        dwPropertyID: u32 align(2),
        dwOptions: u32 align(2),
        dwStatus: u32 align(2),
        colid: DBID align(2),
        vValue: VARIANT align(2),
    },
};
pub const DBPROPSET = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rgProperties: ?*DBPROP,
        cProperties: u32,
        guidPropertySet: Guid,
    },
    .X86 => extern struct {
        rgProperties: ?*DBPROP align(2),
        cProperties: u32 align(2),
        guidPropertySet: Guid align(2),
    },
};
pub const DBINDEXCOLUMNDESC = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pColumnID: ?*DBID,
        eIndexColOrder: u32,
    },
    .X86 => extern struct {
        pColumnID: ?*DBID align(2),
        eIndexColOrder: u32 align(2),
    },
};
pub const DBCOLUMNDESC = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszTypeName: ?PWSTR,
        pTypeInfo: ?*ITypeInfo,
        rgPropertySets: ?*DBPROPSET,
        pclsid: ?*Guid,
        cPropertySets: u32,
        ulColumnSize: usize,
        dbcid: DBID,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        pwszTypeName: ?PWSTR align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        rgPropertySets: ?*DBPROPSET align(2),
        pclsid: ?*Guid align(2),
        cPropertySets: u32 align(2),
        ulColumnSize: usize align(2),
        dbcid: DBID align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBCOLUMNACCESS = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pData: ?*anyopaque,
        columnid: DBID,
        cbDataLen: usize,
        dwStatus: u32,
        cbMaxLen: usize,
        dwReserved: usize,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        pData: ?*anyopaque align(2),
        columnid: DBID align(2),
        cbDataLen: usize align(2),
        dwStatus: u32 align(2),
        cbMaxLen: usize align(2),
        dwReserved: usize align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBCONSTRAINTDESC = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pConstraintID: ?*DBID,
        ConstraintType: u32,
        cColumns: usize,
        rgColumnList: ?*DBID,
        pReferencedTableID: ?*DBID,
        cForeignKeyColumns: usize,
        rgForeignKeyColumnList: ?*DBID,
        pwszConstraintText: ?PWSTR,
        UpdateRule: u32,
        DeleteRule: u32,
        MatchType: u32,
        Deferrability: u32,
        cReserved: usize,
        rgReserved: ?*DBPROPSET,
    },
    .X86 => extern struct {
        pConstraintID: ?*DBID align(2),
        ConstraintType: u32 align(2),
        cColumns: usize align(2),
        rgColumnList: ?*DBID align(2),
        pReferencedTableID: ?*DBID align(2),
        cForeignKeyColumns: usize align(2),
        rgForeignKeyColumnList: ?*DBID align(2),
        pwszConstraintText: ?PWSTR align(2),
        UpdateRule: u32 align(2),
        DeleteRule: u32 align(2),
        MatchType: u32 align(2),
        Deferrability: u32 align(2),
        cReserved: usize align(2),
        rgReserved: ?*DBPROPSET align(2),
    },
};
pub const MDAXISINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: usize,
        iAxis: usize,
        cDimensions: usize,
        cCoordinates: usize,
        rgcColumns: ?*usize,
        rgpwszDimensionNames: ?*?PWSTR,
    },
    .X86 => extern struct {
        cbSize: usize align(2),
        iAxis: usize align(2),
        cDimensions: usize align(2),
        cCoordinates: usize align(2),
        rgcColumns: ?*usize align(2),
        rgpwszDimensionNames: ?*?PWSTR align(2),
    },
};
pub const RMTPACK = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pISeqStream: ?*ISequentialStream,
        cbData: u32,
        cBSTR: u32,
        rgBSTR: ?*?BSTR,
        cVARIANT: u32,
        rgVARIANT: ?*VARIANT,
        cIDISPATCH: u32,
        rgIDISPATCH: ?*?*IDispatch,
        cIUNKNOWN: u32,
        rgIUNKNOWN: ?*?*IUnknown,
        cPROPVARIANT: u32,
        rgPROPVARIANT: ?*PROPVARIANT,
        cArray: u32,
        rgArray: ?*VARIANT,
    },
    .X86 => extern struct {
        pISeqStream: ?*ISequentialStream align(2),
        cbData: u32 align(2),
        cBSTR: u32 align(2),
        rgBSTR: ?*?BSTR align(2),
        cVARIANT: u32 align(2),
        rgVARIANT: ?*VARIANT align(2),
        cIDISPATCH: u32 align(2),
        rgIDISPATCH: ?*?*IDispatch align(2),
        cIUNKNOWN: u32 align(2),
        rgIUNKNOWN: ?*?*IUnknown align(2),
        cPROPVARIANT: u32 align(2),
        rgPROPVARIANT: ?*PROPVARIANT align(2),
        cArray: u32 align(2),
        rgArray: ?*VARIANT align(2),
    },
};
pub const DBPARAMBINDINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszDataSourceType: ?PWSTR,
        pwszName: ?PWSTR,
        ulParamSize: usize,
        dwFlags: u32,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        pwszDataSourceType: ?PWSTR align(2),
        pwszName: ?PWSTR align(2),
        ulParamSize: usize align(2),
        dwFlags: u32 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBLITERALINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszLiteralValue: ?PWSTR,
        pwszInvalidChars: ?PWSTR,
        pwszInvalidStartingChars: ?PWSTR,
        lt: u32,
        fSupported: BOOL,
        cchMaxLen: u32,
    },
    .X86 => extern struct {
        pwszLiteralValue: ?PWSTR align(2),
        pwszInvalidChars: ?PWSTR align(2),
        pwszInvalidStartingChars: ?PWSTR align(2),
        lt: u32 align(2),
        fSupported: BOOL align(2),
        cchMaxLen: u32 align(2),
    },
};
pub const ERRORINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hrError: HRESULT,
        dwMinor: u32,
        clsid: Guid,
        iid: Guid,
        dispid: i32,
    },
    .X86 => extern struct {
        hrError: HRESULT align(2),
        dwMinor: u32 align(2),
        clsid: Guid align(2),
        iid: Guid align(2),
        dispid: i32 align(2),
    },
};
pub const tagDBROWWATCHRANGE = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hRegion: usize,
        eChangeKind: u32,
        hRow: usize,
        iRow: usize,
    },
    .X86 => extern struct {
        hRegion: usize align(2),
        eChangeKind: u32 align(2),
        hRow: usize align(2),
        iRow: usize align(2),
    },
};
pub const DBCOST = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        eKind: u32,
        dwUnits: u32,
        lValue: i32,
    },
    .X86 => extern struct {
        eKind: u32 align(2),
        dwUnits: u32 align(2),
        lValue: i32 align(2),
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (211)
//--------------------------------------------------------------------------------
pub extern "odbc32" fn SQLAllocConnect(
    EnvironmentHandle: ?*anyopaque,
    ConnectionHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLAllocEnv(
    EnvironmentHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLAllocHandle(
    HandleType: i16,
    InputHandle: ?*anyopaque,
    OutputHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLAllocStmt(
    ConnectionHandle: ?*anyopaque,
    StatementHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLBindCol = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLBindCol(
    StatementHandle: ?*anyopaque,
    ColumnNumber: u16,
    TargetType: i16,
    TargetValue: ?*anyopaque,
    BufferLength: i32,
    StrLen_or_Ind: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLBindCol,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLBindCol(
    StatementHandle: ?*anyopaque,
    ColumnNumber: u16,
    TargetType: i16,
    TargetValue: ?*anyopaque,
    BufferLength: i64,
    StrLen_or_Ind: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLBindCol,
};

pub const SQLBindParam = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLBindParam(
    StatementHandle: ?*anyopaque,
    ParameterNumber: u16,
    ValueType: i16,
    ParameterType: i16,
    LengthPrecision: u32,
    ParameterScale: i16,
    ParameterValue: ?*anyopaque,
    StrLen_or_Ind: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLBindParam,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLBindParam(
    StatementHandle: ?*anyopaque,
    ParameterNumber: u16,
    ValueType: i16,
    ParameterType: i16,
    LengthPrecision: u64,
    ParameterScale: i16,
    ParameterValue: ?*anyopaque,
    StrLen_or_Ind: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLBindParam,
};

pub extern "odbc32" fn SQLCancel(
    StatementHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCancelHandle(
    HandleType: i16,
    InputHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCloseCursor(
    StatementHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLColAttribute = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLColAttribute(
    StatementHandle: ?*anyopaque,
    ColumnNumber: u16,
    FieldIdentifier: u16,
    // TODO: what to do with BytesParamIndex 4?
    CharacterAttribute: ?*anyopaque,
    BufferLength: i16,
    StringLength: ?*i16,
    NumericAttribute: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttribute,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLColAttribute(
    StatementHandle: ?*anyopaque,
    ColumnNumber: u16,
    FieldIdentifier: u16,
    // TODO: what to do with BytesParamIndex 4?
    CharacterAttribute: ?*anyopaque,
    BufferLength: i16,
    StringLength: ?*i16,
    NumericAttribute: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttribute,
};

pub extern "odbc32" fn SQLColumns(
    StatementHandle: ?*anyopaque,
    CatalogName: ?[*:0]u8,
    NameLength1: i16,
    SchemaName: ?[*:0]u8,
    NameLength2: i16,
    TableName: ?[*:0]u8,
    NameLength3: i16,
    ColumnName: ?[*:0]u8,
    NameLength4: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCompleteAsync(
    HandleType: i16,
    Handle: ?*anyopaque,
    AsyncRetCodePtr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLConnect(
    ConnectionHandle: ?*anyopaque,
    ServerName: [*:0]u8,
    NameLength1: i16,
    UserName: [*:0]u8,
    NameLength2: i16,
    Authentication: [*:0]u8,
    NameLength3: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCopyDesc(
    SourceDescHandle: ?*anyopaque,
    TargetDescHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDataSources(
    EnvironmentHandle: ?*anyopaque,
    Direction: u16,
    ServerName: ?[*:0]u8,
    BufferLength1: i16,
    NameLength1Ptr: ?*i16,
    Description: ?[*:0]u8,
    BufferLength2: i16,
    NameLength2Ptr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLDescribeCol = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLDescribeCol(
    StatementHandle: ?*anyopaque,
    ColumnNumber: u16,
    ColumnName: ?[*:0]u8,
    BufferLength: i16,
    NameLength: ?*i16,
    DataType: ?*i16,
    ColumnSize: ?*u32,
    DecimalDigits: ?*i16,
    Nullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLDescribeCol,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLDescribeCol(
    StatementHandle: ?*anyopaque,
    ColumnNumber: u16,
    ColumnName: ?[*:0]u8,
    BufferLength: i16,
    NameLength: ?*i16,
    DataType: ?*i16,
    ColumnSize: ?*u64,
    DecimalDigits: ?*i16,
    Nullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLDescribeCol,
};

pub extern "odbc32" fn SQLDisconnect(
    ConnectionHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLEndTran(
    HandleType: i16,
    Handle: ?*anyopaque,
    CompletionType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLError(
    EnvironmentHandle: ?*anyopaque,
    ConnectionHandle: ?*anyopaque,
    StatementHandle: ?*anyopaque,
    Sqlstate: *[6]u8,
    NativeError: ?*i32,
    MessageText: ?[*:0]u8,
    BufferLength: i16,
    TextLength: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecDirect(
    StatementHandle: ?*anyopaque,
    StatementText: ?[*:0]u8,
    TextLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecute(
    StatementHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFetch(
    StatementHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLFetchScroll = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLFetchScroll(
    StatementHandle: ?*anyopaque,
    FetchOrientation: i16,
    FetchOffset: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLFetchScroll,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLFetchScroll(
    StatementHandle: ?*anyopaque,
    FetchOrientation: i16,
    FetchOffset: i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLFetchScroll,
};

pub extern "odbc32" fn SQLFreeConnect(
    ConnectionHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFreeEnv(
    EnvironmentHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFreeHandle(
    HandleType: i16,
    Handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFreeStmt(
    StatementHandle: ?*anyopaque,
    Option: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectAttr(
    ConnectionHandle: ?*anyopaque,
    Attribute: i32,
    Value: ?*anyopaque,
    BufferLength: i32,
    StringLengthPtr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectOption(
    ConnectionHandle: ?*anyopaque,
    Option: u16,
    Value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetCursorName(
    StatementHandle: ?*anyopaque,
    CursorName: ?[*:0]u8,
    BufferLength: i16,
    NameLengthPtr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLGetData = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLGetData(
    StatementHandle: ?*anyopaque,
    ColumnNumber: u16,
    TargetType: i16,
    TargetValue: ?*anyopaque,
    BufferLength: i32,
    StrLen_or_IndPtr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLGetData,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLGetData(
    StatementHandle: ?*anyopaque,
    ColumnNumber: u16,
    TargetType: i16,
    TargetValue: ?*anyopaque,
    BufferLength: i64,
    StrLen_or_IndPtr: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLGetData,
};

pub extern "odbc32" fn SQLGetDescField(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    FieldIdentifier: i16,
    Value: ?*anyopaque,
    BufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLGetDescRec = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLGetDescRec(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    Name: ?[*:0]u8,
    BufferLength: i16,
    StringLengthPtr: ?*i16,
    TypePtr: ?*i16,
    SubTypePtr: ?*i16,
    LengthPtr: ?*i32,
    PrecisionPtr: ?*i16,
    ScalePtr: ?*i16,
    NullablePtr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLGetDescRec,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLGetDescRec(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    Name: ?[*:0]u8,
    BufferLength: i16,
    StringLengthPtr: ?*i16,
    TypePtr: ?*i16,
    SubTypePtr: ?*i16,
    LengthPtr: ?*i64,
    PrecisionPtr: ?*i16,
    ScalePtr: ?*i16,
    NullablePtr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLGetDescRec,
};

pub extern "odbc32" fn SQLGetDiagField(
    HandleType: i16,
    Handle: ?*anyopaque,
    RecNumber: i16,
    DiagIdentifier: i16,
    DiagInfo: ?*anyopaque,
    BufferLength: i16,
    StringLength: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDiagRec(
    HandleType: i16,
    Handle: ?*anyopaque,
    RecNumber: i16,
    Sqlstate: ?*[6]u8,
    NativeError: ?*i32,
    MessageText: ?[*:0]u8,
    BufferLength: i16,
    TextLength: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetEnvAttr(
    EnvironmentHandle: ?*anyopaque,
    Attribute: i32,
    Value: ?*anyopaque,
    BufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetFunctions(
    ConnectionHandle: ?*anyopaque,
    FunctionId: u16,
    Supported: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetInfo(
    ConnectionHandle: ?*anyopaque,
    InfoType: u16,
    // TODO: what to do with BytesParamIndex 3?
    InfoValue: ?*anyopaque,
    BufferLength: i16,
    StringLengthPtr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtAttr(
    StatementHandle: ?*anyopaque,
    Attribute: i32,
    Value: ?*anyopaque,
    BufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtOption(
    StatementHandle: ?*anyopaque,
    Option: u16,
    Value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetTypeInfo(
    StatementHandle: ?*anyopaque,
    DataType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNumResultCols(
    StatementHandle: ?*anyopaque,
    ColumnCount: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLParamData(
    StatementHandle: ?*anyopaque,
    Value: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrepare(
    StatementHandle: ?*anyopaque,
    StatementText: [*:0]u8,
    TextLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLPutData = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLPutData(
    StatementHandle: ?*anyopaque,
    Data: ?*anyopaque,
    StrLen_or_Ind: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLPutData,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLPutData(
    StatementHandle: ?*anyopaque,
    Data: ?*anyopaque,
    StrLen_or_Ind: i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLPutData,
};

pub const SQLRowCount = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLRowCount(
    StatementHandle: ?*anyopaque,
    RowCount: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLRowCount,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLRowCount(
    StatementHandle: ?*anyopaque,
    RowCount: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLRowCount,
};

pub extern "odbc32" fn SQLSetConnectAttr(
    ConnectionHandle: ?*anyopaque,
    Attribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    Value: ?*anyopaque,
    StringLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLSetConnectOption = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLSetConnectOption(
    ConnectionHandle: ?*anyopaque,
    Option: u16,
    Value: u32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetConnectOption,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLSetConnectOption(
    ConnectionHandle: ?*anyopaque,
    Option: u16,
    Value: u64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetConnectOption,
};

pub extern "odbc32" fn SQLSetCursorName(
    StatementHandle: ?*anyopaque,
    CursorName: [*:0]u8,
    NameLength: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetDescField(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    FieldIdentifier: i16,
    Value: ?*anyopaque,
    BufferLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLSetDescRec = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLSetDescRec(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    Type: i16,
    SubType: i16,
    Length: i32,
    Precision: i16,
    Scale: i16,
    // TODO: what to do with BytesParamIndex 4?
    Data: ?*anyopaque,
    StringLength: ?*i32,
    Indicator: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetDescRec,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLSetDescRec(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    Type: i16,
    SubType: i16,
    Length: i64,
    Precision: i16,
    Scale: i16,
    // TODO: what to do with BytesParamIndex 4?
    Data: ?*anyopaque,
    StringLength: ?*i64,
    Indicator: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetDescRec,
};

pub extern "odbc32" fn SQLSetEnvAttr(
    EnvironmentHandle: ?*anyopaque,
    Attribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    Value: ?*anyopaque,
    StringLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLSetParam = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLSetParam(
    StatementHandle: ?*anyopaque,
    ParameterNumber: u16,
    ValueType: i16,
    ParameterType: i16,
    LengthPrecision: u32,
    ParameterScale: i16,
    ParameterValue: ?*anyopaque,
    StrLen_or_Ind: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetParam,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLSetParam(
    StatementHandle: ?*anyopaque,
    ParameterNumber: u16,
    ValueType: i16,
    ParameterType: i16,
    LengthPrecision: u64,
    ParameterScale: i16,
    ParameterValue: ?*anyopaque,
    StrLen_or_Ind: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetParam,
};

pub extern "odbc32" fn SQLSetStmtAttr(
    StatementHandle: ?*anyopaque,
    Attribute: i32,
    Value: ?*anyopaque,
    StringLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLSetStmtOption = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLSetStmtOption(
    StatementHandle: ?*anyopaque,
    Option: u16,
    Value: u32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetStmtOption,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLSetStmtOption(
    StatementHandle: ?*anyopaque,
    Option: u16,
    Value: u64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetStmtOption,
};

pub extern "odbc32" fn SQLSpecialColumns(
    StatementHandle: ?*anyopaque,
    IdentifierType: u16,
    CatalogName: ?[*:0]u8,
    NameLength1: i16,
    SchemaName: ?[*:0]u8,
    NameLength2: i16,
    TableName: ?[*:0]u8,
    NameLength3: i16,
    Scope: u16,
    Nullable: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLStatistics(
    StatementHandle: ?*anyopaque,
    CatalogName: ?[*:0]u8,
    NameLength1: i16,
    SchemaName: ?[*:0]u8,
    NameLength2: i16,
    TableName: ?[*:0]u8,
    NameLength3: i16,
    Unique: u16,
    Reserved: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTables(
    StatementHandle: ?*anyopaque,
    CatalogName: ?[*:0]u8,
    NameLength1: i16,
    SchemaName: ?[*:0]u8,
    NameLength2: i16,
    TableName: ?[*:0]u8,
    NameLength3: i16,
    TableType: ?[*:0]u8,
    NameLength4: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTransact(
    EnvironmentHandle: ?*anyopaque,
    ConnectionHandle: ?*anyopaque,
    CompletionType: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_batch(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "odbcbcp" fn bcp_bind(
    param0: ?*anyopaque,
    param1: ?*u8,
    param2: i32,
    param3: i32,
    param4: ?*u8,
    param5: i32,
    param6: i32,
    param7: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_colfmt(
    param0: ?*anyopaque,
    param1: i32,
    param2: u8,
    param3: i32,
    param4: i32,
    param5: ?*u8,
    param6: i32,
    param7: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_collen(
    param0: ?*anyopaque,
    param1: i32,
    param2: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_colptr(
    param0: ?*anyopaque,
    param1: ?*u8,
    param2: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_columns(
    param0: ?*anyopaque,
    param1: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_control(
    param0: ?*anyopaque,
    param1: i32,
    param2: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_done(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "odbcbcp" fn bcp_exec(
    param0: ?*anyopaque,
    param1: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_getcolfmt(
    param0: ?*anyopaque,
    param1: i32,
    param2: i32,
    param3: ?*anyopaque,
    param4: i32,
    param5: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_initA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
    param3: ?[*:0]const u8,
    param4: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_initW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: ?[*:0]const u16,
    param4: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_moretext(
    param0: ?*anyopaque,
    param1: i32,
    param2: ?*u8,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_readfmtA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_readfmtW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_sendrow(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_setcolfmt(
    param0: ?*anyopaque,
    param1: i32,
    param2: i32,
    param3: ?*anyopaque,
    param4: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_writefmtA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_writefmtW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn dbprtypeA(
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "odbcbcp" fn dbprtypeW(
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "odbcbcp" fn SQLLinkedServers(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLLinkedCatalogsA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
    param2: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLLinkedCatalogsW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
    param2: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLInitEnumServers(
    pwchServerName: ?PWSTR,
    pwchInstanceName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "odbcbcp" fn SQLGetNextEnumeration(
    hEnumHandle: ?HANDLE,
    prgEnumData: ?*u8,
    piEnumLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLCloseEnumServers(
    hEnumHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriverConnect(
    hdbc: ?*anyopaque,
    hwnd: isize,
    szConnStrIn: [*:0]u8,
    cchConnStrIn: i16,
    szConnStrOut: ?[*:0]u8,
    cchConnStrOutMax: i16,
    pcchConnStrOut: ?*i16,
    fDriverCompletion: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBrowseConnect(
    hdbc: ?*anyopaque,
    szConnStrIn: [*:0]u8,
    cchConnStrIn: i16,
    szConnStrOut: ?[*:0]u8,
    cchConnStrOutMax: i16,
    pcchConnStrOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBulkOperations(
    StatementHandle: ?*anyopaque,
    Operation: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLColAttributes = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLColAttributes(
    hstmt: ?*anyopaque,
    icol: u16,
    fDescType: u16,
    rgbDesc: ?*anyopaque,
    cbDescMax: i16,
    pcbDesc: ?*i16,
    pfDesc: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributes,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLColAttributes(
    hstmt: ?*anyopaque,
    icol: u16,
    fDescType: u16,
    rgbDesc: ?*anyopaque,
    cbDescMax: i16,
    pcbDesc: ?*i16,
    pfDesc: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributes,
};

pub extern "odbc32" fn SQLColumnPrivileges(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szTableName: ?[*:0]u8,
    cchTableName: i16,
    szColumnName: ?[*:0]u8,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLDescribeParam = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLDescribeParam(
    hstmt: ?*anyopaque,
    ipar: u16,
    pfSqlType: ?*i16,
    pcbParamDef: ?*u32,
    pibScale: ?*i16,
    pfNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLDescribeParam,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLDescribeParam(
    hstmt: ?*anyopaque,
    ipar: u16,
    pfSqlType: ?*i16,
    pcbParamDef: ?*u64,
    pibScale: ?*i16,
    pfNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLDescribeParam,
};

pub const SQLExtendedFetch = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLExtendedFetch(
    hstmt: ?*anyopaque,
    fFetchType: u16,
    irow: i32,
    pcrow: ?*u32,
    rgfRowStatus: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLExtendedFetch,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLExtendedFetch(
    hstmt: ?*anyopaque,
    fFetchType: u16,
    irow: i64,
    pcrow: ?*u64,
    rgfRowStatus: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLExtendedFetch,
};

pub extern "odbc32" fn SQLForeignKeys(
    hstmt: ?*anyopaque,
    szPkCatalogName: ?[*:0]u8,
    cchPkCatalogName: i16,
    szPkSchemaName: ?[*:0]u8,
    cchPkSchemaName: i16,
    szPkTableName: ?[*:0]u8,
    cchPkTableName: i16,
    szFkCatalogName: ?[*:0]u8,
    cchFkCatalogName: i16,
    szFkSchemaName: ?[*:0]u8,
    cchFkSchemaName: i16,
    szFkTableName: ?[*:0]u8,
    cchFkTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLMoreResults(
    hstmt: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNativeSql(
    hdbc: ?*anyopaque,
    szSqlStrIn: [*:0]u8,
    cchSqlStrIn: i32,
    szSqlStr: ?[*:0]u8,
    cchSqlStrMax: i32,
    pcbSqlStr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNumParams(
    hstmt: ?*anyopaque,
    pcpar: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLParamOptions = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLParamOptions(
    hstmt: ?*anyopaque,
    crow: u32,
    pirow: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLParamOptions,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLParamOptions(
    hstmt: ?*anyopaque,
    crow: u64,
    pirow: ?*u64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLParamOptions,
};

pub extern "odbc32" fn SQLPrimaryKeys(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szTableName: ?[*:0]u8,
    cchTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedureColumns(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szProcName: ?[*:0]u8,
    cchProcName: i16,
    szColumnName: ?[*:0]u8,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedures(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szProcName: ?[*:0]u8,
    cchProcName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLSetPos = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLSetPos(
    hstmt: ?*anyopaque,
    irow: u16,
    fOption: u16,
    fLock: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetPos,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLSetPos(
    hstmt: ?*anyopaque,
    irow: u64,
    fOption: u16,
    fLock: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetPos,
};

pub extern "odbc32" fn SQLTablePrivileges(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cchSchemaName: i16,
    szTableName: ?[*:0]u8,
    cchTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDrivers(
    henv: ?*anyopaque,
    fDirection: u16,
    szDriverDesc: ?[*:0]u8,
    cchDriverDescMax: i16,
    pcchDriverDesc: ?*i16,
    szDriverAttributes: ?[*:0]u8,
    cchDrvrAttrMax: i16,
    pcchDrvrAttr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLBindParameter = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLBindParameter(
    hstmt: ?*anyopaque,
    ipar: u16,
    fParamType: i16,
    fCType: i16,
    fSqlType: i16,
    cbColDef: u32,
    ibScale: i16,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
    pcbValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLBindParameter,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLBindParameter(
    hstmt: ?*anyopaque,
    ipar: u16,
    fParamType: i16,
    fCType: i16,
    fSqlType: i16,
    cbColDef: u64,
    ibScale: i16,
    rgbValue: ?*anyopaque,
    cbValueMax: i64,
    pcbValue: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLBindParameter,
};

pub extern "odbc32" fn SQLAllocHandleStd(
    fHandleType: i16,
    hInput: ?*anyopaque,
    phOutput: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLSetScrollOptions = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLSetScrollOptions(
    hstmt: ?*anyopaque,
    fConcurrency: u16,
    crowKeyset: i32,
    crowRowset: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetScrollOptions,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLSetScrollOptions(
    hstmt: ?*anyopaque,
    fConcurrency: u16,
    crowKeyset: i64,
    crowRowset: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetScrollOptions,
};

pub extern "odbc32" fn ODBCSetTryWaitValue(
    dwValue: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "odbc32" fn ODBCGetTryWaitValue(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const SQLColAttributeW = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLColAttributeW(
    hstmt: ?*anyopaque,
    iCol: u16,
    iField: u16,
    // TODO: what to do with BytesParamIndex 4?
    pCharAttr: ?*anyopaque,
    cbDescMax: i16,
    pcbCharAttr: ?*i16,
    pNumAttr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributeW,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLColAttributeW(
    hstmt: ?*anyopaque,
    iCol: u16,
    iField: u16,
    // TODO: what to do with BytesParamIndex 4?
    pCharAttr: ?*anyopaque,
    cbDescMax: i16,
    pcbCharAttr: ?*i16,
    pNumAttr: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributeW,
};

pub const SQLColAttributesW = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLColAttributesW(
    hstmt: ?*anyopaque,
    icol: u16,
    fDescType: u16,
    // TODO: what to do with BytesParamIndex 4?
    rgbDesc: ?*anyopaque,
    cbDescMax: i16,
    pcbDesc: ?*i16,
    pfDesc: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributesW,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLColAttributesW(
    hstmt: ?*anyopaque,
    icol: u16,
    fDescType: u16,
    // TODO: what to do with BytesParamIndex 4?
    rgbDesc: ?*anyopaque,
    cbDescMax: i16,
    pcbDesc: ?*i16,
    pfDesc: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributesW,
};

pub extern "odbc32" fn SQLConnectW(
    hdbc: ?*anyopaque,
    szDSN: [*:0]u16,
    cchDSN: i16,
    szUID: [*:0]u16,
    cchUID: i16,
    szAuthStr: [*:0]u16,
    cchAuthStr: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLDescribeColW = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLDescribeColW(
    hstmt: ?*anyopaque,
    icol: u16,
    szColName: ?[*:0]u16,
    cchColNameMax: i16,
    pcchColName: ?*i16,
    pfSqlType: ?*i16,
    pcbColDef: ?*u32,
    pibScale: ?*i16,
    pfNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLDescribeColW,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLDescribeColW(
    hstmt: ?*anyopaque,
    icol: u16,
    szColName: ?[*:0]u16,
    cchColNameMax: i16,
    pcchColName: ?*i16,
    pfSqlType: ?*i16,
    pcbColDef: ?*u64,
    pibScale: ?*i16,
    pfNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLDescribeColW,
};

pub extern "odbc32" fn SQLErrorW(
    henv: ?*anyopaque,
    hdbc: ?*anyopaque,
    hstmt: ?*anyopaque,
    wszSqlState: *[6]u16,
    pfNativeError: ?*i32,
    wszErrorMsg: ?[*:0]u16,
    cchErrorMsgMax: i16,
    pcchErrorMsg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecDirectW(
    hstmt: ?*anyopaque,
    szSqlStr: ?[*:0]u16,
    TextLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectAttrW(
    hdbc: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
    pcbValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetCursorNameW(
    hstmt: ?*anyopaque,
    szCursor: ?[*:0]u16,
    cchCursorMax: i16,
    pcchCursor: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetDescFieldW(
    DescriptorHandle: ?*anyopaque,
    RecNumber: i16,
    FieldIdentifier: i16,
    Value: ?*anyopaque,
    BufferLength: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDescFieldW(
    hdesc: ?*anyopaque,
    iRecord: i16,
    iField: i16,
    rgbValue: ?*anyopaque,
    cbBufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLGetDescRecW = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLGetDescRecW(
    hdesc: ?*anyopaque,
    iRecord: i16,
    szName: ?[*:0]u16,
    cchNameMax: i16,
    pcchName: ?*i16,
    pfType: ?*i16,
    pfSubType: ?*i16,
    pLength: ?*i32,
    pPrecision: ?*i16,
    pScale: ?*i16,
    pNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLGetDescRecW,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLGetDescRecW(
    hdesc: ?*anyopaque,
    iRecord: i16,
    szName: ?[*:0]u16,
    cchNameMax: i16,
    pcchName: ?*i16,
    pfType: ?*i16,
    pfSubType: ?*i16,
    pLength: ?*i64,
    pPrecision: ?*i16,
    pScale: ?*i16,
    pNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLGetDescRecW,
};

pub extern "odbc32" fn SQLGetDiagFieldW(
    fHandleType: i16,
    handle: ?*anyopaque,
    iRecord: i16,
    fDiagField: i16,
    rgbDiagInfo: ?*anyopaque,
    cbBufferLength: i16,
    pcbStringLength: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDiagRecW(
    fHandleType: i16,
    handle: ?*anyopaque,
    iRecord: i16,
    szSqlState: ?*[6]u16,
    pfNativeError: ?*i32,
    szErrorMsg: ?[*:0]u16,
    cchErrorMsgMax: i16,
    pcchErrorMsg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrepareW(
    hstmt: ?*anyopaque,
    szSqlStr: [*:0]u16,
    cchSqlStr: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetConnectAttrW(
    hdbc: ?*anyopaque,
    fAttribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    rgbValue: ?*anyopaque,
    cbValue: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetCursorNameW(
    hstmt: ?*anyopaque,
    szCursor: [*:0]u16,
    cchCursor: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnsW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    szColumnName: ?[*:0]u16,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectOptionW(
    hdbc: ?*anyopaque,
    fOption: u16,
    pvParam: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetInfoW(
    hdbc: ?*anyopaque,
    fInfoType: u16,
    // TODO: what to do with BytesParamIndex 3?
    rgbInfoValue: ?*anyopaque,
    cbInfoValueMax: i16,
    pcbInfoValue: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetTypeInfoW(
    StatementHandle: ?*anyopaque,
    DataType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLSetConnectOptionW = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLSetConnectOptionW(
    hdbc: ?*anyopaque,
    fOption: u16,
    vParam: u32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetConnectOptionW,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLSetConnectOptionW(
    hdbc: ?*anyopaque,
    fOption: u16,
    vParam: u64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetConnectOptionW,
};

pub extern "odbc32" fn SQLSpecialColumnsW(
    hstmt: ?*anyopaque,
    fColType: u16,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    fScope: u16,
    fNullable: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLStatisticsW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    fUnique: u16,
    fAccuracy: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablesW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    szTableType: ?[*:0]u16,
    cchTableType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDataSourcesW(
    henv: ?*anyopaque,
    fDirection: u16,
    szDSN: ?[*:0]u16,
    cchDSNMax: i16,
    pcchDSN: ?*i16,
    wszDescription: ?[*:0]u16,
    cchDescriptionMax: i16,
    pcchDescription: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriverConnectW(
    hdbc: ?*anyopaque,
    hwnd: isize,
    szConnStrIn: [*:0]u16,
    cchConnStrIn: i16,
    szConnStrOut: ?[*:0]u16,
    cchConnStrOutMax: i16,
    pcchConnStrOut: ?*i16,
    fDriverCompletion: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBrowseConnectW(
    hdbc: ?*anyopaque,
    szConnStrIn: [*:0]u16,
    cchConnStrIn: i16,
    szConnStrOut: ?[*:0]u16,
    cchConnStrOutMax: i16,
    pcchConnStrOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnPrivilegesW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
    szColumnName: ?[*:0]u16,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtAttrW(
    hstmt: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
    pcbValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetStmtAttrW(
    hstmt: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLForeignKeysW(
    hstmt: ?*anyopaque,
    szPkCatalogName: ?[*:0]u16,
    cchPkCatalogName: i16,
    szPkSchemaName: ?[*:0]u16,
    cchPkSchemaName: i16,
    szPkTableName: ?[*:0]u16,
    cchPkTableName: i16,
    szFkCatalogName: ?[*:0]u16,
    cchFkCatalogName: i16,
    szFkSchemaName: ?[*:0]u16,
    cchFkSchemaName: i16,
    szFkTableName: ?[*:0]u16,
    cchFkTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNativeSqlW(
    hdbc: ?*anyopaque,
    szSqlStrIn: [*:0]u16,
    cchSqlStrIn: i32,
    szSqlStr: ?[*:0]u16,
    cchSqlStrMax: i32,
    pcchSqlStr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrimaryKeysW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedureColumnsW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szProcName: ?[*:0]u16,
    cchProcName: i16,
    szColumnName: ?[*:0]u16,
    cchColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProceduresW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szProcName: ?[*:0]u16,
    cchProcName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablePrivilegesW(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u16,
    cchCatalogName: i16,
    szSchemaName: ?[*:0]u16,
    cchSchemaName: i16,
    szTableName: ?[*:0]u16,
    cchTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriversW(
    henv: ?*anyopaque,
    fDirection: u16,
    szDriverDesc: ?[*:0]u16,
    cchDriverDescMax: i16,
    pcchDriverDesc: ?*i16,
    szDriverAttributes: ?[*:0]u16,
    cchDrvrAttrMax: i16,
    pcchDrvrAttr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLColAttributeA = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLColAttributeA(
    hstmt: ?*anyopaque,
    iCol: i16,
    iField: i16,
    // TODO: what to do with BytesParamIndex 4?
    pCharAttr: ?*anyopaque,
    cbCharAttrMax: i16,
    pcbCharAttr: ?*i16,
    pNumAttr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributeA,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLColAttributeA(
    hstmt: ?*anyopaque,
    iCol: i16,
    iField: i16,
    // TODO: what to do with BytesParamIndex 4?
    pCharAttr: ?*anyopaque,
    cbCharAttrMax: i16,
    pcbCharAttr: ?*i16,
    pNumAttr: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributeA,
};

pub const SQLColAttributesA = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLColAttributesA(
    hstmt: ?*anyopaque,
    icol: u16,
    fDescType: u16,
    // TODO: what to do with BytesParamIndex 4?
    rgbDesc: ?*anyopaque,
    cbDescMax: i16,
    pcbDesc: ?*i16,
    pfDesc: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributesA,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLColAttributesA(
    hstmt: ?*anyopaque,
    icol: u16,
    fDescType: u16,
    // TODO: what to do with BytesParamIndex 4?
    rgbDesc: ?*anyopaque,
    cbDescMax: i16,
    pcbDesc: ?*i16,
    pfDesc: ?*i64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLColAttributesA,
};

pub extern "odbc32" fn SQLConnectA(
    hdbc: ?*anyopaque,
    szDSN: [*:0]u8,
    cbDSN: i16,
    szUID: [*:0]u8,
    cbUID: i16,
    szAuthStr: [*:0]u8,
    cbAuthStr: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLDescribeColA = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLDescribeColA(
    hstmt: ?*anyopaque,
    icol: u16,
    szColName: ?[*:0]u8,
    cbColNameMax: i16,
    pcbColName: ?*i16,
    pfSqlType: ?*i16,
    pcbColDef: ?*u32,
    pibScale: ?*i16,
    pfNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLDescribeColA,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLDescribeColA(
    hstmt: ?*anyopaque,
    icol: u16,
    szColName: ?[*:0]u8,
    cbColNameMax: i16,
    pcbColName: ?*i16,
    pfSqlType: ?*i16,
    pcbColDef: ?*u64,
    pibScale: ?*i16,
    pfNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLDescribeColA,
};

pub extern "odbc32" fn SQLErrorA(
    henv: ?*anyopaque,
    hdbc: ?*anyopaque,
    hstmt: ?*anyopaque,
    szSqlState: ?*u8,
    pfNativeError: ?*i32,
    szErrorMsg: ?[*:0]u8,
    cbErrorMsgMax: i16,
    pcbErrorMsg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecDirectA(
    hstmt: ?*anyopaque,
    szSqlStr: ?[*:0]u8,
    cbSqlStr: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectAttrA(
    hdbc: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
    pcbValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetCursorNameA(
    hstmt: ?*anyopaque,
    szCursor: ?[*:0]u8,
    cbCursorMax: i16,
    pcbCursor: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDescFieldA(
    hdesc: ?*anyopaque,
    iRecord: i16,
    iField: i16,
    rgbValue: ?*anyopaque,
    cbBufferLength: i32,
    StringLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLGetDescRecA = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLGetDescRecA(
    hdesc: ?*anyopaque,
    iRecord: i16,
    szName: ?[*:0]u8,
    cbNameMax: i16,
    pcbName: ?*i16,
    pfType: ?*i16,
    pfSubType: ?*i16,
    pLength: ?*i32,
    pPrecision: ?*i16,
    pScale: ?*i16,
    pNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLGetDescRecA,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLGetDescRecA(
    hdesc: ?*anyopaque,
    iRecord: i16,
    szName: ?[*:0]u8,
    cbNameMax: i16,
    pcbName: ?*i16,
    pfType: ?*i16,
    pfSubType: ?*i16,
    pLength: ?*i64,
    pPrecision: ?*i16,
    pScale: ?*i16,
    pNullable: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLGetDescRecA,
};

pub extern "odbc32" fn SQLGetDiagFieldA(
    fHandleType: i16,
    handle: ?*anyopaque,
    iRecord: i16,
    fDiagField: i16,
    rgbDiagInfo: ?*anyopaque,
    cbDiagInfoMax: i16,
    pcbDiagInfo: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDiagRecA(
    fHandleType: i16,
    handle: ?*anyopaque,
    iRecord: i16,
    szSqlState: ?*[6]u8,
    pfNativeError: ?*i32,
    szErrorMsg: ?[*:0]u8,
    cbErrorMsgMax: i16,
    pcbErrorMsg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtAttrA(
    hstmt: ?*anyopaque,
    fAttribute: i32,
    rgbValue: ?*anyopaque,
    cbValueMax: i32,
    pcbValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetTypeInfoA(
    StatementHandle: ?*anyopaque,
    DataType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrepareA(
    hstmt: ?*anyopaque,
    szSqlStr: [*:0]u8,
    cbSqlStr: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetConnectAttrA(
    hdbc: ?*anyopaque,
    fAttribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    rgbValue: ?*anyopaque,
    cbValue: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetCursorNameA(
    hstmt: ?*anyopaque,
    szCursor: [*:0]u8,
    cbCursor: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnsA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    szColumnName: ?[*:0]u8,
    cbColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectOptionA(
    hdbc: ?*anyopaque,
    fOption: u16,
    pvParam: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetInfoA(
    hdbc: ?*anyopaque,
    fInfoType: u16,
    // TODO: what to do with BytesParamIndex 3?
    rgbInfoValue: ?*anyopaque,
    cbInfoValueMax: i16,
    pcbInfoValue: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const SQLSetConnectOptionA = switch (@import("../zig.zig").arch) {
.X86 => (struct {

pub extern "odbc32" fn SQLSetConnectOptionA(
    hdbc: ?*anyopaque,
    fOption: u16,
    vParam: u32,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetConnectOptionA,
.X64, .Arm64 => (struct {

pub extern "odbc32" fn SQLSetConnectOptionA(
    hdbc: ?*anyopaque,
    fOption: u16,
    vParam: u64,
) callconv(@import("std").os.windows.WINAPI) i16;

}).SQLSetConnectOptionA,
};

pub extern "odbc32" fn SQLSpecialColumnsA(
    hstmt: ?*anyopaque,
    fColType: u16,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    fScope: u16,
    fNullable: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLStatisticsA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    fUnique: u16,
    fAccuracy: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablesA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    szTableType: ?[*:0]u8,
    cbTableType: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDataSourcesA(
    henv: ?*anyopaque,
    fDirection: u16,
    szDSN: ?[*:0]u8,
    cbDSNMax: i16,
    pcbDSN: ?*i16,
    szDescription: ?[*:0]u8,
    cbDescriptionMax: i16,
    pcbDescription: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriverConnectA(
    hdbc: ?*anyopaque,
    hwnd: isize,
    szConnStrIn: [*:0]u8,
    cbConnStrIn: i16,
    szConnStrOut: ?[*:0]u8,
    cbConnStrOutMax: i16,
    pcbConnStrOut: ?*i16,
    fDriverCompletion: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBrowseConnectA(
    hdbc: ?*anyopaque,
    szConnStrIn: [*:0]u8,
    cbConnStrIn: i16,
    szConnStrOut: ?[*:0]u8,
    cbConnStrOutMax: i16,
    pcbConnStrOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnPrivilegesA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
    szColumnName: ?[*:0]u8,
    cbColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLForeignKeysA(
    hstmt: ?*anyopaque,
    szPkCatalogName: ?[*:0]u8,
    cbPkCatalogName: i16,
    szPkSchemaName: ?[*:0]u8,
    cbPkSchemaName: i16,
    szPkTableName: ?[*:0]u8,
    cbPkTableName: i16,
    szFkCatalogName: ?[*:0]u8,
    cbFkCatalogName: i16,
    szFkSchemaName: ?[*:0]u8,
    cbFkSchemaName: i16,
    szFkTableName: ?[*:0]u8,
    cbFkTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNativeSqlA(
    hdbc: ?*anyopaque,
    szSqlStrIn: [*:0]u8,
    cbSqlStrIn: i32,
    szSqlStr: ?[*:0]u8,
    cbSqlStrMax: i32,
    pcbSqlStr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrimaryKeysA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedureColumnsA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szProcName: ?[*:0]u8,
    cbProcName: i16,
    szColumnName: ?[*:0]u8,
    cbColumnName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProceduresA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szProcName: ?[*:0]u8,
    cbProcName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablePrivilegesA(
    hstmt: ?*anyopaque,
    szCatalogName: ?[*:0]u8,
    cbCatalogName: i16,
    szSchemaName: ?[*:0]u8,
    cbSchemaName: i16,
    szTableName: ?[*:0]u8,
    cbTableName: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriversA(
    henv: ?*anyopaque,
    fDirection: u16,
    szDriverDesc: ?[*:0]u8,
    cbDriverDescMax: i16,
    pcbDriverDesc: ?*i16,
    szDriverAttributes: ?[*:0]u8,
    cbDrvrAttrMax: i16,
    pcbDrvrAttr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (5)
//--------------------------------------------------------------------------------
pub const bcp_init = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().bcp_initA,
    .wide => @This().bcp_initW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'bcp_init' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const bcp_readfmt = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().bcp_readfmtA,
    .wide => @This().bcp_readfmtW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'bcp_readfmt' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const bcp_writefmt = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().bcp_writefmtA,
    .wide => @This().bcp_writefmtW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'bcp_writefmt' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const dbprtype = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().dbprtypeA,
    .wide => @This().dbprtypeW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'dbprtype' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SQLLinkedCatalogs = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SQLLinkedCatalogsA,
    .wide => @This().SQLLinkedCatalogsW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SQLLinkedCatalogs' requires that UNICODE be set to true or false in the root module",
    ),
};
//--------------------------------------------------------------------------------
// Section: Imports (45)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BLOB = @import("../system/com.zig").BLOB;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CONDITION_OPERATION = @import("../system/search/common.zig").CONDITION_OPERATION;
const CONDITION_TYPE = @import("../system/search/common.zig").CONDITION_TYPE;
const COSERVERINFO = @import("../system/com.zig").COSERVERINFO;
const CY = @import("../system/com.zig").CY;
const DBID = @import("../storage/index_server.zig").DBID;
const DISPPARAMS = @import("../system/com.zig").DISPPARAMS;
const EXPLICIT_ACCESS_W = @import("../security/authorization.zig").EXPLICIT_ACCESS_W;
const FILETIME = @import("../foundation.zig").FILETIME;
const FILTERREGION = @import("../storage/index_server.zig").FILTERREGION;
const FULLPROPSPEC = @import("../storage/index_server.zig").FULLPROPSPEC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IAuthenticate = @import("../system/com.zig").IAuthenticate;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumString = @import("../system/com.zig").IEnumString;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IErrorInfo = @import("../system/com.zig").IErrorInfo;
const IFilter = @import("../storage/index_server.zig").IFilter;
const IMoniker = @import("../system/com.zig").IMoniker;
const IObjectArray = @import("../ui/shell/common.zig").IObjectArray;
const IPersist = @import("../system/com.zig").IPersist;
const IPersistStream = @import("../system/com.zig").IPersistStream;
const IPhraseSink = @import("../storage/index_server.zig").IPhraseSink;
const ISequentialStream = @import("../system/com.zig").ISequentialStream;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const ITransaction = @import("../system/distributed_transaction_coordinator.zig").ITransaction;
const ITransactionOptions = @import("../system/distributed_transaction_coordinator.zig").ITransactionOptions;
const ITypeInfo = @import("../system/com.zig").ITypeInfo;
const IUnknown = @import("../system/com.zig").IUnknown;
const MULTI_QI = @import("../system/com.zig").MULTI_QI;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPSPEC = @import("../system/com/structured_storage.zig").PROPSPEC;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const TRUSTEE_W = @import("../security/authorization.zig").TRUSTEE_W;
const VARIANT = @import("../system/com.zig").VARIANT;
const WORDREP_BREAK_TYPE = @import("../storage/index_server.zig").WORDREP_BREAK_TYPE;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "SQL_ASYNC_NOTIFICATION_CALLBACK")) { _ = SQL_ASYNC_NOTIFICATION_CALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (1)
//--------------------------------------------------------------------------------
pub const common = @import("search/common.zig");
