//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (32)
//--------------------------------------------------------------------------------
pub const SYNC_VERSION_FLAG_FROM_FEED = @as(u32, 1);
pub const SYNC_VERSION_FLAG_HAS_BY = @as(u32, 2);
pub const SYNC_SERIALIZE_REPLICA_KEY_MAP = @as(u32, 1);
pub const SYNC_FILTER_INFO_FLAG_ITEM_LIST = @as(u32, 1);
pub const SYNC_FILTER_INFO_FLAG_CHANGE_UNIT_LIST = @as(u32, 2);
pub const SYNC_FILTER_INFO_FLAG_CUSTOM = @as(u32, 4);
pub const SYNC_FILTER_INFO_COMBINED = @as(u32, 8);
pub const SYNC_CHANGE_FLAG_DELETED = @as(u32, 1);
pub const SYNC_CHANGE_FLAG_DOES_NOT_EXIST = @as(u32, 2);
pub const SYNC_CHANGE_FLAG_GHOST = @as(u32, 4);
pub const PKEY_PROVIDER_INSTANCEID = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 2 };
pub const PKEY_PROVIDER_CLSID = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 3 };
pub const PKEY_PROVIDER_CONFIGUI = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 4 };
pub const PKEY_PROVIDER_CONTENTTYPE = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 5 };
pub const PKEY_PROVIDER_CAPABILITIES = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 6 };
pub const PKEY_PROVIDER_SUPPORTED_ARCHITECTURE = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 7 };
pub const PKEY_PROVIDER_NAME = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 8 };
pub const PKEY_PROVIDER_DESCRIPTION = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 9 };
pub const PKEY_PROVIDER_TOOLTIPS = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 10 };
pub const PKEY_PROVIDER_ICON = PROPERTYKEY { .fmtid = Guid.initString("84179e61-60f6-4c1c-88ed-f1c531b32bda"), .pid = 11 };
pub const PKEY_CONFIGUI_INSTANCEID = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 2 };
pub const PKEY_CONFIGUI_CLSID = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 3 };
pub const PKEY_CONFIGUI_CONTENTTYPE = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 4 };
pub const PKEY_CONFIGUI_CAPABILITIES = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 5 };
pub const PKEY_CONFIGUI_SUPPORTED_ARCHITECTURE = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 6 };
pub const PKEY_CONFIGUI_IS_GLOBAL = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 7 };
pub const PKEY_CONFIGUI_NAME = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 8 };
pub const PKEY_CONFIGUI_DESCRIPTION = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 9 };
pub const PKEY_CONFIGUI_TOOLTIPS = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 10 };
pub const PKEY_CONFIGUI_ICON = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 11 };
pub const PKEY_CONFIGUI_MENUITEM_NOUI = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 12 };
pub const PKEY_CONFIGUI_MENUITEM = PROPERTYKEY { .fmtid = Guid.initString("554b24ea-e8e3-45ba-9352-dfb561e171e4"), .pid = 13 };

//--------------------------------------------------------------------------------
// Section: Types (102)
//--------------------------------------------------------------------------------
pub const ID_PARAMETER_PAIR = extern struct {
    fIsVariable: BOOL,
    cbIdSize: u16,
};

pub const ID_PARAMETERS = extern struct {
    dwSize: u32,
    replicaId: ID_PARAMETER_PAIR,
    itemId: ID_PARAMETER_PAIR,
    changeUnitId: ID_PARAMETER_PAIR,
};

pub const SYNC_SESSION_STATISTICS = extern struct {
    dwChangesApplied: u32,
    dwChangesFailed: u32,
};

pub const SYNC_VERSION = extern struct {
    dwLastUpdatingReplicaKey: u32,
    ullTickCount: u64,
};

pub const SYNC_RANGE = extern struct {
    pbClosedLowerBound: ?*u8,
    pbClosedUpperBound: ?*u8,
};

pub const SYNC_TIME = extern struct {
    dwDate: u32,
    dwTime: u32,
};

pub const SYNC_FILTER_CHANGE = extern struct {
    fMoveIn: BOOL,
    moveVersion: SYNC_VERSION,
};

pub const SYNC_PROVIDER_ROLE = enum(i32) {
    SOURCE = 0,
    DESTINATION = 1,
};
pub const SPR_SOURCE = SYNC_PROVIDER_ROLE.SOURCE;
pub const SPR_DESTINATION = SYNC_PROVIDER_ROLE.DESTINATION;

pub const CONFLICT_RESOLUTION_POLICY = enum(i32) {
    NONE = 0,
    DESTINATION_PROVIDER_WINS = 1,
    SOURCE_PROVIDER_WINS = 2,
    LAST = 3,
};
pub const CRP_NONE = CONFLICT_RESOLUTION_POLICY.NONE;
pub const CRP_DESTINATION_PROVIDER_WINS = CONFLICT_RESOLUTION_POLICY.DESTINATION_PROVIDER_WINS;
pub const CRP_SOURCE_PROVIDER_WINS = CONFLICT_RESOLUTION_POLICY.SOURCE_PROVIDER_WINS;
pub const CRP_LAST = CONFLICT_RESOLUTION_POLICY.LAST;

pub const SYNC_PROGRESS_STAGE = enum(i32) {
    DETECTION = 0,
    ENUMERATION = 1,
    APPLICATION = 2,
};
pub const SPS_CHANGE_DETECTION = SYNC_PROGRESS_STAGE.DETECTION;
pub const SPS_CHANGE_ENUMERATION = SYNC_PROGRESS_STAGE.ENUMERATION;
pub const SPS_CHANGE_APPLICATION = SYNC_PROGRESS_STAGE.APPLICATION;

pub const SYNC_FULL_ENUMERATION_ACTION = enum(i32) {
    FULL_ENUMERATION = 0,
    PARTIAL_SYNC = 1,
    ABORT = 2,
};
pub const SFEA_FULL_ENUMERATION = SYNC_FULL_ENUMERATION_ACTION.FULL_ENUMERATION;
pub const SFEA_PARTIAL_SYNC = SYNC_FULL_ENUMERATION_ACTION.PARTIAL_SYNC;
pub const SFEA_ABORT = SYNC_FULL_ENUMERATION_ACTION.ABORT;

pub const SYNC_RESOLVE_ACTION = enum(i32) {
    DEFER = 0,
    ACCEPT_DESTINATION_PROVIDER = 1,
    ACCEPT_SOURCE_PROVIDER = 2,
    MERGE = 3,
    TRANSFER_AND_DEFER = 4,
    LAST = 5,
};
pub const SRA_DEFER = SYNC_RESOLVE_ACTION.DEFER;
pub const SRA_ACCEPT_DESTINATION_PROVIDER = SYNC_RESOLVE_ACTION.ACCEPT_DESTINATION_PROVIDER;
pub const SRA_ACCEPT_SOURCE_PROVIDER = SYNC_RESOLVE_ACTION.ACCEPT_SOURCE_PROVIDER;
pub const SRA_MERGE = SYNC_RESOLVE_ACTION.MERGE;
pub const SRA_TRANSFER_AND_DEFER = SYNC_RESOLVE_ACTION.TRANSFER_AND_DEFER;
pub const SRA_LAST = SYNC_RESOLVE_ACTION.LAST;

pub const SYNC_STATISTICS = enum(i32) {
    T = 0,
};
pub const SYNC_STATISTICS_RANGE_COUNT = SYNC_STATISTICS.T;

pub const SYNC_SERIALIZATION_VERSION = enum(i32) {
    @"1" = 1,
    @"2" = 4,
    @"3" = 5,
};
pub const SYNC_SERIALIZATION_VERSION_V1 = SYNC_SERIALIZATION_VERSION.@"1";
pub const SYNC_SERIALIZATION_VERSION_V2 = SYNC_SERIALIZATION_VERSION.@"2";
pub const SYNC_SERIALIZATION_VERSION_V3 = SYNC_SERIALIZATION_VERSION.@"3";

pub const FILTERING_TYPE = enum(i32) {
    ONLY = 0,
    AND_VERSIONS_FOR_MOVED_OUT_ITEMS = 1,
};
pub const FT_CURRENT_ITEMS_ONLY = FILTERING_TYPE.ONLY;
pub const FT_CURRENT_ITEMS_AND_VERSIONS_FOR_MOVED_OUT_ITEMS = FILTERING_TYPE.AND_VERSIONS_FOR_MOVED_OUT_ITEMS;

pub const SYNC_CONSTRAINT_RESOLVE_ACTION = enum(i32) {
    DEFER = 0,
    ACCEPT_DESTINATION_PROVIDER = 1,
    ACCEPT_SOURCE_PROVIDER = 2,
    TRANSFER_AND_DEFER = 3,
    MERGE = 4,
    RENAME_SOURCE = 5,
    RENAME_DESTINATION = 6,
};
pub const SCRA_DEFER = SYNC_CONSTRAINT_RESOLVE_ACTION.DEFER;
pub const SCRA_ACCEPT_DESTINATION_PROVIDER = SYNC_CONSTRAINT_RESOLVE_ACTION.ACCEPT_DESTINATION_PROVIDER;
pub const SCRA_ACCEPT_SOURCE_PROVIDER = SYNC_CONSTRAINT_RESOLVE_ACTION.ACCEPT_SOURCE_PROVIDER;
pub const SCRA_TRANSFER_AND_DEFER = SYNC_CONSTRAINT_RESOLVE_ACTION.TRANSFER_AND_DEFER;
pub const SCRA_MERGE = SYNC_CONSTRAINT_RESOLVE_ACTION.MERGE;
pub const SCRA_RENAME_SOURCE = SYNC_CONSTRAINT_RESOLVE_ACTION.RENAME_SOURCE;
pub const SCRA_RENAME_DESTINATION = SYNC_CONSTRAINT_RESOLVE_ACTION.RENAME_DESTINATION;

pub const CONSTRAINT_CONFLICT_REASON = enum(i32) {
    OTHER = 0,
    COLLISION = 1,
    NOPARENT = 2,
    IDENTITY = 3,
};
pub const CCR_OTHER = CONSTRAINT_CONFLICT_REASON.OTHER;
pub const CCR_COLLISION = CONSTRAINT_CONFLICT_REASON.COLLISION;
pub const CCR_NOPARENT = CONSTRAINT_CONFLICT_REASON.NOPARENT;
pub const CCR_IDENTITY = CONSTRAINT_CONFLICT_REASON.IDENTITY;

pub const KNOWLEDGE_COOKIE_COMPARISON_RESULT = enum(i32) {
    EQUAL = 0,
    CONTAINED = 1,
    CONTAINS = 2,
    NOT_COMPARABLE = 3,
};
pub const KCCR_COOKIE_KNOWLEDGE_EQUAL = KNOWLEDGE_COOKIE_COMPARISON_RESULT.EQUAL;
pub const KCCR_COOKIE_KNOWLEDGE_CONTAINED = KNOWLEDGE_COOKIE_COMPARISON_RESULT.CONTAINED;
pub const KCCR_COOKIE_KNOWLEDGE_CONTAINS = KNOWLEDGE_COOKIE_COMPARISON_RESULT.CONTAINS;
pub const KCCR_COOKIE_KNOWLEDGE_NOT_COMPARABLE = KNOWLEDGE_COOKIE_COMPARISON_RESULT.NOT_COMPARABLE;

// TODO: this type is limited to platform 'windows6.1'
const IID_IClockVectorElement_Value = Guid.initString("e71c4250-adf8-4a07-8fae-5669596909c1");
pub const IID_IClockVectorElement = &IID_IClockVectorElement_Value;
pub const IClockVectorElement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetReplicaKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IClockVectorElement,
                pdwReplicaKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IClockVectorElement,
                pdwReplicaKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTickCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IClockVectorElement,
                pullTickCount: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IClockVectorElement,
                pullTickCount: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClockVectorElement_GetReplicaKey(self: *const T, pdwReplicaKey: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClockVectorElement.VTable, self.vtable).GetReplicaKey(@ptrCast(*const IClockVectorElement, self), pdwReplicaKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClockVectorElement_GetTickCount(self: *const T, pullTickCount: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClockVectorElement.VTable, self.vtable).GetTickCount(@ptrCast(*const IClockVectorElement, self), pullTickCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IFeedClockVectorElement_Value = Guid.initString("a40b46d2-e97b-4156-b6da-991f501b0f05");
pub const IID_IFeedClockVectorElement = &IID_IFeedClockVectorElement_Value;
pub const IFeedClockVectorElement = extern struct {
    pub const VTable = extern struct {
        base: IClockVectorElement.VTable,
        GetSyncTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFeedClockVectorElement,
                pSyncTime: ?*SYNC_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFeedClockVectorElement,
                pSyncTime: ?*SYNC_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFeedClockVectorElement,
                pbFlags: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFeedClockVectorElement,
                pbFlags: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IClockVectorElement.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFeedClockVectorElement_GetSyncTime(self: *const T, pSyncTime: ?*SYNC_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFeedClockVectorElement.VTable, self.vtable).GetSyncTime(@ptrCast(*const IFeedClockVectorElement, self), pSyncTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFeedClockVectorElement_GetFlags(self: *const T, pbFlags: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFeedClockVectorElement.VTable, self.vtable).GetFlags(@ptrCast(*const IFeedClockVectorElement, self), pbFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IClockVector_Value = Guid.initString("14b2274a-8698-4cc6-9333-f89bd1d47bc4");
pub const IID_IClockVector = &IID_IClockVector_Value;
pub const IClockVector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClockVectorElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IClockVector,
                riid: ?*const Guid,
                ppiEnumClockVector: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IClockVector,
                riid: ?*const Guid,
                ppiEnumClockVector: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClockVectorElementCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IClockVector,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IClockVector,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClockVector_GetClockVectorElements(self: *const T, riid: ?*const Guid, ppiEnumClockVector: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClockVector.VTable, self.vtable).GetClockVectorElements(@ptrCast(*const IClockVector, self), riid, ppiEnumClockVector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClockVector_GetClockVectorElementCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClockVector.VTable, self.vtable).GetClockVectorElementCount(@ptrCast(*const IClockVector, self), pdwCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IFeedClockVector_Value = Guid.initString("8d1d98d1-9fb8-4ec9-a553-54dd924e0f67");
pub const IID_IFeedClockVector = &IID_IFeedClockVector_Value;
pub const IFeedClockVector = extern struct {
    pub const VTable = extern struct {
        base: IClockVector.VTable,
        GetUpdateCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFeedClockVector,
                pdwUpdateCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFeedClockVector,
                pdwUpdateCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsNoConflictsSpecified: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFeedClockVector,
                pfIsNoConflictsSpecified: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFeedClockVector,
                pfIsNoConflictsSpecified: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IClockVector.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFeedClockVector_GetUpdateCount(self: *const T, pdwUpdateCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFeedClockVector.VTable, self.vtable).GetUpdateCount(@ptrCast(*const IFeedClockVector, self), pdwUpdateCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFeedClockVector_IsNoConflictsSpecified(self: *const T, pfIsNoConflictsSpecified: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFeedClockVector.VTable, self.vtable).IsNoConflictsSpecified(@ptrCast(*const IFeedClockVector, self), pfIsNoConflictsSpecified);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IEnumClockVector_Value = Guid.initString("525844db-2837-4799-9e80-81a66e02220c");
pub const IID_IEnumClockVector = &IID_IEnumClockVector_Value;
pub const IEnumClockVector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumClockVector,
                cClockVectorElements: u32,
                ppiClockVectorElements: ?*?*IClockVectorElement,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumClockVector,
                cClockVectorElements: u32,
                ppiClockVectorElements: ?*?*IClockVectorElement,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumClockVector,
                cSyncVersions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumClockVector,
                cSyncVersions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumClockVector,
                ppiEnum: ?*?*IEnumClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumClockVector,
                ppiEnum: ?*?*IEnumClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumClockVector_Next(self: *const T, cClockVectorElements: u32, ppiClockVectorElements: ?*?*IClockVectorElement, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumClockVector.VTable, self.vtable).Next(@ptrCast(*const IEnumClockVector, self), cClockVectorElements, ppiClockVectorElements, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumClockVector_Skip(self: *const T, cSyncVersions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumClockVector.VTable, self.vtable).Skip(@ptrCast(*const IEnumClockVector, self), cSyncVersions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumClockVector_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumClockVector.VTable, self.vtable).Reset(@ptrCast(*const IEnumClockVector, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumClockVector_Clone(self: *const T, ppiEnum: ?*?*IEnumClockVector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumClockVector.VTable, self.vtable).Clone(@ptrCast(*const IEnumClockVector, self), ppiEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IEnumFeedClockVector_Value = Guid.initString("550f763d-146a-48f6-abeb-6c88c7f70514");
pub const IID_IEnumFeedClockVector = &IID_IEnumFeedClockVector_Value;
pub const IEnumFeedClockVector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFeedClockVector,
                cClockVectorElements: u32,
                ppiClockVectorElements: ?*?*IFeedClockVectorElement,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFeedClockVector,
                cClockVectorElements: u32,
                ppiClockVectorElements: ?*?*IFeedClockVectorElement,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFeedClockVector,
                cSyncVersions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFeedClockVector,
                cSyncVersions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFeedClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFeedClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFeedClockVector,
                ppiEnum: ?*?*IEnumFeedClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFeedClockVector,
                ppiEnum: ?*?*IEnumFeedClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFeedClockVector_Next(self: *const T, cClockVectorElements: u32, ppiClockVectorElements: ?*?*IFeedClockVectorElement, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFeedClockVector.VTable, self.vtable).Next(@ptrCast(*const IEnumFeedClockVector, self), cClockVectorElements, ppiClockVectorElements, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFeedClockVector_Skip(self: *const T, cSyncVersions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFeedClockVector.VTable, self.vtable).Skip(@ptrCast(*const IEnumFeedClockVector, self), cSyncVersions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFeedClockVector_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFeedClockVector.VTable, self.vtable).Reset(@ptrCast(*const IEnumFeedClockVector, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFeedClockVector_Clone(self: *const T, ppiEnum: ?*?*IEnumFeedClockVector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFeedClockVector.VTable, self.vtable).Clone(@ptrCast(*const IEnumFeedClockVector, self), ppiEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ICoreFragment_Value = Guid.initString("613b2ab5-b304-47d9-9c31-ce6c54401a15");
pub const IID_ICoreFragment = &IID_ICoreFragment_Value;
pub const ICoreFragment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NextColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICoreFragment,
                pChangeUnitId: ?*u8,
                pChangeUnitIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICoreFragment,
                pChangeUnitId: ?*u8,
                pChangeUnitIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NextRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICoreFragment,
                pItemId: ?*u8,
                pItemIdSize: ?*u32,
                piClockVector: ?*?*IClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICoreFragment,
                pItemId: ?*u8,
                pItemIdSize: ?*u32,
                piClockVector: ?*?*IClockVector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICoreFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICoreFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICoreFragment,
                pColumnCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICoreFragment,
                pColumnCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRangeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICoreFragment,
                pRangeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICoreFragment,
                pRangeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICoreFragment_NextColumn(self: *const T, pChangeUnitId: ?*u8, pChangeUnitIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICoreFragment.VTable, self.vtable).NextColumn(@ptrCast(*const ICoreFragment, self), pChangeUnitId, pChangeUnitIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICoreFragment_NextRange(self: *const T, pItemId: ?*u8, pItemIdSize: ?*u32, piClockVector: ?*?*IClockVector) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICoreFragment.VTable, self.vtable).NextRange(@ptrCast(*const ICoreFragment, self), pItemId, pItemIdSize, piClockVector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICoreFragment_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICoreFragment.VTable, self.vtable).Reset(@ptrCast(*const ICoreFragment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICoreFragment_GetColumnCount(self: *const T, pColumnCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICoreFragment.VTable, self.vtable).GetColumnCount(@ptrCast(*const ICoreFragment, self), pColumnCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICoreFragment_GetRangeCount(self: *const T, pRangeCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICoreFragment.VTable, self.vtable).GetRangeCount(@ptrCast(*const ICoreFragment, self), pRangeCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ICoreFragmentInspector_Value = Guid.initString("f7fcc5fd-ae26-4679-ba16-96aac583c134");
pub const IID_ICoreFragmentInspector = &IID_ICoreFragmentInspector_Value;
pub const ICoreFragmentInspector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NextCoreFragments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICoreFragmentInspector,
                requestedCount: u32,
                ppiCoreFragments: ?*?*ICoreFragment,
                pFetchedCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICoreFragmentInspector,
                requestedCount: u32,
                ppiCoreFragments: ?*?*ICoreFragment,
                pFetchedCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICoreFragmentInspector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICoreFragmentInspector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICoreFragmentInspector_NextCoreFragments(self: *const T, requestedCount: u32, ppiCoreFragments: ?*?*ICoreFragment, pFetchedCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICoreFragmentInspector.VTable, self.vtable).NextCoreFragments(@ptrCast(*const ICoreFragmentInspector, self), requestedCount, ppiCoreFragments, pFetchedCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICoreFragmentInspector_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICoreFragmentInspector.VTable, self.vtable).Reset(@ptrCast(*const ICoreFragmentInspector, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IRangeException_Value = Guid.initString("75ae8777-6848-49f7-956c-a3a92f5096e8");
pub const IID_IRangeException = &IID_IRangeException_Value;
pub const IRangeException = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClosedRangeStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRangeException,
                pbClosedRangeStart: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRangeException,
                pbClosedRangeStart: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClosedRangeEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRangeException,
                pbClosedRangeEnd: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRangeException,
                pbClosedRangeEnd: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClockVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRangeException,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRangeException,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeException_GetClosedRangeStart(self: *const T, pbClosedRangeStart: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeException.VTable, self.vtable).GetClosedRangeStart(@ptrCast(*const IRangeException, self), pbClosedRangeStart, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeException_GetClosedRangeEnd(self: *const T, pbClosedRangeEnd: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeException.VTable, self.vtable).GetClosedRangeEnd(@ptrCast(*const IRangeException, self), pbClosedRangeEnd, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeException_GetClockVector(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeException.VTable, self.vtable).GetClockVector(@ptrCast(*const IRangeException, self), riid, ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IEnumRangeExceptions_Value = Guid.initString("0944439f-ddb1-4176-b703-046ff22a2386");
pub const IID_IEnumRangeExceptions = &IID_IEnumRangeExceptions_Value;
pub const IEnumRangeExceptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRangeExceptions,
                cExceptions: u32,
                ppRangeException: ?*?*IRangeException,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRangeExceptions,
                cExceptions: u32,
                ppRangeException: ?*?*IRangeException,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRangeExceptions,
                cExceptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRangeExceptions,
                cExceptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRangeExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRangeExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRangeExceptions,
                ppEnum: ?*?*IEnumRangeExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRangeExceptions,
                ppEnum: ?*?*IEnumRangeExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRangeExceptions_Next(self: *const T, cExceptions: u32, ppRangeException: ?*?*IRangeException, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRangeExceptions.VTable, self.vtable).Next(@ptrCast(*const IEnumRangeExceptions, self), cExceptions, ppRangeException, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRangeExceptions_Skip(self: *const T, cExceptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRangeExceptions.VTable, self.vtable).Skip(@ptrCast(*const IEnumRangeExceptions, self), cExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRangeExceptions_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRangeExceptions.VTable, self.vtable).Reset(@ptrCast(*const IEnumRangeExceptions, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRangeExceptions_Clone(self: *const T, ppEnum: ?*?*IEnumRangeExceptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRangeExceptions.VTable, self.vtable).Clone(@ptrCast(*const IEnumRangeExceptions, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISingleItemException_Value = Guid.initString("892fb9b0-7c55-4a18-9316-fdf449569b64");
pub const IID_ISingleItemException = &IID_ISingleItemException_Value;
pub const ISingleItemException = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISingleItemException,
                pbItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISingleItemException,
                pbItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClockVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISingleItemException,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISingleItemException,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISingleItemException_GetItemId(self: *const T, pbItemId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISingleItemException.VTable, self.vtable).GetItemId(@ptrCast(*const ISingleItemException, self), pbItemId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISingleItemException_GetClockVector(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISingleItemException.VTable, self.vtable).GetClockVector(@ptrCast(*const ISingleItemException, self), riid, ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IEnumSingleItemExceptions_Value = Guid.initString("e563381c-1b4d-4c66-9796-c86faccdcd40");
pub const IID_IEnumSingleItemExceptions = &IID_IEnumSingleItemExceptions_Value;
pub const IEnumSingleItemExceptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSingleItemExceptions,
                cExceptions: u32,
                ppSingleItemException: ?*?*ISingleItemException,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSingleItemExceptions,
                cExceptions: u32,
                ppSingleItemException: ?*?*ISingleItemException,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSingleItemExceptions,
                cExceptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSingleItemExceptions,
                cExceptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSingleItemExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSingleItemExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSingleItemExceptions,
                ppEnum: ?*?*IEnumSingleItemExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSingleItemExceptions,
                ppEnum: ?*?*IEnumSingleItemExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSingleItemExceptions_Next(self: *const T, cExceptions: u32, ppSingleItemException: ?*?*ISingleItemException, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSingleItemExceptions.VTable, self.vtable).Next(@ptrCast(*const IEnumSingleItemExceptions, self), cExceptions, ppSingleItemException, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSingleItemExceptions_Skip(self: *const T, cExceptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSingleItemExceptions.VTable, self.vtable).Skip(@ptrCast(*const IEnumSingleItemExceptions, self), cExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSingleItemExceptions_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSingleItemExceptions.VTable, self.vtable).Reset(@ptrCast(*const IEnumSingleItemExceptions, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSingleItemExceptions_Clone(self: *const T, ppEnum: ?*?*IEnumSingleItemExceptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSingleItemExceptions.VTable, self.vtable).Clone(@ptrCast(*const IEnumSingleItemExceptions, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IChangeUnitException_Value = Guid.initString("0cd7ee7c-fec0-4021-99ee-f0e5348f2a5f");
pub const IID_IChangeUnitException = &IID_IChangeUnitException_Value;
pub const IChangeUnitException = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeUnitException,
                pbItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeUnitException,
                pbItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeUnitId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeUnitException,
                pbChangeUnitId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeUnitException,
                pbChangeUnitId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClockVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeUnitException,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeUnitException,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeUnitException_GetItemId(self: *const T, pbItemId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeUnitException.VTable, self.vtable).GetItemId(@ptrCast(*const IChangeUnitException, self), pbItemId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeUnitException_GetChangeUnitId(self: *const T, pbChangeUnitId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeUnitException.VTable, self.vtable).GetChangeUnitId(@ptrCast(*const IChangeUnitException, self), pbChangeUnitId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeUnitException_GetClockVector(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeUnitException.VTable, self.vtable).GetClockVector(@ptrCast(*const IChangeUnitException, self), riid, ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IEnumChangeUnitExceptions_Value = Guid.initString("3074e802-9319-4420-be21-1022e2e21da8");
pub const IID_IEnumChangeUnitExceptions = &IID_IEnumChangeUnitExceptions_Value;
pub const IEnumChangeUnitExceptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumChangeUnitExceptions,
                cExceptions: u32,
                ppChangeUnitException: ?*?*IChangeUnitException,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumChangeUnitExceptions,
                cExceptions: u32,
                ppChangeUnitException: ?*?*IChangeUnitException,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumChangeUnitExceptions,
                cExceptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumChangeUnitExceptions,
                cExceptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumChangeUnitExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumChangeUnitExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumChangeUnitExceptions,
                ppEnum: ?*?*IEnumChangeUnitExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumChangeUnitExceptions,
                ppEnum: ?*?*IEnumChangeUnitExceptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumChangeUnitExceptions_Next(self: *const T, cExceptions: u32, ppChangeUnitException: ?*?*IChangeUnitException, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumChangeUnitExceptions.VTable, self.vtable).Next(@ptrCast(*const IEnumChangeUnitExceptions, self), cExceptions, ppChangeUnitException, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumChangeUnitExceptions_Skip(self: *const T, cExceptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumChangeUnitExceptions.VTable, self.vtable).Skip(@ptrCast(*const IEnumChangeUnitExceptions, self), cExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumChangeUnitExceptions_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumChangeUnitExceptions.VTable, self.vtable).Reset(@ptrCast(*const IEnumChangeUnitExceptions, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumChangeUnitExceptions_Clone(self: *const T, ppEnum: ?*?*IEnumChangeUnitExceptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumChangeUnitExceptions.VTable, self.vtable).Clone(@ptrCast(*const IEnumChangeUnitExceptions, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IReplicaKeyMap_Value = Guid.initString("2209f4fc-fd10-4ff0-84a8-f0a1982e440e");
pub const IID_IReplicaKeyMap = &IID_IReplicaKeyMap_Value;
pub const IReplicaKeyMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LookupReplicaKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IReplicaKeyMap,
                pbReplicaId: ?*const u8,
                pdwReplicaKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IReplicaKeyMap,
                pbReplicaId: ?*const u8,
                pdwReplicaKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LookupReplicaId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IReplicaKeyMap,
                dwReplicaKey: u32,
                pbReplicaId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IReplicaKeyMap,
                dwReplicaKey: u32,
                pbReplicaId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IReplicaKeyMap,
                pbReplicaKeyMap: ?*u8,
                pcbReplicaKeyMap: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IReplicaKeyMap,
                pbReplicaKeyMap: ?*u8,
                pcbReplicaKeyMap: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReplicaKeyMap_LookupReplicaKey(self: *const T, pbReplicaId: ?*const u8, pdwReplicaKey: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReplicaKeyMap.VTable, self.vtable).LookupReplicaKey(@ptrCast(*const IReplicaKeyMap, self), pbReplicaId, pdwReplicaKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReplicaKeyMap_LookupReplicaId(self: *const T, dwReplicaKey: u32, pbReplicaId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReplicaKeyMap.VTable, self.vtable).LookupReplicaId(@ptrCast(*const IReplicaKeyMap, self), dwReplicaKey, pbReplicaId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReplicaKeyMap_Serialize(self: *const T, pbReplicaKeyMap: ?*u8, pcbReplicaKeyMap: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReplicaKeyMap.VTable, self.vtable).Serialize(@ptrCast(*const IReplicaKeyMap, self), pbReplicaKeyMap, pcbReplicaKeyMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IConstructReplicaKeyMap_Value = Guid.initString("ded10970-ec85-4115-b52c-4405845642a5");
pub const IID_IConstructReplicaKeyMap = &IID_IConstructReplicaKeyMap_Value;
pub const IConstructReplicaKeyMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindOrAddReplica: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstructReplicaKeyMap,
                pbReplicaId: ?*const u8,
                pdwReplicaKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstructReplicaKeyMap,
                pbReplicaId: ?*const u8,
                pdwReplicaKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstructReplicaKeyMap_FindOrAddReplica(self: *const T, pbReplicaId: ?*const u8, pdwReplicaKey: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstructReplicaKeyMap.VTable, self.vtable).FindOrAddReplica(@ptrCast(*const IConstructReplicaKeyMap, self), pbReplicaId, pdwReplicaKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncKnowledge_Value = Guid.initString("615bbb53-c945-4203-bf4b-2cb65919a0aa");
pub const IID_ISyncKnowledge = &IID_ISyncKnowledge_Value;
pub const ISyncKnowledge = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOwnerReplicaId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbReplicaId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbReplicaId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                fSerializeReplicaKeyMap: BOOL,
                pbKnowledge: ?*u8,
                pcbKnowledge: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                fSerializeReplicaKeyMap: BOOL,
                pbKnowledge: ?*u8,
                pcbKnowledge: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLocalTickCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                ullTickCount: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                ullTickCount: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContainsChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbVersionOwnerReplicaId: ?*const u8,
                pgidItemId: ?*const u8,
                pSyncVersion: ?*const SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbVersionOwnerReplicaId: ?*const u8,
                pgidItemId: ?*const u8,
                pSyncVersion: ?*const SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContainsChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbVersionOwnerReplicaId: ?*const u8,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
                pSyncVersion: ?*const SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbVersionOwnerReplicaId: ?*const u8,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
                pSyncVersion: ?*const SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReplicaKeyMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                ppReplicaKeyMap: ?*?*IReplicaKeyMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                ppReplicaKeyMap: ?*?*IReplicaKeyMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                ppClonedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                ppClonedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pKnowledgeIn: ?*ISyncKnowledge,
                pbCurrentOwnerId: ?*const u8,
                pVersionIn: ?*const SYNC_VERSION,
                pbNewOwnerId: ?*u8,
                pcbIdSize: ?*u32,
                pVersionOut: ?*SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pKnowledgeIn: ?*ISyncKnowledge,
                pbCurrentOwnerId: ?*const u8,
                pVersionIn: ?*const SYNC_VERSION,
                pbNewOwnerId: ?*u8,
                pcbIdSize: ?*u32,
                pVersionOut: ?*SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapRemoteToLocal: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pRemoteKnowledge: ?*ISyncKnowledge,
                ppMappedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pRemoteKnowledge: ?*ISyncKnowledge,
                ppMappedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Union: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProjectOntoItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                ppKnowledgeOut: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                ppKnowledgeOut: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProjectOntoChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
                ppKnowledgeOut: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
                ppKnowledgeOut: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProjectOntoRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                psrngSyncRange: ?*const SYNC_RANGE,
                ppKnowledgeOut: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                psrngSyncRange: ?*const SYNC_RANGE,
                ppKnowledgeOut: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExcludeItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExcludeChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContainsKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindMinTickCountForReplica: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbReplicaId: ?*const u8,
                pullReplicaTickCount: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbReplicaId: ?*const u8,
                pullReplicaTickCount: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRangeExceptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSingleItemExceptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeUnitExceptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindClockVectorForItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindClockVectorForChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_GetOwnerReplicaId(self: *const T, pbReplicaId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).GetOwnerReplicaId(@ptrCast(*const ISyncKnowledge, self), pbReplicaId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_Serialize(self: *const T, fSerializeReplicaKeyMap: BOOL, pbKnowledge: ?*u8, pcbKnowledge: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).Serialize(@ptrCast(*const ISyncKnowledge, self), fSerializeReplicaKeyMap, pbKnowledge, pcbKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_SetLocalTickCount(self: *const T, ullTickCount: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).SetLocalTickCount(@ptrCast(*const ISyncKnowledge, self), ullTickCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_ContainsChange(self: *const T, pbVersionOwnerReplicaId: ?*const u8, pgidItemId: ?*const u8, pSyncVersion: ?*const SYNC_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).ContainsChange(@ptrCast(*const ISyncKnowledge, self), pbVersionOwnerReplicaId, pgidItemId, pSyncVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_ContainsChangeUnit(self: *const T, pbVersionOwnerReplicaId: ?*const u8, pbItemId: ?*const u8, pbChangeUnitId: ?*const u8, pSyncVersion: ?*const SYNC_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).ContainsChangeUnit(@ptrCast(*const ISyncKnowledge, self), pbVersionOwnerReplicaId, pbItemId, pbChangeUnitId, pSyncVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_GetScopeVector(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).GetScopeVector(@ptrCast(*const ISyncKnowledge, self), riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_GetReplicaKeyMap(self: *const T, ppReplicaKeyMap: ?*?*IReplicaKeyMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).GetReplicaKeyMap(@ptrCast(*const ISyncKnowledge, self), ppReplicaKeyMap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_Clone(self: *const T, ppClonedKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).Clone(@ptrCast(*const ISyncKnowledge, self), ppClonedKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_ConvertVersion(self: *const T, pKnowledgeIn: ?*ISyncKnowledge, pbCurrentOwnerId: ?*const u8, pVersionIn: ?*const SYNC_VERSION, pbNewOwnerId: ?*u8, pcbIdSize: ?*u32, pVersionOut: ?*SYNC_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).ConvertVersion(@ptrCast(*const ISyncKnowledge, self), pKnowledgeIn, pbCurrentOwnerId, pVersionIn, pbNewOwnerId, pcbIdSize, pVersionOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_MapRemoteToLocal(self: *const T, pRemoteKnowledge: ?*ISyncKnowledge, ppMappedKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).MapRemoteToLocal(@ptrCast(*const ISyncKnowledge, self), pRemoteKnowledge, ppMappedKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_Union(self: *const T, pKnowledge: ?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).Union(@ptrCast(*const ISyncKnowledge, self), pKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_ProjectOntoItem(self: *const T, pbItemId: ?*const u8, ppKnowledgeOut: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).ProjectOntoItem(@ptrCast(*const ISyncKnowledge, self), pbItemId, ppKnowledgeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_ProjectOntoChangeUnit(self: *const T, pbItemId: ?*const u8, pbChangeUnitId: ?*const u8, ppKnowledgeOut: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).ProjectOntoChangeUnit(@ptrCast(*const ISyncKnowledge, self), pbItemId, pbChangeUnitId, ppKnowledgeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_ProjectOntoRange(self: *const T, psrngSyncRange: ?*const SYNC_RANGE, ppKnowledgeOut: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).ProjectOntoRange(@ptrCast(*const ISyncKnowledge, self), psrngSyncRange, ppKnowledgeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_ExcludeItem(self: *const T, pbItemId: ?*const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).ExcludeItem(@ptrCast(*const ISyncKnowledge, self), pbItemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_ExcludeChangeUnit(self: *const T, pbItemId: ?*const u8, pbChangeUnitId: ?*const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).ExcludeChangeUnit(@ptrCast(*const ISyncKnowledge, self), pbItemId, pbChangeUnitId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_ContainsKnowledge(self: *const T, pKnowledge: ?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).ContainsKnowledge(@ptrCast(*const ISyncKnowledge, self), pKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_FindMinTickCountForReplica(self: *const T, pbReplicaId: ?*const u8, pullReplicaTickCount: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).FindMinTickCountForReplica(@ptrCast(*const ISyncKnowledge, self), pbReplicaId, pullReplicaTickCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_GetRangeExceptions(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).GetRangeExceptions(@ptrCast(*const ISyncKnowledge, self), riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_GetSingleItemExceptions(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).GetSingleItemExceptions(@ptrCast(*const ISyncKnowledge, self), riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_GetChangeUnitExceptions(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).GetChangeUnitExceptions(@ptrCast(*const ISyncKnowledge, self), riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_FindClockVectorForItem(self: *const T, pbItemId: ?*const u8, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).FindClockVectorForItem(@ptrCast(*const ISyncKnowledge, self), pbItemId, riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_FindClockVectorForChangeUnit(self: *const T, pbItemId: ?*const u8, pbChangeUnitId: ?*const u8, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).FindClockVectorForChangeUnit(@ptrCast(*const ISyncKnowledge, self), pbItemId, pbChangeUnitId, riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge_GetVersion(self: *const T, pdwVersion: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge.VTable, self.vtable).GetVersion(@ptrCast(*const ISyncKnowledge, self), pdwVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IForgottenKnowledge_Value = Guid.initString("456e0f96-6036-452b-9f9d-bcc4b4a85db2");
pub const IID_IForgottenKnowledge = &IID_IForgottenKnowledge_Value;
pub const IForgottenKnowledge = extern struct {
    pub const VTable = extern struct {
        base: ISyncKnowledge.VTable,
        ForgetToVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IForgottenKnowledge,
                pKnowledge: ?*ISyncKnowledge,
                pVersion: ?*const SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IForgottenKnowledge,
                pKnowledge: ?*ISyncKnowledge,
                pVersion: ?*const SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncKnowledge.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IForgottenKnowledge_ForgetToVersion(self: *const T, pKnowledge: ?*ISyncKnowledge, pVersion: ?*const SYNC_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IForgottenKnowledge.VTable, self.vtable).ForgetToVersion(@ptrCast(*const IForgottenKnowledge, self), pKnowledge, pVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncKnowledge2_Value = Guid.initString("ed0addc0-3b4b-46a1-9a45-45661d2114c8");
pub const IID_ISyncKnowledge2 = &IID_ISyncKnowledge2_Value;
pub const ISyncKnowledge2 = extern struct {
    pub const VTable = extern struct {
        base: ISyncKnowledge.VTable,
        GetIdParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                pIdParameters: ?*ID_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                pIdParameters: ?*ID_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProjectOntoColumnSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                ppColumns: ?*const ?*u8,
                count: u32,
                ppiKnowledgeOut: ?*?*ISyncKnowledge2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                ppColumns: ?*const ?*u8,
                count: u32,
                ppiKnowledgeOut: ?*?*ISyncKnowledge2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SerializeWithOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                targetFormatVersion: SYNC_SERIALIZATION_VERSION,
                dwFlags: u32,
                pbBuffer: ?*u8,
                pdwSerializedSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                targetFormatVersion: SYNC_SERIALIZATION_VERSION,
                dwFlags: u32,
                pbBuffer: ?*u8,
                pdwSerializedSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLowestUncontainedId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                piSyncKnowledge: ?*ISyncKnowledge2,
                pbItemId: ?*u8,
                pcbItemIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                piSyncKnowledge: ?*ISyncKnowledge2,
                pbItemId: ?*u8,
                pcbItemIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInspector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                riid: ?*const Guid,
                ppiInspector: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                riid: ?*const Guid,
                ppiInspector: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMinimumSupportedVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                pVersion: ?*SYNC_SERIALIZATION_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                pVersion: ?*SYNC_SERIALIZATION_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                which: SYNC_STATISTICS,
                pValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                which: SYNC_STATISTICS,
                pValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContainsKnowledgeForItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                pKnowledge: ?*ISyncKnowledge,
                pbItemId: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                pKnowledge: ?*ISyncKnowledge,
                pbItemId: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContainsKnowledgeForChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                pKnowledge: ?*ISyncKnowledge,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                pKnowledge: ?*ISyncKnowledge,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProjectOntoKnowledgeWithPrerequisite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                pPrerequisiteKnowledge: ?*ISyncKnowledge,
                pTemplateKnowledge: ?*ISyncKnowledge,
                ppProjectedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                pPrerequisiteKnowledge: ?*ISyncKnowledge,
                pTemplateKnowledge: ?*ISyncKnowledge,
                ppProjectedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Complement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                pSyncKnowledge: ?*ISyncKnowledge,
                ppComplementedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                pSyncKnowledge: ?*ISyncKnowledge,
                ppComplementedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IntersectsWithKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                pSyncKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                pSyncKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKnowledgeCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                ppKnowledgeCookie: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                ppKnowledgeCookie: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareToKnowledgeCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncKnowledge2,
                pKnowledgeCookie: ?*IUnknown,
                pResult: ?*KNOWLEDGE_COOKIE_COMPARISON_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncKnowledge2,
                pKnowledgeCookie: ?*IUnknown,
                pResult: ?*KNOWLEDGE_COOKIE_COMPARISON_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncKnowledge.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_GetIdParameters(self: *const T, pIdParameters: ?*ID_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).GetIdParameters(@ptrCast(*const ISyncKnowledge2, self), pIdParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_ProjectOntoColumnSet(self: *const T, ppColumns: ?*const ?*u8, count: u32, ppiKnowledgeOut: ?*?*ISyncKnowledge2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).ProjectOntoColumnSet(@ptrCast(*const ISyncKnowledge2, self), ppColumns, count, ppiKnowledgeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_SerializeWithOptions(self: *const T, targetFormatVersion: SYNC_SERIALIZATION_VERSION, dwFlags: u32, pbBuffer: ?*u8, pdwSerializedSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).SerializeWithOptions(@ptrCast(*const ISyncKnowledge2, self), targetFormatVersion, dwFlags, pbBuffer, pdwSerializedSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_GetLowestUncontainedId(self: *const T, piSyncKnowledge: ?*ISyncKnowledge2, pbItemId: ?*u8, pcbItemIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).GetLowestUncontainedId(@ptrCast(*const ISyncKnowledge2, self), piSyncKnowledge, pbItemId, pcbItemIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_GetInspector(self: *const T, riid: ?*const Guid, ppiInspector: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).GetInspector(@ptrCast(*const ISyncKnowledge2, self), riid, ppiInspector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_GetMinimumSupportedVersion(self: *const T, pVersion: ?*SYNC_SERIALIZATION_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).GetMinimumSupportedVersion(@ptrCast(*const ISyncKnowledge2, self), pVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_GetStatistics(self: *const T, which: SYNC_STATISTICS, pValue: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).GetStatistics(@ptrCast(*const ISyncKnowledge2, self), which, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_ContainsKnowledgeForItem(self: *const T, pKnowledge: ?*ISyncKnowledge, pbItemId: ?*const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).ContainsKnowledgeForItem(@ptrCast(*const ISyncKnowledge2, self), pKnowledge, pbItemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_ContainsKnowledgeForChangeUnit(self: *const T, pKnowledge: ?*ISyncKnowledge, pbItemId: ?*const u8, pbChangeUnitId: ?*const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).ContainsKnowledgeForChangeUnit(@ptrCast(*const ISyncKnowledge2, self), pKnowledge, pbItemId, pbChangeUnitId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_ProjectOntoKnowledgeWithPrerequisite(self: *const T, pPrerequisiteKnowledge: ?*ISyncKnowledge, pTemplateKnowledge: ?*ISyncKnowledge, ppProjectedKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).ProjectOntoKnowledgeWithPrerequisite(@ptrCast(*const ISyncKnowledge2, self), pPrerequisiteKnowledge, pTemplateKnowledge, ppProjectedKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_Complement(self: *const T, pSyncKnowledge: ?*ISyncKnowledge, ppComplementedKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).Complement(@ptrCast(*const ISyncKnowledge2, self), pSyncKnowledge, ppComplementedKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_IntersectsWithKnowledge(self: *const T, pSyncKnowledge: ?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).IntersectsWithKnowledge(@ptrCast(*const ISyncKnowledge2, self), pSyncKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_GetKnowledgeCookie(self: *const T, ppKnowledgeCookie: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).GetKnowledgeCookie(@ptrCast(*const ISyncKnowledge2, self), ppKnowledgeCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncKnowledge2_CompareToKnowledgeCookie(self: *const T, pKnowledgeCookie: ?*IUnknown, pResult: ?*KNOWLEDGE_COOKIE_COMPARISON_RESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncKnowledge2.VTable, self.vtable).CompareToKnowledgeCookie(@ptrCast(*const ISyncKnowledge2, self), pKnowledgeCookie, pResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IRecoverableErrorData_Value = Guid.initString("b37c4a0a-4b7d-4c2d-9711-3b00d119b1c8");
pub const IID_IRecoverableErrorData = &IID_IRecoverableErrorData_Value;
pub const IRecoverableErrorData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRecoverableErrorData,
                pcszItemDisplayName: ?[*:0]const u16,
                pcszErrorDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRecoverableErrorData,
                pcszItemDisplayName: ?[*:0]const u16,
                pcszErrorDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRecoverableErrorData,
                pszItemDisplayName: ?PWSTR,
                pcchItemDisplayName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRecoverableErrorData,
                pszItemDisplayName: ?PWSTR,
                pcchItemDisplayName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRecoverableErrorData,
                pszErrorDescription: ?PWSTR,
                pcchErrorDescription: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRecoverableErrorData,
                pszErrorDescription: ?PWSTR,
                pcchErrorDescription: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecoverableErrorData_Initialize(self: *const T, pcszItemDisplayName: ?[*:0]const u16, pcszErrorDescription: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecoverableErrorData.VTable, self.vtable).Initialize(@ptrCast(*const IRecoverableErrorData, self), pcszItemDisplayName, pcszErrorDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecoverableErrorData_GetItemDisplayName(self: *const T, pszItemDisplayName: ?PWSTR, pcchItemDisplayName: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecoverableErrorData.VTable, self.vtable).GetItemDisplayName(@ptrCast(*const IRecoverableErrorData, self), pszItemDisplayName, pcchItemDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecoverableErrorData_GetErrorDescription(self: *const T, pszErrorDescription: ?PWSTR, pcchErrorDescription: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecoverableErrorData.VTable, self.vtable).GetErrorDescription(@ptrCast(*const IRecoverableErrorData, self), pszErrorDescription, pcchErrorDescription);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IRecoverableError_Value = Guid.initString("0f5625e8-0a7b-45ee-9637-1ce13645909e");
pub const IID_IRecoverableError = &IID_IRecoverableError_Value;
pub const IRecoverableError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRecoverableError,
                pStage: ?*SYNC_PROGRESS_STAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRecoverableError,
                pStage: ?*SYNC_PROGRESS_STAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRecoverableError,
                pProviderRole: ?*SYNC_PROVIDER_ROLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRecoverableError,
                pProviderRole: ?*SYNC_PROVIDER_ROLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeWithRecoverableError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRecoverableError,
                ppChangeWithRecoverableError: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRecoverableError,
                ppChangeWithRecoverableError: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecoverableErrorDataForChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRecoverableError,
                phrError: ?*HRESULT,
                ppErrorData: ?*?*IRecoverableErrorData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRecoverableError,
                phrError: ?*HRESULT,
                ppErrorData: ?*?*IRecoverableErrorData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecoverableErrorDataForChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRecoverableError,
                pChangeUnit: ?*ISyncChangeUnit,
                phrError: ?*HRESULT,
                ppErrorData: ?*?*IRecoverableErrorData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRecoverableError,
                pChangeUnit: ?*ISyncChangeUnit,
                phrError: ?*HRESULT,
                ppErrorData: ?*?*IRecoverableErrorData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecoverableError_GetStage(self: *const T, pStage: ?*SYNC_PROGRESS_STAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecoverableError.VTable, self.vtable).GetStage(@ptrCast(*const IRecoverableError, self), pStage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecoverableError_GetProvider(self: *const T, pProviderRole: ?*SYNC_PROVIDER_ROLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecoverableError.VTable, self.vtable).GetProvider(@ptrCast(*const IRecoverableError, self), pProviderRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecoverableError_GetChangeWithRecoverableError(self: *const T, ppChangeWithRecoverableError: ?*?*ISyncChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecoverableError.VTable, self.vtable).GetChangeWithRecoverableError(@ptrCast(*const IRecoverableError, self), ppChangeWithRecoverableError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecoverableError_GetRecoverableErrorDataForChange(self: *const T, phrError: ?*HRESULT, ppErrorData: ?*?*IRecoverableErrorData) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecoverableError.VTable, self.vtable).GetRecoverableErrorDataForChange(@ptrCast(*const IRecoverableError, self), phrError, ppErrorData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecoverableError_GetRecoverableErrorDataForChangeUnit(self: *const T, pChangeUnit: ?*ISyncChangeUnit, phrError: ?*HRESULT, ppErrorData: ?*?*IRecoverableErrorData) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecoverableError.VTable, self.vtable).GetRecoverableErrorDataForChangeUnit(@ptrCast(*const IRecoverableError, self), pChangeUnit, phrError, ppErrorData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IChangeConflict_Value = Guid.initString("014ebf97-9f20-4f7a-bdd4-25979c77c002");
pub const IID_IChangeConflict = &IID_IChangeConflict_Value;
pub const IChangeConflict = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDestinationProviderConflictingChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeConflict,
                ppConflictingChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeConflict,
                ppConflictingChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceProviderConflictingChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeConflict,
                ppConflictingChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeConflict,
                ppConflictingChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDestinationProviderConflictingData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeConflict,
                ppConflictingData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeConflict,
                ppConflictingData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceProviderConflictingData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeConflict,
                ppConflictingData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeConflict,
                ppConflictingData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResolveActionForChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeConflict,
                pResolveAction: ?*SYNC_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeConflict,
                pResolveAction: ?*SYNC_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetResolveActionForChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeConflict,
                resolveAction: SYNC_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeConflict,
                resolveAction: SYNC_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResolveActionForChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeConflict,
                pChangeUnit: ?*ISyncChangeUnit,
                pResolveAction: ?*SYNC_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeConflict,
                pChangeUnit: ?*ISyncChangeUnit,
                pResolveAction: ?*SYNC_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetResolveActionForChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeConflict,
                pChangeUnit: ?*ISyncChangeUnit,
                resolveAction: SYNC_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeConflict,
                pChangeUnit: ?*ISyncChangeUnit,
                resolveAction: SYNC_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeConflict_GetDestinationProviderConflictingChange(self: *const T, ppConflictingChange: ?*?*ISyncChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeConflict.VTable, self.vtable).GetDestinationProviderConflictingChange(@ptrCast(*const IChangeConflict, self), ppConflictingChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeConflict_GetSourceProviderConflictingChange(self: *const T, ppConflictingChange: ?*?*ISyncChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeConflict.VTable, self.vtable).GetSourceProviderConflictingChange(@ptrCast(*const IChangeConflict, self), ppConflictingChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeConflict_GetDestinationProviderConflictingData(self: *const T, ppConflictingData: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeConflict.VTable, self.vtable).GetDestinationProviderConflictingData(@ptrCast(*const IChangeConflict, self), ppConflictingData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeConflict_GetSourceProviderConflictingData(self: *const T, ppConflictingData: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeConflict.VTable, self.vtable).GetSourceProviderConflictingData(@ptrCast(*const IChangeConflict, self), ppConflictingData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeConflict_GetResolveActionForChange(self: *const T, pResolveAction: ?*SYNC_RESOLVE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeConflict.VTable, self.vtable).GetResolveActionForChange(@ptrCast(*const IChangeConflict, self), pResolveAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeConflict_SetResolveActionForChange(self: *const T, resolveAction: SYNC_RESOLVE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeConflict.VTable, self.vtable).SetResolveActionForChange(@ptrCast(*const IChangeConflict, self), resolveAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeConflict_GetResolveActionForChangeUnit(self: *const T, pChangeUnit: ?*ISyncChangeUnit, pResolveAction: ?*SYNC_RESOLVE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeConflict.VTable, self.vtable).GetResolveActionForChangeUnit(@ptrCast(*const IChangeConflict, self), pChangeUnit, pResolveAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeConflict_SetResolveActionForChangeUnit(self: *const T, pChangeUnit: ?*ISyncChangeUnit, resolveAction: SYNC_RESOLVE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeConflict.VTable, self.vtable).SetResolveActionForChangeUnit(@ptrCast(*const IChangeConflict, self), pChangeUnit, resolveAction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IConstraintConflict_Value = Guid.initString("00d2302e-1cf8-4835-b85f-b7ca4f799e0a");
pub const IID_IConstraintConflict = &IID_IConstraintConflict_Value;
pub const IConstraintConflict = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDestinationProviderConflictingChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                ppConflictingChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                ppConflictingChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceProviderConflictingChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                ppConflictingChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                ppConflictingChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDestinationProviderOriginalChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                ppOriginalChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                ppOriginalChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDestinationProviderConflictingData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                ppConflictingData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                ppConflictingData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceProviderConflictingData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                ppConflictingData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                ppConflictingData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDestinationProviderOriginalData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                ppOriginalData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                ppOriginalData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstraintResolveActionForChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                pConstraintResolveAction: ?*SYNC_CONSTRAINT_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                pConstraintResolveAction: ?*SYNC_CONSTRAINT_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConstraintResolveActionForChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                constraintResolveAction: SYNC_CONSTRAINT_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                constraintResolveAction: SYNC_CONSTRAINT_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstraintResolveActionForChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                pChangeUnit: ?*ISyncChangeUnit,
                pConstraintResolveAction: ?*SYNC_CONSTRAINT_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                pChangeUnit: ?*ISyncChangeUnit,
                pConstraintResolveAction: ?*SYNC_CONSTRAINT_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConstraintResolveActionForChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                pChangeUnit: ?*ISyncChangeUnit,
                constraintResolveAction: SYNC_CONSTRAINT_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                pChangeUnit: ?*ISyncChangeUnit,
                constraintResolveAction: SYNC_CONSTRAINT_RESOLVE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstraintConflictReason: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
                pConstraintConflictReason: ?*CONSTRAINT_CONFLICT_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
                pConstraintConflictReason: ?*CONSTRAINT_CONFLICT_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTemporary: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConstraintConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConstraintConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_GetDestinationProviderConflictingChange(self: *const T, ppConflictingChange: ?*?*ISyncChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).GetDestinationProviderConflictingChange(@ptrCast(*const IConstraintConflict, self), ppConflictingChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_GetSourceProviderConflictingChange(self: *const T, ppConflictingChange: ?*?*ISyncChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).GetSourceProviderConflictingChange(@ptrCast(*const IConstraintConflict, self), ppConflictingChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_GetDestinationProviderOriginalChange(self: *const T, ppOriginalChange: ?*?*ISyncChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).GetDestinationProviderOriginalChange(@ptrCast(*const IConstraintConflict, self), ppOriginalChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_GetDestinationProviderConflictingData(self: *const T, ppConflictingData: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).GetDestinationProviderConflictingData(@ptrCast(*const IConstraintConflict, self), ppConflictingData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_GetSourceProviderConflictingData(self: *const T, ppConflictingData: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).GetSourceProviderConflictingData(@ptrCast(*const IConstraintConflict, self), ppConflictingData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_GetDestinationProviderOriginalData(self: *const T, ppOriginalData: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).GetDestinationProviderOriginalData(@ptrCast(*const IConstraintConflict, self), ppOriginalData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_GetConstraintResolveActionForChange(self: *const T, pConstraintResolveAction: ?*SYNC_CONSTRAINT_RESOLVE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).GetConstraintResolveActionForChange(@ptrCast(*const IConstraintConflict, self), pConstraintResolveAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_SetConstraintResolveActionForChange(self: *const T, constraintResolveAction: SYNC_CONSTRAINT_RESOLVE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).SetConstraintResolveActionForChange(@ptrCast(*const IConstraintConflict, self), constraintResolveAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_GetConstraintResolveActionForChangeUnit(self: *const T, pChangeUnit: ?*ISyncChangeUnit, pConstraintResolveAction: ?*SYNC_CONSTRAINT_RESOLVE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).GetConstraintResolveActionForChangeUnit(@ptrCast(*const IConstraintConflict, self), pChangeUnit, pConstraintResolveAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_SetConstraintResolveActionForChangeUnit(self: *const T, pChangeUnit: ?*ISyncChangeUnit, constraintResolveAction: SYNC_CONSTRAINT_RESOLVE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).SetConstraintResolveActionForChangeUnit(@ptrCast(*const IConstraintConflict, self), pChangeUnit, constraintResolveAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_GetConstraintConflictReason(self: *const T, pConstraintConflictReason: ?*CONSTRAINT_CONFLICT_REASON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).GetConstraintConflictReason(@ptrCast(*const IConstraintConflict, self), pConstraintConflictReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConstraintConflict_IsTemporary(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConstraintConflict.VTable, self.vtable).IsTemporary(@ptrCast(*const IConstraintConflict, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncCallback_Value = Guid.initString("0599797f-5ed9-485c-ae36-0c5d1bf2e7a5");
pub const IID_ISyncCallback = &IID_ISyncCallback_Value;
pub const ISyncCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncCallback,
                provider: SYNC_PROVIDER_ROLE,
                syncStage: SYNC_PROGRESS_STAGE,
                dwCompletedWork: u32,
                dwTotalWork: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncCallback,
                provider: SYNC_PROVIDER_ROLE,
                syncStage: SYNC_PROGRESS_STAGE,
                dwCompletedWork: u32,
                dwTotalWork: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncCallback,
                pSyncChange: ?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncCallback,
                pSyncChange: ?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnConflict: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncCallback,
                pConflict: ?*IChangeConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncCallback,
                pConflict: ?*IChangeConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFullEnumerationNeeded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncCallback,
                pFullEnumerationAction: ?*SYNC_FULL_ENUMERATION_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncCallback,
                pFullEnumerationAction: ?*SYNC_FULL_ENUMERATION_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnRecoverableError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncCallback,
                pRecoverableError: ?*IRecoverableError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncCallback,
                pRecoverableError: ?*IRecoverableError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncCallback_OnProgress(self: *const T, provider: SYNC_PROVIDER_ROLE, syncStage: SYNC_PROGRESS_STAGE, dwCompletedWork: u32, dwTotalWork: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncCallback.VTable, self.vtable).OnProgress(@ptrCast(*const ISyncCallback, self), provider, syncStage, dwCompletedWork, dwTotalWork);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncCallback_OnChange(self: *const T, pSyncChange: ?*ISyncChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncCallback.VTable, self.vtable).OnChange(@ptrCast(*const ISyncCallback, self), pSyncChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncCallback_OnConflict(self: *const T, pConflict: ?*IChangeConflict) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncCallback.VTable, self.vtable).OnConflict(@ptrCast(*const ISyncCallback, self), pConflict);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncCallback_OnFullEnumerationNeeded(self: *const T, pFullEnumerationAction: ?*SYNC_FULL_ENUMERATION_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncCallback.VTable, self.vtable).OnFullEnumerationNeeded(@ptrCast(*const ISyncCallback, self), pFullEnumerationAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncCallback_OnRecoverableError(self: *const T, pRecoverableError: ?*IRecoverableError) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncCallback.VTable, self.vtable).OnRecoverableError(@ptrCast(*const ISyncCallback, self), pRecoverableError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncCallback2_Value = Guid.initString("47ce84af-7442-4ead-8630-12015e030ad7");
pub const IID_ISyncCallback2 = &IID_ISyncCallback2_Value;
pub const ISyncCallback2 = extern struct {
    pub const VTable = extern struct {
        base: ISyncCallback.VTable,
        OnChangeApplied: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncCallback2,
                dwChangesApplied: u32,
                dwChangesFailed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncCallback2,
                dwChangesApplied: u32,
                dwChangesFailed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnChangeFailed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncCallback2,
                dwChangesApplied: u32,
                dwChangesFailed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncCallback2,
                dwChangesApplied: u32,
                dwChangesFailed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncCallback2_OnChangeApplied(self: *const T, dwChangesApplied: u32, dwChangesFailed: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncCallback2.VTable, self.vtable).OnChangeApplied(@ptrCast(*const ISyncCallback2, self), dwChangesApplied, dwChangesFailed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncCallback2_OnChangeFailed(self: *const T, dwChangesApplied: u32, dwChangesFailed: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncCallback2.VTable, self.vtable).OnChangeFailed(@ptrCast(*const ISyncCallback2, self), dwChangesApplied, dwChangesFailed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISyncConstraintCallback_Value = Guid.initString("8af3843e-75b3-438c-bb51-6f020d70d3cb");
pub const IID_ISyncConstraintCallback = &IID_ISyncConstraintCallback_Value;
pub const ISyncConstraintCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnConstraintConflict: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncConstraintCallback,
                pConflict: ?*IConstraintConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncConstraintCallback,
                pConflict: ?*IConstraintConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncConstraintCallback_OnConstraintConflict(self: *const T, pConflict: ?*IConstraintConflict) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncConstraintCallback.VTable, self.vtable).OnConstraintConflict(@ptrCast(*const ISyncConstraintCallback, self), pConflict);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncProvider_Value = Guid.initString("8f657056-2bce-4a17-8c68-c7bb7898b56f");
pub const IID_ISyncProvider = &IID_ISyncProvider_Value;
pub const ISyncProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProvider,
                pIdParameters: ?*ID_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProvider,
                pIdParameters: ?*ID_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProvider_GetIdParameters(self: *const T, pIdParameters: ?*ID_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProvider.VTable, self.vtable).GetIdParameters(@ptrCast(*const ISyncProvider, self), pIdParameters);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncSessionState_Value = Guid.initString("b8a940fe-9f01-483b-9434-c37d361225d9");
pub const IID_ISyncSessionState = &IID_ISyncSessionState_Value;
pub const ISyncSessionState = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsCanceled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionState,
                pfIsCanceled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionState,
                pfIsCanceled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfoForChangeApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionState,
                pbChangeApplierInfo: ?*u8,
                pcbChangeApplierInfo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionState,
                pbChangeApplierInfo: ?*u8,
                pcbChangeApplierInfo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadInfoFromChangeApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionState,
                pbChangeApplierInfo: ?*const u8,
                cbChangeApplierInfo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionState,
                pbChangeApplierInfo: ?*const u8,
                cbChangeApplierInfo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetForgottenKnowledgeRecoveryRangeStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionState,
                pbRangeStart: ?*u8,
                pcbRangeStart: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionState,
                pbRangeStart: ?*u8,
                pcbRangeStart: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetForgottenKnowledgeRecoveryRangeEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionState,
                pbRangeEnd: ?*u8,
                pcbRangeEnd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionState,
                pbRangeEnd: ?*u8,
                pcbRangeEnd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetForgottenKnowledgeRecoveryRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionState,
                pRange: ?*const SYNC_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionState,
                pRange: ?*const SYNC_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionState,
                provider: SYNC_PROVIDER_ROLE,
                syncStage: SYNC_PROGRESS_STAGE,
                dwCompletedWork: u32,
                dwTotalWork: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionState,
                provider: SYNC_PROVIDER_ROLE,
                syncStage: SYNC_PROGRESS_STAGE,
                dwCompletedWork: u32,
                dwTotalWork: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionState_IsCanceled(self: *const T, pfIsCanceled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionState.VTable, self.vtable).IsCanceled(@ptrCast(*const ISyncSessionState, self), pfIsCanceled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionState_GetInfoForChangeApplication(self: *const T, pbChangeApplierInfo: ?*u8, pcbChangeApplierInfo: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionState.VTable, self.vtable).GetInfoForChangeApplication(@ptrCast(*const ISyncSessionState, self), pbChangeApplierInfo, pcbChangeApplierInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionState_LoadInfoFromChangeApplication(self: *const T, pbChangeApplierInfo: ?*const u8, cbChangeApplierInfo: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionState.VTable, self.vtable).LoadInfoFromChangeApplication(@ptrCast(*const ISyncSessionState, self), pbChangeApplierInfo, cbChangeApplierInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionState_GetForgottenKnowledgeRecoveryRangeStart(self: *const T, pbRangeStart: ?*u8, pcbRangeStart: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionState.VTable, self.vtable).GetForgottenKnowledgeRecoveryRangeStart(@ptrCast(*const ISyncSessionState, self), pbRangeStart, pcbRangeStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionState_GetForgottenKnowledgeRecoveryRangeEnd(self: *const T, pbRangeEnd: ?*u8, pcbRangeEnd: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionState.VTable, self.vtable).GetForgottenKnowledgeRecoveryRangeEnd(@ptrCast(*const ISyncSessionState, self), pbRangeEnd, pcbRangeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionState_SetForgottenKnowledgeRecoveryRange(self: *const T, pRange: ?*const SYNC_RANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionState.VTable, self.vtable).SetForgottenKnowledgeRecoveryRange(@ptrCast(*const ISyncSessionState, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionState_OnProgress(self: *const T, provider: SYNC_PROVIDER_ROLE, syncStage: SYNC_PROGRESS_STAGE, dwCompletedWork: u32, dwTotalWork: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionState.VTable, self.vtable).OnProgress(@ptrCast(*const ISyncSessionState, self), provider, syncStage, dwCompletedWork, dwTotalWork);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncSessionExtendedErrorInfo_Value = Guid.initString("326c6810-790a-409b-b741-6999388761eb");
pub const IID_ISyncSessionExtendedErrorInfo = &IID_ISyncSessionExtendedErrorInfo_Value;
pub const ISyncSessionExtendedErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSyncProviderWithError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionExtendedErrorInfo,
                ppProviderWithError: ?*?*ISyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionExtendedErrorInfo,
                ppProviderWithError: ?*?*ISyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionExtendedErrorInfo_GetSyncProviderWithError(self: *const T, ppProviderWithError: ?*?*ISyncProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionExtendedErrorInfo.VTable, self.vtable).GetSyncProviderWithError(@ptrCast(*const ISyncSessionExtendedErrorInfo, self), ppProviderWithError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncSessionState2_Value = Guid.initString("9e37cfa3-9e38-4c61-9ca3-ffe810b45ca2");
pub const IID_ISyncSessionState2 = &IID_ISyncSessionState2_Value;
pub const ISyncSessionState2 = extern struct {
    pub const VTable = extern struct {
        base: ISyncSessionState.VTable,
        SetProviderWithError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionState2,
                fSelf: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionState2,
                fSelf: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSessionErrorStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncSessionState2,
                phrSessionError: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncSessionState2,
                phrSessionError: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncSessionState.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionState2_SetProviderWithError(self: *const T, fSelf: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionState2.VTable, self.vtable).SetProviderWithError(@ptrCast(*const ISyncSessionState2, self), fSelf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncSessionState2_GetSessionErrorStatus(self: *const T, phrSessionError: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncSessionState2.VTable, self.vtable).GetSessionErrorStatus(@ptrCast(*const ISyncSessionState2, self), phrSessionError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncFilterInfo_Value = Guid.initString("794eaaf8-3f2e-47e6-9728-17e6fcf94cb7");
pub const IID_ISyncFilterInfo = &IID_ISyncFilterInfo_Value;
pub const ISyncFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFilterInfo,
                pbBuffer: ?*u8,
                pcbBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFilterInfo,
                pbBuffer: ?*u8,
                pcbBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFilterInfo_Serialize(self: *const T, pbBuffer: ?*u8, pcbBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFilterInfo.VTable, self.vtable).Serialize(@ptrCast(*const ISyncFilterInfo, self), pbBuffer, pcbBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncFilterInfo2_Value = Guid.initString("19b394ba-e3d0-468c-934d-321968b2ab34");
pub const IID_ISyncFilterInfo2 = &IID_ISyncFilterInfo2_Value;
pub const ISyncFilterInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ISyncFilterInfo.VTable,
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFilterInfo2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFilterInfo2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncFilterInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFilterInfo2_GetFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFilterInfo2.VTable, self.vtable).GetFlags(@ptrCast(*const ISyncFilterInfo2, self), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IChangeUnitListFilterInfo_Value = Guid.initString("f2837671-0bdf-43fa-b502-232375fb50c2");
pub const IID_IChangeUnitListFilterInfo = &IID_IChangeUnitListFilterInfo_Value;
pub const IChangeUnitListFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: ISyncFilterInfo.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeUnitListFilterInfo,
                ppbChangeUnitIds: ?*const ?*u8,
                dwChangeUnitCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeUnitListFilterInfo,
                ppbChangeUnitIds: ?*const ?*u8,
                dwChangeUnitCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeUnitIdCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeUnitListFilterInfo,
                pdwChangeUnitIdCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeUnitListFilterInfo,
                pdwChangeUnitIdCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeUnitId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IChangeUnitListFilterInfo,
                dwChangeUnitIdIndex: u32,
                pbChangeUnitId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IChangeUnitListFilterInfo,
                dwChangeUnitIdIndex: u32,
                pbChangeUnitId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncFilterInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeUnitListFilterInfo_Initialize(self: *const T, ppbChangeUnitIds: ?*const ?*u8, dwChangeUnitCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeUnitListFilterInfo.VTable, self.vtable).Initialize(@ptrCast(*const IChangeUnitListFilterInfo, self), ppbChangeUnitIds, dwChangeUnitCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeUnitListFilterInfo_GetChangeUnitIdCount(self: *const T, pdwChangeUnitIdCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeUnitListFilterInfo.VTable, self.vtable).GetChangeUnitIdCount(@ptrCast(*const IChangeUnitListFilterInfo, self), pdwChangeUnitIdCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChangeUnitListFilterInfo_GetChangeUnitId(self: *const T, dwChangeUnitIdIndex: u32, pbChangeUnitId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChangeUnitListFilterInfo.VTable, self.vtable).GetChangeUnitId(@ptrCast(*const IChangeUnitListFilterInfo, self), dwChangeUnitIdIndex, pbChangeUnitId, pcbIdSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISyncFilter_Value = Guid.initString("087a3f15-0fcb-44c1-9639-53c14e2b5506");
pub const IID_ISyncFilter = &IID_ISyncFilter_Value;
pub const ISyncFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsIdentical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFilter,
                pSyncFilter: ?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFilter,
                pSyncFilter: ?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFilter,
                pbSyncFilter: ?*u8,
                pcbSyncFilter: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFilter,
                pbSyncFilter: ?*u8,
                pcbSyncFilter: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFilter_IsIdentical(self: *const T, pSyncFilter: ?*ISyncFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFilter.VTable, self.vtable).IsIdentical(@ptrCast(*const ISyncFilter, self), pSyncFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFilter_Serialize(self: *const T, pbSyncFilter: ?*u8, pcbSyncFilter: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFilter.VTable, self.vtable).Serialize(@ptrCast(*const ISyncFilter, self), pbSyncFilter, pcbSyncFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISyncFilterDeserializer_Value = Guid.initString("b45b7a72-e5c7-46be-9c82-77b8b15dab8a");
pub const IID_ISyncFilterDeserializer = &IID_ISyncFilterDeserializer_Value;
pub const ISyncFilterDeserializer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeserializeSyncFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFilterDeserializer,
                pbSyncFilter: ?*const u8,
                dwCbSyncFilter: u32,
                ppISyncFilter: ?*?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFilterDeserializer,
                pbSyncFilter: ?*const u8,
                dwCbSyncFilter: u32,
                ppISyncFilter: ?*?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFilterDeserializer_DeserializeSyncFilter(self: *const T, pbSyncFilter: ?*const u8, dwCbSyncFilter: u32, ppISyncFilter: ?*?*ISyncFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFilterDeserializer.VTable, self.vtable).DeserializeSyncFilter(@ptrCast(*const ISyncFilterDeserializer, self), pbSyncFilter, dwCbSyncFilter, ppISyncFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICustomFilterInfo_Value = Guid.initString("1d335dff-6f88-4e4d-91a8-a3f351cfd473");
pub const IID_ICustomFilterInfo = &IID_ICustomFilterInfo_Value;
pub const ICustomFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: ISyncFilterInfo.VTable,
        GetSyncFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICustomFilterInfo,
                pISyncFilter: ?*?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICustomFilterInfo,
                pISyncFilter: ?*?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncFilterInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomFilterInfo_GetSyncFilter(self: *const T, pISyncFilter: ?*?*ISyncFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomFilterInfo.VTable, self.vtable).GetSyncFilter(@ptrCast(*const ICustomFilterInfo, self), pISyncFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FILTER_COMBINATION_TYPE = enum(i32) {
    N = 0,
};
pub const FCT_INTERSECTION = FILTER_COMBINATION_TYPE.N;

const IID_ICombinedFilterInfo_Value = Guid.initString("11f9de71-2818-4779-b2ac-42d450565f45");
pub const IID_ICombinedFilterInfo = &IID_ICombinedFilterInfo_Value;
pub const ICombinedFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: ISyncFilterInfo.VTable,
        GetFilterCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICombinedFilterInfo,
                pdwFilterCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICombinedFilterInfo,
                pdwFilterCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICombinedFilterInfo,
                dwFilterIndex: u32,
                ppIFilterInfo: ?*?*ISyncFilterInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICombinedFilterInfo,
                dwFilterIndex: u32,
                ppIFilterInfo: ?*?*ISyncFilterInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterCombinationType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICombinedFilterInfo,
                pFilterCombinationType: ?*FILTER_COMBINATION_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICombinedFilterInfo,
                pFilterCombinationType: ?*FILTER_COMBINATION_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncFilterInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICombinedFilterInfo_GetFilterCount(self: *const T, pdwFilterCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICombinedFilterInfo.VTable, self.vtable).GetFilterCount(@ptrCast(*const ICombinedFilterInfo, self), pdwFilterCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICombinedFilterInfo_GetFilterInfo(self: *const T, dwFilterIndex: u32, ppIFilterInfo: ?*?*ISyncFilterInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICombinedFilterInfo.VTable, self.vtable).GetFilterInfo(@ptrCast(*const ICombinedFilterInfo, self), dwFilterIndex, ppIFilterInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICombinedFilterInfo_GetFilterCombinationType(self: *const T, pFilterCombinationType: ?*FILTER_COMBINATION_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICombinedFilterInfo.VTable, self.vtable).GetFilterCombinationType(@ptrCast(*const ICombinedFilterInfo, self), pFilterCombinationType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IEnumSyncChanges_Value = Guid.initString("5f86be4a-5e78-4e32-ac1c-c24fd223ef85");
pub const IID_IEnumSyncChanges = &IID_IEnumSyncChanges_Value;
pub const IEnumSyncChanges = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncChanges,
                cChanges: u32,
                ppChange: ?*?*ISyncChange,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncChanges,
                cChanges: u32,
                ppChange: ?*?*ISyncChange,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncChanges,
                cChanges: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncChanges,
                cChanges: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncChanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncChanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncChanges,
                ppEnum: ?*?*IEnumSyncChanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncChanges,
                ppEnum: ?*?*IEnumSyncChanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncChanges_Next(self: *const T, cChanges: u32, ppChange: ?*?*ISyncChange, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncChanges.VTable, self.vtable).Next(@ptrCast(*const IEnumSyncChanges, self), cChanges, ppChange, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncChanges_Skip(self: *const T, cChanges: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncChanges.VTable, self.vtable).Skip(@ptrCast(*const IEnumSyncChanges, self), cChanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncChanges_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncChanges.VTable, self.vtable).Reset(@ptrCast(*const IEnumSyncChanges, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncChanges_Clone(self: *const T, ppEnum: ?*?*IEnumSyncChanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncChanges.VTable, self.vtable).Clone(@ptrCast(*const IEnumSyncChanges, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncChangeBuilder_Value = Guid.initString("56f14771-8677-484f-a170-e386e418a676");
pub const IID_ISyncChangeBuilder = &IID_ISyncChangeBuilder_Value;
pub const ISyncChangeBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddChangeUnitMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBuilder,
                pbChangeUnitId: ?*const u8,
                pChangeUnitVersion: ?*const SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBuilder,
                pbChangeUnitId: ?*const u8,
                pChangeUnitVersion: ?*const SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBuilder_AddChangeUnitMetadata(self: *const T, pbChangeUnitId: ?*const u8, pChangeUnitVersion: ?*const SYNC_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBuilder.VTable, self.vtable).AddChangeUnitMetadata(@ptrCast(*const ISyncChangeBuilder, self), pbChangeUnitId, pChangeUnitVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFilterTrackingSyncChangeBuilder_Value = Guid.initString("295024a0-70da-4c58-883c-ce2afb308d0b");
pub const IID_IFilterTrackingSyncChangeBuilder = &IID_IFilterTrackingSyncChangeBuilder_Value;
pub const IFilterTrackingSyncChangeBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddFilterChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterTrackingSyncChangeBuilder,
                dwFilterKey: u32,
                pFilterChange: ?*const SYNC_FILTER_CHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterTrackingSyncChangeBuilder,
                dwFilterKey: u32,
                pFilterChange: ?*const SYNC_FILTER_CHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllChangeUnitsPresentFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterTrackingSyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterTrackingSyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterTrackingSyncChangeBuilder_AddFilterChange(self: *const T, dwFilterKey: u32, pFilterChange: ?*const SYNC_FILTER_CHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterTrackingSyncChangeBuilder.VTable, self.vtable).AddFilterChange(@ptrCast(*const IFilterTrackingSyncChangeBuilder, self), dwFilterKey, pFilterChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterTrackingSyncChangeBuilder_SetAllChangeUnitsPresentFlag(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterTrackingSyncChangeBuilder.VTable, self.vtable).SetAllChangeUnitsPresentFlag(@ptrCast(*const IFilterTrackingSyncChangeBuilder, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncChangeBatchBase_Value = Guid.initString("52f6e694-6a71-4494-a184-a8311bf5d227");
pub const IID_ISyncChangeBatchBase = &IID_ISyncChangeBatchBase_Value;
pub const ISyncChangeBatchBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChangeEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                ppEnum: ?*?*IEnumSyncChanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                ppEnum: ?*?*IEnumSyncChanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIsLastBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                pfLastBatch: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                pfLastBatch: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWorkEstimateForBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                pdwWorkForBatch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                pdwWorkForBatch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRemainingWorkEstimateForSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                pdwRemainingWorkForSession: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                pdwRemainingWorkForSession: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginOrderedGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                pbLowerBound: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                pbLowerBound: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndOrderedGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                pbUpperBound: ?*const u8,
                pMadeWithKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                pbUpperBound: ?*const u8,
                pMadeWithKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddItemMetadataToGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                pbOwnerReplicaId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwFlags: u32,
                dwWorkForChange: u32,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                pbOwnerReplicaId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwFlags: u32,
                dwWorkForChange: u32,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                ppLearnedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                ppLearnedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrerequisiteKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                ppPrerequisteKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                ppPrerequisteKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceForgottenKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                ppSourceForgottenKnowledge: ?*?*IForgottenKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                ppSourceForgottenKnowledge: ?*?*IForgottenKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLastBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWorkEstimateForBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                dwWorkForBatch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                dwWorkForBatch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRemainingWorkEstimateForSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                dwRemainingWorkForSession: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                dwRemainingWorkForSession: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase,
                pbChangeBatch: ?*u8,
                pcbChangeBatch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase,
                pbChangeBatch: ?*u8,
                pcbChangeBatch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_GetChangeEnumerator(self: *const T, ppEnum: ?*?*IEnumSyncChanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).GetChangeEnumerator(@ptrCast(*const ISyncChangeBatchBase, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_GetIsLastBatch(self: *const T, pfLastBatch: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).GetIsLastBatch(@ptrCast(*const ISyncChangeBatchBase, self), pfLastBatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_GetWorkEstimateForBatch(self: *const T, pdwWorkForBatch: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).GetWorkEstimateForBatch(@ptrCast(*const ISyncChangeBatchBase, self), pdwWorkForBatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_GetRemainingWorkEstimateForSession(self: *const T, pdwRemainingWorkForSession: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).GetRemainingWorkEstimateForSession(@ptrCast(*const ISyncChangeBatchBase, self), pdwRemainingWorkForSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_BeginOrderedGroup(self: *const T, pbLowerBound: ?*const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).BeginOrderedGroup(@ptrCast(*const ISyncChangeBatchBase, self), pbLowerBound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_EndOrderedGroup(self: *const T, pbUpperBound: ?*const u8, pMadeWithKnowledge: ?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).EndOrderedGroup(@ptrCast(*const ISyncChangeBatchBase, self), pbUpperBound, pMadeWithKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_AddItemMetadataToGroup(self: *const T, pbOwnerReplicaId: ?*const u8, pbItemId: ?*const u8, pChangeVersion: ?*const SYNC_VERSION, pCreationVersion: ?*const SYNC_VERSION, dwFlags: u32, dwWorkForChange: u32, ppChangeBuilder: ?*?*ISyncChangeBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).AddItemMetadataToGroup(@ptrCast(*const ISyncChangeBatchBase, self), pbOwnerReplicaId, pbItemId, pChangeVersion, pCreationVersion, dwFlags, dwWorkForChange, ppChangeBuilder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_GetLearnedKnowledge(self: *const T, ppLearnedKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).GetLearnedKnowledge(@ptrCast(*const ISyncChangeBatchBase, self), ppLearnedKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_GetPrerequisiteKnowledge(self: *const T, ppPrerequisteKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).GetPrerequisiteKnowledge(@ptrCast(*const ISyncChangeBatchBase, self), ppPrerequisteKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_GetSourceForgottenKnowledge(self: *const T, ppSourceForgottenKnowledge: ?*?*IForgottenKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).GetSourceForgottenKnowledge(@ptrCast(*const ISyncChangeBatchBase, self), ppSourceForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_SetLastBatch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).SetLastBatch(@ptrCast(*const ISyncChangeBatchBase, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_SetWorkEstimateForBatch(self: *const T, dwWorkForBatch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).SetWorkEstimateForBatch(@ptrCast(*const ISyncChangeBatchBase, self), dwWorkForBatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_SetRemainingWorkEstimateForSession(self: *const T, dwRemainingWorkForSession: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).SetRemainingWorkEstimateForSession(@ptrCast(*const ISyncChangeBatchBase, self), dwRemainingWorkForSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase_Serialize(self: *const T, pbChangeBatch: ?*u8, pcbChangeBatch: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase.VTable, self.vtable).Serialize(@ptrCast(*const ISyncChangeBatchBase, self), pbChangeBatch, pcbChangeBatch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncChangeBatch_Value = Guid.initString("70c64dee-380f-4c2e-8f70-31c55bd5f9b3");
pub const IID_ISyncChangeBatch = &IID_ISyncChangeBatch_Value;
pub const ISyncChangeBatch = extern struct {
    pub const VTable = extern struct {
        base: ISyncChangeBatchBase.VTable,
        BeginUnorderedGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndUnorderedGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatch,
                pMadeWithKnowledge: ?*ISyncKnowledge,
                fAllChangesForKnowledge: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatch,
                pMadeWithKnowledge: ?*ISyncKnowledge,
                fAllChangesForKnowledge: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddLoggedConflict: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatch,
                pbOwnerReplicaId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwFlags: u32,
                dwWorkForChange: u32,
                pConflictKnowledge: ?*ISyncKnowledge,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatch,
                pbOwnerReplicaId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwFlags: u32,
                dwWorkForChange: u32,
                pConflictKnowledge: ?*ISyncKnowledge,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncChangeBatchBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatch_BeginUnorderedGroup(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatch.VTable, self.vtable).BeginUnorderedGroup(@ptrCast(*const ISyncChangeBatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatch_EndUnorderedGroup(self: *const T, pMadeWithKnowledge: ?*ISyncKnowledge, fAllChangesForKnowledge: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatch.VTable, self.vtable).EndUnorderedGroup(@ptrCast(*const ISyncChangeBatch, self), pMadeWithKnowledge, fAllChangesForKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatch_AddLoggedConflict(self: *const T, pbOwnerReplicaId: ?*const u8, pbItemId: ?*const u8, pChangeVersion: ?*const SYNC_VERSION, pCreationVersion: ?*const SYNC_VERSION, dwFlags: u32, dwWorkForChange: u32, pConflictKnowledge: ?*ISyncKnowledge, ppChangeBuilder: ?*?*ISyncChangeBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatch.VTable, self.vtable).AddLoggedConflict(@ptrCast(*const ISyncChangeBatch, self), pbOwnerReplicaId, pbItemId, pChangeVersion, pCreationVersion, dwFlags, dwWorkForChange, pConflictKnowledge, ppChangeBuilder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncFullEnumerationChangeBatch_Value = Guid.initString("ef64197d-4f44-4ea2-b355-4524713e3bed");
pub const IID_ISyncFullEnumerationChangeBatch = &IID_ISyncFullEnumerationChangeBatch_Value;
pub const ISyncFullEnumerationChangeBatch = extern struct {
    pub const VTable = extern struct {
        base: ISyncChangeBatchBase.VTable,
        GetLearnedKnowledgeAfterRecoveryComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFullEnumerationChangeBatch,
                ppLearnedKnowledgeAfterRecoveryComplete: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFullEnumerationChangeBatch,
                ppLearnedKnowledgeAfterRecoveryComplete: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClosedLowerBoundItemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFullEnumerationChangeBatch,
                pbClosedLowerBoundItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFullEnumerationChangeBatch,
                pbClosedLowerBoundItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClosedUpperBoundItemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFullEnumerationChangeBatch,
                pbClosedUpperBoundItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFullEnumerationChangeBatch,
                pbClosedUpperBoundItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncChangeBatchBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFullEnumerationChangeBatch_GetLearnedKnowledgeAfterRecoveryComplete(self: *const T, ppLearnedKnowledgeAfterRecoveryComplete: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFullEnumerationChangeBatch.VTable, self.vtable).GetLearnedKnowledgeAfterRecoveryComplete(@ptrCast(*const ISyncFullEnumerationChangeBatch, self), ppLearnedKnowledgeAfterRecoveryComplete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFullEnumerationChangeBatch_GetClosedLowerBoundItemId(self: *const T, pbClosedLowerBoundItemId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFullEnumerationChangeBatch.VTable, self.vtable).GetClosedLowerBoundItemId(@ptrCast(*const ISyncFullEnumerationChangeBatch, self), pbClosedLowerBoundItemId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFullEnumerationChangeBatch_GetClosedUpperBoundItemId(self: *const T, pbClosedUpperBoundItemId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFullEnumerationChangeBatch.VTable, self.vtable).GetClosedUpperBoundItemId(@ptrCast(*const ISyncFullEnumerationChangeBatch, self), pbClosedUpperBoundItemId, pcbIdSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncChangeBatchWithPrerequisite_Value = Guid.initString("097f13be-5b92-4048-b3f2-7b42a2515e07");
pub const IID_ISyncChangeBatchWithPrerequisite = &IID_ISyncChangeBatchWithPrerequisite_Value;
pub const ISyncChangeBatchWithPrerequisite = extern struct {
    pub const VTable = extern struct {
        base: ISyncChangeBatchBase.VTable,
        SetPrerequisiteKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithPrerequisite,
                pPrerequisiteKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithPrerequisite,
                pPrerequisiteKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedKnowledgeWithPrerequisite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithPrerequisite,
                pDestinationKnowledge: ?*ISyncKnowledge,
                ppLearnedWithPrerequisiteKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithPrerequisite,
                pDestinationKnowledge: ?*ISyncKnowledge,
                ppLearnedWithPrerequisiteKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedForgottenKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithPrerequisite,
                ppLearnedForgottenKnowledge: ?*?*IForgottenKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithPrerequisite,
                ppLearnedForgottenKnowledge: ?*?*IForgottenKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncChangeBatchBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithPrerequisite_SetPrerequisiteKnowledge(self: *const T, pPrerequisiteKnowledge: ?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithPrerequisite.VTable, self.vtable).SetPrerequisiteKnowledge(@ptrCast(*const ISyncChangeBatchWithPrerequisite, self), pPrerequisiteKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithPrerequisite_GetLearnedKnowledgeWithPrerequisite(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, ppLearnedWithPrerequisiteKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithPrerequisite.VTable, self.vtable).GetLearnedKnowledgeWithPrerequisite(@ptrCast(*const ISyncChangeBatchWithPrerequisite, self), pDestinationKnowledge, ppLearnedWithPrerequisiteKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithPrerequisite_GetLearnedForgottenKnowledge(self: *const T, ppLearnedForgottenKnowledge: ?*?*IForgottenKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithPrerequisite.VTable, self.vtable).GetLearnedForgottenKnowledge(@ptrCast(*const ISyncChangeBatchWithPrerequisite, self), ppLearnedForgottenKnowledge);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncChangeBatchBase2_Value = Guid.initString("6fdb596a-d755-4584-bd0c-c0c23a548fbf");
pub const IID_ISyncChangeBatchBase2 = &IID_ISyncChangeBatchBase2_Value;
pub const ISyncChangeBatchBase2 = extern struct {
    pub const VTable = extern struct {
        base: ISyncChangeBatchBase.VTable,
        SerializeWithOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchBase2,
                targetFormatVersion: SYNC_SERIALIZATION_VERSION,
                dwFlags: u32,
                pbBuffer: ?*u8,
                pdwSerializedSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchBase2,
                targetFormatVersion: SYNC_SERIALIZATION_VERSION,
                dwFlags: u32,
                pbBuffer: ?*u8,
                pdwSerializedSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncChangeBatchBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchBase2_SerializeWithOptions(self: *const T, targetFormatVersion: SYNC_SERIALIZATION_VERSION, dwFlags: u32, pbBuffer: ?*u8, pdwSerializedSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchBase2.VTable, self.vtable).SerializeWithOptions(@ptrCast(*const ISyncChangeBatchBase2, self), targetFormatVersion, dwFlags, pbBuffer, pdwSerializedSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncChangeBatchAdvanced_Value = Guid.initString("0f1a4995-cbc8-421d-b550-5d0bebf3e9a5");
pub const IID_ISyncChangeBatchAdvanced = &IID_ISyncChangeBatchAdvanced_Value;
pub const ISyncChangeBatchAdvanced = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilterInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchAdvanced,
                ppFilterInfo: ?*?*ISyncFilterInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchAdvanced,
                ppFilterInfo: ?*?*ISyncFilterInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertFullEnumerationChangeBatchToRegularChangeBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchAdvanced,
                ppChangeBatch: ?*?*ISyncChangeBatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchAdvanced,
                ppChangeBatch: ?*?*ISyncChangeBatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUpperBoundItemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchAdvanced,
                pbItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchAdvanced,
                pbItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBatchLevelKnowledgeShouldBeApplied: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchAdvanced,
                pfBatchKnowledgeShouldBeApplied: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchAdvanced,
                pfBatchKnowledgeShouldBeApplied: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchAdvanced_GetFilterInfo(self: *const T, ppFilterInfo: ?*?*ISyncFilterInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchAdvanced.VTable, self.vtable).GetFilterInfo(@ptrCast(*const ISyncChangeBatchAdvanced, self), ppFilterInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchAdvanced_ConvertFullEnumerationChangeBatchToRegularChangeBatch(self: *const T, ppChangeBatch: ?*?*ISyncChangeBatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchAdvanced.VTable, self.vtable).ConvertFullEnumerationChangeBatchToRegularChangeBatch(@ptrCast(*const ISyncChangeBatchAdvanced, self), ppChangeBatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchAdvanced_GetUpperBoundItemId(self: *const T, pbItemId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchAdvanced.VTable, self.vtable).GetUpperBoundItemId(@ptrCast(*const ISyncChangeBatchAdvanced, self), pbItemId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchAdvanced_GetBatchLevelKnowledgeShouldBeApplied(self: *const T, pfBatchKnowledgeShouldBeApplied: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchAdvanced.VTable, self.vtable).GetBatchLevelKnowledgeShouldBeApplied(@ptrCast(*const ISyncChangeBatchAdvanced, self), pfBatchKnowledgeShouldBeApplied);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISyncChangeBatch2_Value = Guid.initString("225f4a33-f5ee-4cc7-b039-67a262b4b2ac");
pub const IID_ISyncChangeBatch2 = &IID_ISyncChangeBatch2_Value;
pub const ISyncChangeBatch2 = extern struct {
    pub const VTable = extern struct {
        base: ISyncChangeBatch.VTable,
        AddMergeTombstoneMetadataToGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatch2,
                pbOwnerReplicaId: ?*const u8,
                pbWinnerItemId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwWorkForChange: u32,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatch2,
                pbOwnerReplicaId: ?*const u8,
                pbWinnerItemId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwWorkForChange: u32,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddMergeTombstoneLoggedConflict: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatch2,
                pbOwnerReplicaId: ?*const u8,
                pbWinnerItemId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwWorkForChange: u32,
                pConflictKnowledge: ?*ISyncKnowledge,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatch2,
                pbOwnerReplicaId: ?*const u8,
                pbWinnerItemId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwWorkForChange: u32,
                pConflictKnowledge: ?*ISyncKnowledge,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncChangeBatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatch2_AddMergeTombstoneMetadataToGroup(self: *const T, pbOwnerReplicaId: ?*const u8, pbWinnerItemId: ?*const u8, pbItemId: ?*const u8, pChangeVersion: ?*const SYNC_VERSION, pCreationVersion: ?*const SYNC_VERSION, dwWorkForChange: u32, ppChangeBuilder: ?*?*ISyncChangeBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatch2.VTable, self.vtable).AddMergeTombstoneMetadataToGroup(@ptrCast(*const ISyncChangeBatch2, self), pbOwnerReplicaId, pbWinnerItemId, pbItemId, pChangeVersion, pCreationVersion, dwWorkForChange, ppChangeBuilder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatch2_AddMergeTombstoneLoggedConflict(self: *const T, pbOwnerReplicaId: ?*const u8, pbWinnerItemId: ?*const u8, pbItemId: ?*const u8, pChangeVersion: ?*const SYNC_VERSION, pCreationVersion: ?*const SYNC_VERSION, dwWorkForChange: u32, pConflictKnowledge: ?*ISyncKnowledge, ppChangeBuilder: ?*?*ISyncChangeBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatch2.VTable, self.vtable).AddMergeTombstoneLoggedConflict(@ptrCast(*const ISyncChangeBatch2, self), pbOwnerReplicaId, pbWinnerItemId, pbItemId, pChangeVersion, pCreationVersion, dwWorkForChange, pConflictKnowledge, ppChangeBuilder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISyncFullEnumerationChangeBatch2_Value = Guid.initString("e06449f4-a205-4b65-9724-01b22101eec1");
pub const IID_ISyncFullEnumerationChangeBatch2 = &IID_ISyncFullEnumerationChangeBatch2_Value;
pub const ISyncFullEnumerationChangeBatch2 = extern struct {
    pub const VTable = extern struct {
        base: ISyncFullEnumerationChangeBatch.VTable,
        AddMergeTombstoneMetadataToGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFullEnumerationChangeBatch2,
                pbOwnerReplicaId: ?*const u8,
                pbWinnerItemId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwWorkForChange: u32,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFullEnumerationChangeBatch2,
                pbOwnerReplicaId: ?*const u8,
                pbWinnerItemId: ?*const u8,
                pbItemId: ?*const u8,
                pChangeVersion: ?*const SYNC_VERSION,
                pCreationVersion: ?*const SYNC_VERSION,
                dwWorkForChange: u32,
                ppChangeBuilder: ?*?*ISyncChangeBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncFullEnumerationChangeBatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFullEnumerationChangeBatch2_AddMergeTombstoneMetadataToGroup(self: *const T, pbOwnerReplicaId: ?*const u8, pbWinnerItemId: ?*const u8, pbItemId: ?*const u8, pChangeVersion: ?*const SYNC_VERSION, pCreationVersion: ?*const SYNC_VERSION, dwWorkForChange: u32, ppChangeBuilder: ?*?*ISyncChangeBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFullEnumerationChangeBatch2.VTable, self.vtable).AddMergeTombstoneMetadataToGroup(@ptrCast(*const ISyncFullEnumerationChangeBatch2, self), pbOwnerReplicaId, pbWinnerItemId, pbItemId, pChangeVersion, pCreationVersion, dwWorkForChange, ppChangeBuilder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IKnowledgeSyncProvider_Value = Guid.initString("43434a49-8da4-47f2-8172-ad7b8b024978");
pub const IID_IKnowledgeSyncProvider = &IID_IKnowledgeSyncProvider_Value;
pub const IKnowledgeSyncProvider = extern struct {
    pub const VTable = extern struct {
        base: ISyncProvider.VTable,
        BeginSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKnowledgeSyncProvider,
                role: SYNC_PROVIDER_ROLE,
                pSessionState: ?*ISyncSessionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKnowledgeSyncProvider,
                role: SYNC_PROVIDER_ROLE,
                pSessionState: ?*ISyncSessionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncBatchParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKnowledgeSyncProvider,
                ppSyncKnowledge: ?*?*ISyncKnowledge,
                pdwRequestedBatchSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKnowledgeSyncProvider,
                ppSyncKnowledge: ?*?*ISyncKnowledge,
                pdwRequestedBatchSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKnowledgeSyncProvider,
                dwBatchSize: u32,
                pSyncKnowledge: ?*ISyncKnowledge,
                ppSyncChangeBatch: ?*?*ISyncChangeBatch,
                ppUnkDataRetriever: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKnowledgeSyncProvider,
                dwBatchSize: u32,
                pSyncKnowledge: ?*ISyncKnowledge,
                ppSyncChangeBatch: ?*?*ISyncChangeBatch,
                ppUnkDataRetriever: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFullEnumerationChangeBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKnowledgeSyncProvider,
                dwBatchSize: u32,
                pbLowerEnumerationBound: ?*const u8,
                pSyncKnowledge: ?*ISyncKnowledge,
                ppSyncChangeBatch: ?*?*ISyncFullEnumerationChangeBatch,
                ppUnkDataRetriever: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKnowledgeSyncProvider,
                dwBatchSize: u32,
                pbLowerEnumerationBound: ?*const u8,
                pSyncKnowledge: ?*ISyncKnowledge,
                ppSyncChangeBatch: ?*?*ISyncFullEnumerationChangeBatch,
                ppUnkDataRetriever: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessChangeBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKnowledgeSyncProvider,
                resolutionPolicy: CONFLICT_RESOLUTION_POLICY,
                pSourceChangeBatch: ?*ISyncChangeBatch,
                pUnkDataRetriever: ?*IUnknown,
                pCallback: ?*ISyncCallback,
                pSyncSessionStatistics: ?*SYNC_SESSION_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKnowledgeSyncProvider,
                resolutionPolicy: CONFLICT_RESOLUTION_POLICY,
                pSourceChangeBatch: ?*ISyncChangeBatch,
                pUnkDataRetriever: ?*IUnknown,
                pCallback: ?*ISyncCallback,
                pSyncSessionStatistics: ?*SYNC_SESSION_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessFullEnumerationChangeBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKnowledgeSyncProvider,
                resolutionPolicy: CONFLICT_RESOLUTION_POLICY,
                pSourceChangeBatch: ?*ISyncFullEnumerationChangeBatch,
                pUnkDataRetriever: ?*IUnknown,
                pCallback: ?*ISyncCallback,
                pSyncSessionStatistics: ?*SYNC_SESSION_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKnowledgeSyncProvider,
                resolutionPolicy: CONFLICT_RESOLUTION_POLICY,
                pSourceChangeBatch: ?*ISyncFullEnumerationChangeBatch,
                pUnkDataRetriever: ?*IUnknown,
                pCallback: ?*ISyncCallback,
                pSyncSessionStatistics: ?*SYNC_SESSION_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKnowledgeSyncProvider,
                pSessionState: ?*ISyncSessionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKnowledgeSyncProvider,
                pSessionState: ?*ISyncSessionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnowledgeSyncProvider_BeginSession(self: *const T, role: SYNC_PROVIDER_ROLE, pSessionState: ?*ISyncSessionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnowledgeSyncProvider.VTable, self.vtable).BeginSession(@ptrCast(*const IKnowledgeSyncProvider, self), role, pSessionState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnowledgeSyncProvider_GetSyncBatchParameters(self: *const T, ppSyncKnowledge: ?*?*ISyncKnowledge, pdwRequestedBatchSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnowledgeSyncProvider.VTable, self.vtable).GetSyncBatchParameters(@ptrCast(*const IKnowledgeSyncProvider, self), ppSyncKnowledge, pdwRequestedBatchSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnowledgeSyncProvider_GetChangeBatch(self: *const T, dwBatchSize: u32, pSyncKnowledge: ?*ISyncKnowledge, ppSyncChangeBatch: ?*?*ISyncChangeBatch, ppUnkDataRetriever: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnowledgeSyncProvider.VTable, self.vtable).GetChangeBatch(@ptrCast(*const IKnowledgeSyncProvider, self), dwBatchSize, pSyncKnowledge, ppSyncChangeBatch, ppUnkDataRetriever);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnowledgeSyncProvider_GetFullEnumerationChangeBatch(self: *const T, dwBatchSize: u32, pbLowerEnumerationBound: ?*const u8, pSyncKnowledge: ?*ISyncKnowledge, ppSyncChangeBatch: ?*?*ISyncFullEnumerationChangeBatch, ppUnkDataRetriever: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnowledgeSyncProvider.VTable, self.vtable).GetFullEnumerationChangeBatch(@ptrCast(*const IKnowledgeSyncProvider, self), dwBatchSize, pbLowerEnumerationBound, pSyncKnowledge, ppSyncChangeBatch, ppUnkDataRetriever);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnowledgeSyncProvider_ProcessChangeBatch(self: *const T, resolutionPolicy: CONFLICT_RESOLUTION_POLICY, pSourceChangeBatch: ?*ISyncChangeBatch, pUnkDataRetriever: ?*IUnknown, pCallback: ?*ISyncCallback, pSyncSessionStatistics: ?*SYNC_SESSION_STATISTICS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnowledgeSyncProvider.VTable, self.vtable).ProcessChangeBatch(@ptrCast(*const IKnowledgeSyncProvider, self), resolutionPolicy, pSourceChangeBatch, pUnkDataRetriever, pCallback, pSyncSessionStatistics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnowledgeSyncProvider_ProcessFullEnumerationChangeBatch(self: *const T, resolutionPolicy: CONFLICT_RESOLUTION_POLICY, pSourceChangeBatch: ?*ISyncFullEnumerationChangeBatch, pUnkDataRetriever: ?*IUnknown, pCallback: ?*ISyncCallback, pSyncSessionStatistics: ?*SYNC_SESSION_STATISTICS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnowledgeSyncProvider.VTable, self.vtable).ProcessFullEnumerationChangeBatch(@ptrCast(*const IKnowledgeSyncProvider, self), resolutionPolicy, pSourceChangeBatch, pUnkDataRetriever, pCallback, pSyncSessionStatistics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnowledgeSyncProvider_EndSession(self: *const T, pSessionState: ?*ISyncSessionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnowledgeSyncProvider.VTable, self.vtable).EndSession(@ptrCast(*const IKnowledgeSyncProvider, self), pSessionState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncChangeUnit_Value = Guid.initString("60edd8ca-7341-4bb7-95ce-fab6394b51cb");
pub const IID_ISyncChangeUnit = &IID_ISyncChangeUnit_Value;
pub const ISyncChangeUnit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeUnit,
                ppSyncChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeUnit,
                ppSyncChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeUnitId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeUnit,
                pbChangeUnitId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeUnit,
                pbChangeUnitId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeUnitVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeUnit,
                pbCurrentReplicaId: ?*const u8,
                pVersion: ?*SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeUnit,
                pbCurrentReplicaId: ?*const u8,
                pVersion: ?*SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeUnit_GetItemChange(self: *const T, ppSyncChange: ?*?*ISyncChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeUnit.VTable, self.vtable).GetItemChange(@ptrCast(*const ISyncChangeUnit, self), ppSyncChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeUnit_GetChangeUnitId(self: *const T, pbChangeUnitId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeUnit.VTable, self.vtable).GetChangeUnitId(@ptrCast(*const ISyncChangeUnit, self), pbChangeUnitId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeUnit_GetChangeUnitVersion(self: *const T, pbCurrentReplicaId: ?*const u8, pVersion: ?*SYNC_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeUnit.VTable, self.vtable).GetChangeUnitVersion(@ptrCast(*const ISyncChangeUnit, self), pbCurrentReplicaId, pVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IEnumSyncChangeUnits_Value = Guid.initString("346b35f1-8703-4c6d-ab1a-4dbca2cff97f");
pub const IID_IEnumSyncChangeUnits = &IID_IEnumSyncChangeUnits_Value;
pub const IEnumSyncChangeUnits = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncChangeUnits,
                cChanges: u32,
                ppChangeUnit: ?*?*ISyncChangeUnit,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncChangeUnits,
                cChanges: u32,
                ppChangeUnit: ?*?*ISyncChangeUnit,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncChangeUnits,
                cChanges: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncChangeUnits,
                cChanges: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncChangeUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncChangeUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncChangeUnits,
                ppEnum: ?*?*IEnumSyncChangeUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncChangeUnits,
                ppEnum: ?*?*IEnumSyncChangeUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncChangeUnits_Next(self: *const T, cChanges: u32, ppChangeUnit: ?*?*ISyncChangeUnit, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncChangeUnits.VTable, self.vtable).Next(@ptrCast(*const IEnumSyncChangeUnits, self), cChanges, ppChangeUnit, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncChangeUnits_Skip(self: *const T, cChanges: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncChangeUnits.VTable, self.vtable).Skip(@ptrCast(*const IEnumSyncChangeUnits, self), cChanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncChangeUnits_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncChangeUnits.VTable, self.vtable).Reset(@ptrCast(*const IEnumSyncChangeUnits, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncChangeUnits_Clone(self: *const T, ppEnum: ?*?*IEnumSyncChangeUnits) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncChangeUnits.VTable, self.vtable).Clone(@ptrCast(*const IEnumSyncChangeUnits, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncChange_Value = Guid.initString("a1952beb-0f6b-4711-b136-01da85b968a6");
pub const IID_ISyncChange = &IID_ISyncChange_Value;
pub const ISyncChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOwnerReplicaId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                pbReplicaId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                pbReplicaId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootItemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                pbRootItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                pbRootItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                pbCurrentReplicaId: ?*const u8,
                pVersion: ?*SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                pbCurrentReplicaId: ?*const u8,
                pVersion: ?*SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCreationVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                pbCurrentReplicaId: ?*const u8,
                pVersion: ?*SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                pbCurrentReplicaId: ?*const u8,
                pVersion: ?*SYNC_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWorkEstimate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                pdwWork: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                pdwWork: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeUnits: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                ppEnum: ?*?*IEnumSyncChangeUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                ppEnum: ?*?*IEnumSyncChangeUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMadeWithKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                ppMadeWithKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                ppMadeWithKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                ppLearnedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                ppLearnedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWorkEstimate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChange,
                dwWork: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChange,
                dwWork: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_GetOwnerReplicaId(self: *const T, pbReplicaId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).GetOwnerReplicaId(@ptrCast(*const ISyncChange, self), pbReplicaId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_GetRootItemId(self: *const T, pbRootItemId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).GetRootItemId(@ptrCast(*const ISyncChange, self), pbRootItemId, pcbIdSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_GetChangeVersion(self: *const T, pbCurrentReplicaId: ?*const u8, pVersion: ?*SYNC_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).GetChangeVersion(@ptrCast(*const ISyncChange, self), pbCurrentReplicaId, pVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_GetCreationVersion(self: *const T, pbCurrentReplicaId: ?*const u8, pVersion: ?*SYNC_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).GetCreationVersion(@ptrCast(*const ISyncChange, self), pbCurrentReplicaId, pVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_GetFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).GetFlags(@ptrCast(*const ISyncChange, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_GetWorkEstimate(self: *const T, pdwWork: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).GetWorkEstimate(@ptrCast(*const ISyncChange, self), pdwWork);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_GetChangeUnits(self: *const T, ppEnum: ?*?*IEnumSyncChangeUnits) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).GetChangeUnits(@ptrCast(*const ISyncChange, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_GetMadeWithKnowledge(self: *const T, ppMadeWithKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).GetMadeWithKnowledge(@ptrCast(*const ISyncChange, self), ppMadeWithKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_GetLearnedKnowledge(self: *const T, ppLearnedKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).GetLearnedKnowledge(@ptrCast(*const ISyncChange, self), ppLearnedKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChange_SetWorkEstimate(self: *const T, dwWork: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChange.VTable, self.vtable).SetWorkEstimate(@ptrCast(*const ISyncChange, self), dwWork);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncChangeWithPrerequisite_Value = Guid.initString("9e38382f-1589-48c3-92e4-05ecdcb4f3f7");
pub const IID_ISyncChangeWithPrerequisite = &IID_ISyncChangeWithPrerequisite_Value;
pub const ISyncChangeWithPrerequisite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPrerequisiteKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithPrerequisite,
                ppPrerequisiteKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithPrerequisite,
                ppPrerequisiteKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedKnowledgeWithPrerequisite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithPrerequisite,
                pDestinationKnowledge: ?*ISyncKnowledge,
                ppLearnedKnowledgeWithPrerequisite: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithPrerequisite,
                pDestinationKnowledge: ?*ISyncKnowledge,
                ppLearnedKnowledgeWithPrerequisite: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithPrerequisite_GetPrerequisiteKnowledge(self: *const T, ppPrerequisiteKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithPrerequisite.VTable, self.vtable).GetPrerequisiteKnowledge(@ptrCast(*const ISyncChangeWithPrerequisite, self), ppPrerequisiteKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithPrerequisite_GetLearnedKnowledgeWithPrerequisite(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, ppLearnedKnowledgeWithPrerequisite: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithPrerequisite.VTable, self.vtable).GetLearnedKnowledgeWithPrerequisite(@ptrCast(*const ISyncChangeWithPrerequisite, self), pDestinationKnowledge, ppLearnedKnowledgeWithPrerequisite);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncFullEnumerationChange_Value = Guid.initString("9785e0bd-bdff-40c4-98c5-b34b2f1991b3");
pub const IID_ISyncFullEnumerationChange = &IID_ISyncFullEnumerationChange_Value;
pub const ISyncFullEnumerationChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLearnedKnowledgeAfterRecoveryComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFullEnumerationChange,
                ppLearnedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFullEnumerationChange,
                ppLearnedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedForgottenKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncFullEnumerationChange,
                ppLearnedForgottenKnowledge: ?*?*IForgottenKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncFullEnumerationChange,
                ppLearnedForgottenKnowledge: ?*?*IForgottenKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFullEnumerationChange_GetLearnedKnowledgeAfterRecoveryComplete(self: *const T, ppLearnedKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFullEnumerationChange.VTable, self.vtable).GetLearnedKnowledgeAfterRecoveryComplete(@ptrCast(*const ISyncFullEnumerationChange, self), ppLearnedKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncFullEnumerationChange_GetLearnedForgottenKnowledge(self: *const T, ppLearnedForgottenKnowledge: ?*?*IForgottenKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncFullEnumerationChange.VTable, self.vtable).GetLearnedForgottenKnowledge(@ptrCast(*const ISyncFullEnumerationChange, self), ppLearnedForgottenKnowledge);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISyncMergeTombstoneChange_Value = Guid.initString("6ec62597-0903-484c-ad61-36d6e938f47b");
pub const IID_ISyncMergeTombstoneChange = &IID_ISyncMergeTombstoneChange_Value;
pub const ISyncMergeTombstoneChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWinnerItemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncMergeTombstoneChange,
                pbWinnerItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncMergeTombstoneChange,
                pbWinnerItemId: ?*u8,
                pcbIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMergeTombstoneChange_GetWinnerItemId(self: *const T, pbWinnerItemId: ?*u8, pcbIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMergeTombstoneChange.VTable, self.vtable).GetWinnerItemId(@ptrCast(*const ISyncMergeTombstoneChange, self), pbWinnerItemId, pcbIdSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumItemIds_Value = Guid.initString("43aa3f61-4b2e-4b60-83df-b110d3e148f1");
pub const IID_IEnumItemIds = &IID_IEnumItemIds_Value;
pub const IEnumItemIds = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumItemIds,
                pbItemId: ?*u8,
                pcbItemIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumItemIds,
                pbItemId: ?*u8,
                pcbItemIdSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumItemIds_Next(self: *const T, pbItemId: ?*u8, pcbItemIdSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumItemIds.VTable, self.vtable).Next(@ptrCast(*const IEnumItemIds, self), pbItemId, pcbItemIdSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFilterKeyMap_Value = Guid.initString("ca169652-07c6-4708-a3da-6e4eba8d2297");
pub const IID_IFilterKeyMap = &IID_IFilterKeyMap_Value;
pub const IFilterKeyMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterKeyMap,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterKeyMap,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterKeyMap,
                pISyncFilter: ?*ISyncFilter,
                pdwFilterKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterKeyMap,
                pISyncFilter: ?*ISyncFilter,
                pdwFilterKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterKeyMap,
                dwFilterKey: u32,
                ppISyncFilter: ?*?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterKeyMap,
                dwFilterKey: u32,
                ppISyncFilter: ?*?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterKeyMap,
                pbFilterKeyMap: ?*u8,
                pcbFilterKeyMap: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterKeyMap,
                pbFilterKeyMap: ?*u8,
                pcbFilterKeyMap: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterKeyMap_GetCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterKeyMap.VTable, self.vtable).GetCount(@ptrCast(*const IFilterKeyMap, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterKeyMap_AddFilter(self: *const T, pISyncFilter: ?*ISyncFilter, pdwFilterKey: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterKeyMap.VTable, self.vtable).AddFilter(@ptrCast(*const IFilterKeyMap, self), pISyncFilter, pdwFilterKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterKeyMap_GetFilter(self: *const T, dwFilterKey: u32, ppISyncFilter: ?*?*ISyncFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterKeyMap.VTable, self.vtable).GetFilter(@ptrCast(*const IFilterKeyMap, self), dwFilterKey, ppISyncFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterKeyMap_Serialize(self: *const T, pbFilterKeyMap: ?*u8, pcbFilterKeyMap: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterKeyMap.VTable, self.vtable).Serialize(@ptrCast(*const IFilterKeyMap, self), pbFilterKeyMap, pcbFilterKeyMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISyncChangeWithFilterKeyMap_Value = Guid.initString("bfe1ef00-e87d-42fd-a4e9-242d70414aef");
pub const IID_ISyncChangeWithFilterKeyMap = &IID_ISyncChangeWithFilterKeyMap_Value;
pub const ISyncChangeWithFilterKeyMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilterCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pdwFilterCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pdwFilterCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithFilterKeyMap,
                dwFilterKey: u32,
                pFilterChange: ?*SYNC_FILTER_CHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithFilterKeyMap,
                dwFilterKey: u32,
                pFilterChange: ?*SYNC_FILTER_CHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllChangeUnitsPresentFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pfAllChangeUnitsPresent: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pfAllChangeUnitsPresent: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterForgottenKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithFilterKeyMap,
                dwFilterKey: u32,
                ppIFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithFilterKeyMap,
                dwFilterKey: u32,
                ppIFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilteredReplicaLearnedKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedFilterForgottenKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                dwFilterKey: u32,
                ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                dwFilterKey: u32,
                ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilteredReplicaLearnedForgottenKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilteredReplicaLearnedForgottenKnowledgeAfterRecoveryComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedFilterForgottenKnowledgeAfterRecoveryComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                dwFilterKey: u32,
                ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                dwFilterKey: u32,
                ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithFilterKeyMap_GetFilterCount(self: *const T, pdwFilterCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithFilterKeyMap.VTable, self.vtable).GetFilterCount(@ptrCast(*const ISyncChangeWithFilterKeyMap, self), pdwFilterCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithFilterKeyMap_GetFilterChange(self: *const T, dwFilterKey: u32, pFilterChange: ?*SYNC_FILTER_CHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithFilterKeyMap.VTable, self.vtable).GetFilterChange(@ptrCast(*const ISyncChangeWithFilterKeyMap, self), dwFilterKey, pFilterChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithFilterKeyMap_GetAllChangeUnitsPresentFlag(self: *const T, pfAllChangeUnitsPresent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithFilterKeyMap.VTable, self.vtable).GetAllChangeUnitsPresentFlag(@ptrCast(*const ISyncChangeWithFilterKeyMap, self), pfAllChangeUnitsPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithFilterKeyMap_GetFilterForgottenKnowledge(self: *const T, dwFilterKey: u32, ppIFilterForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithFilterKeyMap.VTable, self.vtable).GetFilterForgottenKnowledge(@ptrCast(*const ISyncChangeWithFilterKeyMap, self), dwFilterKey, ppIFilterForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithFilterKeyMap_GetFilteredReplicaLearnedKnowledge(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, ppLearnedKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithFilterKeyMap.VTable, self.vtable).GetFilteredReplicaLearnedKnowledge(@ptrCast(*const ISyncChangeWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, ppLearnedKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithFilterKeyMap_GetLearnedFilterForgottenKnowledge(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, dwFilterKey: u32, ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithFilterKeyMap.VTable, self.vtable).GetLearnedFilterForgottenKnowledge(@ptrCast(*const ISyncChangeWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, dwFilterKey, ppLearnedFilterForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithFilterKeyMap_GetFilteredReplicaLearnedForgottenKnowledge(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithFilterKeyMap.VTable, self.vtable).GetFilteredReplicaLearnedForgottenKnowledge(@ptrCast(*const ISyncChangeWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, ppLearnedForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithFilterKeyMap_GetFilteredReplicaLearnedForgottenKnowledgeAfterRecoveryComplete(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithFilterKeyMap.VTable, self.vtable).GetFilteredReplicaLearnedForgottenKnowledgeAfterRecoveryComplete(@ptrCast(*const ISyncChangeWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, ppLearnedForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeWithFilterKeyMap_GetLearnedFilterForgottenKnowledgeAfterRecoveryComplete(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, dwFilterKey: u32, ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeWithFilterKeyMap.VTable, self.vtable).GetLearnedFilterForgottenKnowledgeAfterRecoveryComplete(@ptrCast(*const ISyncChangeWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, dwFilterKey, ppLearnedFilterForgottenKnowledge);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISyncChangeBatchWithFilterKeyMap_Value = Guid.initString("de247002-566d-459a-a6ed-a5aab3459fb7");
pub const IID_ISyncChangeBatchWithFilterKeyMap = &IID_ISyncChangeBatchWithFilterKeyMap_Value;
pub const ISyncChangeBatchWithFilterKeyMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilterKeyMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                ppIFilterKeyMap: ?*?*IFilterKeyMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                ppIFilterKeyMap: ?*?*IFilterKeyMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFilterKeyMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pIFilterKeyMap: ?*IFilterKeyMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pIFilterKeyMap: ?*IFilterKeyMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFilterForgottenKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                dwFilterKey: u32,
                pFilterForgottenKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                dwFilterKey: u32,
                pFilterForgottenKnowledge: ?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilteredReplicaLearnedKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedFilterForgottenKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                dwFilterKey: u32,
                ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                dwFilterKey: u32,
                ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilteredReplicaLearnedForgottenKnowledge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilteredReplicaLearnedForgottenKnowledgeAfterRecoveryComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLearnedFilterForgottenKnowledgeAfterRecoveryComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                dwFilterKey: u32,
                ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncChangeBatchWithFilterKeyMap,
                pDestinationKnowledge: ?*ISyncKnowledge,
                pNewMoveins: ?*IEnumItemIds,
                dwFilterKey: u32,
                ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithFilterKeyMap_GetFilterKeyMap(self: *const T, ppIFilterKeyMap: ?*?*IFilterKeyMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithFilterKeyMap.VTable, self.vtable).GetFilterKeyMap(@ptrCast(*const ISyncChangeBatchWithFilterKeyMap, self), ppIFilterKeyMap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithFilterKeyMap_SetFilterKeyMap(self: *const T, pIFilterKeyMap: ?*IFilterKeyMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithFilterKeyMap.VTable, self.vtable).SetFilterKeyMap(@ptrCast(*const ISyncChangeBatchWithFilterKeyMap, self), pIFilterKeyMap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithFilterKeyMap_SetFilterForgottenKnowledge(self: *const T, dwFilterKey: u32, pFilterForgottenKnowledge: ?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithFilterKeyMap.VTable, self.vtable).SetFilterForgottenKnowledge(@ptrCast(*const ISyncChangeBatchWithFilterKeyMap, self), dwFilterKey, pFilterForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithFilterKeyMap_GetFilteredReplicaLearnedKnowledge(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithFilterKeyMap.VTable, self.vtable).GetFilteredReplicaLearnedKnowledge(@ptrCast(*const ISyncChangeBatchWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, ppLearnedForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithFilterKeyMap_GetLearnedFilterForgottenKnowledge(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, dwFilterKey: u32, ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithFilterKeyMap.VTable, self.vtable).GetLearnedFilterForgottenKnowledge(@ptrCast(*const ISyncChangeBatchWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, dwFilterKey, ppLearnedFilterForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithFilterKeyMap_GetFilteredReplicaLearnedForgottenKnowledge(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithFilterKeyMap.VTable, self.vtable).GetFilteredReplicaLearnedForgottenKnowledge(@ptrCast(*const ISyncChangeBatchWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, ppLearnedForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithFilterKeyMap_GetFilteredReplicaLearnedForgottenKnowledgeAfterRecoveryComplete(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, ppLearnedForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithFilterKeyMap.VTable, self.vtable).GetFilteredReplicaLearnedForgottenKnowledgeAfterRecoveryComplete(@ptrCast(*const ISyncChangeBatchWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, ppLearnedForgottenKnowledge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncChangeBatchWithFilterKeyMap_GetLearnedFilterForgottenKnowledgeAfterRecoveryComplete(self: *const T, pDestinationKnowledge: ?*ISyncKnowledge, pNewMoveins: ?*IEnumItemIds, dwFilterKey: u32, ppLearnedFilterForgottenKnowledge: ?*?*ISyncKnowledge) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncChangeBatchWithFilterKeyMap.VTable, self.vtable).GetLearnedFilterForgottenKnowledgeAfterRecoveryComplete(@ptrCast(*const ISyncChangeBatchWithFilterKeyMap, self), pDestinationKnowledge, pNewMoveins, dwFilterKey, ppLearnedFilterForgottenKnowledge);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDataRetrieverCallback_Value = Guid.initString("71b4863b-f969-4676-bbc3-3d9fdc3fb2c7");
pub const IID_IDataRetrieverCallback = &IID_IDataRetrieverCallback_Value;
pub const IDataRetrieverCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadChangeDataComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataRetrieverCallback,
                pUnkData: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataRetrieverCallback,
                pUnkData: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadChangeDataError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataRetrieverCallback,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataRetrieverCallback,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataRetrieverCallback_LoadChangeDataComplete(self: *const T, pUnkData: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataRetrieverCallback.VTable, self.vtable).LoadChangeDataComplete(@ptrCast(*const IDataRetrieverCallback, self), pUnkData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataRetrieverCallback_LoadChangeDataError(self: *const T, hrError: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataRetrieverCallback.VTable, self.vtable).LoadChangeDataError(@ptrCast(*const IDataRetrieverCallback, self), hrError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ILoadChangeContext_Value = Guid.initString("44a4aaca-ec39-46d5-b5c9-d633c0ee67e2");
pub const IID_ILoadChangeContext = &IID_ILoadChangeContext_Value;
pub const ILoadChangeContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSyncChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILoadChangeContext,
                ppSyncChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILoadChangeContext,
                ppSyncChange: ?*?*ISyncChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRecoverableErrorOnChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILoadChangeContext,
                hrError: HRESULT,
                pErrorData: ?*IRecoverableErrorData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILoadChangeContext,
                hrError: HRESULT,
                pErrorData: ?*IRecoverableErrorData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRecoverableErrorOnChangeUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILoadChangeContext,
                hrError: HRESULT,
                pChangeUnit: ?*ISyncChangeUnit,
                pErrorData: ?*IRecoverableErrorData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILoadChangeContext,
                hrError: HRESULT,
                pChangeUnit: ?*ISyncChangeUnit,
                pErrorData: ?*IRecoverableErrorData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILoadChangeContext_GetSyncChange(self: *const T, ppSyncChange: ?*?*ISyncChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILoadChangeContext.VTable, self.vtable).GetSyncChange(@ptrCast(*const ILoadChangeContext, self), ppSyncChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILoadChangeContext_SetRecoverableErrorOnChange(self: *const T, hrError: HRESULT, pErrorData: ?*IRecoverableErrorData) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILoadChangeContext.VTable, self.vtable).SetRecoverableErrorOnChange(@ptrCast(*const ILoadChangeContext, self), hrError, pErrorData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILoadChangeContext_SetRecoverableErrorOnChangeUnit(self: *const T, hrError: HRESULT, pChangeUnit: ?*ISyncChangeUnit, pErrorData: ?*IRecoverableErrorData) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILoadChangeContext.VTable, self.vtable).SetRecoverableErrorOnChangeUnit(@ptrCast(*const ILoadChangeContext, self), hrError, pChangeUnit, pErrorData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISynchronousDataRetriever_Value = Guid.initString("9b22f2a9-a4cd-4648-9d8e-3a510d4da04b");
pub const IID_ISynchronousDataRetriever = &IID_ISynchronousDataRetriever_Value;
pub const ISynchronousDataRetriever = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISynchronousDataRetriever,
                pIdParameters: ?*ID_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISynchronousDataRetriever,
                pIdParameters: ?*ID_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadChangeData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISynchronousDataRetriever,
                pLoadChangeContext: ?*ILoadChangeContext,
                ppUnkData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISynchronousDataRetriever,
                pLoadChangeContext: ?*ILoadChangeContext,
                ppUnkData: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronousDataRetriever_GetIdParameters(self: *const T, pIdParameters: ?*ID_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronousDataRetriever.VTable, self.vtable).GetIdParameters(@ptrCast(*const ISynchronousDataRetriever, self), pIdParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronousDataRetriever_LoadChangeData(self: *const T, pLoadChangeContext: ?*ILoadChangeContext, ppUnkData: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronousDataRetriever.VTable, self.vtable).LoadChangeData(@ptrCast(*const ISynchronousDataRetriever, self), pLoadChangeContext, ppUnkData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAsynchronousDataRetriever_Value = Guid.initString("9fc7e470-61ea-4a88-9be4-df56a27cfef2");
pub const IID_IAsynchronousDataRetriever = &IID_IAsynchronousDataRetriever_Value;
pub const IAsynchronousDataRetriever = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsynchronousDataRetriever,
                pIdParameters: ?*ID_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsynchronousDataRetriever,
                pIdParameters: ?*ID_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsynchronousDataRetriever,
                pDataRetrieverCallback: ?*IDataRetrieverCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsynchronousDataRetriever,
                pDataRetrieverCallback: ?*IDataRetrieverCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevokeCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsynchronousDataRetriever,
                pDataRetrieverCallback: ?*IDataRetrieverCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsynchronousDataRetriever,
                pDataRetrieverCallback: ?*IDataRetrieverCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadChangeData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsynchronousDataRetriever,
                pLoadChangeContext: ?*ILoadChangeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsynchronousDataRetriever,
                pLoadChangeContext: ?*ILoadChangeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsynchronousDataRetriever_GetIdParameters(self: *const T, pIdParameters: ?*ID_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsynchronousDataRetriever.VTable, self.vtable).GetIdParameters(@ptrCast(*const IAsynchronousDataRetriever, self), pIdParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsynchronousDataRetriever_RegisterCallback(self: *const T, pDataRetrieverCallback: ?*IDataRetrieverCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsynchronousDataRetriever.VTable, self.vtable).RegisterCallback(@ptrCast(*const IAsynchronousDataRetriever, self), pDataRetrieverCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsynchronousDataRetriever_RevokeCallback(self: *const T, pDataRetrieverCallback: ?*IDataRetrieverCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsynchronousDataRetriever.VTable, self.vtable).RevokeCallback(@ptrCast(*const IAsynchronousDataRetriever, self), pDataRetrieverCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsynchronousDataRetriever_LoadChangeData(self: *const T, pLoadChangeContext: ?*ILoadChangeContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsynchronousDataRetriever.VTable, self.vtable).LoadChangeData(@ptrCast(*const IAsynchronousDataRetriever, self), pLoadChangeContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IFilterRequestCallback_Value = Guid.initString("82df8873-6360-463a-a8a1-ede5e1a1594d");
pub const IID_IFilterRequestCallback = &IID_IFilterRequestCallback_Value;
pub const IFilterRequestCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterRequestCallback,
                pFilter: ?*IUnknown,
                filteringType: FILTERING_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterRequestCallback,
                pFilter: ?*IUnknown,
                filteringType: FILTERING_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterRequestCallback_RequestFilter(self: *const T, pFilter: ?*IUnknown, filteringType: FILTERING_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterRequestCallback.VTable, self.vtable).RequestFilter(@ptrCast(*const IFilterRequestCallback, self), pFilter, filteringType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IRequestFilteredSync_Value = Guid.initString("2e020184-6d18-46a7-a32a-da4aeb06696c");
pub const IID_IRequestFilteredSync = &IID_IRequestFilteredSync_Value;
pub const IRequestFilteredSync = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SpecifyFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRequestFilteredSync,
                pCallback: ?*IFilterRequestCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRequestFilteredSync,
                pCallback: ?*IFilterRequestCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRequestFilteredSync_SpecifyFilter(self: *const T, pCallback: ?*IFilterRequestCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRequestFilteredSync.VTable, self.vtable).SpecifyFilter(@ptrCast(*const IRequestFilteredSync, self), pCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISupportFilteredSync_Value = Guid.initString("3d128ded-d555-4e0d-bf4b-fb213a8a9302");
pub const IID_ISupportFilteredSync = &IID_ISupportFilteredSync_Value;
pub const ISupportFilteredSync = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISupportFilteredSync,
                pFilter: ?*IUnknown,
                filteringType: FILTERING_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISupportFilteredSync,
                pFilter: ?*IUnknown,
                filteringType: FILTERING_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISupportFilteredSync_AddFilter(self: *const T, pFilter: ?*IUnknown, filteringType: FILTERING_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISupportFilteredSync.VTable, self.vtable).AddFilter(@ptrCast(*const ISupportFilteredSync, self), pFilter, filteringType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFilterTrackingRequestCallback_Value = Guid.initString("713ca7bb-c858-4674-b4b6-1122436587a9");
pub const IID_IFilterTrackingRequestCallback = &IID_IFilterTrackingRequestCallback_Value;
pub const IFilterTrackingRequestCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestTrackedFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterTrackingRequestCallback,
                pFilter: ?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterTrackingRequestCallback,
                pFilter: ?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterTrackingRequestCallback_RequestTrackedFilter(self: *const T, pFilter: ?*ISyncFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterTrackingRequestCallback.VTable, self.vtable).RequestTrackedFilter(@ptrCast(*const IFilterTrackingRequestCallback, self), pFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFilterTrackingProvider_Value = Guid.initString("743383c0-fc4e-45ba-ad81-d9d84c7a24f8");
pub const IID_IFilterTrackingProvider = &IID_IFilterTrackingProvider_Value;
pub const IFilterTrackingProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SpecifyTrackedFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterTrackingProvider,
                pCallback: ?*IFilterTrackingRequestCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterTrackingProvider,
                pCallback: ?*IFilterTrackingRequestCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTrackedFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterTrackingProvider,
                pFilter: ?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterTrackingProvider,
                pFilter: ?*ISyncFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterTrackingProvider_SpecifyTrackedFilters(self: *const T, pCallback: ?*IFilterTrackingRequestCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterTrackingProvider.VTable, self.vtable).SpecifyTrackedFilters(@ptrCast(*const IFilterTrackingProvider, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterTrackingProvider_AddTrackedFilter(self: *const T, pFilter: ?*ISyncFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterTrackingProvider.VTable, self.vtable).AddTrackedFilter(@ptrCast(*const IFilterTrackingProvider, self), pFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISupportLastWriteTime_Value = Guid.initString("eadf816f-d0bd-43ca-8f40-5acdc6c06f7a");
pub const IID_ISupportLastWriteTime = &IID_ISupportLastWriteTime_Value;
pub const ISupportLastWriteTime = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemChangeTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISupportLastWriteTime,
                pbItemId: ?*const u8,
                pullTimestamp: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISupportLastWriteTime,
                pbItemId: ?*const u8,
                pullTimestamp: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeUnitChangeTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISupportLastWriteTime,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
                pullTimestamp: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISupportLastWriteTime,
                pbItemId: ?*const u8,
                pbChangeUnitId: ?*const u8,
                pullTimestamp: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISupportLastWriteTime_GetItemChangeTime(self: *const T, pbItemId: ?*const u8, pullTimestamp: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISupportLastWriteTime.VTable, self.vtable).GetItemChangeTime(@ptrCast(*const ISupportLastWriteTime, self), pbItemId, pullTimestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISupportLastWriteTime_GetChangeUnitChangeTime(self: *const T, pbItemId: ?*const u8, pbChangeUnitId: ?*const u8, pullTimestamp: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISupportLastWriteTime.VTable, self.vtable).GetChangeUnitChangeTime(@ptrCast(*const ISupportLastWriteTime, self), pbItemId, pbChangeUnitId, pullTimestamp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IProviderConverter_Value = Guid.initString("809b7276-98cf-4957-93a5-0ebdd3dddffd");
pub const IID_IProviderConverter = &IID_IProviderConverter_Value;
pub const IProviderConverter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProviderConverter,
                pISyncProvider: ?*ISyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProviderConverter,
                pISyncProvider: ?*ISyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderConverter_Initialize(self: *const T, pISyncProvider: ?*ISyncProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderConverter.VTable, self.vtable).Initialize(@ptrCast(*const IProviderConverter, self), pISyncProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISyncDataConverter_Value = Guid.initString("435d4861-68d5-44aa-a0f9-72a0b00ef9cf");
pub const IID_ISyncDataConverter = &IID_ISyncDataConverter_Value;
pub const ISyncDataConverter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConvertDataRetrieverFromProviderFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncDataConverter,
                pUnkDataRetrieverIn: ?*IUnknown,
                pEnumSyncChanges: ?*IEnumSyncChanges,
                ppUnkDataOut: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncDataConverter,
                pUnkDataRetrieverIn: ?*IUnknown,
                pEnumSyncChanges: ?*IEnumSyncChanges,
                ppUnkDataOut: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertDataRetrieverToProviderFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncDataConverter,
                pUnkDataRetrieverIn: ?*IUnknown,
                pEnumSyncChanges: ?*IEnumSyncChanges,
                ppUnkDataOut: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncDataConverter,
                pUnkDataRetrieverIn: ?*IUnknown,
                pEnumSyncChanges: ?*IEnumSyncChanges,
                ppUnkDataOut: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertDataFromProviderFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncDataConverter,
                pDataContext: ?*ILoadChangeContext,
                pUnkDataIn: ?*IUnknown,
                ppUnkDataOut: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncDataConverter,
                pDataContext: ?*ILoadChangeContext,
                pUnkDataIn: ?*IUnknown,
                ppUnkDataOut: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertDataToProviderFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncDataConverter,
                pDataContext: ?*ILoadChangeContext,
                pUnkDataOut: ?*IUnknown,
                ppUnkDataout: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncDataConverter,
                pDataContext: ?*ILoadChangeContext,
                pUnkDataOut: ?*IUnknown,
                ppUnkDataout: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncDataConverter_ConvertDataRetrieverFromProviderFormat(self: *const T, pUnkDataRetrieverIn: ?*IUnknown, pEnumSyncChanges: ?*IEnumSyncChanges, ppUnkDataOut: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncDataConverter.VTable, self.vtable).ConvertDataRetrieverFromProviderFormat(@ptrCast(*const ISyncDataConverter, self), pUnkDataRetrieverIn, pEnumSyncChanges, ppUnkDataOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncDataConverter_ConvertDataRetrieverToProviderFormat(self: *const T, pUnkDataRetrieverIn: ?*IUnknown, pEnumSyncChanges: ?*IEnumSyncChanges, ppUnkDataOut: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncDataConverter.VTable, self.vtable).ConvertDataRetrieverToProviderFormat(@ptrCast(*const ISyncDataConverter, self), pUnkDataRetrieverIn, pEnumSyncChanges, ppUnkDataOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncDataConverter_ConvertDataFromProviderFormat(self: *const T, pDataContext: ?*ILoadChangeContext, pUnkDataIn: ?*IUnknown, ppUnkDataOut: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncDataConverter.VTable, self.vtable).ConvertDataFromProviderFormat(@ptrCast(*const ISyncDataConverter, self), pDataContext, pUnkDataIn, ppUnkDataOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncDataConverter_ConvertDataToProviderFormat(self: *const T, pDataContext: ?*ILoadChangeContext, pUnkDataOut: ?*IUnknown, ppUnkDataout: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncDataConverter.VTable, self.vtable).ConvertDataToProviderFormat(@ptrCast(*const ISyncDataConverter, self), pDataContext, pUnkDataOut, ppUnkDataout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SyncProviderRegistration_Value = Guid.initString("f82b4ef1-93a9-4dde-8015-f7950a1a6e31");
pub const CLSID_SyncProviderRegistration = &CLSID_SyncProviderRegistration_Value;

pub const SyncProviderConfiguration = extern struct {
    dwVersion: u32,
    guidInstanceId: Guid,
    clsidProvider: Guid,
    guidConfigUIInstanceId: Guid,
    guidContentType: Guid,
    dwCapabilities: u32,
    dwSupportedArchitecture: u32,
};

pub const SyncProviderConfigUIConfiguration = extern struct {
    dwVersion: u32,
    guidInstanceId: Guid,
    clsidConfigUI: Guid,
    guidContentType: Guid,
    dwCapabilities: u32,
    dwSupportedArchitecture: u32,
    fIsGlobal: BOOL,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncProviderRegistration_Value = Guid.initString("cb45953b-7624-47bc-a472-eb8cac6b222e");
pub const IID_ISyncProviderRegistration = &IID_ISyncProviderRegistration_Value;
pub const ISyncProviderRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSyncProviderConfigUIRegistrationInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pConfigUIConfig: ?*const SyncProviderConfigUIConfiguration,
                ppConfigUIInfo: ?*?*ISyncProviderConfigUIInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pConfigUIConfig: ?*const SyncProviderConfigUIConfiguration,
                ppConfigUIInfo: ?*?*ISyncProviderConfigUIInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterSyncProviderConfigUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateSyncProviderConfigUIs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidContentType: ?*const Guid,
                dwSupportedArchitecture: u32,
                ppEnumSyncProviderConfigUIInfos: ?*?*IEnumSyncProviderConfigUIInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidContentType: ?*const Guid,
                dwSupportedArchitecture: u32,
                ppEnumSyncProviderConfigUIInfos: ?*?*IEnumSyncProviderConfigUIInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSyncProviderRegistrationInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pProviderConfiguration: ?*const SyncProviderConfiguration,
                ppProviderInfo: ?*?*ISyncProviderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pProviderConfiguration: ?*const SyncProviderConfiguration,
                ppProviderInfo: ?*?*ISyncProviderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterSyncProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncProviderConfigUIInfoforProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidProviderInstanceId: ?*const Guid,
                ppProviderConfigUIInfo: ?*?*ISyncProviderConfigUIInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidProviderInstanceId: ?*const Guid,
                ppProviderConfigUIInfo: ?*?*ISyncProviderConfigUIInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateSyncProviders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidContentType: ?*const Guid,
                dwStateFlagsToFilterMask: u32,
                dwStateFlagsToFilter: u32,
                refProviderClsId: ?*const Guid,
                dwSupportedArchitecture: u32,
                ppEnumSyncProviderInfos: ?*?*IEnumSyncProviderInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidContentType: ?*const Guid,
                dwStateFlagsToFilterMask: u32,
                dwStateFlagsToFilter: u32,
                refProviderClsId: ?*const Guid,
                dwSupportedArchitecture: u32,
                ppEnumSyncProviderInfos: ?*?*IEnumSyncProviderInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncProviderInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                ppProviderInfo: ?*?*ISyncProviderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                ppProviderInfo: ?*?*ISyncProviderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncProviderFromInstanceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                dwClsContext: u32,
                ppSyncProvider: ?*?*IRegisteredSyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                dwClsContext: u32,
                ppSyncProvider: ?*?*IRegisteredSyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncProviderConfigUIInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                ppConfigUIInfo: ?*?*ISyncProviderConfigUIInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                ppConfigUIInfo: ?*?*ISyncProviderConfigUIInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncProviderConfigUIFromInstanceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                dwClsContext: u32,
                ppConfigUI: ?*?*ISyncProviderConfigUI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                dwClsContext: u32,
                ppConfigUI: ?*?*ISyncProviderConfigUI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncProviderState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                pdwStateFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                pdwStateFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncProviderState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                dwStateFlagsMask: u32,
                dwStateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                pguidInstanceId: ?*const Guid,
                dwStateFlagsMask: u32,
                dwStateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                phEvent: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                phEvent: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevokeEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderRegistration,
                hEvent: ?HANDLE,
                ppChange: ?*?*ISyncRegistrationChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderRegistration,
                hEvent: ?HANDLE,
                ppChange: ?*?*ISyncRegistrationChange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_CreateSyncProviderConfigUIRegistrationInstance(self: *const T, pConfigUIConfig: ?*const SyncProviderConfigUIConfiguration, ppConfigUIInfo: ?*?*ISyncProviderConfigUIInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).CreateSyncProviderConfigUIRegistrationInstance(@ptrCast(*const ISyncProviderRegistration, self), pConfigUIConfig, ppConfigUIInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_UnregisterSyncProviderConfigUI(self: *const T, pguidInstanceId: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).UnregisterSyncProviderConfigUI(@ptrCast(*const ISyncProviderRegistration, self), pguidInstanceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_EnumerateSyncProviderConfigUIs(self: *const T, pguidContentType: ?*const Guid, dwSupportedArchitecture: u32, ppEnumSyncProviderConfigUIInfos: ?*?*IEnumSyncProviderConfigUIInfos) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).EnumerateSyncProviderConfigUIs(@ptrCast(*const ISyncProviderRegistration, self), pguidContentType, dwSupportedArchitecture, ppEnumSyncProviderConfigUIInfos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_CreateSyncProviderRegistrationInstance(self: *const T, pProviderConfiguration: ?*const SyncProviderConfiguration, ppProviderInfo: ?*?*ISyncProviderInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).CreateSyncProviderRegistrationInstance(@ptrCast(*const ISyncProviderRegistration, self), pProviderConfiguration, ppProviderInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_UnregisterSyncProvider(self: *const T, pguidInstanceId: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).UnregisterSyncProvider(@ptrCast(*const ISyncProviderRegistration, self), pguidInstanceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_GetSyncProviderConfigUIInfoforProvider(self: *const T, pguidProviderInstanceId: ?*const Guid, ppProviderConfigUIInfo: ?*?*ISyncProviderConfigUIInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).GetSyncProviderConfigUIInfoforProvider(@ptrCast(*const ISyncProviderRegistration, self), pguidProviderInstanceId, ppProviderConfigUIInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_EnumerateSyncProviders(self: *const T, pguidContentType: ?*const Guid, dwStateFlagsToFilterMask: u32, dwStateFlagsToFilter: u32, refProviderClsId: ?*const Guid, dwSupportedArchitecture: u32, ppEnumSyncProviderInfos: ?*?*IEnumSyncProviderInfos) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).EnumerateSyncProviders(@ptrCast(*const ISyncProviderRegistration, self), pguidContentType, dwStateFlagsToFilterMask, dwStateFlagsToFilter, refProviderClsId, dwSupportedArchitecture, ppEnumSyncProviderInfos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_GetSyncProviderInfo(self: *const T, pguidInstanceId: ?*const Guid, ppProviderInfo: ?*?*ISyncProviderInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).GetSyncProviderInfo(@ptrCast(*const ISyncProviderRegistration, self), pguidInstanceId, ppProviderInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_GetSyncProviderFromInstanceId(self: *const T, pguidInstanceId: ?*const Guid, dwClsContext: u32, ppSyncProvider: ?*?*IRegisteredSyncProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).GetSyncProviderFromInstanceId(@ptrCast(*const ISyncProviderRegistration, self), pguidInstanceId, dwClsContext, ppSyncProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_GetSyncProviderConfigUIInfo(self: *const T, pguidInstanceId: ?*const Guid, ppConfigUIInfo: ?*?*ISyncProviderConfigUIInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).GetSyncProviderConfigUIInfo(@ptrCast(*const ISyncProviderRegistration, self), pguidInstanceId, ppConfigUIInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_GetSyncProviderConfigUIFromInstanceId(self: *const T, pguidInstanceId: ?*const Guid, dwClsContext: u32, ppConfigUI: ?*?*ISyncProviderConfigUI) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).GetSyncProviderConfigUIFromInstanceId(@ptrCast(*const ISyncProviderRegistration, self), pguidInstanceId, dwClsContext, ppConfigUI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_GetSyncProviderState(self: *const T, pguidInstanceId: ?*const Guid, pdwStateFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).GetSyncProviderState(@ptrCast(*const ISyncProviderRegistration, self), pguidInstanceId, pdwStateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_SetSyncProviderState(self: *const T, pguidInstanceId: ?*const Guid, dwStateFlagsMask: u32, dwStateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).SetSyncProviderState(@ptrCast(*const ISyncProviderRegistration, self), pguidInstanceId, dwStateFlagsMask, dwStateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_RegisterForEvent(self: *const T, phEvent: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).RegisterForEvent(@ptrCast(*const ISyncProviderRegistration, self), phEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_RevokeEvent(self: *const T, hEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).RevokeEvent(@ptrCast(*const ISyncProviderRegistration, self), hEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderRegistration_GetChange(self: *const T, hEvent: ?HANDLE, ppChange: ?*?*ISyncRegistrationChange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderRegistration.VTable, self.vtable).GetChange(@ptrCast(*const ISyncProviderRegistration, self), hEvent, ppChange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IEnumSyncProviderConfigUIInfos_Value = Guid.initString("f6be2602-17c6-4658-a2d7-68ed3330f641");
pub const IID_IEnumSyncProviderConfigUIInfos = &IID_IEnumSyncProviderConfigUIInfos_Value;
pub const IEnumSyncProviderConfigUIInfos = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncProviderConfigUIInfos,
                cFactories: u32,
                ppSyncProviderConfigUIInfo: [*]?*ISyncProviderConfigUIInfo,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncProviderConfigUIInfos,
                cFactories: u32,
                ppSyncProviderConfigUIInfo: [*]?*ISyncProviderConfigUIInfo,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncProviderConfigUIInfos,
                cFactories: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncProviderConfigUIInfos,
                cFactories: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncProviderConfigUIInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncProviderConfigUIInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncProviderConfigUIInfos,
                ppEnum: ?*?*IEnumSyncProviderConfigUIInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncProviderConfigUIInfos,
                ppEnum: ?*?*IEnumSyncProviderConfigUIInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncProviderConfigUIInfos_Next(self: *const T, cFactories: u32, ppSyncProviderConfigUIInfo: [*]?*ISyncProviderConfigUIInfo, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncProviderConfigUIInfos.VTable, self.vtable).Next(@ptrCast(*const IEnumSyncProviderConfigUIInfos, self), cFactories, ppSyncProviderConfigUIInfo, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncProviderConfigUIInfos_Skip(self: *const T, cFactories: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncProviderConfigUIInfos.VTable, self.vtable).Skip(@ptrCast(*const IEnumSyncProviderConfigUIInfos, self), cFactories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncProviderConfigUIInfos_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncProviderConfigUIInfos.VTable, self.vtable).Reset(@ptrCast(*const IEnumSyncProviderConfigUIInfos, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncProviderConfigUIInfos_Clone(self: *const T, ppEnum: ?*?*IEnumSyncProviderConfigUIInfos) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncProviderConfigUIInfos.VTable, self.vtable).Clone(@ptrCast(*const IEnumSyncProviderConfigUIInfos, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IEnumSyncProviderInfos_Value = Guid.initString("a04ba850-5eb1-460d-a973-393fcb608a11");
pub const IID_IEnumSyncProviderInfos = &IID_IEnumSyncProviderInfos_Value;
pub const IEnumSyncProviderInfos = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncProviderInfos,
                cInstances: u32,
                ppSyncProviderInfo: [*]?*ISyncProviderInfo,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncProviderInfos,
                cInstances: u32,
                ppSyncProviderInfo: [*]?*ISyncProviderInfo,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncProviderInfos,
                cInstances: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncProviderInfos,
                cInstances: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncProviderInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncProviderInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSyncProviderInfos,
                ppEnum: ?*?*IEnumSyncProviderInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSyncProviderInfos,
                ppEnum: ?*?*IEnumSyncProviderInfos,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncProviderInfos_Next(self: *const T, cInstances: u32, ppSyncProviderInfo: [*]?*ISyncProviderInfo, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncProviderInfos.VTable, self.vtable).Next(@ptrCast(*const IEnumSyncProviderInfos, self), cInstances, ppSyncProviderInfo, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncProviderInfos_Skip(self: *const T, cInstances: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncProviderInfos.VTable, self.vtable).Skip(@ptrCast(*const IEnumSyncProviderInfos, self), cInstances);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncProviderInfos_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncProviderInfos.VTable, self.vtable).Reset(@ptrCast(*const IEnumSyncProviderInfos, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncProviderInfos_Clone(self: *const T, ppEnum: ?*?*IEnumSyncProviderInfos) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncProviderInfos.VTable, self.vtable).Clone(@ptrCast(*const IEnumSyncProviderInfos, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncProviderInfo_Value = Guid.initString("1ee135de-88a4-4504-b0d0-f7920d7e5ba6");
pub const IID_ISyncProviderInfo = &IID_ISyncProviderInfo_Value;
pub const ISyncProviderInfo = extern struct {
    pub const VTable = extern struct {
        base: IPropertyStore.VTable,
        GetSyncProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderInfo,
                dwClsContext: u32,
                ppSyncProvider: ?*?*IRegisteredSyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderInfo,
                dwClsContext: u32,
                ppSyncProvider: ?*?*IRegisteredSyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPropertyStore.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderInfo_GetSyncProvider(self: *const T, dwClsContext: u32, ppSyncProvider: ?*?*IRegisteredSyncProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderInfo.VTable, self.vtable).GetSyncProvider(@ptrCast(*const ISyncProviderInfo, self), dwClsContext, ppSyncProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncProviderConfigUIInfo_Value = Guid.initString("214141ae-33d7-4d8d-8e37-f227e880ce50");
pub const IID_ISyncProviderConfigUIInfo = &IID_ISyncProviderConfigUIInfo_Value;
pub const ISyncProviderConfigUIInfo = extern struct {
    pub const VTable = extern struct {
        base: IPropertyStore.VTable,
        GetSyncProviderConfigUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderConfigUIInfo,
                dwClsContext: u32,
                ppSyncProviderConfigUI: ?*?*ISyncProviderConfigUI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderConfigUIInfo,
                dwClsContext: u32,
                ppSyncProviderConfigUI: ?*?*ISyncProviderConfigUI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPropertyStore.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderConfigUIInfo_GetSyncProviderConfigUI(self: *const T, dwClsContext: u32, ppSyncProviderConfigUI: ?*?*ISyncProviderConfigUI) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderConfigUIInfo.VTable, self.vtable).GetSyncProviderConfigUI(@ptrCast(*const ISyncProviderConfigUIInfo, self), dwClsContext, ppSyncProviderConfigUI);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncProviderConfigUI_Value = Guid.initString("7b0705f6-cbcd-4071-ab05-3bdc364d4a0c");
pub const IID_ISyncProviderConfigUI = &IID_ISyncProviderConfigUI_Value;
pub const ISyncProviderConfigUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderConfigUI,
                pguidInstanceId: ?*const Guid,
                pguidContentType: ?*const Guid,
                pConfigurationProperties: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderConfigUI,
                pguidInstanceId: ?*const Guid,
                pguidContentType: ?*const Guid,
                pConfigurationProperties: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegisteredProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderConfigUI,
                ppConfigUIProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderConfigUI,
                ppConfigUIProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAndRegisterNewSyncProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderConfigUI,
                hwndParent: ?HWND,
                pUnkContext: ?*IUnknown,
                ppProviderInfo: ?*?*ISyncProviderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderConfigUI,
                hwndParent: ?HWND,
                pUnkContext: ?*IUnknown,
                ppProviderInfo: ?*?*ISyncProviderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifySyncProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncProviderConfigUI,
                hwndParent: ?HWND,
                pUnkContext: ?*IUnknown,
                pProviderInfo: ?*ISyncProviderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncProviderConfigUI,
                hwndParent: ?HWND,
                pUnkContext: ?*IUnknown,
                pProviderInfo: ?*ISyncProviderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderConfigUI_Init(self: *const T, pguidInstanceId: ?*const Guid, pguidContentType: ?*const Guid, pConfigurationProperties: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderConfigUI.VTable, self.vtable).Init(@ptrCast(*const ISyncProviderConfigUI, self), pguidInstanceId, pguidContentType, pConfigurationProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderConfigUI_GetRegisteredProperties(self: *const T, ppConfigUIProperties: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderConfigUI.VTable, self.vtable).GetRegisteredProperties(@ptrCast(*const ISyncProviderConfigUI, self), ppConfigUIProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderConfigUI_CreateAndRegisterNewSyncProvider(self: *const T, hwndParent: ?HWND, pUnkContext: ?*IUnknown, ppProviderInfo: ?*?*ISyncProviderInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderConfigUI.VTable, self.vtable).CreateAndRegisterNewSyncProvider(@ptrCast(*const ISyncProviderConfigUI, self), hwndParent, pUnkContext, ppProviderInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncProviderConfigUI_ModifySyncProvider(self: *const T, hwndParent: ?HWND, pUnkContext: ?*IUnknown, pProviderInfo: ?*ISyncProviderInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncProviderConfigUI.VTable, self.vtable).ModifySyncProvider(@ptrCast(*const ISyncProviderConfigUI, self), hwndParent, pUnkContext, pProviderInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IRegisteredSyncProvider_Value = Guid.initString("913bcf76-47c1-40b5-a896-5e8a9c414c14");
pub const IID_IRegisteredSyncProvider = &IID_IRegisteredSyncProvider_Value;
pub const IRegisteredSyncProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRegisteredSyncProvider,
                pguidInstanceId: ?*const Guid,
                pguidContentType: ?*const Guid,
                pContextPropertyStore: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRegisteredSyncProvider,
                pguidInstanceId: ?*const Guid,
                pguidContentType: ?*const Guid,
                pContextPropertyStore: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstanceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRegisteredSyncProvider,
                pguidInstanceId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRegisteredSyncProvider,
                pguidInstanceId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRegisteredSyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRegisteredSyncProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredSyncProvider_Init(self: *const T, pguidInstanceId: ?*const Guid, pguidContentType: ?*const Guid, pContextPropertyStore: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredSyncProvider.VTable, self.vtable).Init(@ptrCast(*const IRegisteredSyncProvider, self), pguidInstanceId, pguidContentType, pContextPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredSyncProvider_GetInstanceId(self: *const T, pguidInstanceId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredSyncProvider.VTable, self.vtable).GetInstanceId(@ptrCast(*const IRegisteredSyncProvider, self), pguidInstanceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredSyncProvider_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredSyncProvider.VTable, self.vtable).Reset(@ptrCast(*const IRegisteredSyncProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNC_REGISTRATION_EVENT = enum(i32) {
    PROVIDER_ADDED = 0,
    PROVIDER_REMOVED = 1,
    PROVIDER_UPDATED = 2,
    PROVIDER_STATE_CHANGED = 3,
    CONFIGUI_ADDED = 4,
    CONFIGUI_REMOVED = 5,
    CONFIGUI_UPDATED = 6,
};
pub const SRE_PROVIDER_ADDED = SYNC_REGISTRATION_EVENT.PROVIDER_ADDED;
pub const SRE_PROVIDER_REMOVED = SYNC_REGISTRATION_EVENT.PROVIDER_REMOVED;
pub const SRE_PROVIDER_UPDATED = SYNC_REGISTRATION_EVENT.PROVIDER_UPDATED;
pub const SRE_PROVIDER_STATE_CHANGED = SYNC_REGISTRATION_EVENT.PROVIDER_STATE_CHANGED;
pub const SRE_CONFIGUI_ADDED = SYNC_REGISTRATION_EVENT.CONFIGUI_ADDED;
pub const SRE_CONFIGUI_REMOVED = SYNC_REGISTRATION_EVENT.CONFIGUI_REMOVED;
pub const SRE_CONFIGUI_UPDATED = SYNC_REGISTRATION_EVENT.CONFIGUI_UPDATED;

// TODO: this type is limited to platform 'windows6.1'
const IID_ISyncRegistrationChange_Value = Guid.initString("eea0d9ae-6b29-43b4-9e70-e3ae33bb2c3b");
pub const IID_ISyncRegistrationChange = &IID_ISyncRegistrationChange_Value;
pub const ISyncRegistrationChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncRegistrationChange,
                psreEvent: ?*SYNC_REGISTRATION_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncRegistrationChange,
                psreEvent: ?*SYNC_REGISTRATION_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstanceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISyncRegistrationChange,
                pguidInstanceId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISyncRegistrationChange,
                pguidInstanceId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncRegistrationChange_GetEvent(self: *const T, psreEvent: ?*SYNC_REGISTRATION_EVENT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncRegistrationChange.VTable, self.vtable).GetEvent(@ptrCast(*const ISyncRegistrationChange, self), psreEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncRegistrationChange_GetInstanceId(self: *const T, pguidInstanceId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncRegistrationChange.VTable, self.vtable).GetInstanceId(@ptrCast(*const ISyncRegistrationChange, self), pguidInstanceId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IPropertyStore = @import("../ui/shell/properties_system.zig").IPropertyStore;
const IUnknown = @import("../system/com.zig").IUnknown;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
