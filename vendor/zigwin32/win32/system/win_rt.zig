//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (4)
//--------------------------------------------------------------------------------
pub const MAX_ERROR_MESSAGE_CHARS = @as(u32, 512);
pub const CastingSourceInfo_Property_PreferredSourceUriScheme = "PreferredSourceUriScheme";
pub const CastingSourceInfo_Property_CastingTypes = "CastingTypes";
pub const CastingSourceInfo_Property_ProtectedMedia = "ProtectedMedia";

//--------------------------------------------------------------------------------
// Section: Types (59)
//--------------------------------------------------------------------------------
pub const EventRegistrationToken = extern struct {
    value: i64,
};

// TODO: this type has a FreeFunc 'WindowsDeleteString', what can Zig do with this information?
pub const HSTRING = *opaque{};

pub const HSTRING_BUFFER = *opaque{};

pub const ROPARAMIIDHANDLE = isize;

pub const APARTMENT_SHUTDOWN_REGISTRATION_COOKIE = isize;

pub const ACTIVATIONTYPE = enum(i32) {
    UNCATEGORIZED = 0,
    FROM_MONIKER = 1,
    FROM_DATA = 2,
    FROM_STORAGE = 4,
    FROM_STREAM = 8,
    FROM_FILE = 16,
};
pub const ACTIVATIONTYPE_UNCATEGORIZED = ACTIVATIONTYPE.UNCATEGORIZED;
pub const ACTIVATIONTYPE_FROM_MONIKER = ACTIVATIONTYPE.FROM_MONIKER;
pub const ACTIVATIONTYPE_FROM_DATA = ACTIVATIONTYPE.FROM_DATA;
pub const ACTIVATIONTYPE_FROM_STORAGE = ACTIVATIONTYPE.FROM_STORAGE;
pub const ACTIVATIONTYPE_FROM_STREAM = ACTIVATIONTYPE.FROM_STREAM;
pub const ACTIVATIONTYPE_FROM_FILE = ACTIVATIONTYPE.FROM_FILE;

// TODO: this type is limited to platform 'windows8.1'
const IID_IAgileReference_Value = Guid.initString("c03f6a43-65a4-9818-987e-e0b810d2a6f2");
pub const IID_IAgileReference = &IID_IAgileReference_Value;
pub const IAgileReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Resolve: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAgileReference,
                riid: ?*const Guid,
                ppvObjectReference: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAgileReference,
                riid: ?*const Guid,
                ppvObjectReference: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAgileReference_Resolve(self: *const T, riid: ?*const Guid, ppvObjectReference: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAgileReference.VTable, self.vtable).Resolve(@ptrCast(*const IAgileReference, self), riid, ppvObjectReference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IApartmentShutdown_Value = Guid.initString("a2f05a09-27a2-42b5-bc0e-ac163ef49d9b");
pub const IID_IApartmentShutdown = &IID_IApartmentShutdown_Value;
pub const IApartmentShutdown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUninitialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApartmentShutdown,
                ui64ApartmentIdentifier: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IApartmentShutdown,
                ui64ApartmentIdentifier: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApartmentShutdown_OnUninitialize(self: *const T, ui64ApartmentIdentifier: u64) callconv(.Inline) void {
            return @ptrCast(*const IApartmentShutdown.VTable, self.vtable).OnUninitialize(@ptrCast(*const IApartmentShutdown, self), ui64ApartmentIdentifier);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ServerInformation = extern struct {
    dwServerPid: u32,
    dwServerTid: u32,
    ui64ServerAddress: u64,
};

pub const AgileReferenceOptions = enum(i32) {
    FAULT = 0,
    LAYEDMARSHAL = 1,
};
pub const AGILEREFERENCE_DEFAULT = AgileReferenceOptions.FAULT;
pub const AGILEREFERENCE_DELAYEDMARSHAL = AgileReferenceOptions.LAYEDMARSHAL;

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialInteractionManagerInterop_Value = Guid.initString("5c4ee536-6a98-4b86-a170-587013d6fd4b");
pub const IID_ISpatialInteractionManagerInterop = &IID_ISpatialInteractionManagerInterop_Value;
pub const ISpatialInteractionManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpatialInteractionManagerInterop,
                window: ?HWND,
                riid: ?*const Guid,
                spatialInteractionManager: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpatialInteractionManagerInterop,
                window: ?HWND,
                riid: ?*const Guid,
                spatialInteractionManager: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialInteractionManagerInterop_GetForWindow(self: *const T, window: ?HWND, riid: ?*const Guid, spatialInteractionManager: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialInteractionManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const ISpatialInteractionManagerInterop, self), window, riid, spatialInteractionManager);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IHolographicSpaceInterop_Value = Guid.initString("5c4ee536-6a98-4b86-a170-587013d6fd4b");
pub const IID_IHolographicSpaceInterop = &IID_IHolographicSpaceInterop_Value;
pub const IHolographicSpaceInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        CreateForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHolographicSpaceInterop,
                window: ?HWND,
                riid: ?*const Guid,
                holographicSpace: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHolographicSpaceInterop,
                window: ?HWND,
                riid: ?*const Guid,
                holographicSpace: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHolographicSpaceInterop_CreateForWindow(self: *const T, window: ?HWND, riid: ?*const Guid, holographicSpace: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHolographicSpaceInterop.VTable, self.vtable).CreateForWindow(@ptrCast(*const IHolographicSpaceInterop, self), window, riid, holographicSpace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HSTRING_HEADER = extern struct {
    Reserved: extern union {
        Reserved1: ?*anyopaque,
        Reserved2: [24]CHAR,
    },
};

pub const TrustLevel = enum(i32) {
    BaseTrust = 0,
    PartialTrust = 1,
    FullTrust = 2,
};
pub const BaseTrust = TrustLevel.BaseTrust;
pub const PartialTrust = TrustLevel.PartialTrust;
pub const FullTrust = TrustLevel.FullTrust;

// TODO: this type is limited to platform 'windows8.0'
const IID_IInspectable_Value = Guid.initString("af86e2e0-b12d-4c6a-9c5a-d7aa65101e90");
pub const IID_IInspectable = &IID_IInspectable_Value;
pub const IInspectable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIids: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInspectable,
                iidCount: ?*u32,
                iids: ?[*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInspectable,
                iidCount: ?*u32,
                iids: ?[*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRuntimeClassName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInspectable,
                className: ?*?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInspectable,
                className: ?*?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTrustLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInspectable,
                trustLevel: ?*TrustLevel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInspectable,
                trustLevel: ?*TrustLevel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInspectable_GetIids(self: *const T, iidCount: ?*u32, iids: ?[*]?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInspectable.VTable, self.vtable).GetIids(@ptrCast(*const IInspectable, self), iidCount, iids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInspectable_GetRuntimeClassName(self: *const T, className: ?*?HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInspectable.VTable, self.vtable).GetRuntimeClassName(@ptrCast(*const IInspectable, self), className);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInspectable_GetTrustLevel(self: *const T, trustLevel: ?*TrustLevel) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInspectable.VTable, self.vtable).GetTrustLevel(@ptrCast(*const IInspectable, self), trustLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PINSPECT_HSTRING_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        context: ?*anyopaque,
        readAddress: usize,
        length: u32,
        buffer: [*:0]u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        context: ?*anyopaque,
        readAddress: usize,
        length: u32,
        buffer: [*:0]u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PINSPECT_HSTRING_CALLBACK2 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        context: ?*anyopaque,
        readAddress: u64,
        length: u32,
        buffer: [*:0]u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        context: ?*anyopaque,
        readAddress: u64,
        length: u32,
        buffer: [*:0]u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DISPATCHERQUEUE_THREAD_APARTMENTTYPE = enum(i32) {
    NONE = 0,
    ASTA = 1,
    STA = 2,
};
pub const DQTAT_COM_NONE = DISPATCHERQUEUE_THREAD_APARTMENTTYPE.NONE;
pub const DQTAT_COM_ASTA = DISPATCHERQUEUE_THREAD_APARTMENTTYPE.ASTA;
pub const DQTAT_COM_STA = DISPATCHERQUEUE_THREAD_APARTMENTTYPE.STA;

pub const DISPATCHERQUEUE_THREAD_TYPE = enum(i32) {
    DEDICATED = 1,
    CURRENT = 2,
};
pub const DQTYPE_THREAD_DEDICATED = DISPATCHERQUEUE_THREAD_TYPE.DEDICATED;
pub const DQTYPE_THREAD_CURRENT = DISPATCHERQUEUE_THREAD_TYPE.CURRENT;

pub const DispatcherQueueOptions = extern struct {
    dwSize: u32,
    threadType: DISPATCHERQUEUE_THREAD_TYPE,
    apartmentType: DISPATCHERQUEUE_THREAD_APARTMENTTYPE,
};

const IID_IAccountsSettingsPaneInterop_Value = Guid.initString("d3ee12ad-3865-4362-9746-b75a682df0e6");
pub const IID_IAccountsSettingsPaneInterop = &IID_IAccountsSettingsPaneInterop_Value;
pub const IAccountsSettingsPaneInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccountsSettingsPaneInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                accountsSettingsPane: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccountsSettingsPaneInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                accountsSettingsPane: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowManageAccountsForWindowAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccountsSettingsPaneInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                asyncAction: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccountsSettingsPaneInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                asyncAction: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowAddAccountForWindowAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccountsSettingsPaneInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                asyncAction: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccountsSettingsPaneInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                asyncAction: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccountsSettingsPaneInterop_GetForWindow(self: *const T, appWindow: ?HWND, riid: ?*const Guid, accountsSettingsPane: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccountsSettingsPaneInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IAccountsSettingsPaneInterop, self), appWindow, riid, accountsSettingsPane);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccountsSettingsPaneInterop_ShowManageAccountsForWindowAsync(self: *const T, appWindow: ?HWND, riid: ?*const Guid, asyncAction: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccountsSettingsPaneInterop.VTable, self.vtable).ShowManageAccountsForWindowAsync(@ptrCast(*const IAccountsSettingsPaneInterop, self), appWindow, riid, asyncAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccountsSettingsPaneInterop_ShowAddAccountForWindowAsync(self: *const T, appWindow: ?HWND, riid: ?*const Guid, asyncAction: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccountsSettingsPaneInterop.VTable, self.vtable).ShowAddAccountForWindowAsync(@ptrCast(*const IAccountsSettingsPaneInterop, self), appWindow, riid, asyncAction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppServiceConnectionExtendedExecution_Value = Guid.initString("65219584-f9cb-4ae3-81f9-a28a6ca450d9");
pub const IID_IAppServiceConnectionExtendedExecution = &IID_IAppServiceConnectionExtendedExecution_Value;
pub const IAppServiceConnectionExtendedExecution = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenForExtendedExecutionAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAppServiceConnectionExtendedExecution,
                riid: ?*const Guid,
                operation: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAppServiceConnectionExtendedExecution,
                riid: ?*const Guid,
                operation: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppServiceConnectionExtendedExecution_OpenForExtendedExecutionAsync(self: *const T, riid: ?*const Guid, operation: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppServiceConnectionExtendedExecution.VTable, self.vtable).OpenForExtendedExecutionAsync(@ptrCast(*const IAppServiceConnectionExtendedExecution, self), riid, operation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorrelationVectorSource_Value = Guid.initString("152b8a3b-b9b9-4685-b56e-974847bc7545");
pub const IID_ICorrelationVectorSource = &IID_ICorrelationVectorSource_Value;
pub const ICorrelationVectorSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CorrelationVector: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICorrelationVectorSource,
                cv: ?*?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICorrelationVectorSource,
                cv: ?*?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorrelationVectorSource_get_CorrelationVector(self: *const T, cv: ?*?HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICorrelationVectorSource.VTable, self.vtable).get_CorrelationVector(@ptrCast(*const ICorrelationVectorSource, self), cv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CASTING_CONNECTION_ERROR_STATUS = enum(i32) {
    SUCCEEDED = 0,
    DEVICE_DID_NOT_RESPOND = 1,
    DEVICE_ERROR = 2,
    DEVICE_LOCKED = 3,
    PROTECTED_PLAYBACK_FAILED = 4,
    INVALID_CASTING_SOURCE = 5,
    UNKNOWN = 6,
};
pub const CASTING_CONNECTION_ERROR_STATUS_SUCCEEDED = CASTING_CONNECTION_ERROR_STATUS.SUCCEEDED;
pub const CASTING_CONNECTION_ERROR_STATUS_DEVICE_DID_NOT_RESPOND = CASTING_CONNECTION_ERROR_STATUS.DEVICE_DID_NOT_RESPOND;
pub const CASTING_CONNECTION_ERROR_STATUS_DEVICE_ERROR = CASTING_CONNECTION_ERROR_STATUS.DEVICE_ERROR;
pub const CASTING_CONNECTION_ERROR_STATUS_DEVICE_LOCKED = CASTING_CONNECTION_ERROR_STATUS.DEVICE_LOCKED;
pub const CASTING_CONNECTION_ERROR_STATUS_PROTECTED_PLAYBACK_FAILED = CASTING_CONNECTION_ERROR_STATUS.PROTECTED_PLAYBACK_FAILED;
pub const CASTING_CONNECTION_ERROR_STATUS_INVALID_CASTING_SOURCE = CASTING_CONNECTION_ERROR_STATUS.INVALID_CASTING_SOURCE;
pub const CASTING_CONNECTION_ERROR_STATUS_UNKNOWN = CASTING_CONNECTION_ERROR_STATUS.UNKNOWN;

pub const CASTING_CONNECTION_STATE = enum(i32) {
    DISCONNECTED = 0,
    CONNECTED = 1,
    RENDERING = 2,
    DISCONNECTING = 3,
    CONNECTING = 4,
};
pub const CASTING_CONNECTION_STATE_DISCONNECTED = CASTING_CONNECTION_STATE.DISCONNECTED;
pub const CASTING_CONNECTION_STATE_CONNECTED = CASTING_CONNECTION_STATE.CONNECTED;
pub const CASTING_CONNECTION_STATE_RENDERING = CASTING_CONNECTION_STATE.RENDERING;
pub const CASTING_CONNECTION_STATE_DISCONNECTING = CASTING_CONNECTION_STATE.DISCONNECTING;
pub const CASTING_CONNECTION_STATE_CONNECTING = CASTING_CONNECTION_STATE.CONNECTING;

const IID_ICastingEventHandler_Value = Guid.initString("c79a6cb7-bebd-47a6-a2ad-4d45ad79c7bc");
pub const IID_ICastingEventHandler = &IID_ICastingEventHandler_Value;
pub const ICastingEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStateChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICastingEventHandler,
                newState: CASTING_CONNECTION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICastingEventHandler,
                newState: CASTING_CONNECTION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICastingEventHandler,
                errorStatus: CASTING_CONNECTION_ERROR_STATUS,
                errorMessage: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICastingEventHandler,
                errorStatus: CASTING_CONNECTION_ERROR_STATUS,
                errorMessage: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingEventHandler_OnStateChanged(self: *const T, newState: CASTING_CONNECTION_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingEventHandler.VTable, self.vtable).OnStateChanged(@ptrCast(*const ICastingEventHandler, self), newState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingEventHandler_OnError(self: *const T, errorStatus: CASTING_CONNECTION_ERROR_STATUS, errorMessage: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingEventHandler.VTable, self.vtable).OnError(@ptrCast(*const ICastingEventHandler, self), errorStatus, errorMessage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICastingController_Value = Guid.initString("f0a56423-a664-4fbd-8b43-409a45e8d9a1");
pub const IID_ICastingController = &IID_ICastingController_Value;
pub const ICastingController = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICastingController,
                castingEngine: ?*IUnknown,
                castingSource: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICastingController,
                castingEngine: ?*IUnknown,
                castingSource: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICastingController,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICastingController,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICastingController,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICastingController,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICastingController,
                eventHandler: ?*ICastingEventHandler,
                cookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICastingController,
                eventHandler: ?*ICastingEventHandler,
                cookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICastingController,
                cookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICastingController,
                cookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_Initialize(self: *const T, castingEngine: ?*IUnknown, castingSource: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).Initialize(@ptrCast(*const ICastingController, self), castingEngine, castingSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_Connect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).Connect(@ptrCast(*const ICastingController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).Disconnect(@ptrCast(*const ICastingController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_Advise(self: *const T, eventHandler: ?*ICastingEventHandler, cookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).Advise(@ptrCast(*const ICastingController, self), eventHandler, cookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_UnAdvise(self: *const T, cookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).UnAdvise(@ptrCast(*const ICastingController, self), cookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICastingSourceInfo_Value = Guid.initString("45101ab7-7c3a-4bce-9500-12c09024b298");
pub const IID_ICastingSourceInfo = &IID_ICastingSourceInfo_Value;
pub const ICastingSourceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetController: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICastingSourceInfo,
                controller: ?*?*ICastingController,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICastingSourceInfo,
                controller: ?*?*ICastingController,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICastingSourceInfo,
                props: ?*?*INamedPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICastingSourceInfo,
                props: ?*?*INamedPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingSourceInfo_GetController(self: *const T, controller: ?*?*ICastingController) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingSourceInfo.VTable, self.vtable).GetController(@ptrCast(*const ICastingSourceInfo, self), controller);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingSourceInfo_GetProperties(self: *const T, props: ?*?*INamedPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingSourceInfo.VTable, self.vtable).GetProperties(@ptrCast(*const ICastingSourceInfo, self), props);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDragDropManagerInterop_Value = Guid.initString("5ad8cba7-4c01-4dac-9074-827894292d63");
pub const IID_IDragDropManagerInterop = &IID_IDragDropManagerInterop_Value;
pub const IDragDropManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDragDropManagerInterop,
                hwnd: ?HWND,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDragDropManagerInterop,
                hwnd: ?HWND,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragDropManagerInterop_GetForWindow(self: *const T, hwnd: ?HWND, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragDropManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IDragDropManagerInterop, self), hwnd, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IInputPaneInterop_Value = Guid.initString("75cf2c57-9195-4931-8332-f0b409e916af");
pub const IID_IInputPaneInterop = &IID_IInputPaneInterop_Value;
pub const IInputPaneInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInputPaneInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                inputPane: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInputPaneInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                inputPane: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputPaneInterop_GetForWindow(self: *const T, appWindow: ?HWND, riid: ?*const Guid, inputPane: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputPaneInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IInputPaneInterop, self), appWindow, riid, inputPane);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IPlayToManagerInterop_Value = Guid.initString("24394699-1f2c-4eb3-8cd7-0ec1da42a540");
pub const IID_IPlayToManagerInterop = &IID_IPlayToManagerInterop_Value;
pub const IPlayToManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPlayToManagerInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                playToManager: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPlayToManagerInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                playToManager: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowPlayToUIForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPlayToManagerInterop,
                appWindow: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPlayToManagerInterop,
                appWindow: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPlayToManagerInterop_GetForWindow(self: *const T, appWindow: ?HWND, riid: ?*const Guid, playToManager: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPlayToManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IPlayToManagerInterop, self), appWindow, riid, playToManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPlayToManagerInterop_ShowPlayToUIForWindow(self: *const T, appWindow: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPlayToManagerInterop.VTable, self.vtable).ShowPlayToUIForWindow(@ptrCast(*const IPlayToManagerInterop, self), appWindow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorrelationVectorInformation_Value = Guid.initString("83c78b3c-d88b-4950-aa6e-22b8d22aabd3");
pub const IID_ICorrelationVectorInformation = &IID_ICorrelationVectorInformation_Value;
pub const ICorrelationVectorInformation = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastCorrelationVectorForThread: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICorrelationVectorInformation,
                cv: ?*?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICorrelationVectorInformation,
                cv: ?*?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextCorrelationVectorForThread: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICorrelationVectorInformation,
                cv: ?*?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICorrelationVectorInformation,
                cv: ?*?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NextCorrelationVectorForThread: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICorrelationVectorInformation,
                cv: ?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICorrelationVectorInformation,
                cv: ?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorrelationVectorInformation_get_LastCorrelationVectorForThread(self: *const T, cv: ?*?HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICorrelationVectorInformation.VTable, self.vtable).get_LastCorrelationVectorForThread(@ptrCast(*const ICorrelationVectorInformation, self), cv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorrelationVectorInformation_get_NextCorrelationVectorForThread(self: *const T, cv: ?*?HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICorrelationVectorInformation.VTable, self.vtable).get_NextCorrelationVectorForThread(@ptrCast(*const ICorrelationVectorInformation, self), cv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorrelationVectorInformation_put_NextCorrelationVectorForThread(self: *const T, cv: ?HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICorrelationVectorInformation.VTable, self.vtable).put_NextCorrelationVectorForThread(@ptrCast(*const ICorrelationVectorInformation, self), cv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIViewSettingsInterop_Value = Guid.initString("3694dbf9-8f68-44be-8ff5-195c98ede8a6");
pub const IID_IUIViewSettingsInterop = &IID_IUIViewSettingsInterop_Value;
pub const IUIViewSettingsInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIViewSettingsInterop,
                hwnd: ?HWND,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIViewSettingsInterop,
                hwnd: ?HWND,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIViewSettingsInterop_GetForWindow(self: *const T, hwnd: ?HWND, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIViewSettingsInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IUIViewSettingsInterop, self), hwnd, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUserActivityInterop_Value = Guid.initString("1ade314d-0e0a-40d9-824c-9a088a50059f");
pub const IID_IUserActivityInterop = &IID_IUserActivityInterop_Value;
pub const IUserActivityInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        CreateSessionForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUserActivityInterop,
                window: ?HWND,
                iid: ?*const Guid,
                value: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUserActivityInterop,
                window: ?HWND,
                iid: ?*const Guid,
                value: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserActivityInterop_CreateSessionForWindow(self: *const T, window: ?HWND, iid: ?*const Guid, value: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserActivityInterop.VTable, self.vtable).CreateSessionForWindow(@ptrCast(*const IUserActivityInterop, self), window, iid, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUserActivitySourceHostInterop_Value = Guid.initString("c15df8bc-8844-487a-b85b-7578e0f61419");
pub const IID_IUserActivitySourceHostInterop = &IID_IUserActivitySourceHostInterop_Value;
pub const IUserActivitySourceHostInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        SetActivitySourceHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUserActivitySourceHostInterop,
                activitySourceHost: ?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUserActivitySourceHostInterop,
                activitySourceHost: ?HSTRING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserActivitySourceHostInterop_SetActivitySourceHost(self: *const T, activitySourceHost: ?HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserActivitySourceHostInterop.VTable, self.vtable).SetActivitySourceHost(@ptrCast(*const IUserActivitySourceHostInterop, self), activitySourceHost);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUserActivityRequestManagerInterop_Value = Guid.initString("dd69f876-9699-4715-9095-e37ea30dfa1b");
pub const IID_IUserActivityRequestManagerInterop = &IID_IUserActivityRequestManagerInterop_Value;
pub const IUserActivityRequestManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUserActivityRequestManagerInterop,
                window: ?HWND,
                iid: ?*const Guid,
                value: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUserActivityRequestManagerInterop,
                window: ?HWND,
                iid: ?*const Guid,
                value: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserActivityRequestManagerInterop_GetForWindow(self: *const T, window: ?HWND, iid: ?*const Guid, value: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserActivityRequestManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IUserActivityRequestManagerInterop, self), window, iid, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUserConsentVerifierInterop_Value = Guid.initString("39e050c3-4e74-441a-8dc0-b81104df949c");
pub const IID_IUserConsentVerifierInterop = &IID_IUserConsentVerifierInterop_Value;
pub const IUserConsentVerifierInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        RequestVerificationForWindowAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUserConsentVerifierInterop,
                appWindow: ?HWND,
                message: ?HSTRING,
                riid: ?*const Guid,
                asyncOperation: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUserConsentVerifierInterop,
                appWindow: ?HWND,
                message: ?HSTRING,
                riid: ?*const Guid,
                asyncOperation: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserConsentVerifierInterop_RequestVerificationForWindowAsync(self: *const T, appWindow: ?HWND, message: ?HSTRING, riid: ?*const Guid, asyncOperation: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserConsentVerifierInterop.VTable, self.vtable).RequestVerificationForWindowAsync(@ptrCast(*const IUserConsentVerifierInterop, self), appWindow, message, riid, asyncOperation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebAuthenticationCoreManagerInterop_Value = Guid.initString("f4b8e804-811e-4436-b69c-44cb67b72084");
pub const IID_IWebAuthenticationCoreManagerInterop = &IID_IWebAuthenticationCoreManagerInterop_Value;
pub const IWebAuthenticationCoreManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        RequestTokenForWindowAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebAuthenticationCoreManagerInterop,
                appWindow: ?HWND,
                request: ?*IInspectable,
                riid: ?*const Guid,
                asyncInfo: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebAuthenticationCoreManagerInterop,
                appWindow: ?HWND,
                request: ?*IInspectable,
                riid: ?*const Guid,
                asyncInfo: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestTokenWithWebAccountForWindowAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebAuthenticationCoreManagerInterop,
                appWindow: ?HWND,
                request: ?*IInspectable,
                webAccount: ?*IInspectable,
                riid: ?*const Guid,
                asyncInfo: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebAuthenticationCoreManagerInterop,
                appWindow: ?HWND,
                request: ?*IInspectable,
                webAccount: ?*IInspectable,
                riid: ?*const Guid,
                asyncInfo: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebAuthenticationCoreManagerInterop_RequestTokenForWindowAsync(self: *const T, appWindow: ?HWND, request: ?*IInspectable, riid: ?*const Guid, asyncInfo: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebAuthenticationCoreManagerInterop.VTable, self.vtable).RequestTokenForWindowAsync(@ptrCast(*const IWebAuthenticationCoreManagerInterop, self), appWindow, request, riid, asyncInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebAuthenticationCoreManagerInterop_RequestTokenWithWebAccountForWindowAsync(self: *const T, appWindow: ?HWND, request: ?*IInspectable, webAccount: ?*IInspectable, riid: ?*const Guid, asyncInfo: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebAuthenticationCoreManagerInterop.VTable, self.vtable).RequestTokenWithWebAccountForWindowAsync(@ptrCast(*const IWebAuthenticationCoreManagerInterop, self), appWindow, request, webAccount, riid, asyncInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IRestrictedErrorInfo_Value = Guid.initString("82ba7092-4c88-427d-a7bc-16dd93feb67e");
pub const IID_IRestrictedErrorInfo = &IID_IRestrictedErrorInfo_Value;
pub const IRestrictedErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorDetails: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRestrictedErrorInfo,
                description: ?*?BSTR,
                @"error": ?*HRESULT,
                restrictedDescription: ?*?BSTR,
                capabilitySid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRestrictedErrorInfo,
                description: ?*?BSTR,
                @"error": ?*HRESULT,
                restrictedDescription: ?*?BSTR,
                capabilitySid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRestrictedErrorInfo,
                reference: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRestrictedErrorInfo,
                reference: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRestrictedErrorInfo_GetErrorDetails(self: *const T, description: ?*?BSTR, @"error": ?*HRESULT, restrictedDescription: ?*?BSTR, capabilitySid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRestrictedErrorInfo.VTable, self.vtable).GetErrorDetails(@ptrCast(*const IRestrictedErrorInfo, self), description, @"error", restrictedDescription, capabilitySid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRestrictedErrorInfo_GetReference(self: *const T, reference: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRestrictedErrorInfo.VTable, self.vtable).GetReference(@ptrCast(*const IRestrictedErrorInfo, self), reference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ILanguageExceptionErrorInfo_Value = Guid.initString("04a2dbf3-df83-116c-0946-0812abf6e07d");
pub const IID_ILanguageExceptionErrorInfo = &IID_ILanguageExceptionErrorInfo_Value;
pub const ILanguageExceptionErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLanguageException: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILanguageExceptionErrorInfo,
                languageException: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILanguageExceptionErrorInfo,
                languageException: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionErrorInfo_GetLanguageException(self: *const T, languageException: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionErrorInfo.VTable, self.vtable).GetLanguageException(@ptrCast(*const ILanguageExceptionErrorInfo, self), languageException);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ILanguageExceptionTransform_Value = Guid.initString("feb5a271-a6cd-45ce-880a-696706badc65");
pub const IID_ILanguageExceptionTransform = &IID_ILanguageExceptionTransform_Value;
pub const ILanguageExceptionTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTransformedRestrictedErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILanguageExceptionTransform,
                restrictedErrorInfo: ?*?*IRestrictedErrorInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILanguageExceptionTransform,
                restrictedErrorInfo: ?*?*IRestrictedErrorInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionTransform_GetTransformedRestrictedErrorInfo(self: *const T, restrictedErrorInfo: ?*?*IRestrictedErrorInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionTransform.VTable, self.vtable).GetTransformedRestrictedErrorInfo(@ptrCast(*const ILanguageExceptionTransform, self), restrictedErrorInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ILanguageExceptionStackBackTrace_Value = Guid.initString("cbe53fb5-f967-4258-8d34-42f5e25833de");
pub const IID_ILanguageExceptionStackBackTrace = &IID_ILanguageExceptionStackBackTrace_Value;
pub const ILanguageExceptionStackBackTrace = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStackBackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILanguageExceptionStackBackTrace,
                maxFramesToCapture: u32,
                stackBackTrace: ?*usize,
                framesCaptured: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILanguageExceptionStackBackTrace,
                maxFramesToCapture: u32,
                stackBackTrace: ?*usize,
                framesCaptured: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionStackBackTrace_GetStackBackTrace(self: *const T, maxFramesToCapture: u32, stackBackTrace: ?*usize, framesCaptured: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionStackBackTrace.VTable, self.vtable).GetStackBackTrace(@ptrCast(*const ILanguageExceptionStackBackTrace, self), maxFramesToCapture, stackBackTrace, framesCaptured);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ILanguageExceptionErrorInfo2_Value = Guid.initString("5746e5c4-5b97-424c-b620-2822915734dd");
pub const IID_ILanguageExceptionErrorInfo2 = &IID_ILanguageExceptionErrorInfo2_Value;
pub const ILanguageExceptionErrorInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ILanguageExceptionErrorInfo.VTable,
        GetPreviousLanguageExceptionErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILanguageExceptionErrorInfo2,
                previousLanguageExceptionErrorInfo: ?*?*ILanguageExceptionErrorInfo2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILanguageExceptionErrorInfo2,
                previousLanguageExceptionErrorInfo: ?*?*ILanguageExceptionErrorInfo2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CapturePropagationContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILanguageExceptionErrorInfo2,
                languageException: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILanguageExceptionErrorInfo2,
                languageException: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropagationContextHead: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILanguageExceptionErrorInfo2,
                propagatedLanguageExceptionErrorInfoHead: ?*?*ILanguageExceptionErrorInfo2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILanguageExceptionErrorInfo2,
                propagatedLanguageExceptionErrorInfoHead: ?*?*ILanguageExceptionErrorInfo2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ILanguageExceptionErrorInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionErrorInfo2_GetPreviousLanguageExceptionErrorInfo(self: *const T, previousLanguageExceptionErrorInfo: ?*?*ILanguageExceptionErrorInfo2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionErrorInfo2.VTable, self.vtable).GetPreviousLanguageExceptionErrorInfo(@ptrCast(*const ILanguageExceptionErrorInfo2, self), previousLanguageExceptionErrorInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionErrorInfo2_CapturePropagationContext(self: *const T, languageException: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionErrorInfo2.VTable, self.vtable).CapturePropagationContext(@ptrCast(*const ILanguageExceptionErrorInfo2, self), languageException);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionErrorInfo2_GetPropagationContextHead(self: *const T, propagatedLanguageExceptionErrorInfoHead: ?*?*ILanguageExceptionErrorInfo2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionErrorInfo2.VTable, self.vtable).GetPropagationContextHead(@ptrCast(*const ILanguageExceptionErrorInfo2, self), propagatedLanguageExceptionErrorInfoHead);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IActivationFactory_Value = Guid.initString("00000035-0000-0000-c000-000000000046");
pub const IID_IActivationFactory = &IID_IActivationFactory_Value;
pub const IActivationFactory = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        ActivateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActivationFactory,
                instance: ?*?*IInspectable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActivationFactory,
                instance: ?*?*IInspectable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActivationFactory_ActivateInstance(self: *const T, instance: ?*?*IInspectable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActivationFactory.VTable, self.vtable).ActivateInstance(@ptrCast(*const IActivationFactory, self), instance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RO_INIT_TYPE = enum(i32) {
    SINGLETHREADED = 0,
    MULTITHREADED = 1,
};
pub const RO_INIT_SINGLETHREADED = RO_INIT_TYPE.SINGLETHREADED;
pub const RO_INIT_MULTITHREADED = RO_INIT_TYPE.MULTITHREADED;

pub const _RO_REGISTRATION_COOKIE = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IBufferByteAccess_Value = Guid.initString("905a0fef-bc53-11df-8c49-001e4fc686da");
pub const IID_IBufferByteAccess = &IID_IBufferByteAccess_Value;
pub const IBufferByteAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Buffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBufferByteAccess,
                value: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBufferByteAccess,
                value: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBufferByteAccess_Buffer(self: *const T, value: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBufferByteAccess.VTable, self.vtable).Buffer(@ptrCast(*const IBufferByteAccess, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RO_ERROR_REPORTING_FLAGS = enum(u32) {
    NONE = 0,
    SUPPRESSEXCEPTIONS = 1,
    FORCEEXCEPTIONS = 2,
    USESETERRORINFO = 4,
    SUPPRESSSETERRORINFO = 8,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        SUPPRESSEXCEPTIONS: u1 = 0,
        FORCEEXCEPTIONS: u1 = 0,
        USESETERRORINFO: u1 = 0,
        SUPPRESSSETERRORINFO: u1 = 0,
    }) RO_ERROR_REPORTING_FLAGS {
        return @intToEnum(RO_ERROR_REPORTING_FLAGS,
              (if (o.NONE == 1) @enumToInt(RO_ERROR_REPORTING_FLAGS.NONE) else 0)
            | (if (o.SUPPRESSEXCEPTIONS == 1) @enumToInt(RO_ERROR_REPORTING_FLAGS.SUPPRESSEXCEPTIONS) else 0)
            | (if (o.FORCEEXCEPTIONS == 1) @enumToInt(RO_ERROR_REPORTING_FLAGS.FORCEEXCEPTIONS) else 0)
            | (if (o.USESETERRORINFO == 1) @enumToInt(RO_ERROR_REPORTING_FLAGS.USESETERRORINFO) else 0)
            | (if (o.SUPPRESSSETERRORINFO == 1) @enumToInt(RO_ERROR_REPORTING_FLAGS.SUPPRESSSETERRORINFO) else 0)
        );
    }
};
pub const RO_ERROR_REPORTING_NONE = RO_ERROR_REPORTING_FLAGS.NONE;
pub const RO_ERROR_REPORTING_SUPPRESSEXCEPTIONS = RO_ERROR_REPORTING_FLAGS.SUPPRESSEXCEPTIONS;
pub const RO_ERROR_REPORTING_FORCEEXCEPTIONS = RO_ERROR_REPORTING_FLAGS.FORCEEXCEPTIONS;
pub const RO_ERROR_REPORTING_USESETERRORINFO = RO_ERROR_REPORTING_FLAGS.USESETERRORINFO;
pub const RO_ERROR_REPORTING_SUPPRESSSETERRORINFO = RO_ERROR_REPORTING_FLAGS.SUPPRESSSETERRORINFO;

pub const PINSPECT_MEMORY_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        context: ?*anyopaque,
        readAddress: usize,
        length: u32,
        buffer: [*:0]u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        context: ?*anyopaque,
        readAddress: usize,
        length: u32,
        buffer: [*:0]u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const IRoSimpleMetaDataBuilder = extern struct {
    pub const VTable = extern struct {
        SetWinRtInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                iid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                iid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDelegate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                iid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                iid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterfaceGroupSimpleDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                defaultInterfaceName: ?[*:0]const u16,
                defaultInterfaceIID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                defaultInterfaceName: ?[*:0]const u16,
                defaultInterfaceIID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterfaceGroupParameterizedDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                elementCount: u32,
                defaultInterfaceNameElements: [*]?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                elementCount: u32,
                defaultInterfaceNameElements: [*]?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRuntimeClassSimpleDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                defaultInterfaceName: ?[*:0]const u16,
                defaultInterfaceIID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                defaultInterfaceName: ?[*:0]const u16,
                defaultInterfaceIID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRuntimeClassParameterizedDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                elementCount: u32,
                defaultInterfaceNameElements: [*]const ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                elementCount: u32,
                defaultInterfaceNameElements: [*]const ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStruct: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                numFields: u32,
                fieldTypeNames: [*]const ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                numFields: u32,
                fieldTypeNames: [*]const ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                baseType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]const u16,
                baseType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParameterizedInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                piid: Guid,
                numArgs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                piid: Guid,
                numArgs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParameterizedDelegate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                piid: Guid,
                numArgs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                piid: Guid,
                numArgs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetWinRtInterface(self: *const T, iid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetWinRtInterface(@ptrCast(*const IRoSimpleMetaDataBuilder, self), iid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetDelegate(self: *const T, iid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetDelegate(@ptrCast(*const IRoSimpleMetaDataBuilder, self), iid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetInterfaceGroupSimpleDefault(self: *const T, name: ?[*:0]const u16, defaultInterfaceName: ?[*:0]const u16, defaultInterfaceIID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetInterfaceGroupSimpleDefault(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, defaultInterfaceName, defaultInterfaceIID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetInterfaceGroupParameterizedDefault(self: *const T, name: ?[*:0]const u16, elementCount: u32, defaultInterfaceNameElements: [*]?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetInterfaceGroupParameterizedDefault(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, elementCount, defaultInterfaceNameElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetRuntimeClassSimpleDefault(self: *const T, name: ?[*:0]const u16, defaultInterfaceName: ?[*:0]const u16, defaultInterfaceIID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetRuntimeClassSimpleDefault(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, defaultInterfaceName, defaultInterfaceIID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetRuntimeClassParameterizedDefault(self: *const T, name: ?[*:0]const u16, elementCount: u32, defaultInterfaceNameElements: [*]const ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetRuntimeClassParameterizedDefault(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, elementCount, defaultInterfaceNameElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetStruct(self: *const T, name: ?[*:0]const u16, numFields: u32, fieldTypeNames: [*]const ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetStruct(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, numFields, fieldTypeNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetEnum(self: *const T, name: ?[*:0]const u16, baseType: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetEnum(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, baseType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetParameterizedInterface(self: *const T, piid: Guid, numArgs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetParameterizedInterface(@ptrCast(*const IRoSimpleMetaDataBuilder, self), piid, numArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetParameterizedDelegate(self: *const T, piid: Guid, numArgs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetParameterizedDelegate(@ptrCast(*const IRoSimpleMetaDataBuilder, self), piid, numArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IRoMetaDataLocator = extern struct {
    pub const VTable = extern struct {
        Locate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoMetaDataLocator,
                nameElement: ?[*:0]const u16,
                metaDataDestination: ?*IRoSimpleMetaDataBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoMetaDataLocator,
                nameElement: ?[*:0]const u16,
                metaDataDestination: ?*IRoSimpleMetaDataBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoMetaDataLocator_Locate(self: *const T, nameElement: ?[*:0]const u16, metaDataDestination: ?*IRoSimpleMetaDataBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoMetaDataLocator.VTable, self.vtable).Locate(@ptrCast(*const IRoMetaDataLocator, self), nameElement, metaDataDestination);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BSOS_OPTIONS = enum(i32) {
    DEFAULT = 0,
    PREFERDESTINATIONSTREAM = 1,
};
pub const BSOS_DEFAULT = BSOS_OPTIONS.DEFAULT;
pub const BSOS_PREFERDESTINATIONSTREAM = BSOS_OPTIONS.PREFERDESTINATIONSTREAM;

const IID_IMemoryBufferByteAccess_Value = Guid.initString("5b0d3235-4dba-4d44-865e-8f1d0e4fd04d");
pub const IID_IMemoryBufferByteAccess = &IID_IMemoryBufferByteAccess_Value;
pub const IMemoryBufferByteAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemoryBufferByteAccess,
                value: ?*?*u8,
                capacity: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemoryBufferByteAccess,
                value: ?*?*u8,
                capacity: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemoryBufferByteAccess_GetBuffer(self: *const T, value: ?*?*u8, capacity: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemoryBufferByteAccess.VTable, self.vtable).GetBuffer(@ptrCast(*const IMemoryBufferByteAccess, self), value, capacity);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWeakReference_Value = Guid.initString("00000037-0000-0000-c000-000000000046");
pub const IID_IWeakReference = &IID_IWeakReference_Value;
pub const IWeakReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Resolve: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWeakReference,
                riid: ?*const Guid,
                objectReference: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWeakReference,
                riid: ?*const Guid,
                objectReference: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeakReference_Resolve(self: *const T, riid: ?*const Guid, objectReference: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeakReference.VTable, self.vtable).Resolve(@ptrCast(*const IWeakReference, self), riid, objectReference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWeakReferenceSource_Value = Guid.initString("00000038-0000-0000-c000-000000000046");
pub const IID_IWeakReferenceSource = &IID_IWeakReferenceSource_Value;
pub const IWeakReferenceSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWeakReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWeakReferenceSource,
                weakReference: ?*?*IWeakReference,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWeakReferenceSource,
                weakReference: ?*?*IWeakReference,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeakReferenceSource_GetWeakReference(self: *const T, weakReference: ?*?*IWeakReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeakReferenceSource.VTable, self.vtable).GetWeakReference(@ptrCast(*const IWeakReferenceSource, self), weakReference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISystemMediaTransportControlsInterop_Value = Guid.initString("ddb0472d-c911-4a1f-86d9-dc3d71a95f5a");
pub const IID_ISystemMediaTransportControlsInterop = &IID_ISystemMediaTransportControlsInterop_Value;
pub const ISystemMediaTransportControlsInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISystemMediaTransportControlsInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                mediaTransportControl: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISystemMediaTransportControlsInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                mediaTransportControl: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISystemMediaTransportControlsInterop_GetForWindow(self: *const T, appWindow: ?HWND, riid: ?*const Guid, mediaTransportControl: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISystemMediaTransportControlsInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const ISystemMediaTransportControlsInterop, self), appWindow, riid, mediaTransportControl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShareWindowCommandEventArgsInterop_Value = Guid.initString("6571a721-643d-43d4-aca4-6b6f5f30f1ad");
pub const IID_IShareWindowCommandEventArgsInterop = &IID_IShareWindowCommandEventArgsInterop_Value;
pub const IShareWindowCommandEventArgsInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IShareWindowCommandEventArgsInterop,
                value: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IShareWindowCommandEventArgsInterop,
                value: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShareWindowCommandEventArgsInterop_GetWindow(self: *const T, value: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShareWindowCommandEventArgsInterop.VTable, self.vtable).GetWindow(@ptrCast(*const IShareWindowCommandEventArgsInterop, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShareWindowCommandSourceInterop_Value = Guid.initString("461a191f-8424-43a6-a0fa-3451a22f56ab");
pub const IID_IShareWindowCommandSourceInterop = &IID_IShareWindowCommandSourceInterop_Value;
pub const IShareWindowCommandSourceInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IShareWindowCommandSourceInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                shareWindowCommandSource: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IShareWindowCommandSourceInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                shareWindowCommandSource: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShareWindowCommandSourceInterop_GetForWindow(self: *const T, appWindow: ?HWND, riid: ?*const Guid, shareWindowCommandSource: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShareWindowCommandSourceInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IShareWindowCommandSourceInterop, self), appWindow, riid, shareWindowCommandSource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMessageDispatcher_Value = Guid.initString("f5f84c8f-cfd0-4cd6-b66b-c5d26ff1689d");
pub const IID_IMessageDispatcher = &IID_IMessageDispatcher_Value;
pub const IMessageDispatcher = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        PumpMessages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMessageDispatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMessageDispatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageDispatcher_PumpMessages(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageDispatcher.VTable, self.vtable).PumpMessages(@ptrCast(*const IMessageDispatcher, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (68)
//--------------------------------------------------------------------------------
pub extern "ole32" fn CoDecodeProxy(
    dwClientPid: u32,
    ui64ProxyAddress: u64,
    pServerInformation: ?*ServerInformation,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ole32" fn RoGetAgileReference(
    options: AgileReferenceOptions,
    riid: ?*const Guid,
    pUnk: ?*IUnknown,
    ppAgileReference: ?*?*IAgileReference,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserFree(
    param0: ?*u32,
    param1: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserFree64(
    param0: ?*u32,
    param1: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsCreateString(
    sourceString: ?[*:0]const u16,
    length: u32,
    string: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsCreateStringReference(
    sourceString: ?[*:0]const u16,
    length: u32,
    hstringHeader: ?*HSTRING_HEADER,
    string: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsDeleteString(
    string: ?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsDuplicateString(
    string: ?HSTRING,
    newString: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsGetStringLen(
    string: ?HSTRING,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsGetStringRawBuffer(
    string: ?HSTRING,
    length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsIsStringEmpty(
    string: ?HSTRING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsStringHasEmbeddedNull(
    string: ?HSTRING,
    hasEmbedNull: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsCompareStringOrdinal(
    string1: ?HSTRING,
    string2: ?HSTRING,
    result: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsSubstring(
    string: ?HSTRING,
    startIndex: u32,
    newString: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsSubstringWithSpecifiedLength(
    string: ?HSTRING,
    startIndex: u32,
    length: u32,
    newString: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsConcatString(
    string1: ?HSTRING,
    string2: ?HSTRING,
    newString: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsReplaceString(
    string: ?HSTRING,
    stringReplaced: ?HSTRING,
    stringReplaceWith: ?HSTRING,
    newString: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsTrimStringStart(
    string: ?HSTRING,
    trimString: ?HSTRING,
    newString: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsTrimStringEnd(
    string: ?HSTRING,
    trimString: ?HSTRING,
    newString: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsPreallocateStringBuffer(
    length: u32,
    charBuffer: ?*?*u16,
    bufferHandle: ?*?HSTRING_BUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsPromoteStringBuffer(
    bufferHandle: ?HSTRING_BUFFER,
    string: ?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsDeleteStringBuffer(
    bufferHandle: ?HSTRING_BUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsInspectString(
    targetHString: usize,
    machine: u16,
    callback: ?PINSPECT_HSTRING_CALLBACK,
    context: ?*anyopaque,
    length: ?*u32,
    targetStringAddress: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-1" fn WindowsInspectString2(
    targetHString: u64,
    machine: u16,
    callback: ?PINSPECT_HSTRING_CALLBACK2,
    context: ?*anyopaque,
    length: ?*u32,
    targetStringAddress: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "coremessaging" fn CreateDispatcherQueueController(
    options: DispatcherQueueOptions,
    dispatcherQueueController: ?**struct{comment: []const u8 = "MissingClrType DispatcherQueueController.Windows.System"},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoInitialize(
    initType: RO_INIT_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoUninitialize(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoActivateInstance(
    activatableClassId: ?HSTRING,
    instance: ?*?*IInspectable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoRegisterActivationFactories(
    activatableClassIds: [*]?HSTRING,
    activationFactoryCallbacks: [*]isize,
    count: u32,
    cookie: ?*isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoRevokeActivationFactories(
    cookie: isize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoGetActivationFactory(
    activatableClassId: ?HSTRING,
    iid: ?*const Guid,
    factory: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoRegisterForApartmentShutdown(
    callbackObject: ?*IApartmentShutdown,
    apartmentIdentifier: ?*u64,
    regCookie: ?*APARTMENT_SHUTDOWN_REGISTRATION_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoUnregisterForApartmentShutdown(
    regCookie: APARTMENT_SHUTDOWN_REGISTRATION_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoGetApartmentIdentifier(
    apartmentIdentifier: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-robuffer-l1-1-0" fn RoGetBufferMarshaler(
    bufferMarshaler: ?*?*IMarshal,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoGetErrorReportingFlags(
    pflags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoSetErrorReportingFlags(
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoResolveRestrictedErrorInfoReference(
    reference: ?[*:0]const u16,
    ppRestrictedErrorInfo: ?*?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn SetRestrictedErrorInfo(
    pRestrictedErrorInfo: ?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn GetRestrictedErrorInfo(
    ppRestrictedErrorInfo: ?*?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoOriginateErrorW(
    @"error": HRESULT,
    cchMax: u32,
    message: ?*[512]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoOriginateError(
    @"error": HRESULT,
    message: ?HSTRING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoTransformErrorW(
    oldError: HRESULT,
    newError: HRESULT,
    cchMax: u32,
    message: ?*[512]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoTransformError(
    oldError: HRESULT,
    newError: HRESULT,
    message: ?HSTRING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoCaptureErrorContext(
    hr: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoFailFastWithErrorContext(
    hrError: HRESULT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoOriginateLanguageException(
    @"error": HRESULT,
    message: ?HSTRING,
    languageException: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoClearError(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoReportUnhandledError(
    pRestrictedErrorInfo: ?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoInspectThreadErrorInfo(
    targetTebAddress: usize,
    machine: u16,
    readMemoryCallback: ?PINSPECT_MEMORY_CALLBACK,
    context: ?*anyopaque,
    targetErrorInfoAddress: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoInspectCapturedStackBackTrace(
    targetErrorInfoAddress: usize,
    machine: u16,
    readMemoryCallback: ?PINSPECT_MEMORY_CALLBACK,
    context: ?*anyopaque,
    frameCount: ?*u32,
    targetBackTraceAddress: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoGetMatchingRestrictedErrorInfo(
    hrIn: HRESULT,
    ppRestrictedErrorInfo: ?*?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoReportFailedDelegate(
    punkDelegate: ?*IUnknown,
    pRestrictedErrorInfo: ?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn IsErrorPropagationEnabled(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "rometadata" fn MetaDataGetDispenser(
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoGetParameterizedTypeInstanceIID(
    nameElementCount: u32,
    nameElements: [*]?PWSTR,
    metaDataLocator: ?*IRoMetaDataLocator,
    iid: ?*Guid,
    pExtra: ?*ROPARAMIIDHANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoFreeParameterizedTypeExtra(
    extra: ROPARAMIIDHANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoParameterizedTypeExtraGetTypeSignature(
    extra: ROPARAMIIDHANDLE,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-registration-l1-1-0" fn RoGetServerActivatableClasses(
    serverName: ?HSTRING,
    activatableClassIds: ?*?*?HSTRING,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-stream-winrt-l1-1-0" fn CreateRandomAccessStreamOnFile(
    filePath: ?[*:0]const u16,
    accessMode: u32,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-stream-winrt-l1-1-0" fn CreateRandomAccessStreamOverStream(
    stream: ?*IStream,
    options: BSOS_OPTIONS,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-stream-winrt-l1-1-0" fn CreateStreamOverRandomAccessStream(
    randomAccessStream: ?*IUnknown,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (12)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IMarshal = @import("../system/com/marshal.zig").IMarshal;
const INamedPropertyStore = @import("../ui/shell/properties_system.zig").INamedPropertyStore;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PINSPECT_HSTRING_CALLBACK")) { _ = PINSPECT_HSTRING_CALLBACK; }
    if (@hasDecl(@This(), "PINSPECT_HSTRING_CALLBACK2")) { _ = PINSPECT_HSTRING_CALLBACK2; }
    if (@hasDecl(@This(), "PINSPECT_MEMORY_CALLBACK")) { _ = PINSPECT_MEMORY_CALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (15)
//--------------------------------------------------------------------------------
pub const all_joyn = @import("win_rt/all_joyn.zig");
pub const composition = @import("win_rt/composition.zig");
pub const core_input_view = @import("win_rt/core_input_view.zig");
pub const direct3d11 = @import("win_rt/direct3d11.zig");
pub const display = @import("win_rt/display.zig");
pub const graphics = @import("win_rt/graphics.zig");
pub const holographic = @import("win_rt/holographic.zig");
pub const isolation = @import("win_rt/isolation.zig");
pub const media = @import("win_rt/media.zig");
pub const ml = @import("win_rt/ml.zig");
pub const pdf = @import("win_rt/pdf.zig");
pub const printing = @import("win_rt/printing.zig");
pub const shell = @import("win_rt/shell.zig");
pub const storage = @import("win_rt/storage.zig");
pub const xaml = @import("win_rt/xaml.zig");
