//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (252)
//--------------------------------------------------------------------------------
pub const RTCCS_FORCE_PROFILE = @as(u32, 1);
pub const RTCCS_FAIL_ON_REDIRECT = @as(u32, 2);
pub const RTCMT_AUDIO_SEND = @as(u32, 1);
pub const RTCMT_AUDIO_RECEIVE = @as(u32, 2);
pub const RTCMT_VIDEO_SEND = @as(u32, 4);
pub const RTCMT_VIDEO_RECEIVE = @as(u32, 8);
pub const RTCMT_T120_SENDRECV = @as(u32, 16);
pub const RTCSI_PC_TO_PC = @as(u32, 1);
pub const RTCSI_PC_TO_PHONE = @as(u32, 2);
pub const RTCSI_PHONE_TO_PHONE = @as(u32, 4);
pub const RTCSI_IM = @as(u32, 8);
pub const RTCSI_MULTIPARTY_IM = @as(u32, 16);
pub const RTCSI_APPLICATION = @as(u32, 32);
pub const RTCTR_UDP = @as(u32, 1);
pub const RTCTR_TCP = @as(u32, 2);
pub const RTCTR_TLS = @as(u32, 4);
pub const RTCAU_BASIC = @as(u32, 1);
pub const RTCAU_DIGEST = @as(u32, 2);
pub const RTCAU_NTLM = @as(u32, 4);
pub const RTCAU_KERBEROS = @as(u32, 8);
pub const RTCAU_USE_LOGON_CRED = @as(u32, 65536);
pub const RTCRF_REGISTER_INVITE_SESSIONS = @as(u32, 1);
pub const RTCRF_REGISTER_MESSAGE_SESSIONS = @as(u32, 2);
pub const RTCRF_REGISTER_PRESENCE = @as(u32, 4);
pub const RTCRF_REGISTER_NOTIFY = @as(u32, 8);
pub const RTCRF_REGISTER_ALL = @as(u32, 15);
pub const RTCRMF_BUDDY_ROAMING = @as(u32, 1);
pub const RTCRMF_WATCHER_ROAMING = @as(u32, 2);
pub const RTCRMF_PRESENCE_ROAMING = @as(u32, 4);
pub const RTCRMF_PROFILE_ROAMING = @as(u32, 8);
pub const RTCRMF_ALL_ROAMING = @as(u32, 15);
pub const RTCEF_CLIENT = @as(u32, 1);
pub const RTCEF_REGISTRATION_STATE_CHANGE = @as(u32, 2);
pub const RTCEF_SESSION_STATE_CHANGE = @as(u32, 4);
pub const RTCEF_SESSION_OPERATION_COMPLETE = @as(u32, 8);
pub const RTCEF_PARTICIPANT_STATE_CHANGE = @as(u32, 16);
pub const RTCEF_MEDIA = @as(u32, 32);
pub const RTCEF_INTENSITY = @as(u32, 64);
pub const RTCEF_MESSAGING = @as(u32, 128);
pub const RTCEF_BUDDY = @as(u32, 256);
pub const RTCEF_WATCHER = @as(u32, 512);
pub const RTCEF_PROFILE = @as(u32, 1024);
pub const RTCEF_USERSEARCH = @as(u32, 2048);
pub const RTCEF_INFO = @as(u32, 4096);
pub const RTCEF_GROUP = @as(u32, 8192);
pub const RTCEF_MEDIA_REQUEST = @as(u32, 16384);
pub const RTCEF_ROAMING = @as(u32, 65536);
pub const RTCEF_PRESENCE_PROPERTY = @as(u32, 131072);
pub const RTCEF_BUDDY2 = @as(u32, 262144);
pub const RTCEF_WATCHER2 = @as(u32, 524288);
pub const RTCEF_SESSION_REFER_STATUS = @as(u32, 1048576);
pub const RTCEF_SESSION_REFERRED = @as(u32, 2097152);
pub const RTCEF_REINVITE = @as(u32, 4194304);
pub const RTCEF_PRESENCE_DATA = @as(u32, 8388608);
pub const RTCEF_PRESENCE_STATUS = @as(u32, 16777216);
pub const RTCEF_ALL = @as(u32, 33554431);
pub const RTCIF_DISABLE_MEDIA = @as(u32, 1);
pub const RTCIF_DISABLE_UPNP = @as(u32, 2);
pub const RTCIF_ENABLE_SERVER_CLASS = @as(u32, 4);
pub const RTCIF_DISABLE_STRICT_DNS = @as(u32, 8);
pub const FACILITY_RTC_INTERFACE = @as(u32, 238);
pub const FACILITY_SIP_STATUS_CODE = @as(u32, 239);
pub const FACILITY_PINT_STATUS_CODE = @as(u32, 240);
pub const STATUS_SEVERITY_RTC_ERROR = @as(u32, 2);
pub const RTC_E_SIP_CODECS_DO_NOT_MATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886080));
pub const RTC_E_SIP_STREAM_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886079));
pub const RTC_E_SIP_STREAM_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886078));
pub const RTC_E_SIP_NO_STREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886077));
pub const RTC_E_SIP_PARSE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886076));
pub const RTC_E_SIP_HEADER_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886075));
pub const RTC_E_SDP_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886074));
pub const RTC_E_SDP_PARSE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886073));
pub const RTC_E_SDP_UPDATE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886072));
pub const RTC_E_SDP_MULTICAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886071));
pub const RTC_E_SDP_CONNECTION_ADDR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886070));
pub const RTC_E_SDP_NO_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886069));
pub const RTC_E_SIP_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886068));
pub const RTC_E_SDP_FAILED_TO_BUILD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886067));
pub const RTC_E_SIP_INVITE_TRANSACTION_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886066));
pub const RTC_E_SIP_AUTH_HEADER_SENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886065));
pub const RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886064));
pub const RTC_E_SIP_AUTH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886063));
pub const RTC_E_INVALID_SIP_URL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886062));
pub const RTC_E_DESTINATION_ADDRESS_LOCAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886061));
pub const RTC_E_INVALID_ADDRESS_LOCAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886060));
pub const RTC_E_DESTINATION_ADDRESS_MULTICAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886059));
pub const RTC_E_INVALID_PROXY_ADDRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886058));
pub const RTC_E_SIP_TRANSPORT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886057));
pub const RTC_E_SIP_NEED_MORE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886056));
pub const RTC_E_SIP_CALL_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886055));
pub const RTC_E_SIP_REQUEST_DESTINATION_ADDR_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886054));
pub const RTC_E_SIP_UDP_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886053));
pub const RTC_E_SIP_SSL_TUNNEL_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886052));
pub const RTC_E_SIP_SSL_NEGOTIATION_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886051));
pub const RTC_E_SIP_STACK_SHUTDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886050));
pub const RTC_E_MEDIA_CONTROLLER_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886049));
pub const RTC_E_MEDIA_NEED_TERMINAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886048));
pub const RTC_E_MEDIA_AUDIO_DEVICE_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886047));
pub const RTC_E_MEDIA_VIDEO_DEVICE_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886046));
pub const RTC_E_START_STREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886045));
pub const RTC_E_MEDIA_AEC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886044));
pub const RTC_E_CLIENT_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886043));
pub const RTC_E_CLIENT_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886042));
pub const RTC_E_CLIENT_ALREADY_SHUT_DOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886041));
pub const RTC_E_PRESENCE_NOT_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886040));
pub const RTC_E_INVALID_SESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886039));
pub const RTC_E_INVALID_SESSION_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886038));
pub const RTC_E_NO_PROFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886037));
pub const RTC_E_LOCAL_PHONE_NEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886036));
pub const RTC_E_NO_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886035));
pub const RTC_E_INVALID_PROFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886034));
pub const RTC_E_PROFILE_NO_PROVISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886033));
pub const RTC_E_PROFILE_NO_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886032));
pub const RTC_E_PROFILE_NO_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886031));
pub const RTC_E_PROFILE_NO_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886030));
pub const RTC_E_PROFILE_NO_USER_URI = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886029));
pub const RTC_E_PROFILE_NO_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886028));
pub const RTC_E_PROFILE_NO_SERVER_ADDRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886027));
pub const RTC_E_PROFILE_NO_SERVER_PROTOCOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886026));
pub const RTC_E_PROFILE_INVALID_SERVER_PROTOCOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886025));
pub const RTC_E_PROFILE_INVALID_SERVER_AUTHMETHOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886024));
pub const RTC_E_PROFILE_INVALID_SERVER_ROLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886023));
pub const RTC_E_PROFILE_MULTIPLE_REGISTRARS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886022));
pub const RTC_E_PROFILE_INVALID_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886021));
pub const RTC_E_PROFILE_INVALID_SESSION_PARTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886020));
pub const RTC_E_PROFILE_INVALID_SESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886019));
pub const RTC_E_OPERATION_WITH_TOO_MANY_PARTICIPANTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886018));
pub const RTC_E_BASIC_AUTH_SET_TLS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886017));
pub const RTC_E_SIP_HIGH_SECURITY_SET_TLS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886016));
pub const RTC_S_ROAMING_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 15597633));
pub const RTC_E_PROFILE_SERVER_UNAUTHORIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886014));
pub const RTC_E_DUPLICATE_REALM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886013));
pub const RTC_E_POLICY_NOT_ALLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886012));
pub const RTC_E_PORT_MAPPING_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886011));
pub const RTC_E_PORT_MAPPING_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886010));
pub const RTC_E_SECURITY_LEVEL_NOT_COMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886009));
pub const RTC_E_SECURITY_LEVEL_NOT_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886008));
pub const RTC_E_SECURITY_LEVEL_NOT_SUPPORTED_BY_PARTICIPANT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886007));
pub const RTC_E_DUPLICATE_BUDDY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886006));
pub const RTC_E_DUPLICATE_WATCHER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886005));
pub const RTC_E_MALFORMED_XML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886004));
pub const RTC_E_ROAMING_OPERATION_INTERRUPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886003));
pub const RTC_E_ROAMING_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886002));
pub const RTC_E_INVALID_BUDDY_LIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886001));
pub const RTC_E_INVALID_ACL_LIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131886000));
pub const RTC_E_NO_GROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885999));
pub const RTC_E_DUPLICATE_GROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885998));
pub const RTC_E_TOO_MANY_GROUPS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885997));
pub const RTC_E_NO_BUDDY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885996));
pub const RTC_E_NO_WATCHER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885995));
pub const RTC_E_NO_REALM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885994));
pub const RTC_E_NO_TRANSPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885993));
pub const RTC_E_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885992));
pub const RTC_E_INVALID_PREFERENCE_LIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885991));
pub const RTC_E_MAX_PENDING_OPERATIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885990));
pub const RTC_E_TOO_MANY_RETRIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885989));
pub const RTC_E_INVALID_PORTRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885988));
pub const RTC_E_SIP_CALL_CONNECTION_NOT_ESTABLISHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885987));
pub const RTC_E_SIP_ADDITIONAL_PARTY_IN_TWO_PARTY_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885986));
pub const RTC_E_SIP_PARTY_ALREADY_IN_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885985));
pub const RTC_E_SIP_OTHER_PARTY_JOIN_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885984));
pub const RTC_E_INVALID_OBJECT_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885983));
pub const RTC_E_PRESENCE_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885982));
pub const RTC_E_ROAMING_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885981));
pub const RTC_E_SIP_TLS_INCOMPATIBLE_ENCRYPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885980));
pub const RTC_E_SIP_INVALID_CERTIFICATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885979));
pub const RTC_E_SIP_DNS_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885978));
pub const RTC_E_SIP_TCP_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885977));
pub const RTC_E_TOO_SMALL_EXPIRES_VALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885976));
pub const RTC_E_SIP_TLS_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885975));
pub const RTC_E_NOT_PRESENCE_PROFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885974));
pub const RTC_E_SIP_INVITEE_PARTY_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885973));
pub const RTC_E_SIP_AUTH_TIME_SKEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885972));
pub const RTC_E_INVALID_REGISTRATION_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885971));
pub const RTC_E_MEDIA_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885970));
pub const RTC_E_MEDIA_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885969));
pub const RTC_E_REFER_NOT_ACCEPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885968));
pub const RTC_E_REFER_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885967));
pub const RTC_E_REFER_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885966));
pub const RTC_E_SIP_HOLD_OPERATION_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885965));
pub const RTC_E_SIP_UNHOLD_OPERATION_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885964));
pub const RTC_E_MEDIA_SESSION_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885963));
pub const RTC_E_MEDIA_SESSION_IN_HOLD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885962));
pub const RTC_E_ANOTHER_MEDIA_SESSION_ACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885961));
pub const RTC_E_MAX_REDIRECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885960));
pub const RTC_E_REDIRECT_PROCESSING_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885959));
pub const RTC_E_LISTENING_SOCKET_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885958));
pub const RTC_E_INVALID_LISTEN_SOCKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885957));
pub const RTC_E_PORT_MANAGER_ALREADY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885956));
pub const RTC_E_SECURITY_LEVEL_ALREADY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885955));
pub const RTC_E_UDP_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885954));
pub const RTC_E_SIP_REFER_OPERATION_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885953));
pub const RTC_E_PLATFORM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885952));
pub const RTC_E_SIP_PEER_PARTICIPANT_IN_MULTIPARTY_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885951));
pub const RTC_E_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885950));
pub const RTC_E_REGISTRATION_DEACTIVATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885949));
pub const RTC_E_REGISTRATION_REJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885948));
pub const RTC_E_REGISTRATION_UNREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131885947));
pub const RTC_E_STATUS_INFO_TRYING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 15663204));
pub const RTC_E_STATUS_INFO_RINGING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 15663284));
pub const RTC_E_STATUS_INFO_CALL_FORWARDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 15663285));
pub const RTC_E_STATUS_INFO_QUEUED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 15663286));
pub const RTC_E_STATUS_SESSION_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 15663287));
pub const RTC_E_STATUS_SUCCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 15663304));
pub const RTC_E_STATUS_REDIRECT_MULTIPLE_CHOICES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820244));
pub const RTC_E_STATUS_REDIRECT_MOVED_PERMANENTLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820243));
pub const RTC_E_STATUS_REDIRECT_MOVED_TEMPORARILY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820242));
pub const RTC_E_STATUS_REDIRECT_SEE_OTHER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820241));
pub const RTC_E_STATUS_REDIRECT_USE_PROXY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820239));
pub const RTC_E_STATUS_REDIRECT_ALTERNATIVE_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820164));
pub const RTC_E_STATUS_CLIENT_BAD_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820144));
pub const RTC_E_STATUS_CLIENT_UNAUTHORIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820143));
pub const RTC_E_STATUS_CLIENT_PAYMENT_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820142));
pub const RTC_E_STATUS_CLIENT_FORBIDDEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820141));
pub const RTC_E_STATUS_CLIENT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820140));
pub const RTC_E_STATUS_CLIENT_METHOD_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820139));
pub const RTC_E_STATUS_CLIENT_NOT_ACCEPTABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820138));
pub const RTC_E_STATUS_CLIENT_PROXY_AUTHENTICATION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820137));
pub const RTC_E_STATUS_CLIENT_REQUEST_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820136));
pub const RTC_E_STATUS_CLIENT_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820135));
pub const RTC_E_STATUS_CLIENT_GONE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820134));
pub const RTC_E_STATUS_CLIENT_LENGTH_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820133));
pub const RTC_E_STATUS_CLIENT_REQUEST_ENTITY_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820131));
pub const RTC_E_STATUS_CLIENT_REQUEST_URI_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820130));
pub const RTC_E_STATUS_CLIENT_UNSUPPORTED_MEDIA_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820129));
pub const RTC_E_STATUS_CLIENT_BAD_EXTENSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820124));
pub const RTC_E_STATUS_CLIENT_TEMPORARILY_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820064));
pub const RTC_E_STATUS_CLIENT_TRANSACTION_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820063));
pub const RTC_E_STATUS_CLIENT_LOOP_DETECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820062));
pub const RTC_E_STATUS_CLIENT_TOO_MANY_HOPS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820061));
pub const RTC_E_STATUS_CLIENT_ADDRESS_INCOMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820060));
pub const RTC_E_STATUS_CLIENT_AMBIGUOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820059));
pub const RTC_E_STATUS_CLIENT_BUSY_HERE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820058));
pub const RTC_E_STATUS_REQUEST_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820057));
pub const RTC_E_STATUS_NOT_ACCEPTABLE_HERE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820056));
pub const RTC_E_STATUS_SERVER_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820044));
pub const RTC_E_STATUS_SERVER_NOT_IMPLEMENTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820043));
pub const RTC_E_STATUS_SERVER_BAD_GATEWAY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820042));
pub const RTC_E_STATUS_SERVER_SERVICE_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820041));
pub const RTC_E_STATUS_SERVER_SERVER_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820040));
pub const RTC_E_STATUS_SERVER_VERSION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131820039));
pub const RTC_E_STATUS_GLOBAL_BUSY_EVERYWHERE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131819944));
pub const RTC_E_STATUS_GLOBAL_DECLINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131819941));
pub const RTC_E_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131819940));
pub const RTC_E_STATUS_GLOBAL_NOT_ACCEPTABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131819938));
pub const RTC_E_PINT_STATUS_REJECTED_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131755003));
pub const RTC_E_PINT_STATUS_REJECTED_NO_ANSWER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131755002));
pub const RTC_E_PINT_STATUS_REJECTED_ALL_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131755001));
pub const RTC_E_PINT_STATUS_REJECTED_PL_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131755000));
pub const RTC_E_PINT_STATUS_REJECTED_SW_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131754999));
pub const RTC_E_PINT_STATUS_REJECTED_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131754998));
pub const RTC_E_PINT_STATUS_REJECTED_BADNUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2131754997));

//--------------------------------------------------------------------------------
// Section: Types (107)
//--------------------------------------------------------------------------------
const CLSID_RTCClient_Value = Guid.initString("7a42ea29-a2b7-40c4-b091-f6f024aa89be");
pub const CLSID_RTCClient = &CLSID_RTCClient_Value;

pub const RTC_AUDIO_DEVICE = enum(i32) {
    SPEAKER = 0,
    MICROPHONE = 1,
};
pub const RTCAD_SPEAKER = RTC_AUDIO_DEVICE.SPEAKER;
pub const RTCAD_MICROPHONE = RTC_AUDIO_DEVICE.MICROPHONE;

pub const RTC_VIDEO_DEVICE = enum(i32) {
    RECEIVE = 0,
    PREVIEW = 1,
};
pub const RTCVD_RECEIVE = RTC_VIDEO_DEVICE.RECEIVE;
pub const RTCVD_PREVIEW = RTC_VIDEO_DEVICE.PREVIEW;

pub const RTC_EVENT = enum(i32) {
    CLIENT = 0,
    REGISTRATION_STATE_CHANGE = 1,
    SESSION_STATE_CHANGE = 2,
    SESSION_OPERATION_COMPLETE = 3,
    PARTICIPANT_STATE_CHANGE = 4,
    MEDIA = 5,
    INTENSITY = 6,
    MESSAGING = 7,
    BUDDY = 8,
    WATCHER = 9,
    PROFILE = 10,
    USERSEARCH = 11,
    INFO = 12,
    GROUP = 13,
    MEDIA_REQUEST = 14,
    ROAMING = 15,
    PRESENCE_PROPERTY = 16,
    PRESENCE_DATA = 17,
    PRESENCE_STATUS = 18,
    SESSION_REFER_STATUS = 19,
    SESSION_REFERRED = 20,
    REINVITE = 21,
};
pub const RTCE_CLIENT = RTC_EVENT.CLIENT;
pub const RTCE_REGISTRATION_STATE_CHANGE = RTC_EVENT.REGISTRATION_STATE_CHANGE;
pub const RTCE_SESSION_STATE_CHANGE = RTC_EVENT.SESSION_STATE_CHANGE;
pub const RTCE_SESSION_OPERATION_COMPLETE = RTC_EVENT.SESSION_OPERATION_COMPLETE;
pub const RTCE_PARTICIPANT_STATE_CHANGE = RTC_EVENT.PARTICIPANT_STATE_CHANGE;
pub const RTCE_MEDIA = RTC_EVENT.MEDIA;
pub const RTCE_INTENSITY = RTC_EVENT.INTENSITY;
pub const RTCE_MESSAGING = RTC_EVENT.MESSAGING;
pub const RTCE_BUDDY = RTC_EVENT.BUDDY;
pub const RTCE_WATCHER = RTC_EVENT.WATCHER;
pub const RTCE_PROFILE = RTC_EVENT.PROFILE;
pub const RTCE_USERSEARCH = RTC_EVENT.USERSEARCH;
pub const RTCE_INFO = RTC_EVENT.INFO;
pub const RTCE_GROUP = RTC_EVENT.GROUP;
pub const RTCE_MEDIA_REQUEST = RTC_EVENT.MEDIA_REQUEST;
pub const RTCE_ROAMING = RTC_EVENT.ROAMING;
pub const RTCE_PRESENCE_PROPERTY = RTC_EVENT.PRESENCE_PROPERTY;
pub const RTCE_PRESENCE_DATA = RTC_EVENT.PRESENCE_DATA;
pub const RTCE_PRESENCE_STATUS = RTC_EVENT.PRESENCE_STATUS;
pub const RTCE_SESSION_REFER_STATUS = RTC_EVENT.SESSION_REFER_STATUS;
pub const RTCE_SESSION_REFERRED = RTC_EVENT.SESSION_REFERRED;
pub const RTCE_REINVITE = RTC_EVENT.REINVITE;

pub const RTC_LISTEN_MODE = enum(i32) {
    NONE = 0,
    DYNAMIC = 1,
    BOTH = 2,
};
pub const RTCLM_NONE = RTC_LISTEN_MODE.NONE;
pub const RTCLM_DYNAMIC = RTC_LISTEN_MODE.DYNAMIC;
pub const RTCLM_BOTH = RTC_LISTEN_MODE.BOTH;

pub const RTC_CLIENT_EVENT_TYPE = enum(i32) {
    VOLUME_CHANGE = 0,
    DEVICE_CHANGE = 1,
    NETWORK_QUALITY_CHANGE = 2,
    ASYNC_CLEANUP_DONE = 3,
};
pub const RTCCET_VOLUME_CHANGE = RTC_CLIENT_EVENT_TYPE.VOLUME_CHANGE;
pub const RTCCET_DEVICE_CHANGE = RTC_CLIENT_EVENT_TYPE.DEVICE_CHANGE;
pub const RTCCET_NETWORK_QUALITY_CHANGE = RTC_CLIENT_EVENT_TYPE.NETWORK_QUALITY_CHANGE;
pub const RTCCET_ASYNC_CLEANUP_DONE = RTC_CLIENT_EVENT_TYPE.ASYNC_CLEANUP_DONE;

pub const RTC_BUDDY_EVENT_TYPE = enum(i32) {
    ADD = 0,
    REMOVE = 1,
    UPDATE = 2,
    STATE_CHANGE = 3,
    ROAMED = 4,
    SUBSCRIBED = 5,
};
pub const RTCBET_BUDDY_ADD = RTC_BUDDY_EVENT_TYPE.ADD;
pub const RTCBET_BUDDY_REMOVE = RTC_BUDDY_EVENT_TYPE.REMOVE;
pub const RTCBET_BUDDY_UPDATE = RTC_BUDDY_EVENT_TYPE.UPDATE;
pub const RTCBET_BUDDY_STATE_CHANGE = RTC_BUDDY_EVENT_TYPE.STATE_CHANGE;
pub const RTCBET_BUDDY_ROAMED = RTC_BUDDY_EVENT_TYPE.ROAMED;
pub const RTCBET_BUDDY_SUBSCRIBED = RTC_BUDDY_EVENT_TYPE.SUBSCRIBED;

pub const RTC_WATCHER_EVENT_TYPE = enum(i32) {
    ADD = 0,
    REMOVE = 1,
    UPDATE = 2,
    OFFERING = 3,
    ROAMED = 4,
};
pub const RTCWET_WATCHER_ADD = RTC_WATCHER_EVENT_TYPE.ADD;
pub const RTCWET_WATCHER_REMOVE = RTC_WATCHER_EVENT_TYPE.REMOVE;
pub const RTCWET_WATCHER_UPDATE = RTC_WATCHER_EVENT_TYPE.UPDATE;
pub const RTCWET_WATCHER_OFFERING = RTC_WATCHER_EVENT_TYPE.OFFERING;
pub const RTCWET_WATCHER_ROAMED = RTC_WATCHER_EVENT_TYPE.ROAMED;

pub const RTC_GROUP_EVENT_TYPE = enum(i32) {
    ADD = 0,
    REMOVE = 1,
    UPDATE = 2,
    BUDDY_ADD = 3,
    BUDDY_REMOVE = 4,
    ROAMED = 5,
};
pub const RTCGET_GROUP_ADD = RTC_GROUP_EVENT_TYPE.ADD;
pub const RTCGET_GROUP_REMOVE = RTC_GROUP_EVENT_TYPE.REMOVE;
pub const RTCGET_GROUP_UPDATE = RTC_GROUP_EVENT_TYPE.UPDATE;
pub const RTCGET_GROUP_BUDDY_ADD = RTC_GROUP_EVENT_TYPE.BUDDY_ADD;
pub const RTCGET_GROUP_BUDDY_REMOVE = RTC_GROUP_EVENT_TYPE.BUDDY_REMOVE;
pub const RTCGET_GROUP_ROAMED = RTC_GROUP_EVENT_TYPE.ROAMED;

pub const RTC_TERMINATE_REASON = enum(i32) {
    NORMAL = 0,
    DND = 1,
    BUSY = 2,
    REJECT = 3,
    TIMEOUT = 4,
    SHUTDOWN = 5,
    INSUFFICIENT_SECURITY_LEVEL = 6,
    NOT_SUPPORTED = 7,
};
pub const RTCTR_NORMAL = RTC_TERMINATE_REASON.NORMAL;
pub const RTCTR_DND = RTC_TERMINATE_REASON.DND;
pub const RTCTR_BUSY = RTC_TERMINATE_REASON.BUSY;
pub const RTCTR_REJECT = RTC_TERMINATE_REASON.REJECT;
pub const RTCTR_TIMEOUT = RTC_TERMINATE_REASON.TIMEOUT;
pub const RTCTR_SHUTDOWN = RTC_TERMINATE_REASON.SHUTDOWN;
pub const RTCTR_INSUFFICIENT_SECURITY_LEVEL = RTC_TERMINATE_REASON.INSUFFICIENT_SECURITY_LEVEL;
pub const RTCTR_NOT_SUPPORTED = RTC_TERMINATE_REASON.NOT_SUPPORTED;

pub const RTC_REGISTRATION_STATE = enum(i32) {
    NOT_REGISTERED = 0,
    REGISTERING = 1,
    REGISTERED = 2,
    REJECTED = 3,
    UNREGISTERING = 4,
    ERROR = 5,
    LOGGED_OFF = 6,
    LOCAL_PA_LOGGED_OFF = 7,
    REMOTE_PA_LOGGED_OFF = 8,
};
pub const RTCRS_NOT_REGISTERED = RTC_REGISTRATION_STATE.NOT_REGISTERED;
pub const RTCRS_REGISTERING = RTC_REGISTRATION_STATE.REGISTERING;
pub const RTCRS_REGISTERED = RTC_REGISTRATION_STATE.REGISTERED;
pub const RTCRS_REJECTED = RTC_REGISTRATION_STATE.REJECTED;
pub const RTCRS_UNREGISTERING = RTC_REGISTRATION_STATE.UNREGISTERING;
pub const RTCRS_ERROR = RTC_REGISTRATION_STATE.ERROR;
pub const RTCRS_LOGGED_OFF = RTC_REGISTRATION_STATE.LOGGED_OFF;
pub const RTCRS_LOCAL_PA_LOGGED_OFF = RTC_REGISTRATION_STATE.LOCAL_PA_LOGGED_OFF;
pub const RTCRS_REMOTE_PA_LOGGED_OFF = RTC_REGISTRATION_STATE.REMOTE_PA_LOGGED_OFF;

pub const RTC_SESSION_STATE = enum(i32) {
    IDLE = 0,
    INCOMING = 1,
    ANSWERING = 2,
    INPROGRESS = 3,
    CONNECTED = 4,
    DISCONNECTED = 5,
    HOLD = 6,
    REFER = 7,
};
pub const RTCSS_IDLE = RTC_SESSION_STATE.IDLE;
pub const RTCSS_INCOMING = RTC_SESSION_STATE.INCOMING;
pub const RTCSS_ANSWERING = RTC_SESSION_STATE.ANSWERING;
pub const RTCSS_INPROGRESS = RTC_SESSION_STATE.INPROGRESS;
pub const RTCSS_CONNECTED = RTC_SESSION_STATE.CONNECTED;
pub const RTCSS_DISCONNECTED = RTC_SESSION_STATE.DISCONNECTED;
pub const RTCSS_HOLD = RTC_SESSION_STATE.HOLD;
pub const RTCSS_REFER = RTC_SESSION_STATE.REFER;

pub const RTC_PARTICIPANT_STATE = enum(i32) {
    IDLE = 0,
    PENDING = 1,
    INCOMING = 2,
    ANSWERING = 3,
    INPROGRESS = 4,
    ALERTING = 5,
    CONNECTED = 6,
    DISCONNECTING = 7,
    DISCONNECTED = 8,
};
pub const RTCPS_IDLE = RTC_PARTICIPANT_STATE.IDLE;
pub const RTCPS_PENDING = RTC_PARTICIPANT_STATE.PENDING;
pub const RTCPS_INCOMING = RTC_PARTICIPANT_STATE.INCOMING;
pub const RTCPS_ANSWERING = RTC_PARTICIPANT_STATE.ANSWERING;
pub const RTCPS_INPROGRESS = RTC_PARTICIPANT_STATE.INPROGRESS;
pub const RTCPS_ALERTING = RTC_PARTICIPANT_STATE.ALERTING;
pub const RTCPS_CONNECTED = RTC_PARTICIPANT_STATE.CONNECTED;
pub const RTCPS_DISCONNECTING = RTC_PARTICIPANT_STATE.DISCONNECTING;
pub const RTCPS_DISCONNECTED = RTC_PARTICIPANT_STATE.DISCONNECTED;

pub const RTC_WATCHER_STATE = enum(i32) {
    UNKNOWN = 0,
    OFFERING = 1,
    ALLOWED = 2,
    BLOCKED = 3,
    DENIED = 4,
    PROMPT = 5,
};
pub const RTCWS_UNKNOWN = RTC_WATCHER_STATE.UNKNOWN;
pub const RTCWS_OFFERING = RTC_WATCHER_STATE.OFFERING;
pub const RTCWS_ALLOWED = RTC_WATCHER_STATE.ALLOWED;
pub const RTCWS_BLOCKED = RTC_WATCHER_STATE.BLOCKED;
pub const RTCWS_DENIED = RTC_WATCHER_STATE.DENIED;
pub const RTCWS_PROMPT = RTC_WATCHER_STATE.PROMPT;

pub const RTC_ACE_SCOPE = enum(i32) {
    USER = 0,
    DOMAIN = 1,
    ALL = 2,
};
pub const RTCAS_SCOPE_USER = RTC_ACE_SCOPE.USER;
pub const RTCAS_SCOPE_DOMAIN = RTC_ACE_SCOPE.DOMAIN;
pub const RTCAS_SCOPE_ALL = RTC_ACE_SCOPE.ALL;

pub const RTC_OFFER_WATCHER_MODE = enum(i32) {
    OFFER_WATCHER_EVENT = 0,
    AUTOMATICALLY_ADD_WATCHER = 1,
};
pub const RTCOWM_OFFER_WATCHER_EVENT = RTC_OFFER_WATCHER_MODE.OFFER_WATCHER_EVENT;
pub const RTCOWM_AUTOMATICALLY_ADD_WATCHER = RTC_OFFER_WATCHER_MODE.AUTOMATICALLY_ADD_WATCHER;

pub const RTC_WATCHER_MATCH_MODE = enum(i32) {
    EXACT_MATCH = 0,
    BEST_ACE_MATCH = 1,
};
pub const RTCWMM_EXACT_MATCH = RTC_WATCHER_MATCH_MODE.EXACT_MATCH;
pub const RTCWMM_BEST_ACE_MATCH = RTC_WATCHER_MATCH_MODE.BEST_ACE_MATCH;

pub const RTC_PRIVACY_MODE = enum(i32) {
    BLOCK_LIST_EXCLUDED = 0,
    ALLOW_LIST_ONLY = 1,
};
pub const RTCPM_BLOCK_LIST_EXCLUDED = RTC_PRIVACY_MODE.BLOCK_LIST_EXCLUDED;
pub const RTCPM_ALLOW_LIST_ONLY = RTC_PRIVACY_MODE.ALLOW_LIST_ONLY;

pub const RTC_SESSION_TYPE = enum(i32) {
    PC_TO_PC = 0,
    PC_TO_PHONE = 1,
    PHONE_TO_PHONE = 2,
    IM = 3,
    MULTIPARTY_IM = 4,
    APPLICATION = 5,
};
pub const RTCST_PC_TO_PC = RTC_SESSION_TYPE.PC_TO_PC;
pub const RTCST_PC_TO_PHONE = RTC_SESSION_TYPE.PC_TO_PHONE;
pub const RTCST_PHONE_TO_PHONE = RTC_SESSION_TYPE.PHONE_TO_PHONE;
pub const RTCST_IM = RTC_SESSION_TYPE.IM;
pub const RTCST_MULTIPARTY_IM = RTC_SESSION_TYPE.MULTIPARTY_IM;
pub const RTCST_APPLICATION = RTC_SESSION_TYPE.APPLICATION;

pub const RTC_PRESENCE_STATUS = enum(i32) {
    OFFLINE = 0,
    ONLINE = 1,
    AWAY = 2,
    IDLE = 3,
    BUSY = 4,
    BE_RIGHT_BACK = 5,
    ON_THE_PHONE = 6,
    OUT_TO_LUNCH = 7,
};
pub const RTCXS_PRESENCE_OFFLINE = RTC_PRESENCE_STATUS.OFFLINE;
pub const RTCXS_PRESENCE_ONLINE = RTC_PRESENCE_STATUS.ONLINE;
pub const RTCXS_PRESENCE_AWAY = RTC_PRESENCE_STATUS.AWAY;
pub const RTCXS_PRESENCE_IDLE = RTC_PRESENCE_STATUS.IDLE;
pub const RTCXS_PRESENCE_BUSY = RTC_PRESENCE_STATUS.BUSY;
pub const RTCXS_PRESENCE_BE_RIGHT_BACK = RTC_PRESENCE_STATUS.BE_RIGHT_BACK;
pub const RTCXS_PRESENCE_ON_THE_PHONE = RTC_PRESENCE_STATUS.ON_THE_PHONE;
pub const RTCXS_PRESENCE_OUT_TO_LUNCH = RTC_PRESENCE_STATUS.OUT_TO_LUNCH;

pub const RTC_BUDDY_SUBSCRIPTION_TYPE = enum(i32) {
    SUBSCRIBED = 0,
    ALWAYS_OFFLINE = 1,
    ALWAYS_ONLINE = 2,
    POLL = 3,
};
pub const RTCBT_SUBSCRIBED = RTC_BUDDY_SUBSCRIPTION_TYPE.SUBSCRIBED;
pub const RTCBT_ALWAYS_OFFLINE = RTC_BUDDY_SUBSCRIPTION_TYPE.ALWAYS_OFFLINE;
pub const RTCBT_ALWAYS_ONLINE = RTC_BUDDY_SUBSCRIPTION_TYPE.ALWAYS_ONLINE;
pub const RTCBT_POLL = RTC_BUDDY_SUBSCRIPTION_TYPE.POLL;

pub const RTC_MEDIA_EVENT_TYPE = enum(i32) {
    STOPPED = 0,
    STARTED = 1,
    FAILED = 2,
};
pub const RTCMET_STOPPED = RTC_MEDIA_EVENT_TYPE.STOPPED;
pub const RTCMET_STARTED = RTC_MEDIA_EVENT_TYPE.STARTED;
pub const RTCMET_FAILED = RTC_MEDIA_EVENT_TYPE.FAILED;

pub const RTC_MEDIA_EVENT_REASON = enum(i32) {
    NORMAL = 0,
    HOLD = 1,
    TIMEOUT = 2,
    BAD_DEVICE = 3,
    NO_PORT = 4,
    PORT_MAPPING_FAILED = 5,
    REMOTE_REQUEST = 6,
};
pub const RTCMER_NORMAL = RTC_MEDIA_EVENT_REASON.NORMAL;
pub const RTCMER_HOLD = RTC_MEDIA_EVENT_REASON.HOLD;
pub const RTCMER_TIMEOUT = RTC_MEDIA_EVENT_REASON.TIMEOUT;
pub const RTCMER_BAD_DEVICE = RTC_MEDIA_EVENT_REASON.BAD_DEVICE;
pub const RTCMER_NO_PORT = RTC_MEDIA_EVENT_REASON.NO_PORT;
pub const RTCMER_PORT_MAPPING_FAILED = RTC_MEDIA_EVENT_REASON.PORT_MAPPING_FAILED;
pub const RTCMER_REMOTE_REQUEST = RTC_MEDIA_EVENT_REASON.REMOTE_REQUEST;

pub const RTC_MESSAGING_EVENT_TYPE = enum(i32) {
    MESSAGE = 0,
    STATUS = 1,
};
pub const RTCMSET_MESSAGE = RTC_MESSAGING_EVENT_TYPE.MESSAGE;
pub const RTCMSET_STATUS = RTC_MESSAGING_EVENT_TYPE.STATUS;

pub const RTC_MESSAGING_USER_STATUS = enum(i32) {
    IDLE = 0,
    TYPING = 1,
};
pub const RTCMUS_IDLE = RTC_MESSAGING_USER_STATUS.IDLE;
pub const RTCMUS_TYPING = RTC_MESSAGING_USER_STATUS.TYPING;

pub const RTC_DTMF = enum(i32) {
    @"0" = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    @"5" = 5,
    @"6" = 6,
    @"7" = 7,
    @"8" = 8,
    @"9" = 9,
    STAR = 10,
    POUND = 11,
    A = 12,
    B = 13,
    C = 14,
    D = 15,
    FLASH = 16,
};
pub const RTC_DTMF_0 = RTC_DTMF.@"0";
pub const RTC_DTMF_1 = RTC_DTMF.@"1";
pub const RTC_DTMF_2 = RTC_DTMF.@"2";
pub const RTC_DTMF_3 = RTC_DTMF.@"3";
pub const RTC_DTMF_4 = RTC_DTMF.@"4";
pub const RTC_DTMF_5 = RTC_DTMF.@"5";
pub const RTC_DTMF_6 = RTC_DTMF.@"6";
pub const RTC_DTMF_7 = RTC_DTMF.@"7";
pub const RTC_DTMF_8 = RTC_DTMF.@"8";
pub const RTC_DTMF_9 = RTC_DTMF.@"9";
pub const RTC_DTMF_STAR = RTC_DTMF.STAR;
pub const RTC_DTMF_POUND = RTC_DTMF.POUND;
pub const RTC_DTMF_A = RTC_DTMF.A;
pub const RTC_DTMF_B = RTC_DTMF.B;
pub const RTC_DTMF_C = RTC_DTMF.C;
pub const RTC_DTMF_D = RTC_DTMF.D;
pub const RTC_DTMF_FLASH = RTC_DTMF.FLASH;

pub const RTC_PROVIDER_URI = enum(i32) {
    HOMEPAGE = 0,
    HELPDESK = 1,
    PERSONALACCOUNT = 2,
    DISPLAYDURINGCALL = 3,
    DISPLAYDURINGIDLE = 4,
};
pub const RTCPU_URIHOMEPAGE = RTC_PROVIDER_URI.HOMEPAGE;
pub const RTCPU_URIHELPDESK = RTC_PROVIDER_URI.HELPDESK;
pub const RTCPU_URIPERSONALACCOUNT = RTC_PROVIDER_URI.PERSONALACCOUNT;
pub const RTCPU_URIDISPLAYDURINGCALL = RTC_PROVIDER_URI.DISPLAYDURINGCALL;
pub const RTCPU_URIDISPLAYDURINGIDLE = RTC_PROVIDER_URI.DISPLAYDURINGIDLE;

pub const RTC_RING_TYPE = enum(i32) {
    PHONE = 0,
    MESSAGE = 1,
    RINGBACK = 2,
};
pub const RTCRT_PHONE = RTC_RING_TYPE.PHONE;
pub const RTCRT_MESSAGE = RTC_RING_TYPE.MESSAGE;
pub const RTCRT_RINGBACK = RTC_RING_TYPE.RINGBACK;

pub const RTC_T120_APPLET = enum(i32) {
    WHITEBOARD = 0,
    APPSHARING = 1,
};
pub const RTCTA_WHITEBOARD = RTC_T120_APPLET.WHITEBOARD;
pub const RTCTA_APPSHARING = RTC_T120_APPLET.APPSHARING;

pub const RTC_PORT_TYPE = enum(i32) {
    AUDIO_RTP = 0,
    AUDIO_RTCP = 1,
    VIDEO_RTP = 2,
    VIDEO_RTCP = 3,
    SIP = 4,
};
pub const RTCPT_AUDIO_RTP = RTC_PORT_TYPE.AUDIO_RTP;
pub const RTCPT_AUDIO_RTCP = RTC_PORT_TYPE.AUDIO_RTCP;
pub const RTCPT_VIDEO_RTP = RTC_PORT_TYPE.VIDEO_RTP;
pub const RTCPT_VIDEO_RTCP = RTC_PORT_TYPE.VIDEO_RTCP;
pub const RTCPT_SIP = RTC_PORT_TYPE.SIP;

pub const RTC_USER_SEARCH_COLUMN = enum(i32) {
    URI = 0,
    DISPLAYNAME = 1,
    TITLE = 2,
    OFFICE = 3,
    PHONE = 4,
    COMPANY = 5,
    CITY = 6,
    STATE = 7,
    COUNTRY = 8,
    EMAIL = 9,
};
pub const RTCUSC_URI = RTC_USER_SEARCH_COLUMN.URI;
pub const RTCUSC_DISPLAYNAME = RTC_USER_SEARCH_COLUMN.DISPLAYNAME;
pub const RTCUSC_TITLE = RTC_USER_SEARCH_COLUMN.TITLE;
pub const RTCUSC_OFFICE = RTC_USER_SEARCH_COLUMN.OFFICE;
pub const RTCUSC_PHONE = RTC_USER_SEARCH_COLUMN.PHONE;
pub const RTCUSC_COMPANY = RTC_USER_SEARCH_COLUMN.COMPANY;
pub const RTCUSC_CITY = RTC_USER_SEARCH_COLUMN.CITY;
pub const RTCUSC_STATE = RTC_USER_SEARCH_COLUMN.STATE;
pub const RTCUSC_COUNTRY = RTC_USER_SEARCH_COLUMN.COUNTRY;
pub const RTCUSC_EMAIL = RTC_USER_SEARCH_COLUMN.EMAIL;

pub const RTC_USER_SEARCH_PREFERENCE = enum(i32) {
    MAX_MATCHES = 0,
    TIME_LIMIT = 1,
};
pub const RTCUSP_MAX_MATCHES = RTC_USER_SEARCH_PREFERENCE.MAX_MATCHES;
pub const RTCUSP_TIME_LIMIT = RTC_USER_SEARCH_PREFERENCE.TIME_LIMIT;

pub const RTC_ROAMING_EVENT_TYPE = enum(i32) {
    BUDDY_ROAMING = 0,
    WATCHER_ROAMING = 1,
    PRESENCE_ROAMING = 2,
    PROFILE_ROAMING = 3,
    WPENDING_ROAMING = 4,
};
pub const RTCRET_BUDDY_ROAMING = RTC_ROAMING_EVENT_TYPE.BUDDY_ROAMING;
pub const RTCRET_WATCHER_ROAMING = RTC_ROAMING_EVENT_TYPE.WATCHER_ROAMING;
pub const RTCRET_PRESENCE_ROAMING = RTC_ROAMING_EVENT_TYPE.PRESENCE_ROAMING;
pub const RTCRET_PROFILE_ROAMING = RTC_ROAMING_EVENT_TYPE.PROFILE_ROAMING;
pub const RTCRET_WPENDING_ROAMING = RTC_ROAMING_EVENT_TYPE.WPENDING_ROAMING;

pub const RTC_PROFILE_EVENT_TYPE = enum(i32) {
    GET = 0,
    UPDATE = 1,
};
pub const RTCPFET_PROFILE_GET = RTC_PROFILE_EVENT_TYPE.GET;
pub const RTCPFET_PROFILE_UPDATE = RTC_PROFILE_EVENT_TYPE.UPDATE;

pub const RTC_ANSWER_MODE = enum(i32) {
    OFFER_SESSION_EVENT = 0,
    AUTOMATICALLY_ACCEPT = 1,
    AUTOMATICALLY_REJECT = 2,
    NOT_SUPPORTED = 3,
};
pub const RTCAM_OFFER_SESSION_EVENT = RTC_ANSWER_MODE.OFFER_SESSION_EVENT;
pub const RTCAM_AUTOMATICALLY_ACCEPT = RTC_ANSWER_MODE.AUTOMATICALLY_ACCEPT;
pub const RTCAM_AUTOMATICALLY_REJECT = RTC_ANSWER_MODE.AUTOMATICALLY_REJECT;
pub const RTCAM_NOT_SUPPORTED = RTC_ANSWER_MODE.NOT_SUPPORTED;

pub const RTC_SESSION_REFER_STATUS = enum(i32) {
    REFERRING = 0,
    ACCEPTED = 1,
    ERROR = 2,
    REJECTED = 3,
    DROPPED = 4,
    DONE = 5,
};
pub const RTCSRS_REFERRING = RTC_SESSION_REFER_STATUS.REFERRING;
pub const RTCSRS_ACCEPTED = RTC_SESSION_REFER_STATUS.ACCEPTED;
pub const RTCSRS_ERROR = RTC_SESSION_REFER_STATUS.ERROR;
pub const RTCSRS_REJECTED = RTC_SESSION_REFER_STATUS.REJECTED;
pub const RTCSRS_DROPPED = RTC_SESSION_REFER_STATUS.DROPPED;
pub const RTCSRS_DONE = RTC_SESSION_REFER_STATUS.DONE;

pub const RTC_PRESENCE_PROPERTY = enum(i32) {
    PHONENUMBER = 0,
    DISPLAYNAME = 1,
    EMAIL = 2,
    DEVICE_NAME = 3,
    MULTIPLE = 4,
};
pub const RTCPP_PHONENUMBER = RTC_PRESENCE_PROPERTY.PHONENUMBER;
pub const RTCPP_DISPLAYNAME = RTC_PRESENCE_PROPERTY.DISPLAYNAME;
pub const RTCPP_EMAIL = RTC_PRESENCE_PROPERTY.EMAIL;
pub const RTCPP_DEVICE_NAME = RTC_PRESENCE_PROPERTY.DEVICE_NAME;
pub const RTCPP_MULTIPLE = RTC_PRESENCE_PROPERTY.MULTIPLE;

pub const RTC_SECURITY_TYPE = enum(i32) {
    AUDIO_VIDEO_MEDIA_ENCRYPTION = 0,
    T120_MEDIA_ENCRYPTION = 1,
};
pub const RTCSECT_AUDIO_VIDEO_MEDIA_ENCRYPTION = RTC_SECURITY_TYPE.AUDIO_VIDEO_MEDIA_ENCRYPTION;
pub const RTCSECT_T120_MEDIA_ENCRYPTION = RTC_SECURITY_TYPE.T120_MEDIA_ENCRYPTION;

pub const RTC_SECURITY_LEVEL = enum(i32) {
    UNSUPPORTED = 1,
    SUPPORTED = 2,
    REQUIRED = 3,
};
pub const RTCSECL_UNSUPPORTED = RTC_SECURITY_LEVEL.UNSUPPORTED;
pub const RTCSECL_SUPPORTED = RTC_SECURITY_LEVEL.SUPPORTED;
pub const RTCSECL_REQUIRED = RTC_SECURITY_LEVEL.REQUIRED;

pub const RTC_REINVITE_STATE = enum(i32) {
    INCOMING = 0,
    SUCCEEDED = 1,
    FAIL = 2,
};
pub const RTCRIN_INCOMING = RTC_REINVITE_STATE.INCOMING;
pub const RTCRIN_SUCCEEDED = RTC_REINVITE_STATE.SUCCEEDED;
pub const RTCRIN_FAIL = RTC_REINVITE_STATE.FAIL;

const IID_IRTCClient_Value = Guid.initString("07829e45-9a34-408e-a011-bddf13487cd1");
pub const IID_IRTCClient = &IID_IRTCClient_Value;
pub const IRTCClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrepareForShutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                lFilter: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                lFilter: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                plFilter: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                plFilter: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPreferredMediaTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
                lMediaTypes: i32,
                fPersistent: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
                lMediaTypes: i32,
                fPersistent: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredMediaTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaCapabilities: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
                enType: RTC_SESSION_TYPE,
                bstrLocalPhoneURI: ?BSTR,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
                enType: RTC_SESSION_TYPE,
                bstrLocalPhoneURI: ?BSTR,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ListenForIncomingSessions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enListen: RTC_LISTEN_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enListen: RTC_LISTEN_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ListenForIncomingSessions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                penListen: ?*RTC_LISTEN_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                penListen: ?*RTC_LISTEN_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetworkAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                fTCP: i16,
                fExternal: i16,
                pvAddresses: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                fTCP: i16,
                fExternal: i16,
                pvAddresses: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioMuted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                fMuted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                fMuted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioMuted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                pfMuted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                pfMuted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IVideoWindow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enDevice: RTC_VIDEO_DEVICE,
                ppIVideoWindow: ?*?*IVideoWindow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enDevice: RTC_VIDEO_DEVICE,
                ppIVideoWindow: ?*?*IVideoWindow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredAudioDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                bstrDeviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                bstrDeviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredAudioDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                pbstrDeviceName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                pbstrDeviceName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredVolume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredVolume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enDevice: RTC_AUDIO_DEVICE,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredAEC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                bEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                bEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredAEC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredVideoDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                bstrDeviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                bstrDeviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredVideoDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                pbstrDeviceName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                pbstrDeviceName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                plMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                plMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxBitrate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                lMaxBitrate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                lMaxBitrate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxBitrate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                plMaxBitrate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                plMaxBitrate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TemporalSpatialTradeOff: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                lValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                lValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TemporalSpatialTradeOff: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                plValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                plValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetworkQuality: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                plNetworkQuality: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                plNetworkQuality: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartT120Applet: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
                enApplet: RTC_T120_APPLET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
                enApplet: RTC_T120_APPLET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopT120Applets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsT120AppletRunning: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                enApplet: RTC_T120_APPLET,
                pfRunning: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                enApplet: RTC_T120_APPLET,
                pfRunning: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalUserURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                pbstrUserURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                pbstrUserURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalUserURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                bstrUserURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                bstrUserURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalUserName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                pbstrUserName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                pbstrUserName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalUserName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                bstrUserName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                bstrUserName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayRing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
                enType: RTC_RING_TYPE,
                bPlay: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
                enType: RTC_RING_TYPE,
                bPlay: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendDTMF: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
                enDTMF: RTC_DTMF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
                enDTMF: RTC_DTMF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeTuningWizard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient,
                hwndParent: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient,
                hwndParent: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsTuned: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient,
                pfTuned: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient,
                pfTuned: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_Initialize(self: *const T) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IRTCClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_Shutdown(self: *const T) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IRTCClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_PrepareForShutdown(self: *const T) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).PrepareForShutdown(@as(*const IRTCClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_EventFilter(self: *const T, lFilter: i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_EventFilter(@as(*const IRTCClient, @ptrCast(self)), lFilter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_EventFilter(self: *const T, plFilter: ?*i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_EventFilter(@as(*const IRTCClient, @ptrCast(self)), plFilter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_SetPreferredMediaTypes(self: *const T, lMediaTypes: i32, fPersistent: i16) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).SetPreferredMediaTypes(@as(*const IRTCClient, @ptrCast(self)), lMediaTypes, fPersistent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_PreferredMediaTypes(self: *const T, plMediaTypes: ?*i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_PreferredMediaTypes(@as(*const IRTCClient, @ptrCast(self)), plMediaTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_MediaCapabilities(self: *const T, plMediaTypes: ?*i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_MediaCapabilities(@as(*const IRTCClient, @ptrCast(self)), plMediaTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_CreateSession(self: *const T, enType: RTC_SESSION_TYPE, bstrLocalPhoneURI: ?BSTR, pProfile: ?*IRTCProfile, lFlags: i32, ppSession: ?*?*IRTCSession) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).CreateSession(@as(*const IRTCClient, @ptrCast(self)), enType, bstrLocalPhoneURI, pProfile, lFlags, ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_ListenForIncomingSessions(self: *const T, enListen: RTC_LISTEN_MODE) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_ListenForIncomingSessions(@as(*const IRTCClient, @ptrCast(self)), enListen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_ListenForIncomingSessions(self: *const T, penListen: ?*RTC_LISTEN_MODE) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_ListenForIncomingSessions(@as(*const IRTCClient, @ptrCast(self)), penListen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_NetworkAddresses(self: *const T, fTCP: i16, fExternal: i16, pvAddresses: ?*VARIANT) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_NetworkAddresses(@as(*const IRTCClient, @ptrCast(self)), fTCP, fExternal, pvAddresses);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_Volume(self: *const T, enDevice: RTC_AUDIO_DEVICE, lVolume: i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_Volume(@as(*const IRTCClient, @ptrCast(self)), enDevice, lVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_Volume(self: *const T, enDevice: RTC_AUDIO_DEVICE, plVolume: ?*i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_Volume(@as(*const IRTCClient, @ptrCast(self)), enDevice, plVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_AudioMuted(self: *const T, enDevice: RTC_AUDIO_DEVICE, fMuted: i16) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_AudioMuted(@as(*const IRTCClient, @ptrCast(self)), enDevice, fMuted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_AudioMuted(self: *const T, enDevice: RTC_AUDIO_DEVICE, pfMuted: ?*i16) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_AudioMuted(@as(*const IRTCClient, @ptrCast(self)), enDevice, pfMuted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_IVideoWindow(self: *const T, enDevice: RTC_VIDEO_DEVICE, ppIVideoWindow: ?*?*IVideoWindow) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_IVideoWindow(@as(*const IRTCClient, @ptrCast(self)), enDevice, ppIVideoWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_PreferredAudioDevice(self: *const T, enDevice: RTC_AUDIO_DEVICE, bstrDeviceName: ?BSTR) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_PreferredAudioDevice(@as(*const IRTCClient, @ptrCast(self)), enDevice, bstrDeviceName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_PreferredAudioDevice(self: *const T, enDevice: RTC_AUDIO_DEVICE, pbstrDeviceName: ?*?BSTR) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_PreferredAudioDevice(@as(*const IRTCClient, @ptrCast(self)), enDevice, pbstrDeviceName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_PreferredVolume(self: *const T, enDevice: RTC_AUDIO_DEVICE, lVolume: i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_PreferredVolume(@as(*const IRTCClient, @ptrCast(self)), enDevice, lVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_PreferredVolume(self: *const T, enDevice: RTC_AUDIO_DEVICE, plVolume: ?*i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_PreferredVolume(@as(*const IRTCClient, @ptrCast(self)), enDevice, plVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_PreferredAEC(self: *const T, bEnable: i16) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_PreferredAEC(@as(*const IRTCClient, @ptrCast(self)), bEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_PreferredAEC(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_PreferredAEC(@as(*const IRTCClient, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_PreferredVideoDevice(self: *const T, bstrDeviceName: ?BSTR) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_PreferredVideoDevice(@as(*const IRTCClient, @ptrCast(self)), bstrDeviceName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_PreferredVideoDevice(self: *const T, pbstrDeviceName: ?*?BSTR) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_PreferredVideoDevice(@as(*const IRTCClient, @ptrCast(self)), pbstrDeviceName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_ActiveMedia(self: *const T, plMediaType: ?*i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_ActiveMedia(@as(*const IRTCClient, @ptrCast(self)), plMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_MaxBitrate(self: *const T, lMaxBitrate: i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_MaxBitrate(@as(*const IRTCClient, @ptrCast(self)), lMaxBitrate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_MaxBitrate(self: *const T, plMaxBitrate: ?*i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_MaxBitrate(@as(*const IRTCClient, @ptrCast(self)), plMaxBitrate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_TemporalSpatialTradeOff(self: *const T, lValue: i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_TemporalSpatialTradeOff(@as(*const IRTCClient, @ptrCast(self)), lValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_TemporalSpatialTradeOff(self: *const T, plValue: ?*i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_TemporalSpatialTradeOff(@as(*const IRTCClient, @ptrCast(self)), plValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_NetworkQuality(self: *const T, plNetworkQuality: ?*i32) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_NetworkQuality(@as(*const IRTCClient, @ptrCast(self)), plNetworkQuality);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_StartT120Applet(self: *const T, enApplet: RTC_T120_APPLET) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).StartT120Applet(@as(*const IRTCClient, @ptrCast(self)), enApplet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_StopT120Applets(self: *const T) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).StopT120Applets(@as(*const IRTCClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_IsT120AppletRunning(self: *const T, enApplet: RTC_T120_APPLET, pfRunning: ?*i16) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_IsT120AppletRunning(@as(*const IRTCClient, @ptrCast(self)), enApplet, pfRunning);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_LocalUserURI(self: *const T, pbstrUserURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_LocalUserURI(@as(*const IRTCClient, @ptrCast(self)), pbstrUserURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_LocalUserURI(self: *const T, bstrUserURI: ?BSTR) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_LocalUserURI(@as(*const IRTCClient, @ptrCast(self)), bstrUserURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_LocalUserName(self: *const T, pbstrUserName: ?*?BSTR) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_LocalUserName(@as(*const IRTCClient, @ptrCast(self)), pbstrUserName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_put_LocalUserName(self: *const T, bstrUserName: ?BSTR) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).put_LocalUserName(@as(*const IRTCClient, @ptrCast(self)), bstrUserName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_PlayRing(self: *const T, enType: RTC_RING_TYPE, bPlay: i16) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).PlayRing(@as(*const IRTCClient, @ptrCast(self)), enType, bPlay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_SendDTMF(self: *const T, enDTMF: RTC_DTMF) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).SendDTMF(@as(*const IRTCClient, @ptrCast(self)), enDTMF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_InvokeTuningWizard(self: *const T, hwndParent: isize) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).InvokeTuningWizard(@as(*const IRTCClient, @ptrCast(self)), hwndParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient_get_IsTuned(self: *const T, pfTuned: ?*i16) HRESULT {
                return @as(*const IRTCClient.VTable, @ptrCast(self.vtable)).get_IsTuned(@as(*const IRTCClient, @ptrCast(self)), pfTuned);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCClient2_Value = Guid.initString("0c91d71d-1064-42da-bfa5-572beb8eea84");
pub const IID_IRTCClient2 = &IID_IRTCClient2_Value;
pub const IRTCClient2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCClient.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AnswerMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient2,
                enType: RTC_SESSION_TYPE,
                enMode: RTC_ANSWER_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient2,
                enType: RTC_SESSION_TYPE,
                enMode: RTC_ANSWER_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AnswerMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient2,
                enType: RTC_SESSION_TYPE,
                penMode: ?*RTC_ANSWER_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient2,
                enType: RTC_SESSION_TYPE,
                penMode: ?*RTC_ANSWER_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeTuningWizardEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient2,
                hwndParent: isize,
                fAllowAudio: i16,
                fAllowVideo: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient2,
                hwndParent: isize,
                fAllowAudio: i16,
                fAllowVideo: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient2,
                plVersion: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient2,
                plVersion: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient2,
                bstrClientName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient2,
                bstrClientName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientCurVer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient2,
                bstrClientCurVer: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient2,
                bstrClientCurVer: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient2,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient2,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSessionWithDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient2,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppSession2: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient2,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppSession2: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSessionDescriptionManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClient2,
                pSessionDescriptionManager: ?*IRTCSessionDescriptionManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClient2,
                pSessionDescriptionManager: ?*IRTCSessionDescriptionManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredSecurityLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient2,
                enSecurityType: RTC_SECURITY_TYPE,
                enSecurityLevel: RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient2,
                enSecurityType: RTC_SECURITY_TYPE,
                enSecurityLevel: RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredSecurityLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient2,
                enSecurityType: RTC_SECURITY_TYPE,
                penSecurityLevel: ?*RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient2,
                enSecurityType: RTC_SECURITY_TYPE,
                penSecurityLevel: ?*RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowedPorts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient2,
                lTransport: i32,
                enListenMode: RTC_LISTEN_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient2,
                lTransport: i32,
                enListenMode: RTC_LISTEN_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowedPorts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClient2,
                lTransport: i32,
                penListenMode: ?*RTC_LISTEN_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClient2,
                lTransport: i32,
                penListenMode: ?*RTC_LISTEN_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCClient.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_put_AnswerMode(self: *const T, enType: RTC_SESSION_TYPE, enMode: RTC_ANSWER_MODE) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).put_AnswerMode(@as(*const IRTCClient2, @ptrCast(self)), enType, enMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_get_AnswerMode(self: *const T, enType: RTC_SESSION_TYPE, penMode: ?*RTC_ANSWER_MODE) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).get_AnswerMode(@as(*const IRTCClient2, @ptrCast(self)), enType, penMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_InvokeTuningWizardEx(self: *const T, hwndParent: isize, fAllowAudio: i16, fAllowVideo: i16) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).InvokeTuningWizardEx(@as(*const IRTCClient2, @ptrCast(self)), hwndParent, fAllowAudio, fAllowVideo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_get_Version(self: *const T, plVersion: ?*i32) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).get_Version(@as(*const IRTCClient2, @ptrCast(self)), plVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_put_ClientName(self: *const T, bstrClientName: ?BSTR) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).put_ClientName(@as(*const IRTCClient2, @ptrCast(self)), bstrClientName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_put_ClientCurVer(self: *const T, bstrClientCurVer: ?BSTR) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).put_ClientCurVer(@as(*const IRTCClient2, @ptrCast(self)), bstrClientCurVer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_InitializeEx(self: *const T, lFlags: i32) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).InitializeEx(@as(*const IRTCClient2, @ptrCast(self)), lFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_CreateSessionWithDescription(self: *const T, bstrContentType: ?BSTR, bstrSessionDescription: ?BSTR, pProfile: ?*IRTCProfile, lFlags: i32, ppSession2: ?*?*IRTCSession2) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).CreateSessionWithDescription(@as(*const IRTCClient2, @ptrCast(self)), bstrContentType, bstrSessionDescription, pProfile, lFlags, ppSession2);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_SetSessionDescriptionManager(self: *const T, pSessionDescriptionManager: ?*IRTCSessionDescriptionManager) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).SetSessionDescriptionManager(@as(*const IRTCClient2, @ptrCast(self)), pSessionDescriptionManager);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_put_PreferredSecurityLevel(self: *const T, enSecurityType: RTC_SECURITY_TYPE, enSecurityLevel: RTC_SECURITY_LEVEL) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).put_PreferredSecurityLevel(@as(*const IRTCClient2, @ptrCast(self)), enSecurityType, enSecurityLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_get_PreferredSecurityLevel(self: *const T, enSecurityType: RTC_SECURITY_TYPE, penSecurityLevel: ?*RTC_SECURITY_LEVEL) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).get_PreferredSecurityLevel(@as(*const IRTCClient2, @ptrCast(self)), enSecurityType, penSecurityLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_put_AllowedPorts(self: *const T, lTransport: i32, enListenMode: RTC_LISTEN_MODE) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).put_AllowedPorts(@as(*const IRTCClient2, @ptrCast(self)), lTransport, enListenMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClient2_get_AllowedPorts(self: *const T, lTransport: i32, penListenMode: ?*RTC_LISTEN_MODE) HRESULT {
                return @as(*const IRTCClient2.VTable, @ptrCast(self.vtable)).get_AllowedPorts(@as(*const IRTCClient2, @ptrCast(self)), lTransport, penListenMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCClientPresence_Value = Guid.initString("11c3cbcc-0744-42d1-968a-51aa1bb274c6");
pub const IID_IRTCClientPresence = &IID_IRTCClientPresence_Value;
pub const IRTCClientPresence = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnablePresence: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                fUseStorage: i16,
                varStorage: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                fUseStorage: i16,
                varStorage: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Export: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                varStorage: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                varStorage: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Import: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                varStorage: VARIANT,
                fReplaceAll: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                varStorage: VARIANT,
                fReplaceAll: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateBuddies: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                ppEnum: ?*?*IRTCEnumBuddies,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                ppEnum: ?*?*IRTCEnumBuddies,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Buddies: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Buddy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence,
                bstrPresentityURI: ?BSTR,
                ppBuddy: ?*?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence,
                bstrPresentityURI: ?BSTR,
                ppBuddy: ?*?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBuddy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                bstrPresentityURI: ?BSTR,
                bstrUserName: ?BSTR,
                bstrData: ?BSTR,
                fPersistent: i16,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppBuddy: ?*?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                bstrPresentityURI: ?BSTR,
                bstrUserName: ?BSTR,
                bstrData: ?BSTR,
                fPersistent: i16,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppBuddy: ?*?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBuddy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                pBuddy: ?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                pBuddy: ?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateWatchers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                ppEnum: ?*?*IRTCEnumWatchers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                ppEnum: ?*?*IRTCEnumWatchers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Watchers: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Watcher: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence,
                bstrPresentityURI: ?BSTR,
                ppWatcher: ?*?*IRTCWatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence,
                bstrPresentityURI: ?BSTR,
                ppWatcher: ?*?*IRTCWatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddWatcher: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                bstrPresentityURI: ?BSTR,
                bstrUserName: ?BSTR,
                bstrData: ?BSTR,
                fBlocked: i16,
                fPersistent: i16,
                ppWatcher: ?*?*IRTCWatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                bstrPresentityURI: ?BSTR,
                bstrUserName: ?BSTR,
                bstrData: ?BSTR,
                fBlocked: i16,
                fPersistent: i16,
                ppWatcher: ?*?*IRTCWatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveWatcher: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                pWatcher: ?*IRTCWatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                pWatcher: ?*IRTCWatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLocalPresenceInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence,
                enStatus: RTC_PRESENCE_STATUS,
                bstrNotes: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence,
                enStatus: RTC_PRESENCE_STATUS,
                bstrNotes: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OfferWatcherMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence,
                penMode: ?*RTC_OFFER_WATCHER_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence,
                penMode: ?*RTC_OFFER_WATCHER_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OfferWatcherMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence,
                enMode: RTC_OFFER_WATCHER_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence,
                enMode: RTC_OFFER_WATCHER_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrivacyMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence,
                penMode: ?*RTC_PRIVACY_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence,
                penMode: ?*RTC_PRIVACY_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PrivacyMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence,
                enMode: RTC_PRIVACY_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence,
                enMode: RTC_PRIVACY_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_EnablePresence(self: *const T, fUseStorage: i16, varStorage: VARIANT) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).EnablePresence(@as(*const IRTCClientPresence, @ptrCast(self)), fUseStorage, varStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_Export(self: *const T, varStorage: VARIANT) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).Export(@as(*const IRTCClientPresence, @ptrCast(self)), varStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_Import(self: *const T, varStorage: VARIANT, fReplaceAll: i16) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).Import(@as(*const IRTCClientPresence, @ptrCast(self)), varStorage, fReplaceAll);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_EnumerateBuddies(self: *const T, ppEnum: ?*?*IRTCEnumBuddies) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).EnumerateBuddies(@as(*const IRTCClientPresence, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_get_Buddies(self: *const T, ppCollection: ?*?*IRTCCollection) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).get_Buddies(@as(*const IRTCClientPresence, @ptrCast(self)), ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_get_Buddy(self: *const T, bstrPresentityURI: ?BSTR, ppBuddy: ?*?*IRTCBuddy) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).get_Buddy(@as(*const IRTCClientPresence, @ptrCast(self)), bstrPresentityURI, ppBuddy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_AddBuddy(self: *const T, bstrPresentityURI: ?BSTR, bstrUserName: ?BSTR, bstrData: ?BSTR, fPersistent: i16, pProfile: ?*IRTCProfile, lFlags: i32, ppBuddy: ?*?*IRTCBuddy) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).AddBuddy(@as(*const IRTCClientPresence, @ptrCast(self)), bstrPresentityURI, bstrUserName, bstrData, fPersistent, pProfile, lFlags, ppBuddy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_RemoveBuddy(self: *const T, pBuddy: ?*IRTCBuddy) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).RemoveBuddy(@as(*const IRTCClientPresence, @ptrCast(self)), pBuddy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_EnumerateWatchers(self: *const T, ppEnum: ?*?*IRTCEnumWatchers) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).EnumerateWatchers(@as(*const IRTCClientPresence, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_get_Watchers(self: *const T, ppCollection: ?*?*IRTCCollection) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).get_Watchers(@as(*const IRTCClientPresence, @ptrCast(self)), ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_get_Watcher(self: *const T, bstrPresentityURI: ?BSTR, ppWatcher: ?*?*IRTCWatcher) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).get_Watcher(@as(*const IRTCClientPresence, @ptrCast(self)), bstrPresentityURI, ppWatcher);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_AddWatcher(self: *const T, bstrPresentityURI: ?BSTR, bstrUserName: ?BSTR, bstrData: ?BSTR, fBlocked: i16, fPersistent: i16, ppWatcher: ?*?*IRTCWatcher) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).AddWatcher(@as(*const IRTCClientPresence, @ptrCast(self)), bstrPresentityURI, bstrUserName, bstrData, fBlocked, fPersistent, ppWatcher);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_RemoveWatcher(self: *const T, pWatcher: ?*IRTCWatcher) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).RemoveWatcher(@as(*const IRTCClientPresence, @ptrCast(self)), pWatcher);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_SetLocalPresenceInfo(self: *const T, enStatus: RTC_PRESENCE_STATUS, bstrNotes: ?BSTR) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).SetLocalPresenceInfo(@as(*const IRTCClientPresence, @ptrCast(self)), enStatus, bstrNotes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_get_OfferWatcherMode(self: *const T, penMode: ?*RTC_OFFER_WATCHER_MODE) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).get_OfferWatcherMode(@as(*const IRTCClientPresence, @ptrCast(self)), penMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_put_OfferWatcherMode(self: *const T, enMode: RTC_OFFER_WATCHER_MODE) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).put_OfferWatcherMode(@as(*const IRTCClientPresence, @ptrCast(self)), enMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_get_PrivacyMode(self: *const T, penMode: ?*RTC_PRIVACY_MODE) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).get_PrivacyMode(@as(*const IRTCClientPresence, @ptrCast(self)), penMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence_put_PrivacyMode(self: *const T, enMode: RTC_PRIVACY_MODE) HRESULT {
                return @as(*const IRTCClientPresence.VTable, @ptrCast(self.vtable)).put_PrivacyMode(@as(*const IRTCClientPresence, @ptrCast(self)), enMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCClientPresence2_Value = Guid.initString("ad1809e8-62f7-4783-909a-29c9d2cb1d34");
pub const IID_IRTCClientPresence2 = &IID_IRTCClientPresence2_Value;
pub const IRTCClientPresence2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCClientPresence.VTable,
        EnablePresenceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                pProfile: ?*IRTCProfile,
                varStorage: VARIANT,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
                pProfile: ?*IRTCProfile,
                varStorage: VARIANT,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisablePresence: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                bstrGroupName: ?BSTR,
                bstrData: ?BSTR,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppGroup: ?*?*IRTCBuddyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
                bstrGroupName: ?BSTR,
                bstrData: ?BSTR,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppGroup: ?*?*IRTCBuddyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                pGroup: ?*IRTCBuddyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
                pGroup: ?*IRTCBuddyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateGroups: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                ppEnum: ?*?*IRTCEnumGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
                ppEnum: ?*?*IRTCEnumGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Groups: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence2,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Group: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                bstrGroupName: ?BSTR,
                ppGroup: ?*?*IRTCBuddyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence2,
                bstrGroupName: ?BSTR,
                ppGroup: ?*?*IRTCBuddyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddWatcherEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                bstrPresentityURI: ?BSTR,
                bstrUserName: ?BSTR,
                bstrData: ?BSTR,
                enState: RTC_WATCHER_STATE,
                fPersistent: i16,
                enScope: RTC_ACE_SCOPE,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppWatcher: ?*?*IRTCWatcher2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
                bstrPresentityURI: ?BSTR,
                bstrUserName: ?BSTR,
                bstrData: ?BSTR,
                enState: RTC_WATCHER_STATE,
                fPersistent: i16,
                enScope: RTC_ACE_SCOPE,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppWatcher: ?*?*IRTCWatcher2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WatcherEx: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                enMode: RTC_WATCHER_MATCH_MODE,
                bstrPresentityURI: ?BSTR,
                ppWatcher: ?*?*IRTCWatcher2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence2,
                enMode: RTC_WATCHER_MATCH_MODE,
                bstrPresentityURI: ?BSTR,
                ppWatcher: ?*?*IRTCWatcher2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PresenceProperty: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                enProperty: RTC_PRESENCE_PROPERTY,
                bstrProperty: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence2,
                enProperty: RTC_PRESENCE_PROPERTY,
                bstrProperty: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PresenceProperty: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                enProperty: RTC_PRESENCE_PROPERTY,
                pbstrProperty: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientPresence2,
                enProperty: RTC_PRESENCE_PROPERTY,
                pbstrProperty: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPresenceData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                bstrNamespace: ?BSTR,
                bstrData: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
                bstrNamespace: ?BSTR,
                bstrData: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresenceData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                pbstrNamespace: ?*?BSTR,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
                pbstrNamespace: ?*?BSTR,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocalPresenceInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                penStatus: ?*RTC_PRESENCE_STATUS,
                pbstrNotes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
                penStatus: ?*RTC_PRESENCE_STATUS,
                pbstrNotes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBuddyEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPresence2,
                bstrPresentityURI: ?BSTR,
                bstrUserName: ?BSTR,
                bstrData: ?BSTR,
                fPersistent: i16,
                enSubscriptionType: RTC_BUDDY_SUBSCRIPTION_TYPE,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppBuddy: ?*?*IRTCBuddy2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPresence2,
                bstrPresentityURI: ?BSTR,
                bstrUserName: ?BSTR,
                bstrData: ?BSTR,
                fPersistent: i16,
                enSubscriptionType: RTC_BUDDY_SUBSCRIPTION_TYPE,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
                ppBuddy: ?*?*IRTCBuddy2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCClientPresence.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_EnablePresenceEx(self: *const T, pProfile: ?*IRTCProfile, varStorage: VARIANT, lFlags: i32) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).EnablePresenceEx(@as(*const IRTCClientPresence2, @ptrCast(self)), pProfile, varStorage, lFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_DisablePresence(self: *const T) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).DisablePresence(@as(*const IRTCClientPresence2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_AddGroup(self: *const T, bstrGroupName: ?BSTR, bstrData: ?BSTR, pProfile: ?*IRTCProfile, lFlags: i32, ppGroup: ?*?*IRTCBuddyGroup) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).AddGroup(@as(*const IRTCClientPresence2, @ptrCast(self)), bstrGroupName, bstrData, pProfile, lFlags, ppGroup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_RemoveGroup(self: *const T, pGroup: ?*IRTCBuddyGroup) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).RemoveGroup(@as(*const IRTCClientPresence2, @ptrCast(self)), pGroup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_EnumerateGroups(self: *const T, ppEnum: ?*?*IRTCEnumGroups) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).EnumerateGroups(@as(*const IRTCClientPresence2, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_get_Groups(self: *const T, ppCollection: ?*?*IRTCCollection) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).get_Groups(@as(*const IRTCClientPresence2, @ptrCast(self)), ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_get_Group(self: *const T, bstrGroupName: ?BSTR, ppGroup: ?*?*IRTCBuddyGroup) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).get_Group(@as(*const IRTCClientPresence2, @ptrCast(self)), bstrGroupName, ppGroup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_AddWatcherEx(self: *const T, bstrPresentityURI: ?BSTR, bstrUserName: ?BSTR, bstrData: ?BSTR, enState: RTC_WATCHER_STATE, fPersistent: i16, enScope: RTC_ACE_SCOPE, pProfile: ?*IRTCProfile, lFlags: i32, ppWatcher: ?*?*IRTCWatcher2) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).AddWatcherEx(@as(*const IRTCClientPresence2, @ptrCast(self)), bstrPresentityURI, bstrUserName, bstrData, enState, fPersistent, enScope, pProfile, lFlags, ppWatcher);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_get_WatcherEx(self: *const T, enMode: RTC_WATCHER_MATCH_MODE, bstrPresentityURI: ?BSTR, ppWatcher: ?*?*IRTCWatcher2) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).get_WatcherEx(@as(*const IRTCClientPresence2, @ptrCast(self)), enMode, bstrPresentityURI, ppWatcher);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_put_PresenceProperty(self: *const T, enProperty: RTC_PRESENCE_PROPERTY, bstrProperty: ?BSTR) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).put_PresenceProperty(@as(*const IRTCClientPresence2, @ptrCast(self)), enProperty, bstrProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_get_PresenceProperty(self: *const T, enProperty: RTC_PRESENCE_PROPERTY, pbstrProperty: ?*?BSTR) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).get_PresenceProperty(@as(*const IRTCClientPresence2, @ptrCast(self)), enProperty, pbstrProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_SetPresenceData(self: *const T, bstrNamespace: ?BSTR, bstrData: ?BSTR) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).SetPresenceData(@as(*const IRTCClientPresence2, @ptrCast(self)), bstrNamespace, bstrData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_GetPresenceData(self: *const T, pbstrNamespace: ?*?BSTR, pbstrData: ?*?BSTR) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).GetPresenceData(@as(*const IRTCClientPresence2, @ptrCast(self)), pbstrNamespace, pbstrData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_GetLocalPresenceInfo(self: *const T, penStatus: ?*RTC_PRESENCE_STATUS, pbstrNotes: ?*?BSTR) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).GetLocalPresenceInfo(@as(*const IRTCClientPresence2, @ptrCast(self)), penStatus, pbstrNotes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPresence2_AddBuddyEx(self: *const T, bstrPresentityURI: ?BSTR, bstrUserName: ?BSTR, bstrData: ?BSTR, fPersistent: i16, enSubscriptionType: RTC_BUDDY_SUBSCRIPTION_TYPE, pProfile: ?*IRTCProfile, lFlags: i32, ppBuddy: ?*?*IRTCBuddy2) HRESULT {
                return @as(*const IRTCClientPresence2.VTable, @ptrCast(self.vtable)).AddBuddyEx(@as(*const IRTCClientPresence2, @ptrCast(self)), bstrPresentityURI, bstrUserName, bstrData, fPersistent, enSubscriptionType, pProfile, lFlags, ppBuddy);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCClientProvisioning_Value = Guid.initString("b9f5cf06-65b9-4a80-a0e6-73cae3ef3822");
pub const IID_IRTCClientProvisioning = &IID_IRTCClientProvisioning_Value;
pub const IRTCClientProvisioning = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientProvisioning,
                bstrProfileXML: ?BSTR,
                ppProfile: ?*?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientProvisioning,
                bstrProfileXML: ?BSTR,
                ppProfile: ?*?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientProvisioning,
                pProfile: ?*IRTCProfile,
                lRegisterFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientProvisioning,
                pProfile: ?*IRTCProfile,
                lRegisterFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientProvisioning,
                pProfile: ?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientProvisioning,
                pProfile: ?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateProfiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientProvisioning,
                ppEnum: ?*?*IRTCEnumProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientProvisioning,
                ppEnum: ?*?*IRTCEnumProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profiles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientProvisioning,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientProvisioning,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientProvisioning,
                bstrUserAccount: ?BSTR,
                bstrUserPassword: ?BSTR,
                bstrUserURI: ?BSTR,
                bstrServer: ?BSTR,
                lTransport: i32,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientProvisioning,
                bstrUserAccount: ?BSTR,
                bstrUserPassword: ?BSTR,
                bstrUserURI: ?BSTR,
                bstrServer: ?BSTR,
                lTransport: i32,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionCapabilities: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientProvisioning,
                plSupportedSessions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientProvisioning,
                plSupportedSessions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientProvisioning_CreateProfile(self: *const T, bstrProfileXML: ?BSTR, ppProfile: ?*?*IRTCProfile) HRESULT {
                return @as(*const IRTCClientProvisioning.VTable, @ptrCast(self.vtable)).CreateProfile(@as(*const IRTCClientProvisioning, @ptrCast(self)), bstrProfileXML, ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientProvisioning_EnableProfile(self: *const T, pProfile: ?*IRTCProfile, lRegisterFlags: i32) HRESULT {
                return @as(*const IRTCClientProvisioning.VTable, @ptrCast(self.vtable)).EnableProfile(@as(*const IRTCClientProvisioning, @ptrCast(self)), pProfile, lRegisterFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientProvisioning_DisableProfile(self: *const T, pProfile: ?*IRTCProfile) HRESULT {
                return @as(*const IRTCClientProvisioning.VTable, @ptrCast(self.vtable)).DisableProfile(@as(*const IRTCClientProvisioning, @ptrCast(self)), pProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientProvisioning_EnumerateProfiles(self: *const T, ppEnum: ?*?*IRTCEnumProfiles) HRESULT {
                return @as(*const IRTCClientProvisioning.VTable, @ptrCast(self.vtable)).EnumerateProfiles(@as(*const IRTCClientProvisioning, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientProvisioning_get_Profiles(self: *const T, ppCollection: ?*?*IRTCCollection) HRESULT {
                return @as(*const IRTCClientProvisioning.VTable, @ptrCast(self.vtable)).get_Profiles(@as(*const IRTCClientProvisioning, @ptrCast(self)), ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientProvisioning_GetProfile(self: *const T, bstrUserAccount: ?BSTR, bstrUserPassword: ?BSTR, bstrUserURI: ?BSTR, bstrServer: ?BSTR, lTransport: i32, lCookie: isize) HRESULT {
                return @as(*const IRTCClientProvisioning.VTable, @ptrCast(self.vtable)).GetProfile(@as(*const IRTCClientProvisioning, @ptrCast(self)), bstrUserAccount, bstrUserPassword, bstrUserURI, bstrServer, lTransport, lCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientProvisioning_get_SessionCapabilities(self: *const T, plSupportedSessions: ?*i32) HRESULT {
                return @as(*const IRTCClientProvisioning.VTable, @ptrCast(self.vtable)).get_SessionCapabilities(@as(*const IRTCClientProvisioning, @ptrCast(self)), plSupportedSessions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCClientProvisioning2_Value = Guid.initString("a70909b5-f40e-4587-bb75-e6bc0845023e");
pub const IID_IRTCClientProvisioning2 = &IID_IRTCClientProvisioning2_Value;
pub const IRTCClientProvisioning2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCClientProvisioning.VTable,
        EnableProfileEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientProvisioning2,
                pProfile: ?*IRTCProfile,
                lRegisterFlags: i32,
                lRoamingFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientProvisioning2,
                pProfile: ?*IRTCProfile,
                lRegisterFlags: i32,
                lRoamingFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCClientProvisioning.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientProvisioning2_EnableProfileEx(self: *const T, pProfile: ?*IRTCProfile, lRegisterFlags: i32, lRoamingFlags: i32) HRESULT {
                return @as(*const IRTCClientProvisioning2.VTable, @ptrCast(self.vtable)).EnableProfileEx(@as(*const IRTCClientProvisioning2, @ptrCast(self)), pProfile, lRegisterFlags, lRoamingFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCProfile_Value = Guid.initString("d07eca9e-4062-4dd4-9e7d-722a49ba7303");
pub const IID_IRTCProfile = &IID_IRTCProfile_Value;
pub const IRTCProfile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Key: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrKey: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrKey: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XML: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrXML: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrXML: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                enURI: RTC_PROVIDER_URI,
                pbstrURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                enURI: RTC_PROVIDER_URI,
                pbstrURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderData: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientBanner: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pfBanner: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pfBanner: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientMinVer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrMinVer: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrMinVer: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientCurVer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrCurVer: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrCurVer: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientUpdateURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrUpdateURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrUpdateURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientData: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrUserURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrUserURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrUserName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrUserName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAccount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                pbstrUserAccount: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                pbstrUserAccount: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCProfile,
                bstrUserURI: ?BSTR,
                bstrUserAccount: ?BSTR,
                bstrPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCProfile,
                bstrUserURI: ?BSTR,
                bstrUserAccount: ?BSTR,
                bstrPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionCapabilities: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                plSupportedSessions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                plSupportedSessions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile,
                penState: ?*RTC_REGISTRATION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile,
                penState: ?*RTC_REGISTRATION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_Key(self: *const T, pbstrKey: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_Key(@as(*const IRTCProfile, @ptrCast(self)), pbstrKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_Name(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IRTCProfile, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_XML(self: *const T, pbstrXML: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_XML(@as(*const IRTCProfile, @ptrCast(self)), pbstrXML);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_ProviderName(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_ProviderName(@as(*const IRTCProfile, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_ProviderURI(self: *const T, enURI: RTC_PROVIDER_URI, pbstrURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_ProviderURI(@as(*const IRTCProfile, @ptrCast(self)), enURI, pbstrURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_ProviderData(self: *const T, pbstrData: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_ProviderData(@as(*const IRTCProfile, @ptrCast(self)), pbstrData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_ClientName(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_ClientName(@as(*const IRTCProfile, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_ClientBanner(self: *const T, pfBanner: ?*i16) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_ClientBanner(@as(*const IRTCProfile, @ptrCast(self)), pfBanner);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_ClientMinVer(self: *const T, pbstrMinVer: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_ClientMinVer(@as(*const IRTCProfile, @ptrCast(self)), pbstrMinVer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_ClientCurVer(self: *const T, pbstrCurVer: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_ClientCurVer(@as(*const IRTCProfile, @ptrCast(self)), pbstrCurVer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_ClientUpdateURI(self: *const T, pbstrUpdateURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_ClientUpdateURI(@as(*const IRTCProfile, @ptrCast(self)), pbstrUpdateURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_ClientData(self: *const T, pbstrData: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_ClientData(@as(*const IRTCProfile, @ptrCast(self)), pbstrData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_UserURI(self: *const T, pbstrUserURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_UserURI(@as(*const IRTCProfile, @ptrCast(self)), pbstrUserURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_UserName(self: *const T, pbstrUserName: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_UserName(@as(*const IRTCProfile, @ptrCast(self)), pbstrUserName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_UserAccount(self: *const T, pbstrUserAccount: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_UserAccount(@as(*const IRTCProfile, @ptrCast(self)), pbstrUserAccount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_SetCredentials(self: *const T, bstrUserURI: ?BSTR, bstrUserAccount: ?BSTR, bstrPassword: ?BSTR) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).SetCredentials(@as(*const IRTCProfile, @ptrCast(self)), bstrUserURI, bstrUserAccount, bstrPassword);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_SessionCapabilities(self: *const T, plSupportedSessions: ?*i32) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_SessionCapabilities(@as(*const IRTCProfile, @ptrCast(self)), plSupportedSessions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile_get_State(self: *const T, penState: ?*RTC_REGISTRATION_STATE) HRESULT {
                return @as(*const IRTCProfile.VTable, @ptrCast(self.vtable)).get_State(@as(*const IRTCProfile, @ptrCast(self)), penState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCProfile2_Value = Guid.initString("4b81f84e-bdc7-4184-9154-3cb2dd7917fb");
pub const IID_IRTCProfile2 = &IID_IRTCProfile2_Value;
pub const IRTCProfile2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCProfile.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Realm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile2,
                pbstrRealm: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile2,
                pbstrRealm: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Realm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile2,
                bstrRealm: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile2,
                bstrRealm: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowedAuth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile2,
                plAllowedAuth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile2,
                plAllowedAuth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowedAuth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfile2,
                lAllowedAuth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfile2,
                lAllowedAuth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCProfile.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile2_get_Realm(self: *const T, pbstrRealm: ?*?BSTR) HRESULT {
                return @as(*const IRTCProfile2.VTable, @ptrCast(self.vtable)).get_Realm(@as(*const IRTCProfile2, @ptrCast(self)), pbstrRealm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile2_put_Realm(self: *const T, bstrRealm: ?BSTR) HRESULT {
                return @as(*const IRTCProfile2.VTable, @ptrCast(self.vtable)).put_Realm(@as(*const IRTCProfile2, @ptrCast(self)), bstrRealm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile2_get_AllowedAuth(self: *const T, plAllowedAuth: ?*i32) HRESULT {
                return @as(*const IRTCProfile2.VTable, @ptrCast(self.vtable)).get_AllowedAuth(@as(*const IRTCProfile2, @ptrCast(self)), plAllowedAuth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfile2_put_AllowedAuth(self: *const T, lAllowedAuth: i32) HRESULT {
                return @as(*const IRTCProfile2.VTable, @ptrCast(self.vtable)).put_AllowedAuth(@as(*const IRTCProfile2, @ptrCast(self)), lAllowedAuth);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSession_Value = Guid.initString("387c8086-99be-42fb-9973-7c0fc0ca9fa8");
pub const IID_IRTCSession = &IID_IRTCSession_Value;
pub const IRTCSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Client: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession,
                ppClient: ?*?*IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession,
                ppClient: ?*?*IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession,
                penState: ?*RTC_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession,
                penState: ?*RTC_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession,
                penType: ?*RTC_SESSION_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession,
                penType: ?*RTC_SESSION_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession,
                ppProfile: ?*?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession,
                ppProfile: ?*?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Participants: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Answer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
                enReason: RTC_TERMINATE_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
                enReason: RTC_TERMINATE_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Redirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
                enType: RTC_SESSION_TYPE,
                bstrLocalPhoneURI: ?BSTR,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
                enType: RTC_SESSION_TYPE,
                bstrLocalPhoneURI: ?BSTR,
                pProfile: ?*IRTCProfile,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddParticipant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
                bstrAddress: ?BSTR,
                bstrName: ?BSTR,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
                bstrAddress: ?BSTR,
                bstrName: ?BSTR,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveParticipant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
                pParticipant: ?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
                pParticipant: ?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateParticipants: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
                ppEnum: ?*?*IRTCEnumParticipants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
                ppEnum: ?*?*IRTCEnumParticipants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanAddParticipants: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession,
                pfCanAdd: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession,
                pfCanAdd: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RedirectedUserURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession,
                pbstrUserURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession,
                pbstrUserURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RedirectedUserName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession,
                pbstrUserName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession,
                pbstrUserName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NextRedirectedUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
                bstrMessageHeader: ?BSTR,
                bstrMessage: ?BSTR,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
                bstrMessageHeader: ?BSTR,
                bstrMessage: ?BSTR,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendMessageStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
                enUserStatus: RTC_MESSAGING_USER_STATUS,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
                enUserStatus: RTC_MESSAGING_USER_STATUS,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
                lMediaType: i32,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
                lMediaType: i32,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession,
                lMediaType: i32,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession,
                lMediaType: i32,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EncryptionKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession,
                lMediaType: i32,
                EncryptionKey: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession,
                lMediaType: i32,
                EncryptionKey: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_get_Client(self: *const T, ppClient: ?*?*IRTCClient) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).get_Client(@as(*const IRTCSession, @ptrCast(self)), ppClient);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_get_State(self: *const T, penState: ?*RTC_SESSION_STATE) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).get_State(@as(*const IRTCSession, @ptrCast(self)), penState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_get_Type(self: *const T, penType: ?*RTC_SESSION_TYPE) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IRTCSession, @ptrCast(self)), penType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_get_Profile(self: *const T, ppProfile: ?*?*IRTCProfile) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).get_Profile(@as(*const IRTCSession, @ptrCast(self)), ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_get_Participants(self: *const T, ppCollection: ?*?*IRTCCollection) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).get_Participants(@as(*const IRTCSession, @ptrCast(self)), ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_Answer(self: *const T) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).Answer(@as(*const IRTCSession, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_Terminate(self: *const T, enReason: RTC_TERMINATE_REASON) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).Terminate(@as(*const IRTCSession, @ptrCast(self)), enReason);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_Redirect(self: *const T, enType: RTC_SESSION_TYPE, bstrLocalPhoneURI: ?BSTR, pProfile: ?*IRTCProfile, lFlags: i32) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).Redirect(@as(*const IRTCSession, @ptrCast(self)), enType, bstrLocalPhoneURI, pProfile, lFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_AddParticipant(self: *const T, bstrAddress: ?BSTR, bstrName: ?BSTR, ppParticipant: ?*?*IRTCParticipant) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).AddParticipant(@as(*const IRTCSession, @ptrCast(self)), bstrAddress, bstrName, ppParticipant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_RemoveParticipant(self: *const T, pParticipant: ?*IRTCParticipant) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).RemoveParticipant(@as(*const IRTCSession, @ptrCast(self)), pParticipant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_EnumerateParticipants(self: *const T, ppEnum: ?*?*IRTCEnumParticipants) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).EnumerateParticipants(@as(*const IRTCSession, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_get_CanAddParticipants(self: *const T, pfCanAdd: ?*i16) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).get_CanAddParticipants(@as(*const IRTCSession, @ptrCast(self)), pfCanAdd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_get_RedirectedUserURI(self: *const T, pbstrUserURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).get_RedirectedUserURI(@as(*const IRTCSession, @ptrCast(self)), pbstrUserURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_get_RedirectedUserName(self: *const T, pbstrUserName: ?*?BSTR) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).get_RedirectedUserName(@as(*const IRTCSession, @ptrCast(self)), pbstrUserName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_NextRedirectedUser(self: *const T) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).NextRedirectedUser(@as(*const IRTCSession, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_SendMessage(self: *const T, bstrMessageHeader: ?BSTR, bstrMessage: ?BSTR, lCookie: isize) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).SendMessage(@as(*const IRTCSession, @ptrCast(self)), bstrMessageHeader, bstrMessage, lCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_SendMessageStatus(self: *const T, enUserStatus: RTC_MESSAGING_USER_STATUS, lCookie: isize) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).SendMessageStatus(@as(*const IRTCSession, @ptrCast(self)), enUserStatus, lCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_AddStream(self: *const T, lMediaType: i32, lCookie: isize) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).AddStream(@as(*const IRTCSession, @ptrCast(self)), lMediaType, lCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_RemoveStream(self: *const T, lMediaType: i32, lCookie: isize) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).RemoveStream(@as(*const IRTCSession, @ptrCast(self)), lMediaType, lCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession_put_EncryptionKey(self: *const T, lMediaType: i32, EncryptionKey: ?BSTR) HRESULT {
                return @as(*const IRTCSession.VTable, @ptrCast(self.vtable)).put_EncryptionKey(@as(*const IRTCSession, @ptrCast(self)), lMediaType, EncryptionKey);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSession2_Value = Guid.initString("17d7cdfc-b007-484c-99d2-86a8a820991d");
pub const IID_IRTCSession2 = &IID_IRTCSession2_Value;
pub const IRTCSession2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCSession.VTable,
        SendInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession2,
                bstrInfoHeader: ?BSTR,
                bstrInfo: ?BSTR,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession2,
                bstrInfoHeader: ?BSTR,
                bstrInfo: ?BSTR,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredSecurityLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession2,
                enSecurityType: RTC_SECURITY_TYPE,
                enSecurityLevel: RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession2,
                enSecurityType: RTC_SECURITY_TYPE,
                enSecurityLevel: RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredSecurityLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSession2,
                enSecurityType: RTC_SECURITY_TYPE,
                penSecurityLevel: ?*RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSession2,
                enSecurityType: RTC_SECURITY_TYPE,
                penSecurityLevel: ?*RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSecurityEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession2,
                enSecurityType: RTC_SECURITY_TYPE,
                pfSecurityEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession2,
                enSecurityType: RTC_SECURITY_TYPE,
                pfSecurityEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AnswerWithSessionDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession2,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession2,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReInviteWithSessionDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSession2,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSession2,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCSession.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession2_SendInfo(self: *const T, bstrInfoHeader: ?BSTR, bstrInfo: ?BSTR, lCookie: isize) HRESULT {
                return @as(*const IRTCSession2.VTable, @ptrCast(self.vtable)).SendInfo(@as(*const IRTCSession2, @ptrCast(self)), bstrInfoHeader, bstrInfo, lCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession2_put_PreferredSecurityLevel(self: *const T, enSecurityType: RTC_SECURITY_TYPE, enSecurityLevel: RTC_SECURITY_LEVEL) HRESULT {
                return @as(*const IRTCSession2.VTable, @ptrCast(self.vtable)).put_PreferredSecurityLevel(@as(*const IRTCSession2, @ptrCast(self)), enSecurityType, enSecurityLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession2_get_PreferredSecurityLevel(self: *const T, enSecurityType: RTC_SECURITY_TYPE, penSecurityLevel: ?*RTC_SECURITY_LEVEL) HRESULT {
                return @as(*const IRTCSession2.VTable, @ptrCast(self.vtable)).get_PreferredSecurityLevel(@as(*const IRTCSession2, @ptrCast(self)), enSecurityType, penSecurityLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession2_IsSecurityEnabled(self: *const T, enSecurityType: RTC_SECURITY_TYPE, pfSecurityEnabled: ?*i16) HRESULT {
                return @as(*const IRTCSession2.VTable, @ptrCast(self.vtable)).IsSecurityEnabled(@as(*const IRTCSession2, @ptrCast(self)), enSecurityType, pfSecurityEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession2_AnswerWithSessionDescription(self: *const T, bstrContentType: ?BSTR, bstrSessionDescription: ?BSTR) HRESULT {
                return @as(*const IRTCSession2.VTable, @ptrCast(self.vtable)).AnswerWithSessionDescription(@as(*const IRTCSession2, @ptrCast(self)), bstrContentType, bstrSessionDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSession2_ReInviteWithSessionDescription(self: *const T, bstrContentType: ?BSTR, bstrSessionDescription: ?BSTR, lCookie: isize) HRESULT {
                return @as(*const IRTCSession2.VTable, @ptrCast(self.vtable)).ReInviteWithSessionDescription(@as(*const IRTCSession2, @ptrCast(self)), bstrContentType, bstrSessionDescription, lCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSessionCallControl_Value = Guid.initString("e9a50d94-190b-4f82-9530-3b8ebf60758a");
pub const IID_IRTCSessionCallControl = &IID_IRTCSessionCallControl_Value;
pub const IRTCSessionCallControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Hold: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionCallControl,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionCallControl,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnHold: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionCallControl,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionCallControl,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Forward: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionCallControl,
                bstrForwardToURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionCallControl,
                bstrForwardToURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionCallControl,
                bstrReferToURI: ?BSTR,
                bstrReferCookie: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionCallControl,
                bstrReferToURI: ?BSTR,
                bstrReferCookie: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReferredByURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionCallControl,
                bstrReferredByURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionCallControl,
                bstrReferredByURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReferredByURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionCallControl,
                pbstrReferredByURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionCallControl,
                pbstrReferredByURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReferCookie: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionCallControl,
                bstrReferCookie: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionCallControl,
                bstrReferCookie: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReferCookie: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionCallControl,
                pbstrReferCookie: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionCallControl,
                pbstrReferCookie: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsReferred: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionCallControl,
                pfIsReferred: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionCallControl,
                pfIsReferred: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionCallControl_Hold(self: *const T, lCookie: isize) HRESULT {
                return @as(*const IRTCSessionCallControl.VTable, @ptrCast(self.vtable)).Hold(@as(*const IRTCSessionCallControl, @ptrCast(self)), lCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionCallControl_UnHold(self: *const T, lCookie: isize) HRESULT {
                return @as(*const IRTCSessionCallControl.VTable, @ptrCast(self.vtable)).UnHold(@as(*const IRTCSessionCallControl, @ptrCast(self)), lCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionCallControl_Forward(self: *const T, bstrForwardToURI: ?BSTR) HRESULT {
                return @as(*const IRTCSessionCallControl.VTable, @ptrCast(self.vtable)).Forward(@as(*const IRTCSessionCallControl, @ptrCast(self)), bstrForwardToURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionCallControl_Refer(self: *const T, bstrReferToURI: ?BSTR, bstrReferCookie: ?BSTR) HRESULT {
                return @as(*const IRTCSessionCallControl.VTable, @ptrCast(self.vtable)).Refer(@as(*const IRTCSessionCallControl, @ptrCast(self)), bstrReferToURI, bstrReferCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionCallControl_put_ReferredByURI(self: *const T, bstrReferredByURI: ?BSTR) HRESULT {
                return @as(*const IRTCSessionCallControl.VTable, @ptrCast(self.vtable)).put_ReferredByURI(@as(*const IRTCSessionCallControl, @ptrCast(self)), bstrReferredByURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionCallControl_get_ReferredByURI(self: *const T, pbstrReferredByURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionCallControl.VTable, @ptrCast(self.vtable)).get_ReferredByURI(@as(*const IRTCSessionCallControl, @ptrCast(self)), pbstrReferredByURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionCallControl_put_ReferCookie(self: *const T, bstrReferCookie: ?BSTR) HRESULT {
                return @as(*const IRTCSessionCallControl.VTable, @ptrCast(self.vtable)).put_ReferCookie(@as(*const IRTCSessionCallControl, @ptrCast(self)), bstrReferCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionCallControl_get_ReferCookie(self: *const T, pbstrReferCookie: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionCallControl.VTable, @ptrCast(self.vtable)).get_ReferCookie(@as(*const IRTCSessionCallControl, @ptrCast(self)), pbstrReferCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionCallControl_get_IsReferred(self: *const T, pfIsReferred: ?*i16) HRESULT {
                return @as(*const IRTCSessionCallControl.VTable, @ptrCast(self.vtable)).get_IsReferred(@as(*const IRTCSessionCallControl, @ptrCast(self)), pfIsReferred);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCParticipant_Value = Guid.initString("ae86add5-26b1-4414-af1d-b94cd938d739");
pub const IID_IRTCParticipant = &IID_IRTCParticipant_Value;
pub const IRTCParticipant = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCParticipant,
                pbstrUserURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCParticipant,
                pbstrUserURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCParticipant,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCParticipant,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Removable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCParticipant,
                pfRemovable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCParticipant,
                pfRemovable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCParticipant,
                penState: ?*RTC_PARTICIPANT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCParticipant,
                penState: ?*RTC_PARTICIPANT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCParticipant,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCParticipant,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCParticipant_get_UserURI(self: *const T, pbstrUserURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCParticipant.VTable, @ptrCast(self.vtable)).get_UserURI(@as(*const IRTCParticipant, @ptrCast(self)), pbstrUserURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCParticipant_get_Name(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IRTCParticipant.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IRTCParticipant, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCParticipant_get_Removable(self: *const T, pfRemovable: ?*i16) HRESULT {
                return @as(*const IRTCParticipant.VTable, @ptrCast(self.vtable)).get_Removable(@as(*const IRTCParticipant, @ptrCast(self)), pfRemovable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCParticipant_get_State(self: *const T, penState: ?*RTC_PARTICIPANT_STATE) HRESULT {
                return @as(*const IRTCParticipant.VTable, @ptrCast(self.vtable)).get_State(@as(*const IRTCParticipant, @ptrCast(self)), penState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCParticipant_get_Session(self: *const T, ppSession: ?*?*IRTCSession) HRESULT {
                return @as(*const IRTCParticipant.VTable, @ptrCast(self.vtable)).get_Session(@as(*const IRTCParticipant, @ptrCast(self)), ppSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCRoamingEvent_Value = Guid.initString("79960a6b-0cb1-4dc8-a805-7318e99902e8");
pub const IID_IRTCRoamingEvent = &IID_IRTCRoamingEvent_Value;
pub const IRTCRoamingEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCRoamingEvent,
                pEventType: ?*RTC_ROAMING_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCRoamingEvent,
                pEventType: ?*RTC_ROAMING_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCRoamingEvent,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCRoamingEvent,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCRoamingEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCRoamingEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCRoamingEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCRoamingEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCRoamingEvent_get_EventType(self: *const T, pEventType: ?*RTC_ROAMING_EVENT_TYPE) HRESULT {
                return @as(*const IRTCRoamingEvent.VTable, @ptrCast(self.vtable)).get_EventType(@as(*const IRTCRoamingEvent, @ptrCast(self)), pEventType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCRoamingEvent_get_Profile(self: *const T, ppProfile: ?*?*IRTCProfile2) HRESULT {
                return @as(*const IRTCRoamingEvent.VTable, @ptrCast(self.vtable)).get_Profile(@as(*const IRTCRoamingEvent, @ptrCast(self)), ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCRoamingEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCRoamingEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCRoamingEvent, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCRoamingEvent_get_StatusText(self: *const T, pbstrStatusText: ?*?BSTR) HRESULT {
                return @as(*const IRTCRoamingEvent.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IRTCRoamingEvent, @ptrCast(self)), pbstrStatusText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCProfileEvent_Value = Guid.initString("d6d5ab3b-770e-43e8-800a-79b062395fca");
pub const IID_IRTCProfileEvent = &IID_IRTCProfileEvent_Value;
pub const IRTCProfileEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfileEvent,
                ppProfile: ?*?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfileEvent,
                ppProfile: ?*?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cookie: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfileEvent,
                plCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfileEvent,
                plCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfileEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfileEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfileEvent_get_Profile(self: *const T, ppProfile: ?*?*IRTCProfile) HRESULT {
                return @as(*const IRTCProfileEvent.VTable, @ptrCast(self.vtable)).get_Profile(@as(*const IRTCProfileEvent, @ptrCast(self)), ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfileEvent_get_Cookie(self: *const T, plCookie: ?*isize) HRESULT {
                return @as(*const IRTCProfileEvent.VTable, @ptrCast(self.vtable)).get_Cookie(@as(*const IRTCProfileEvent, @ptrCast(self)), plCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfileEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCProfileEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCProfileEvent, @ptrCast(self)), plStatusCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCProfileEvent2_Value = Guid.initString("62e56edc-03fa-4121-94fb-23493fd0ae64");
pub const IID_IRTCProfileEvent2 = &IID_IRTCProfileEvent2_Value;
pub const IRTCProfileEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCProfileEvent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCProfileEvent2,
                pEventType: ?*RTC_PROFILE_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCProfileEvent2,
                pEventType: ?*RTC_PROFILE_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCProfileEvent.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCProfileEvent2_get_EventType(self: *const T, pEventType: ?*RTC_PROFILE_EVENT_TYPE) HRESULT {
                return @as(*const IRTCProfileEvent2.VTable, @ptrCast(self.vtable)).get_EventType(@as(*const IRTCProfileEvent2, @ptrCast(self)), pEventType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCClientEvent_Value = Guid.initString("2b493b7a-3cba-4170-9c8b-76a9dacdd644");
pub const IID_IRTCClientEvent = &IID_IRTCClientEvent_Value;
pub const IRTCClientEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientEvent,
                penEventType: ?*RTC_CLIENT_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientEvent,
                penEventType: ?*RTC_CLIENT_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Client: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCClientEvent,
                ppClient: ?*?*IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCClientEvent,
                ppClient: ?*?*IRTCClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientEvent_get_EventType(self: *const T, penEventType: ?*RTC_CLIENT_EVENT_TYPE) HRESULT {
                return @as(*const IRTCClientEvent.VTable, @ptrCast(self.vtable)).get_EventType(@as(*const IRTCClientEvent, @ptrCast(self)), penEventType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientEvent_get_Client(self: *const T, ppClient: ?*?*IRTCClient) HRESULT {
                return @as(*const IRTCClientEvent.VTable, @ptrCast(self.vtable)).get_Client(@as(*const IRTCClientEvent, @ptrCast(self)), ppClient);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCRegistrationStateChangeEvent_Value = Guid.initString("62d0991b-50ab-4f02-b948-ca94f26f8f95");
pub const IID_IRTCRegistrationStateChangeEvent = &IID_IRTCRegistrationStateChangeEvent_Value;
pub const IRTCRegistrationStateChangeEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCRegistrationStateChangeEvent,
                ppProfile: ?*?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCRegistrationStateChangeEvent,
                ppProfile: ?*?*IRTCProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCRegistrationStateChangeEvent,
                penState: ?*RTC_REGISTRATION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCRegistrationStateChangeEvent,
                penState: ?*RTC_REGISTRATION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCRegistrationStateChangeEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCRegistrationStateChangeEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCRegistrationStateChangeEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCRegistrationStateChangeEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCRegistrationStateChangeEvent_get_Profile(self: *const T, ppProfile: ?*?*IRTCProfile) HRESULT {
                return @as(*const IRTCRegistrationStateChangeEvent.VTable, @ptrCast(self.vtable)).get_Profile(@as(*const IRTCRegistrationStateChangeEvent, @ptrCast(self)), ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCRegistrationStateChangeEvent_get_State(self: *const T, penState: ?*RTC_REGISTRATION_STATE) HRESULT {
                return @as(*const IRTCRegistrationStateChangeEvent.VTable, @ptrCast(self.vtable)).get_State(@as(*const IRTCRegistrationStateChangeEvent, @ptrCast(self)), penState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCRegistrationStateChangeEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCRegistrationStateChangeEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCRegistrationStateChangeEvent, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCRegistrationStateChangeEvent_get_StatusText(self: *const T, pbstrStatusText: ?*?BSTR) HRESULT {
                return @as(*const IRTCRegistrationStateChangeEvent.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IRTCRegistrationStateChangeEvent, @ptrCast(self)), pbstrStatusText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSessionStateChangeEvent_Value = Guid.initString("b5bad703-5952-48b3-9321-7f4500521506");
pub const IID_IRTCSessionStateChangeEvent = &IID_IRTCSessionStateChangeEvent_Value;
pub const IRTCSessionStateChangeEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionStateChangeEvent,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionStateChangeEvent,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionStateChangeEvent,
                penState: ?*RTC_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionStateChangeEvent,
                penState: ?*RTC_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionStateChangeEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionStateChangeEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionStateChangeEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionStateChangeEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionStateChangeEvent_get_Session(self: *const T, ppSession: ?*?*IRTCSession) HRESULT {
                return @as(*const IRTCSessionStateChangeEvent.VTable, @ptrCast(self.vtable)).get_Session(@as(*const IRTCSessionStateChangeEvent, @ptrCast(self)), ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionStateChangeEvent_get_State(self: *const T, penState: ?*RTC_SESSION_STATE) HRESULT {
                return @as(*const IRTCSessionStateChangeEvent.VTable, @ptrCast(self.vtable)).get_State(@as(*const IRTCSessionStateChangeEvent, @ptrCast(self)), penState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionStateChangeEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCSessionStateChangeEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCSessionStateChangeEvent, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionStateChangeEvent_get_StatusText(self: *const T, pbstrStatusText: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionStateChangeEvent.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IRTCSessionStateChangeEvent, @ptrCast(self)), pbstrStatusText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSessionStateChangeEvent2_Value = Guid.initString("4f933171-6f95-4880-80d9-2ec8d495d261");
pub const IID_IRTCSessionStateChangeEvent2 = &IID_IRTCSessionStateChangeEvent2_Value;
pub const IRTCSessionStateChangeEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCSessionStateChangeEvent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionStateChangeEvent2,
                pMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionStateChangeEvent2,
                pMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemotePreferredSecurityLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionStateChangeEvent2,
                enSecurityType: RTC_SECURITY_TYPE,
                penSecurityLevel: ?*RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionStateChangeEvent2,
                enSecurityType: RTC_SECURITY_TYPE,
                penSecurityLevel: ?*RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsForked: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionStateChangeEvent2,
                pfIsForked: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionStateChangeEvent2,
                pfIsForked: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRemoteSessionDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionStateChangeEvent2,
                pbstrContentType: ?*?BSTR,
                pbstrSessionDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionStateChangeEvent2,
                pbstrContentType: ?*?BSTR,
                pbstrSessionDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCSessionStateChangeEvent.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionStateChangeEvent2_get_MediaTypes(self: *const T, pMediaTypes: ?*i32) HRESULT {
                return @as(*const IRTCSessionStateChangeEvent2.VTable, @ptrCast(self.vtable)).get_MediaTypes(@as(*const IRTCSessionStateChangeEvent2, @ptrCast(self)), pMediaTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionStateChangeEvent2_get_RemotePreferredSecurityLevel(self: *const T, enSecurityType: RTC_SECURITY_TYPE, penSecurityLevel: ?*RTC_SECURITY_LEVEL) HRESULT {
                return @as(*const IRTCSessionStateChangeEvent2.VTable, @ptrCast(self.vtable)).get_RemotePreferredSecurityLevel(@as(*const IRTCSessionStateChangeEvent2, @ptrCast(self)), enSecurityType, penSecurityLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionStateChangeEvent2_get_IsForked(self: *const T, pfIsForked: ?*i16) HRESULT {
                return @as(*const IRTCSessionStateChangeEvent2.VTable, @ptrCast(self.vtable)).get_IsForked(@as(*const IRTCSessionStateChangeEvent2, @ptrCast(self)), pfIsForked);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionStateChangeEvent2_GetRemoteSessionDescription(self: *const T, pbstrContentType: ?*?BSTR, pbstrSessionDescription: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionStateChangeEvent2.VTable, @ptrCast(self.vtable)).GetRemoteSessionDescription(@as(*const IRTCSessionStateChangeEvent2, @ptrCast(self)), pbstrContentType, pbstrSessionDescription);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSessionOperationCompleteEvent_Value = Guid.initString("a6bff4c0-f7c8-4d3c-9a41-3550f78a95b0");
pub const IID_IRTCSessionOperationCompleteEvent = &IID_IRTCSessionOperationCompleteEvent_Value;
pub const IRTCSessionOperationCompleteEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionOperationCompleteEvent,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionOperationCompleteEvent,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cookie: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionOperationCompleteEvent,
                plCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionOperationCompleteEvent,
                plCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionOperationCompleteEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionOperationCompleteEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionOperationCompleteEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionOperationCompleteEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionOperationCompleteEvent_get_Session(self: *const T, ppSession: ?*?*IRTCSession) HRESULT {
                return @as(*const IRTCSessionOperationCompleteEvent.VTable, @ptrCast(self.vtable)).get_Session(@as(*const IRTCSessionOperationCompleteEvent, @ptrCast(self)), ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionOperationCompleteEvent_get_Cookie(self: *const T, plCookie: ?*isize) HRESULT {
                return @as(*const IRTCSessionOperationCompleteEvent.VTable, @ptrCast(self.vtable)).get_Cookie(@as(*const IRTCSessionOperationCompleteEvent, @ptrCast(self)), plCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionOperationCompleteEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCSessionOperationCompleteEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCSessionOperationCompleteEvent, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionOperationCompleteEvent_get_StatusText(self: *const T, pbstrStatusText: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionOperationCompleteEvent.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IRTCSessionOperationCompleteEvent, @ptrCast(self)), pbstrStatusText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSessionOperationCompleteEvent2_Value = Guid.initString("f6fc2a9b-d5bc-4241-b436-1b8460c13832");
pub const IID_IRTCSessionOperationCompleteEvent2 = &IID_IRTCSessionOperationCompleteEvent2_Value;
pub const IRTCSessionOperationCompleteEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCSessionOperationCompleteEvent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Participant: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionOperationCompleteEvent2,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionOperationCompleteEvent2,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRemoteSessionDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionOperationCompleteEvent2,
                pbstrContentType: ?*?BSTR,
                pbstrSessionDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionOperationCompleteEvent2,
                pbstrContentType: ?*?BSTR,
                pbstrSessionDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCSessionOperationCompleteEvent.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionOperationCompleteEvent2_get_Participant(self: *const T, ppParticipant: ?*?*IRTCParticipant) HRESULT {
                return @as(*const IRTCSessionOperationCompleteEvent2.VTable, @ptrCast(self.vtable)).get_Participant(@as(*const IRTCSessionOperationCompleteEvent2, @ptrCast(self)), ppParticipant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionOperationCompleteEvent2_GetRemoteSessionDescription(self: *const T, pbstrContentType: ?*?BSTR, pbstrSessionDescription: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionOperationCompleteEvent2.VTable, @ptrCast(self.vtable)).GetRemoteSessionDescription(@as(*const IRTCSessionOperationCompleteEvent2, @ptrCast(self)), pbstrContentType, pbstrSessionDescription);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCParticipantStateChangeEvent_Value = Guid.initString("09bcb597-f0fa-48f9-b420-468cea7fde04");
pub const IID_IRTCParticipantStateChangeEvent = &IID_IRTCParticipantStateChangeEvent_Value;
pub const IRTCParticipantStateChangeEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Participant: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCParticipantStateChangeEvent,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCParticipantStateChangeEvent,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCParticipantStateChangeEvent,
                penState: ?*RTC_PARTICIPANT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCParticipantStateChangeEvent,
                penState: ?*RTC_PARTICIPANT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCParticipantStateChangeEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCParticipantStateChangeEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCParticipantStateChangeEvent_get_Participant(self: *const T, ppParticipant: ?*?*IRTCParticipant) HRESULT {
                return @as(*const IRTCParticipantStateChangeEvent.VTable, @ptrCast(self.vtable)).get_Participant(@as(*const IRTCParticipantStateChangeEvent, @ptrCast(self)), ppParticipant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCParticipantStateChangeEvent_get_State(self: *const T, penState: ?*RTC_PARTICIPANT_STATE) HRESULT {
                return @as(*const IRTCParticipantStateChangeEvent.VTable, @ptrCast(self.vtable)).get_State(@as(*const IRTCParticipantStateChangeEvent, @ptrCast(self)), penState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCParticipantStateChangeEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCParticipantStateChangeEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCParticipantStateChangeEvent, @ptrCast(self)), plStatusCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCMediaEvent_Value = Guid.initString("099944fb-bcda-453e-8c41-e13da2adf7f3");
pub const IID_IRTCMediaEvent = &IID_IRTCMediaEvent_Value;
pub const IRTCMediaEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMediaEvent,
                pMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMediaEvent,
                pMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMediaEvent,
                penEventType: ?*RTC_MEDIA_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMediaEvent,
                penEventType: ?*RTC_MEDIA_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventReason: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMediaEvent,
                penEventReason: ?*RTC_MEDIA_EVENT_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMediaEvent,
                penEventReason: ?*RTC_MEDIA_EVENT_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaEvent_get_MediaType(self: *const T, pMediaType: ?*i32) HRESULT {
                return @as(*const IRTCMediaEvent.VTable, @ptrCast(self.vtable)).get_MediaType(@as(*const IRTCMediaEvent, @ptrCast(self)), pMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaEvent_get_EventType(self: *const T, penEventType: ?*RTC_MEDIA_EVENT_TYPE) HRESULT {
                return @as(*const IRTCMediaEvent.VTable, @ptrCast(self.vtable)).get_EventType(@as(*const IRTCMediaEvent, @ptrCast(self)), penEventType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaEvent_get_EventReason(self: *const T, penEventReason: ?*RTC_MEDIA_EVENT_REASON) HRESULT {
                return @as(*const IRTCMediaEvent.VTable, @ptrCast(self.vtable)).get_EventReason(@as(*const IRTCMediaEvent, @ptrCast(self)), penEventReason);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCIntensityEvent_Value = Guid.initString("4c23bf51-390c-4992-a41d-41eec05b2a4b");
pub const IID_IRTCIntensityEvent = &IID_IRTCIntensityEvent_Value;
pub const IRTCIntensityEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Level: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCIntensityEvent,
                plLevel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCIntensityEvent,
                plLevel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Min: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCIntensityEvent,
                plMin: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCIntensityEvent,
                plMin: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Max: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCIntensityEvent,
                plMax: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCIntensityEvent,
                plMax: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Direction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCIntensityEvent,
                penDirection: ?*RTC_AUDIO_DEVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCIntensityEvent,
                penDirection: ?*RTC_AUDIO_DEVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCIntensityEvent_get_Level(self: *const T, plLevel: ?*i32) HRESULT {
                return @as(*const IRTCIntensityEvent.VTable, @ptrCast(self.vtable)).get_Level(@as(*const IRTCIntensityEvent, @ptrCast(self)), plLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCIntensityEvent_get_Min(self: *const T, plMin: ?*i32) HRESULT {
                return @as(*const IRTCIntensityEvent.VTable, @ptrCast(self.vtable)).get_Min(@as(*const IRTCIntensityEvent, @ptrCast(self)), plMin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCIntensityEvent_get_Max(self: *const T, plMax: ?*i32) HRESULT {
                return @as(*const IRTCIntensityEvent.VTable, @ptrCast(self.vtable)).get_Max(@as(*const IRTCIntensityEvent, @ptrCast(self)), plMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCIntensityEvent_get_Direction(self: *const T, penDirection: ?*RTC_AUDIO_DEVICE) HRESULT {
                return @as(*const IRTCIntensityEvent.VTable, @ptrCast(self.vtable)).get_Direction(@as(*const IRTCIntensityEvent, @ptrCast(self)), penDirection);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCMessagingEvent_Value = Guid.initString("d3609541-1b29-4de5-a4ad-5aebaf319512");
pub const IID_IRTCMessagingEvent = &IID_IRTCMessagingEvent_Value;
pub const IRTCMessagingEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMessagingEvent,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMessagingEvent,
                ppSession: ?*?*IRTCSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Participant: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMessagingEvent,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMessagingEvent,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMessagingEvent,
                penEventType: ?*RTC_MESSAGING_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMessagingEvent,
                penEventType: ?*RTC_MESSAGING_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Message: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMessagingEvent,
                pbstrMessage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMessagingEvent,
                pbstrMessage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MessageHeader: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMessagingEvent,
                pbstrMessageHeader: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMessagingEvent,
                pbstrMessageHeader: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMessagingEvent,
                penUserStatus: ?*RTC_MESSAGING_USER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMessagingEvent,
                penUserStatus: ?*RTC_MESSAGING_USER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMessagingEvent_get_Session(self: *const T, ppSession: ?*?*IRTCSession) HRESULT {
                return @as(*const IRTCMessagingEvent.VTable, @ptrCast(self.vtable)).get_Session(@as(*const IRTCMessagingEvent, @ptrCast(self)), ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMessagingEvent_get_Participant(self: *const T, ppParticipant: ?*?*IRTCParticipant) HRESULT {
                return @as(*const IRTCMessagingEvent.VTable, @ptrCast(self.vtable)).get_Participant(@as(*const IRTCMessagingEvent, @ptrCast(self)), ppParticipant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMessagingEvent_get_EventType(self: *const T, penEventType: ?*RTC_MESSAGING_EVENT_TYPE) HRESULT {
                return @as(*const IRTCMessagingEvent.VTable, @ptrCast(self.vtable)).get_EventType(@as(*const IRTCMessagingEvent, @ptrCast(self)), penEventType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMessagingEvent_get_Message(self: *const T, pbstrMessage: ?*?BSTR) HRESULT {
                return @as(*const IRTCMessagingEvent.VTable, @ptrCast(self.vtable)).get_Message(@as(*const IRTCMessagingEvent, @ptrCast(self)), pbstrMessage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMessagingEvent_get_MessageHeader(self: *const T, pbstrMessageHeader: ?*?BSTR) HRESULT {
                return @as(*const IRTCMessagingEvent.VTable, @ptrCast(self.vtable)).get_MessageHeader(@as(*const IRTCMessagingEvent, @ptrCast(self)), pbstrMessageHeader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMessagingEvent_get_UserStatus(self: *const T, penUserStatus: ?*RTC_MESSAGING_USER_STATUS) HRESULT {
                return @as(*const IRTCMessagingEvent.VTable, @ptrCast(self.vtable)).get_UserStatus(@as(*const IRTCMessagingEvent, @ptrCast(self)), penUserStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCBuddyEvent_Value = Guid.initString("f36d755d-17e6-404e-954f-0fc07574c78d");
pub const IID_IRTCBuddyEvent = &IID_IRTCBuddyEvent_Value;
pub const IRTCBuddyEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Buddy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyEvent,
                ppBuddy: ?*?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyEvent,
                ppBuddy: ?*?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyEvent_get_Buddy(self: *const T, ppBuddy: ?*?*IRTCBuddy) HRESULT {
                return @as(*const IRTCBuddyEvent.VTable, @ptrCast(self.vtable)).get_Buddy(@as(*const IRTCBuddyEvent, @ptrCast(self)), ppBuddy);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCBuddyEvent2_Value = Guid.initString("484a7f1e-73f0-4990-bfc2-60bc3978a720");
pub const IID_IRTCBuddyEvent2 = &IID_IRTCBuddyEvent2_Value;
pub const IRTCBuddyEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCBuddyEvent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyEvent2,
                pEventType: ?*RTC_BUDDY_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyEvent2,
                pEventType: ?*RTC_BUDDY_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyEvent2,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyEvent2,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyEvent2,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyEvent2,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCBuddyEvent.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyEvent2_get_EventType(self: *const T, pEventType: ?*RTC_BUDDY_EVENT_TYPE) HRESULT {
                return @as(*const IRTCBuddyEvent2.VTable, @ptrCast(self.vtable)).get_EventType(@as(*const IRTCBuddyEvent2, @ptrCast(self)), pEventType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyEvent2_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCBuddyEvent2.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCBuddyEvent2, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyEvent2_get_StatusText(self: *const T, pbstrStatusText: ?*?BSTR) HRESULT {
                return @as(*const IRTCBuddyEvent2.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IRTCBuddyEvent2, @ptrCast(self)), pbstrStatusText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCWatcherEvent_Value = Guid.initString("f30d7261-587a-424f-822c-312788f43548");
pub const IID_IRTCWatcherEvent = &IID_IRTCWatcherEvent_Value;
pub const IRTCWatcherEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Watcher: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCWatcherEvent,
                ppWatcher: ?*?*IRTCWatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCWatcherEvent,
                ppWatcher: ?*?*IRTCWatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCWatcherEvent_get_Watcher(self: *const T, ppWatcher: ?*?*IRTCWatcher) HRESULT {
                return @as(*const IRTCWatcherEvent.VTable, @ptrCast(self.vtable)).get_Watcher(@as(*const IRTCWatcherEvent, @ptrCast(self)), ppWatcher);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCWatcherEvent2_Value = Guid.initString("e52891e8-188c-49af-b005-98ed13f83f9c");
pub const IID_IRTCWatcherEvent2 = &IID_IRTCWatcherEvent2_Value;
pub const IRTCWatcherEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCWatcherEvent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCWatcherEvent2,
                pEventType: ?*RTC_WATCHER_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCWatcherEvent2,
                pEventType: ?*RTC_WATCHER_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCWatcherEvent2,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCWatcherEvent2,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCWatcherEvent.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCWatcherEvent2_get_EventType(self: *const T, pEventType: ?*RTC_WATCHER_EVENT_TYPE) HRESULT {
                return @as(*const IRTCWatcherEvent2.VTable, @ptrCast(self.vtable)).get_EventType(@as(*const IRTCWatcherEvent2, @ptrCast(self)), pEventType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCWatcherEvent2_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCWatcherEvent2.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCWatcherEvent2, @ptrCast(self)), plStatusCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCBuddyGroupEvent_Value = Guid.initString("3a79e1d1-b736-4414-96f8-bbc7f08863e4");
pub const IID_IRTCBuddyGroupEvent = &IID_IRTCBuddyGroupEvent_Value;
pub const IRTCBuddyGroupEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroupEvent,
                pEventType: ?*RTC_GROUP_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroupEvent,
                pEventType: ?*RTC_GROUP_EVENT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Group: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroupEvent,
                ppGroup: ?*?*IRTCBuddyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroupEvent,
                ppGroup: ?*?*IRTCBuddyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Buddy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroupEvent,
                ppBuddy: ?*?*IRTCBuddy2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroupEvent,
                ppBuddy: ?*?*IRTCBuddy2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroupEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroupEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroupEvent_get_EventType(self: *const T, pEventType: ?*RTC_GROUP_EVENT_TYPE) HRESULT {
                return @as(*const IRTCBuddyGroupEvent.VTable, @ptrCast(self.vtable)).get_EventType(@as(*const IRTCBuddyGroupEvent, @ptrCast(self)), pEventType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroupEvent_get_Group(self: *const T, ppGroup: ?*?*IRTCBuddyGroup) HRESULT {
                return @as(*const IRTCBuddyGroupEvent.VTable, @ptrCast(self.vtable)).get_Group(@as(*const IRTCBuddyGroupEvent, @ptrCast(self)), ppGroup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroupEvent_get_Buddy(self: *const T, ppBuddy: ?*?*IRTCBuddy2) HRESULT {
                return @as(*const IRTCBuddyGroupEvent.VTable, @ptrCast(self.vtable)).get_Buddy(@as(*const IRTCBuddyGroupEvent, @ptrCast(self)), ppBuddy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroupEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCBuddyGroupEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCBuddyGroupEvent, @ptrCast(self)), plStatusCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCInfoEvent_Value = Guid.initString("4e1d68ae-1912-4f49-b2c3-594fadfd425f");
pub const IID_IRTCInfoEvent = &IID_IRTCInfoEvent_Value;
pub const IRTCInfoEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCInfoEvent,
                ppSession: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCInfoEvent,
                ppSession: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Participant: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCInfoEvent,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCInfoEvent,
                ppParticipant: ?*?*IRTCParticipant,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Info: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCInfoEvent,
                pbstrInfo: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCInfoEvent,
                pbstrInfo: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InfoHeader: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCInfoEvent,
                pbstrInfoHeader: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCInfoEvent,
                pbstrInfoHeader: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCInfoEvent_get_Session(self: *const T, ppSession: ?*?*IRTCSession2) HRESULT {
                return @as(*const IRTCInfoEvent.VTable, @ptrCast(self.vtable)).get_Session(@as(*const IRTCInfoEvent, @ptrCast(self)), ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCInfoEvent_get_Participant(self: *const T, ppParticipant: ?*?*IRTCParticipant) HRESULT {
                return @as(*const IRTCInfoEvent.VTable, @ptrCast(self.vtable)).get_Participant(@as(*const IRTCInfoEvent, @ptrCast(self)), ppParticipant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCInfoEvent_get_Info(self: *const T, pbstrInfo: ?*?BSTR) HRESULT {
                return @as(*const IRTCInfoEvent.VTable, @ptrCast(self.vtable)).get_Info(@as(*const IRTCInfoEvent, @ptrCast(self)), pbstrInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCInfoEvent_get_InfoHeader(self: *const T, pbstrInfoHeader: ?*?BSTR) HRESULT {
                return @as(*const IRTCInfoEvent.VTable, @ptrCast(self.vtable)).get_InfoHeader(@as(*const IRTCInfoEvent, @ptrCast(self)), pbstrInfoHeader);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCMediaRequestEvent_Value = Guid.initString("52572d15-148c-4d97-a36c-2da55c289d63");
pub const IID_IRTCMediaRequestEvent = &IID_IRTCMediaRequestEvent_Value;
pub const IRTCMediaRequestEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMediaRequestEvent,
                ppSession: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMediaRequestEvent,
                ppSession: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProposedMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMediaRequestEvent,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMediaRequestEvent,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMediaRequestEvent,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMediaRequestEvent,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Accept: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCMediaRequestEvent,
                lMediaTypes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCMediaRequestEvent,
                lMediaTypes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemotePreferredSecurityLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMediaRequestEvent,
                enSecurityType: RTC_SECURITY_TYPE,
                penSecurityLevel: ?*RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMediaRequestEvent,
                enSecurityType: RTC_SECURITY_TYPE,
                penSecurityLevel: ?*RTC_SECURITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCMediaRequestEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCMediaRequestEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCMediaRequestEvent,
                pState: ?*RTC_REINVITE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCMediaRequestEvent,
                pState: ?*RTC_REINVITE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaRequestEvent_get_Session(self: *const T, ppSession: ?*?*IRTCSession2) HRESULT {
                return @as(*const IRTCMediaRequestEvent.VTable, @ptrCast(self.vtable)).get_Session(@as(*const IRTCMediaRequestEvent, @ptrCast(self)), ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaRequestEvent_get_ProposedMedia(self: *const T, plMediaTypes: ?*i32) HRESULT {
                return @as(*const IRTCMediaRequestEvent.VTable, @ptrCast(self.vtable)).get_ProposedMedia(@as(*const IRTCMediaRequestEvent, @ptrCast(self)), plMediaTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaRequestEvent_get_CurrentMedia(self: *const T, plMediaTypes: ?*i32) HRESULT {
                return @as(*const IRTCMediaRequestEvent.VTable, @ptrCast(self.vtable)).get_CurrentMedia(@as(*const IRTCMediaRequestEvent, @ptrCast(self)), plMediaTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaRequestEvent_Accept(self: *const T, lMediaTypes: i32) HRESULT {
                return @as(*const IRTCMediaRequestEvent.VTable, @ptrCast(self.vtable)).Accept(@as(*const IRTCMediaRequestEvent, @ptrCast(self)), lMediaTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaRequestEvent_get_RemotePreferredSecurityLevel(self: *const T, enSecurityType: RTC_SECURITY_TYPE, penSecurityLevel: ?*RTC_SECURITY_LEVEL) HRESULT {
                return @as(*const IRTCMediaRequestEvent.VTable, @ptrCast(self.vtable)).get_RemotePreferredSecurityLevel(@as(*const IRTCMediaRequestEvent, @ptrCast(self)), enSecurityType, penSecurityLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaRequestEvent_Reject(self: *const T) HRESULT {
                return @as(*const IRTCMediaRequestEvent.VTable, @ptrCast(self.vtable)).Reject(@as(*const IRTCMediaRequestEvent, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCMediaRequestEvent_get_State(self: *const T, pState: ?*RTC_REINVITE_STATE) HRESULT {
                return @as(*const IRTCMediaRequestEvent.VTable, @ptrCast(self.vtable)).get_State(@as(*const IRTCMediaRequestEvent, @ptrCast(self)), pState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCReInviteEvent_Value = Guid.initString("11558d84-204c-43e7-99b0-2034e9417f7d");
pub const IID_IRTCReInviteEvent = &IID_IRTCReInviteEvent_Value;
pub const IRTCReInviteEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCReInviteEvent,
                ppSession2: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCReInviteEvent,
                ppSession2: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Accept: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCReInviteEvent,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCReInviteEvent,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCReInviteEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCReInviteEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCReInviteEvent,
                pState: ?*RTC_REINVITE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCReInviteEvent,
                pState: ?*RTC_REINVITE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRemoteSessionDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCReInviteEvent,
                pbstrContentType: ?*?BSTR,
                pbstrSessionDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCReInviteEvent,
                pbstrContentType: ?*?BSTR,
                pbstrSessionDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCReInviteEvent_get_Session(self: *const T, ppSession2: ?*?*IRTCSession2) HRESULT {
                return @as(*const IRTCReInviteEvent.VTable, @ptrCast(self.vtable)).get_Session(@as(*const IRTCReInviteEvent, @ptrCast(self)), ppSession2);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCReInviteEvent_Accept(self: *const T, bstrContentType: ?BSTR, bstrSessionDescription: ?BSTR) HRESULT {
                return @as(*const IRTCReInviteEvent.VTable, @ptrCast(self.vtable)).Accept(@as(*const IRTCReInviteEvent, @ptrCast(self)), bstrContentType, bstrSessionDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCReInviteEvent_Reject(self: *const T) HRESULT {
                return @as(*const IRTCReInviteEvent.VTable, @ptrCast(self.vtable)).Reject(@as(*const IRTCReInviteEvent, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCReInviteEvent_get_State(self: *const T, pState: ?*RTC_REINVITE_STATE) HRESULT {
                return @as(*const IRTCReInviteEvent.VTable, @ptrCast(self.vtable)).get_State(@as(*const IRTCReInviteEvent, @ptrCast(self)), pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCReInviteEvent_GetRemoteSessionDescription(self: *const T, pbstrContentType: ?*?BSTR, pbstrSessionDescription: ?*?BSTR) HRESULT {
                return @as(*const IRTCReInviteEvent.VTable, @ptrCast(self.vtable)).GetRemoteSessionDescription(@as(*const IRTCReInviteEvent, @ptrCast(self)), pbstrContentType, pbstrSessionDescription);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCPresencePropertyEvent_Value = Guid.initString("f777f570-a820-49d5-86bd-e099493f1518");
pub const IID_IRTCPresencePropertyEvent = &IID_IRTCPresencePropertyEvent_Value;
pub const IRTCPresencePropertyEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresencePropertyEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresencePropertyEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresencePropertyEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresencePropertyEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PresenceProperty: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresencePropertyEvent,
                penPresProp: ?*RTC_PRESENCE_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresencePropertyEvent,
                penPresProp: ?*RTC_PRESENCE_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresencePropertyEvent,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresencePropertyEvent,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresencePropertyEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCPresencePropertyEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCPresencePropertyEvent, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresencePropertyEvent_get_StatusText(self: *const T, pbstrStatusText: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresencePropertyEvent.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IRTCPresencePropertyEvent, @ptrCast(self)), pbstrStatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresencePropertyEvent_get_PresenceProperty(self: *const T, penPresProp: ?*RTC_PRESENCE_PROPERTY) HRESULT {
                return @as(*const IRTCPresencePropertyEvent.VTable, @ptrCast(self.vtable)).get_PresenceProperty(@as(*const IRTCPresencePropertyEvent, @ptrCast(self)), penPresProp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresencePropertyEvent_get_Value(self: *const T, pbstrValue: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresencePropertyEvent.VTable, @ptrCast(self.vtable)).get_Value(@as(*const IRTCPresencePropertyEvent, @ptrCast(self)), pbstrValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCPresenceDataEvent_Value = Guid.initString("38f0e78c-8b87-4c04-a82d-aedd83c909bb");
pub const IID_IRTCPresenceDataEvent = &IID_IRTCPresenceDataEvent_Value;
pub const IRTCPresenceDataEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceDataEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceDataEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceDataEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceDataEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresenceData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCPresenceDataEvent,
                pbstrNamespace: ?*?BSTR,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCPresenceDataEvent,
                pbstrNamespace: ?*?BSTR,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceDataEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCPresenceDataEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCPresenceDataEvent, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceDataEvent_get_StatusText(self: *const T, pbstrStatusText: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceDataEvent.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IRTCPresenceDataEvent, @ptrCast(self)), pbstrStatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceDataEvent_GetPresenceData(self: *const T, pbstrNamespace: ?*?BSTR, pbstrData: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceDataEvent.VTable, @ptrCast(self.vtable)).GetPresenceData(@as(*const IRTCPresenceDataEvent, @ptrCast(self)), pbstrNamespace, pbstrData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCPresenceStatusEvent_Value = Guid.initString("78673f32-4a0f-462c-89aa-ee7706707678");
pub const IID_IRTCPresenceStatusEvent = &IID_IRTCPresenceStatusEvent_Value;
pub const IRTCPresenceStatusEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceStatusEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceStatusEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceStatusEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceStatusEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocalPresenceInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCPresenceStatusEvent,
                penStatus: ?*RTC_PRESENCE_STATUS,
                pbstrNotes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCPresenceStatusEvent,
                penStatus: ?*RTC_PRESENCE_STATUS,
                pbstrNotes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceStatusEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCPresenceStatusEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCPresenceStatusEvent, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceStatusEvent_get_StatusText(self: *const T, pbstrStatusText: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceStatusEvent.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IRTCPresenceStatusEvent, @ptrCast(self)), pbstrStatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceStatusEvent_GetLocalPresenceInfo(self: *const T, penStatus: ?*RTC_PRESENCE_STATUS, pbstrNotes: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceStatusEvent.VTable, @ptrCast(self.vtable)).GetLocalPresenceInfo(@as(*const IRTCPresenceStatusEvent, @ptrCast(self)), penStatus, pbstrNotes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCCollection_Value = Guid.initString("ec7c8096-b918-4044-94f1-e4fba0361d5c");
pub const IID_IRTCCollection = &IID_IRTCCollection_Value;
pub const IRTCCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCCollection,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCCollection,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCCollection,
                Index: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCCollection,
                Index: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCCollection,
                ppNewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCCollection,
                ppNewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCCollection_get_Count(self: *const T, lCount: ?*i32) HRESULT {
                return @as(*const IRTCCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IRTCCollection, @ptrCast(self)), lCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCCollection_get_Item(self: *const T, Index: i32, pVariant: ?*VARIANT) HRESULT {
                return @as(*const IRTCCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IRTCCollection, @ptrCast(self)), Index, pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCCollection_get__NewEnum(self: *const T, ppNewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IRTCCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IRTCCollection, @ptrCast(self)), ppNewEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCEnumParticipants_Value = Guid.initString("fcd56f29-4a4f-41b2-ba5c-f5bccc060bf6");
pub const IID_IRTCEnumParticipants = &IID_IRTCEnumParticipants_Value;
pub const IRTCEnumParticipants = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumParticipants,
                celt: u32,
                ppElements: [*]?*IRTCParticipant,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumParticipants,
                celt: u32,
                ppElements: [*]?*IRTCParticipant,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumParticipants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumParticipants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumParticipants,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumParticipants,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumParticipants,
                ppEnum: ?*?*IRTCEnumParticipants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumParticipants,
                ppEnum: ?*?*IRTCEnumParticipants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumParticipants_Next(self: *const T, celt: u32, ppElements: [*]?*IRTCParticipant, pceltFetched: ?*u32) HRESULT {
                return @as(*const IRTCEnumParticipants.VTable, @ptrCast(self.vtable)).Next(@as(*const IRTCEnumParticipants, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumParticipants_Reset(self: *const T) HRESULT {
                return @as(*const IRTCEnumParticipants.VTable, @ptrCast(self.vtable)).Reset(@as(*const IRTCEnumParticipants, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumParticipants_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IRTCEnumParticipants.VTable, @ptrCast(self.vtable)).Skip(@as(*const IRTCEnumParticipants, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumParticipants_Clone(self: *const T, ppEnum: ?*?*IRTCEnumParticipants) HRESULT {
                return @as(*const IRTCEnumParticipants.VTable, @ptrCast(self.vtable)).Clone(@as(*const IRTCEnumParticipants, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCEnumProfiles_Value = Guid.initString("29b7c41c-ed82-4bca-84ad-39d5101b58e3");
pub const IID_IRTCEnumProfiles = &IID_IRTCEnumProfiles_Value;
pub const IRTCEnumProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumProfiles,
                celt: u32,
                ppElements: [*]?*IRTCProfile,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumProfiles,
                celt: u32,
                ppElements: [*]?*IRTCProfile,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumProfiles,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumProfiles,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumProfiles,
                ppEnum: ?*?*IRTCEnumProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumProfiles,
                ppEnum: ?*?*IRTCEnumProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumProfiles_Next(self: *const T, celt: u32, ppElements: [*]?*IRTCProfile, pceltFetched: ?*u32) HRESULT {
                return @as(*const IRTCEnumProfiles.VTable, @ptrCast(self.vtable)).Next(@as(*const IRTCEnumProfiles, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumProfiles_Reset(self: *const T) HRESULT {
                return @as(*const IRTCEnumProfiles.VTable, @ptrCast(self.vtable)).Reset(@as(*const IRTCEnumProfiles, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumProfiles_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IRTCEnumProfiles.VTable, @ptrCast(self.vtable)).Skip(@as(*const IRTCEnumProfiles, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumProfiles_Clone(self: *const T, ppEnum: ?*?*IRTCEnumProfiles) HRESULT {
                return @as(*const IRTCEnumProfiles.VTable, @ptrCast(self.vtable)).Clone(@as(*const IRTCEnumProfiles, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCEnumBuddies_Value = Guid.initString("f7296917-5569-4b3b-b3af-98d1144b2b87");
pub const IID_IRTCEnumBuddies = &IID_IRTCEnumBuddies_Value;
pub const IRTCEnumBuddies = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumBuddies,
                celt: u32,
                ppElements: [*]?*IRTCBuddy,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumBuddies,
                celt: u32,
                ppElements: [*]?*IRTCBuddy,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumBuddies,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumBuddies,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumBuddies,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumBuddies,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumBuddies,
                ppEnum: ?*?*IRTCEnumBuddies,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumBuddies,
                ppEnum: ?*?*IRTCEnumBuddies,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumBuddies_Next(self: *const T, celt: u32, ppElements: [*]?*IRTCBuddy, pceltFetched: ?*u32) HRESULT {
                return @as(*const IRTCEnumBuddies.VTable, @ptrCast(self.vtable)).Next(@as(*const IRTCEnumBuddies, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumBuddies_Reset(self: *const T) HRESULT {
                return @as(*const IRTCEnumBuddies.VTable, @ptrCast(self.vtable)).Reset(@as(*const IRTCEnumBuddies, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumBuddies_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IRTCEnumBuddies.VTable, @ptrCast(self.vtable)).Skip(@as(*const IRTCEnumBuddies, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumBuddies_Clone(self: *const T, ppEnum: ?*?*IRTCEnumBuddies) HRESULT {
                return @as(*const IRTCEnumBuddies.VTable, @ptrCast(self.vtable)).Clone(@as(*const IRTCEnumBuddies, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCEnumWatchers_Value = Guid.initString("a87d55d7-db74-4ed1-9ca4-77a0e41b413e");
pub const IID_IRTCEnumWatchers = &IID_IRTCEnumWatchers_Value;
pub const IRTCEnumWatchers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumWatchers,
                celt: u32,
                ppElements: [*]?*IRTCWatcher,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumWatchers,
                celt: u32,
                ppElements: [*]?*IRTCWatcher,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumWatchers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumWatchers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumWatchers,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumWatchers,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumWatchers,
                ppEnum: ?*?*IRTCEnumWatchers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumWatchers,
                ppEnum: ?*?*IRTCEnumWatchers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumWatchers_Next(self: *const T, celt: u32, ppElements: [*]?*IRTCWatcher, pceltFetched: ?*u32) HRESULT {
                return @as(*const IRTCEnumWatchers.VTable, @ptrCast(self.vtable)).Next(@as(*const IRTCEnumWatchers, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumWatchers_Reset(self: *const T) HRESULT {
                return @as(*const IRTCEnumWatchers.VTable, @ptrCast(self.vtable)).Reset(@as(*const IRTCEnumWatchers, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumWatchers_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IRTCEnumWatchers.VTable, @ptrCast(self.vtable)).Skip(@as(*const IRTCEnumWatchers, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumWatchers_Clone(self: *const T, ppEnum: ?*?*IRTCEnumWatchers) HRESULT {
                return @as(*const IRTCEnumWatchers.VTable, @ptrCast(self.vtable)).Clone(@as(*const IRTCEnumWatchers, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCEnumGroups_Value = Guid.initString("742378d6-a141-4415-8f27-35d99076cf5d");
pub const IID_IRTCEnumGroups = &IID_IRTCEnumGroups_Value;
pub const IRTCEnumGroups = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumGroups,
                celt: u32,
                ppElements: [*]?*IRTCBuddyGroup,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumGroups,
                celt: u32,
                ppElements: [*]?*IRTCBuddyGroup,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumGroups,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumGroups,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumGroups,
                ppEnum: ?*?*IRTCEnumGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumGroups,
                ppEnum: ?*?*IRTCEnumGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumGroups_Next(self: *const T, celt: u32, ppElements: [*]?*IRTCBuddyGroup, pceltFetched: ?*u32) HRESULT {
                return @as(*const IRTCEnumGroups.VTable, @ptrCast(self.vtable)).Next(@as(*const IRTCEnumGroups, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumGroups_Reset(self: *const T) HRESULT {
                return @as(*const IRTCEnumGroups.VTable, @ptrCast(self.vtable)).Reset(@as(*const IRTCEnumGroups, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumGroups_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IRTCEnumGroups.VTable, @ptrCast(self.vtable)).Skip(@as(*const IRTCEnumGroups, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumGroups_Clone(self: *const T, ppEnum: ?*?*IRTCEnumGroups) HRESULT {
                return @as(*const IRTCEnumGroups.VTable, @ptrCast(self.vtable)).Clone(@as(*const IRTCEnumGroups, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCPresenceContact_Value = Guid.initString("8b22f92c-cd90-42db-a733-212205c3e3df");
pub const IID_IRTCPresenceContact = &IID_IRTCPresenceContact_Value;
pub const IRTCPresenceContact = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PresentityURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceContact,
                pbstrPresentityURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceContact,
                pbstrPresentityURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PresentityURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceContact,
                bstrPresentityURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceContact,
                bstrPresentityURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceContact,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceContact,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceContact,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceContact,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceContact,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceContact,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceContact,
                bstrData: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceContact,
                bstrData: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Persistent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceContact,
                pfPersistent: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceContact,
                pfPersistent: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Persistent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceContact,
                fPersistent: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceContact,
                fPersistent: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceContact_get_PresentityURI(self: *const T, pbstrPresentityURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceContact.VTable, @ptrCast(self.vtable)).get_PresentityURI(@as(*const IRTCPresenceContact, @ptrCast(self)), pbstrPresentityURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceContact_put_PresentityURI(self: *const T, bstrPresentityURI: ?BSTR) HRESULT {
                return @as(*const IRTCPresenceContact.VTable, @ptrCast(self.vtable)).put_PresentityURI(@as(*const IRTCPresenceContact, @ptrCast(self)), bstrPresentityURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceContact_get_Name(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceContact.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IRTCPresenceContact, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceContact_put_Name(self: *const T, bstrName: ?BSTR) HRESULT {
                return @as(*const IRTCPresenceContact.VTable, @ptrCast(self.vtable)).put_Name(@as(*const IRTCPresenceContact, @ptrCast(self)), bstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceContact_get_Data(self: *const T, pbstrData: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceContact.VTable, @ptrCast(self.vtable)).get_Data(@as(*const IRTCPresenceContact, @ptrCast(self)), pbstrData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceContact_put_Data(self: *const T, bstrData: ?BSTR) HRESULT {
                return @as(*const IRTCPresenceContact.VTable, @ptrCast(self.vtable)).put_Data(@as(*const IRTCPresenceContact, @ptrCast(self)), bstrData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceContact_get_Persistent(self: *const T, pfPersistent: ?*i16) HRESULT {
                return @as(*const IRTCPresenceContact.VTable, @ptrCast(self.vtable)).get_Persistent(@as(*const IRTCPresenceContact, @ptrCast(self)), pfPersistent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceContact_put_Persistent(self: *const T, fPersistent: i16) HRESULT {
                return @as(*const IRTCPresenceContact.VTable, @ptrCast(self.vtable)).put_Persistent(@as(*const IRTCPresenceContact, @ptrCast(self)), fPersistent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCBuddy_Value = Guid.initString("fcb136c8-7b90-4e0c-befe-56edf0ba6f1c");
pub const IID_IRTCBuddy = &IID_IRTCBuddy_Value;
pub const IRTCBuddy = extern struct {
    pub const VTable = extern struct {
        base: IRTCPresenceContact.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddy,
                penStatus: ?*RTC_PRESENCE_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddy,
                penStatus: ?*RTC_PRESENCE_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Notes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddy,
                pbstrNotes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddy,
                pbstrNotes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCPresenceContact.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy_get_Status(self: *const T, penStatus: ?*RTC_PRESENCE_STATUS) HRESULT {
                return @as(*const IRTCBuddy.VTable, @ptrCast(self.vtable)).get_Status(@as(*const IRTCBuddy, @ptrCast(self)), penStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy_get_Notes(self: *const T, pbstrNotes: ?*?BSTR) HRESULT {
                return @as(*const IRTCBuddy.VTable, @ptrCast(self.vtable)).get_Notes(@as(*const IRTCBuddy, @ptrCast(self)), pbstrNotes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCBuddy2_Value = Guid.initString("102f9588-23e7-40e3-954d-cd7a1d5c0361");
pub const IID_IRTCBuddy2 = &IID_IRTCBuddy2_Value;
pub const IRTCBuddy2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCBuddy.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddy2,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddy2,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCBuddy2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCBuddy2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateGroups: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCBuddy2,
                ppEnum: ?*?*IRTCEnumGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCBuddy2,
                ppEnum: ?*?*IRTCEnumGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Groups: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddy2,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddy2,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PresenceProperty: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddy2,
                enProperty: RTC_PRESENCE_PROPERTY,
                pbstrProperty: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddy2,
                enProperty: RTC_PRESENCE_PROPERTY,
                pbstrProperty: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumeratePresenceDevices: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCBuddy2,
                ppEnumDevices: ?*?*IRTCEnumPresenceDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCBuddy2,
                ppEnumDevices: ?*?*IRTCEnumPresenceDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PresenceDevices: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddy2,
                ppDevicesCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddy2,
                ppDevicesCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubscriptionType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddy2,
                penSubscriptionType: ?*RTC_BUDDY_SUBSCRIPTION_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddy2,
                penSubscriptionType: ?*RTC_BUDDY_SUBSCRIPTION_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCBuddy.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy2_get_Profile(self: *const T, ppProfile: ?*?*IRTCProfile2) HRESULT {
                return @as(*const IRTCBuddy2.VTable, @ptrCast(self.vtable)).get_Profile(@as(*const IRTCBuddy2, @ptrCast(self)), ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy2_Refresh(self: *const T) HRESULT {
                return @as(*const IRTCBuddy2.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IRTCBuddy2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy2_EnumerateGroups(self: *const T, ppEnum: ?*?*IRTCEnumGroups) HRESULT {
                return @as(*const IRTCBuddy2.VTable, @ptrCast(self.vtable)).EnumerateGroups(@as(*const IRTCBuddy2, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy2_get_Groups(self: *const T, ppCollection: ?*?*IRTCCollection) HRESULT {
                return @as(*const IRTCBuddy2.VTable, @ptrCast(self.vtable)).get_Groups(@as(*const IRTCBuddy2, @ptrCast(self)), ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy2_get_PresenceProperty(self: *const T, enProperty: RTC_PRESENCE_PROPERTY, pbstrProperty: ?*?BSTR) HRESULT {
                return @as(*const IRTCBuddy2.VTable, @ptrCast(self.vtable)).get_PresenceProperty(@as(*const IRTCBuddy2, @ptrCast(self)), enProperty, pbstrProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy2_EnumeratePresenceDevices(self: *const T, ppEnumDevices: ?*?*IRTCEnumPresenceDevices) HRESULT {
                return @as(*const IRTCBuddy2.VTable, @ptrCast(self.vtable)).EnumeratePresenceDevices(@as(*const IRTCBuddy2, @ptrCast(self)), ppEnumDevices);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy2_get_PresenceDevices(self: *const T, ppDevicesCollection: ?*?*IRTCCollection) HRESULT {
                return @as(*const IRTCBuddy2.VTable, @ptrCast(self.vtable)).get_PresenceDevices(@as(*const IRTCBuddy2, @ptrCast(self)), ppDevicesCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddy2_get_SubscriptionType(self: *const T, penSubscriptionType: ?*RTC_BUDDY_SUBSCRIPTION_TYPE) HRESULT {
                return @as(*const IRTCBuddy2.VTable, @ptrCast(self.vtable)).get_SubscriptionType(@as(*const IRTCBuddy2, @ptrCast(self)), penSubscriptionType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCWatcher_Value = Guid.initString("c7cedad8-346b-4d1b-ac02-a2088df9be4f");
pub const IID_IRTCWatcher = &IID_IRTCWatcher_Value;
pub const IRTCWatcher = extern struct {
    pub const VTable = extern struct {
        base: IRTCPresenceContact.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCWatcher,
                penState: ?*RTC_WATCHER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCWatcher,
                penState: ?*RTC_WATCHER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCWatcher,
                enState: RTC_WATCHER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCWatcher,
                enState: RTC_WATCHER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCPresenceContact.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCWatcher_get_State(self: *const T, penState: ?*RTC_WATCHER_STATE) HRESULT {
                return @as(*const IRTCWatcher.VTable, @ptrCast(self.vtable)).get_State(@as(*const IRTCWatcher, @ptrCast(self)), penState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCWatcher_put_State(self: *const T, enState: RTC_WATCHER_STATE) HRESULT {
                return @as(*const IRTCWatcher.VTable, @ptrCast(self.vtable)).put_State(@as(*const IRTCWatcher, @ptrCast(self)), enState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCWatcher2_Value = Guid.initString("d4d9967f-d011-4b1d-91e3-aba78f96393d");
pub const IID_IRTCWatcher2 = &IID_IRTCWatcher2_Value;
pub const IRTCWatcher2 = extern struct {
    pub const VTable = extern struct {
        base: IRTCWatcher.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCWatcher2,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCWatcher2,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCWatcher2,
                penScope: ?*RTC_ACE_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCWatcher2,
                penScope: ?*RTC_ACE_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRTCWatcher.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCWatcher2_get_Profile(self: *const T, ppProfile: ?*?*IRTCProfile2) HRESULT {
                return @as(*const IRTCWatcher2.VTable, @ptrCast(self.vtable)).get_Profile(@as(*const IRTCWatcher2, @ptrCast(self)), ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCWatcher2_get_Scope(self: *const T, penScope: ?*RTC_ACE_SCOPE) HRESULT {
                return @as(*const IRTCWatcher2.VTable, @ptrCast(self.vtable)).get_Scope(@as(*const IRTCWatcher2, @ptrCast(self)), penScope);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCBuddyGroup_Value = Guid.initString("60361e68-9164-4389-a4c6-d0b3925bda5e");
pub const IID_IRTCBuddyGroup = &IID_IRTCBuddyGroup_Value;
pub const IRTCBuddyGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroup,
                pbstrGroupName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroup,
                pbstrGroupName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroup,
                bstrGroupName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroup,
                bstrGroupName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBuddy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCBuddyGroup,
                pBuddy: ?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCBuddyGroup,
                pBuddy: ?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBuddy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCBuddyGroup,
                pBuddy: ?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCBuddyGroup,
                pBuddy: ?*IRTCBuddy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateBuddies: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCBuddyGroup,
                ppEnum: ?*?*IRTCEnumBuddies,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCBuddyGroup,
                ppEnum: ?*?*IRTCEnumBuddies,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Buddies: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroup,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroup,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroup,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroup,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroup,
                bstrData: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroup,
                bstrData: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCBuddyGroup,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCBuddyGroup,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroup_get_Name(self: *const T, pbstrGroupName: ?*?BSTR) HRESULT {
                return @as(*const IRTCBuddyGroup.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IRTCBuddyGroup, @ptrCast(self)), pbstrGroupName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroup_put_Name(self: *const T, bstrGroupName: ?BSTR) HRESULT {
                return @as(*const IRTCBuddyGroup.VTable, @ptrCast(self.vtable)).put_Name(@as(*const IRTCBuddyGroup, @ptrCast(self)), bstrGroupName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroup_AddBuddy(self: *const T, pBuddy: ?*IRTCBuddy) HRESULT {
                return @as(*const IRTCBuddyGroup.VTable, @ptrCast(self.vtable)).AddBuddy(@as(*const IRTCBuddyGroup, @ptrCast(self)), pBuddy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroup_RemoveBuddy(self: *const T, pBuddy: ?*IRTCBuddy) HRESULT {
                return @as(*const IRTCBuddyGroup.VTable, @ptrCast(self.vtable)).RemoveBuddy(@as(*const IRTCBuddyGroup, @ptrCast(self)), pBuddy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroup_EnumerateBuddies(self: *const T, ppEnum: ?*?*IRTCEnumBuddies) HRESULT {
                return @as(*const IRTCBuddyGroup.VTable, @ptrCast(self.vtable)).EnumerateBuddies(@as(*const IRTCBuddyGroup, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroup_get_Buddies(self: *const T, ppCollection: ?*?*IRTCCollection) HRESULT {
                return @as(*const IRTCBuddyGroup.VTable, @ptrCast(self.vtable)).get_Buddies(@as(*const IRTCBuddyGroup, @ptrCast(self)), ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroup_get_Data(self: *const T, pbstrData: ?*?BSTR) HRESULT {
                return @as(*const IRTCBuddyGroup.VTable, @ptrCast(self.vtable)).get_Data(@as(*const IRTCBuddyGroup, @ptrCast(self)), pbstrData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroup_put_Data(self: *const T, bstrData: ?BSTR) HRESULT {
                return @as(*const IRTCBuddyGroup.VTable, @ptrCast(self.vtable)).put_Data(@as(*const IRTCBuddyGroup, @ptrCast(self)), bstrData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCBuddyGroup_get_Profile(self: *const T, ppProfile: ?*?*IRTCProfile2) HRESULT {
                return @as(*const IRTCBuddyGroup.VTable, @ptrCast(self.vtable)).get_Profile(@as(*const IRTCBuddyGroup, @ptrCast(self)), ppProfile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCEventNotification_Value = Guid.initString("13fa24c7-5748-4b21-91f5-7397609ce747");
pub const IID_IRTCEventNotification = &IID_IRTCEventNotification_Value;
pub const IRTCEventNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Event: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEventNotification,
                RTCEvent: RTC_EVENT,
                pEvent: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEventNotification,
                RTCEvent: RTC_EVENT,
                pEvent: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEventNotification_Event(self: *const T, RTCEvent: RTC_EVENT, pEvent: ?*IDispatch) HRESULT {
                return @as(*const IRTCEventNotification.VTable, @ptrCast(self.vtable)).Event(@as(*const IRTCEventNotification, @ptrCast(self)), RTCEvent, pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCPortManager_Value = Guid.initString("da77c14b-6208-43ca-8ddf-5b60a0a69fac");
pub const IID_IRTCPortManager = &IID_IRTCPortManager_Value;
pub const IRTCPortManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCPortManager,
                bstrRemoteAddress: ?BSTR,
                enPortType: RTC_PORT_TYPE,
                pbstrInternalLocalAddress: ?*?BSTR,
                plInternalLocalPort: ?*i32,
                pbstrExternalLocalAddress: ?*?BSTR,
                plExternalLocalPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCPortManager,
                bstrRemoteAddress: ?BSTR,
                enPortType: RTC_PORT_TYPE,
                pbstrInternalLocalAddress: ?*?BSTR,
                plInternalLocalPort: ?*i32,
                pbstrExternalLocalAddress: ?*?BSTR,
                plExternalLocalPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateRemoteAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCPortManager,
                bstrRemoteAddress: ?BSTR,
                bstrInternalLocalAddress: ?BSTR,
                lInternalLocalPort: i32,
                bstrExternalLocalAddress: ?BSTR,
                lExternalLocalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCPortManager,
                bstrRemoteAddress: ?BSTR,
                bstrInternalLocalAddress: ?BSTR,
                lInternalLocalPort: i32,
                bstrExternalLocalAddress: ?BSTR,
                lExternalLocalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCPortManager,
                bstrInternalLocalAddress: ?BSTR,
                lInternalLocalPort: i32,
                bstrExternalLocalAddress: ?BSTR,
                lExternalLocalAddress: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCPortManager,
                bstrInternalLocalAddress: ?BSTR,
                lInternalLocalPort: i32,
                bstrExternalLocalAddress: ?BSTR,
                lExternalLocalAddress: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPortManager_GetMapping(self: *const T, bstrRemoteAddress: ?BSTR, enPortType: RTC_PORT_TYPE, pbstrInternalLocalAddress: ?*?BSTR, plInternalLocalPort: ?*i32, pbstrExternalLocalAddress: ?*?BSTR, plExternalLocalPort: ?*i32) HRESULT {
                return @as(*const IRTCPortManager.VTable, @ptrCast(self.vtable)).GetMapping(@as(*const IRTCPortManager, @ptrCast(self)), bstrRemoteAddress, enPortType, pbstrInternalLocalAddress, plInternalLocalPort, pbstrExternalLocalAddress, plExternalLocalPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPortManager_UpdateRemoteAddress(self: *const T, bstrRemoteAddress: ?BSTR, bstrInternalLocalAddress: ?BSTR, lInternalLocalPort: i32, bstrExternalLocalAddress: ?BSTR, lExternalLocalPort: i32) HRESULT {
                return @as(*const IRTCPortManager.VTable, @ptrCast(self.vtable)).UpdateRemoteAddress(@as(*const IRTCPortManager, @ptrCast(self)), bstrRemoteAddress, bstrInternalLocalAddress, lInternalLocalPort, bstrExternalLocalAddress, lExternalLocalPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPortManager_ReleaseMapping(self: *const T, bstrInternalLocalAddress: ?BSTR, lInternalLocalPort: i32, bstrExternalLocalAddress: ?BSTR, lExternalLocalAddress: i32) HRESULT {
                return @as(*const IRTCPortManager.VTable, @ptrCast(self.vtable)).ReleaseMapping(@as(*const IRTCPortManager, @ptrCast(self)), bstrInternalLocalAddress, lInternalLocalPort, bstrExternalLocalAddress, lExternalLocalAddress);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSessionPortManagement_Value = Guid.initString("a072f1d6-0286-4e1f-85f2-17a2948456ec");
pub const IID_IRTCSessionPortManagement = &IID_IRTCSessionPortManagement_Value;
pub const IRTCSessionPortManagement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPortManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionPortManagement,
                pPortManager: ?*IRTCPortManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionPortManagement,
                pPortManager: ?*IRTCPortManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionPortManagement_SetPortManager(self: *const T, pPortManager: ?*IRTCPortManager) HRESULT {
                return @as(*const IRTCSessionPortManagement.VTable, @ptrCast(self.vtable)).SetPortManager(@as(*const IRTCSessionPortManagement, @ptrCast(self)), pPortManager);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCClientPortManagement_Value = Guid.initString("d5df3f03-4bde-4417-aefe-71177bdaea66");
pub const IID_IRTCClientPortManagement = &IID_IRTCClientPortManagement_Value;
pub const IRTCClientPortManagement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartListenAddressAndPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPortManagement,
                bstrInternalLocalAddress: ?BSTR,
                lInternalLocalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPortManagement,
                bstrInternalLocalAddress: ?BSTR,
                lInternalLocalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopListenAddressAndPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPortManagement,
                bstrInternalLocalAddress: ?BSTR,
                lInternalLocalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPortManagement,
                bstrInternalLocalAddress: ?BSTR,
                lInternalLocalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPortRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCClientPortManagement,
                enPortType: RTC_PORT_TYPE,
                plMinValue: ?*i32,
                plMaxValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCClientPortManagement,
                enPortType: RTC_PORT_TYPE,
                plMinValue: ?*i32,
                plMaxValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPortManagement_StartListenAddressAndPort(self: *const T, bstrInternalLocalAddress: ?BSTR, lInternalLocalPort: i32) HRESULT {
                return @as(*const IRTCClientPortManagement.VTable, @ptrCast(self.vtable)).StartListenAddressAndPort(@as(*const IRTCClientPortManagement, @ptrCast(self)), bstrInternalLocalAddress, lInternalLocalPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPortManagement_StopListenAddressAndPort(self: *const T, bstrInternalLocalAddress: ?BSTR, lInternalLocalPort: i32) HRESULT {
                return @as(*const IRTCClientPortManagement.VTable, @ptrCast(self.vtable)).StopListenAddressAndPort(@as(*const IRTCClientPortManagement, @ptrCast(self)), bstrInternalLocalAddress, lInternalLocalPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCClientPortManagement_GetPortRange(self: *const T, enPortType: RTC_PORT_TYPE, plMinValue: ?*i32, plMaxValue: ?*i32) HRESULT {
                return @as(*const IRTCClientPortManagement.VTable, @ptrCast(self.vtable)).GetPortRange(@as(*const IRTCClientPortManagement, @ptrCast(self)), enPortType, plMinValue, plMaxValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCUserSearch_Value = Guid.initString("b619882b-860c-4db4-be1b-693b6505bbe5");
pub const IID_IRTCUserSearch = &IID_IRTCUserSearch_Value;
pub const IRTCUserSearch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCUserSearch,
                ppQuery: ?*?*IRTCUserSearchQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCUserSearch,
                ppQuery: ?*?*IRTCUserSearchQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteSearch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCUserSearch,
                pQuery: ?*IRTCUserSearchQuery,
                pProfile: ?*IRTCProfile,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCUserSearch,
                pQuery: ?*IRTCUserSearchQuery,
                pProfile: ?*IRTCProfile,
                lCookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearch_CreateQuery(self: *const T, ppQuery: ?*?*IRTCUserSearchQuery) HRESULT {
                return @as(*const IRTCUserSearch.VTable, @ptrCast(self.vtable)).CreateQuery(@as(*const IRTCUserSearch, @ptrCast(self)), ppQuery);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearch_ExecuteSearch(self: *const T, pQuery: ?*IRTCUserSearchQuery, pProfile: ?*IRTCProfile, lCookie: isize) HRESULT {
                return @as(*const IRTCUserSearch.VTable, @ptrCast(self.vtable)).ExecuteSearch(@as(*const IRTCUserSearch, @ptrCast(self)), pQuery, pProfile, lCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCUserSearchQuery_Value = Guid.initString("288300f5-d23a-4365-9a73-9985c98c2881");
pub const IID_IRTCUserSearchQuery = &IID_IRTCUserSearchQuery_Value;
pub const IRTCUserSearchQuery = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SearchTerm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchQuery,
                bstrName: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchQuery,
                bstrName: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SearchTerm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchQuery,
                bstrName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchQuery,
                bstrName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SearchTerms: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchQuery,
                pbstrNames: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchQuery,
                pbstrNames: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SearchPreference: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchQuery,
                enPreference: RTC_USER_SEARCH_PREFERENCE,
                lValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchQuery,
                enPreference: RTC_USER_SEARCH_PREFERENCE,
                lValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SearchPreference: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchQuery,
                enPreference: RTC_USER_SEARCH_PREFERENCE,
                plValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchQuery,
                enPreference: RTC_USER_SEARCH_PREFERENCE,
                plValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SearchDomain: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchQuery,
                bstrDomain: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchQuery,
                bstrDomain: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SearchDomain: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchQuery,
                pbstrDomain: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchQuery,
                pbstrDomain: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchQuery_put_SearchTerm(self: *const T, bstrName: ?BSTR, bstrValue: ?BSTR) HRESULT {
                return @as(*const IRTCUserSearchQuery.VTable, @ptrCast(self.vtable)).put_SearchTerm(@as(*const IRTCUserSearchQuery, @ptrCast(self)), bstrName, bstrValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchQuery_get_SearchTerm(self: *const T, bstrName: ?BSTR, pbstrValue: ?*?BSTR) HRESULT {
                return @as(*const IRTCUserSearchQuery.VTable, @ptrCast(self.vtable)).get_SearchTerm(@as(*const IRTCUserSearchQuery, @ptrCast(self)), bstrName, pbstrValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchQuery_get_SearchTerms(self: *const T, pbstrNames: ?*?BSTR) HRESULT {
                return @as(*const IRTCUserSearchQuery.VTable, @ptrCast(self.vtable)).get_SearchTerms(@as(*const IRTCUserSearchQuery, @ptrCast(self)), pbstrNames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchQuery_put_SearchPreference(self: *const T, enPreference: RTC_USER_SEARCH_PREFERENCE, lValue: i32) HRESULT {
                return @as(*const IRTCUserSearchQuery.VTable, @ptrCast(self.vtable)).put_SearchPreference(@as(*const IRTCUserSearchQuery, @ptrCast(self)), enPreference, lValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchQuery_get_SearchPreference(self: *const T, enPreference: RTC_USER_SEARCH_PREFERENCE, plValue: ?*i32) HRESULT {
                return @as(*const IRTCUserSearchQuery.VTable, @ptrCast(self.vtable)).get_SearchPreference(@as(*const IRTCUserSearchQuery, @ptrCast(self)), enPreference, plValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchQuery_put_SearchDomain(self: *const T, bstrDomain: ?BSTR) HRESULT {
                return @as(*const IRTCUserSearchQuery.VTable, @ptrCast(self.vtable)).put_SearchDomain(@as(*const IRTCUserSearchQuery, @ptrCast(self)), bstrDomain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchQuery_get_SearchDomain(self: *const T, pbstrDomain: ?*?BSTR) HRESULT {
                return @as(*const IRTCUserSearchQuery.VTable, @ptrCast(self.vtable)).get_SearchDomain(@as(*const IRTCUserSearchQuery, @ptrCast(self)), pbstrDomain);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCUserSearchResult_Value = Guid.initString("851278b2-9592-480f-8db5-2de86b26b54d");
pub const IID_IRTCUserSearchResult = &IID_IRTCUserSearchResult_Value;
pub const IRTCUserSearchResult = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchResult,
                enColumn: RTC_USER_SEARCH_COLUMN,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchResult,
                enColumn: RTC_USER_SEARCH_COLUMN,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchResult_get_Value(self: *const T, enColumn: RTC_USER_SEARCH_COLUMN, pbstrValue: ?*?BSTR) HRESULT {
                return @as(*const IRTCUserSearchResult.VTable, @ptrCast(self.vtable)).get_Value(@as(*const IRTCUserSearchResult, @ptrCast(self)), enColumn, pbstrValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCEnumUserSearchResults_Value = Guid.initString("83d4d877-aa5d-4a5b-8d0e-002a8067e0e8");
pub const IID_IRTCEnumUserSearchResults = &IID_IRTCEnumUserSearchResults_Value;
pub const IRTCEnumUserSearchResults = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumUserSearchResults,
                celt: u32,
                ppElements: [*]?*IRTCUserSearchResult,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumUserSearchResults,
                celt: u32,
                ppElements: [*]?*IRTCUserSearchResult,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumUserSearchResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumUserSearchResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumUserSearchResults,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumUserSearchResults,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumUserSearchResults,
                ppEnum: ?*?*IRTCEnumUserSearchResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumUserSearchResults,
                ppEnum: ?*?*IRTCEnumUserSearchResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumUserSearchResults_Next(self: *const T, celt: u32, ppElements: [*]?*IRTCUserSearchResult, pceltFetched: ?*u32) HRESULT {
                return @as(*const IRTCEnumUserSearchResults.VTable, @ptrCast(self.vtable)).Next(@as(*const IRTCEnumUserSearchResults, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumUserSearchResults_Reset(self: *const T) HRESULT {
                return @as(*const IRTCEnumUserSearchResults.VTable, @ptrCast(self.vtable)).Reset(@as(*const IRTCEnumUserSearchResults, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumUserSearchResults_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IRTCEnumUserSearchResults.VTable, @ptrCast(self.vtable)).Skip(@as(*const IRTCEnumUserSearchResults, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumUserSearchResults_Clone(self: *const T, ppEnum: ?*?*IRTCEnumUserSearchResults) HRESULT {
                return @as(*const IRTCEnumUserSearchResults.VTable, @ptrCast(self.vtable)).Clone(@as(*const IRTCEnumUserSearchResults, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCUserSearchResultsEvent_Value = Guid.initString("d8c8c3cd-7fac-4088-81c5-c24cbc0938e3");
pub const IID_IRTCUserSearchResultsEvent = &IID_IRTCUserSearchResultsEvent_Value;
pub const IRTCUserSearchResultsEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        EnumerateResults: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCUserSearchResultsEvent,
                ppEnum: ?*?*IRTCEnumUserSearchResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCUserSearchResultsEvent,
                ppEnum: ?*?*IRTCEnumUserSearchResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Results: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchResultsEvent,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchResultsEvent,
                ppCollection: ?*?*IRTCCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchResultsEvent,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchResultsEvent,
                ppProfile: ?*?*IRTCProfile2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Query: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchResultsEvent,
                ppQuery: ?*?*IRTCUserSearchQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchResultsEvent,
                ppQuery: ?*?*IRTCUserSearchQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cookie: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchResultsEvent,
                plCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchResultsEvent,
                plCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchResultsEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchResultsEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCUserSearchResultsEvent,
                pfMoreAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCUserSearchResultsEvent,
                pfMoreAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchResultsEvent_EnumerateResults(self: *const T, ppEnum: ?*?*IRTCEnumUserSearchResults) HRESULT {
                return @as(*const IRTCUserSearchResultsEvent.VTable, @ptrCast(self.vtable)).EnumerateResults(@as(*const IRTCUserSearchResultsEvent, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchResultsEvent_get_Results(self: *const T, ppCollection: ?*?*IRTCCollection) HRESULT {
                return @as(*const IRTCUserSearchResultsEvent.VTable, @ptrCast(self.vtable)).get_Results(@as(*const IRTCUserSearchResultsEvent, @ptrCast(self)), ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchResultsEvent_get_Profile(self: *const T, ppProfile: ?*?*IRTCProfile2) HRESULT {
                return @as(*const IRTCUserSearchResultsEvent.VTable, @ptrCast(self.vtable)).get_Profile(@as(*const IRTCUserSearchResultsEvent, @ptrCast(self)), ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchResultsEvent_get_Query(self: *const T, ppQuery: ?*?*IRTCUserSearchQuery) HRESULT {
                return @as(*const IRTCUserSearchResultsEvent.VTable, @ptrCast(self.vtable)).get_Query(@as(*const IRTCUserSearchResultsEvent, @ptrCast(self)), ppQuery);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchResultsEvent_get_Cookie(self: *const T, plCookie: ?*isize) HRESULT {
                return @as(*const IRTCUserSearchResultsEvent.VTable, @ptrCast(self.vtable)).get_Cookie(@as(*const IRTCUserSearchResultsEvent, @ptrCast(self)), plCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchResultsEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCUserSearchResultsEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCUserSearchResultsEvent, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCUserSearchResultsEvent_get_MoreAvailable(self: *const T, pfMoreAvailable: ?*i16) HRESULT {
                return @as(*const IRTCUserSearchResultsEvent.VTable, @ptrCast(self.vtable)).get_MoreAvailable(@as(*const IRTCUserSearchResultsEvent, @ptrCast(self)), pfMoreAvailable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSessionReferStatusEvent_Value = Guid.initString("3d8fc2cd-5d76-44ab-bb68-2a80353b34a2");
pub const IID_IRTCSessionReferStatusEvent = &IID_IRTCSessionReferStatusEvent_Value;
pub const IRTCSessionReferStatusEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionReferStatusEvent,
                ppSession: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionReferStatusEvent,
                ppSession: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReferStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionReferStatusEvent,
                penReferStatus: ?*RTC_SESSION_REFER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionReferStatusEvent,
                penReferStatus: ?*RTC_SESSION_REFER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionReferStatusEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionReferStatusEvent,
                plStatusCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionReferStatusEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionReferStatusEvent,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferStatusEvent_get_Session(self: *const T, ppSession: ?*?*IRTCSession2) HRESULT {
                return @as(*const IRTCSessionReferStatusEvent.VTable, @ptrCast(self.vtable)).get_Session(@as(*const IRTCSessionReferStatusEvent, @ptrCast(self)), ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferStatusEvent_get_ReferStatus(self: *const T, penReferStatus: ?*RTC_SESSION_REFER_STATUS) HRESULT {
                return @as(*const IRTCSessionReferStatusEvent.VTable, @ptrCast(self.vtable)).get_ReferStatus(@as(*const IRTCSessionReferStatusEvent, @ptrCast(self)), penReferStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferStatusEvent_get_StatusCode(self: *const T, plStatusCode: ?*i32) HRESULT {
                return @as(*const IRTCSessionReferStatusEvent.VTable, @ptrCast(self.vtable)).get_StatusCode(@as(*const IRTCSessionReferStatusEvent, @ptrCast(self)), plStatusCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferStatusEvent_get_StatusText(self: *const T, pbstrStatusText: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionReferStatusEvent.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IRTCSessionReferStatusEvent, @ptrCast(self)), pbstrStatusText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSessionReferredEvent_Value = Guid.initString("176a6828-4fcc-4f28-a862-04597a6cf1c4");
pub const IID_IRTCSessionReferredEvent = &IID_IRTCSessionReferredEvent_Value;
pub const IRTCSessionReferredEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionReferredEvent,
                ppSession: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionReferredEvent,
                ppSession: ?*?*IRTCSession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReferredByURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionReferredEvent,
                pbstrReferredByURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionReferredEvent,
                pbstrReferredByURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReferToURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionReferredEvent,
                pbstrReferoURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionReferredEvent,
                pbstrReferoURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReferCookie: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCSessionReferredEvent,
                pbstrReferCookie: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCSessionReferredEvent,
                pbstrReferCookie: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Accept: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionReferredEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionReferredEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionReferredEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionReferredEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReferredSessionState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionReferredEvent,
                enState: RTC_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionReferredEvent,
                enState: RTC_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferredEvent_get_Session(self: *const T, ppSession: ?*?*IRTCSession2) HRESULT {
                return @as(*const IRTCSessionReferredEvent.VTable, @ptrCast(self.vtable)).get_Session(@as(*const IRTCSessionReferredEvent, @ptrCast(self)), ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferredEvent_get_ReferredByURI(self: *const T, pbstrReferredByURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionReferredEvent.VTable, @ptrCast(self.vtable)).get_ReferredByURI(@as(*const IRTCSessionReferredEvent, @ptrCast(self)), pbstrReferredByURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferredEvent_get_ReferToURI(self: *const T, pbstrReferoURI: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionReferredEvent.VTable, @ptrCast(self.vtable)).get_ReferToURI(@as(*const IRTCSessionReferredEvent, @ptrCast(self)), pbstrReferoURI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferredEvent_get_ReferCookie(self: *const T, pbstrReferCookie: ?*?BSTR) HRESULT {
                return @as(*const IRTCSessionReferredEvent.VTable, @ptrCast(self.vtable)).get_ReferCookie(@as(*const IRTCSessionReferredEvent, @ptrCast(self)), pbstrReferCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferredEvent_Accept(self: *const T) HRESULT {
                return @as(*const IRTCSessionReferredEvent.VTable, @ptrCast(self.vtable)).Accept(@as(*const IRTCSessionReferredEvent, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferredEvent_Reject(self: *const T) HRESULT {
                return @as(*const IRTCSessionReferredEvent.VTable, @ptrCast(self.vtable)).Reject(@as(*const IRTCSessionReferredEvent, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionReferredEvent_SetReferredSessionState(self: *const T, enState: RTC_SESSION_STATE) HRESULT {
                return @as(*const IRTCSessionReferredEvent.VTable, @ptrCast(self.vtable)).SetReferredSessionState(@as(*const IRTCSessionReferredEvent, @ptrCast(self)), enState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCSessionDescriptionManager_Value = Guid.initString("ba7f518e-d336-4070-93a6-865395c843f9");
pub const IID_IRTCSessionDescriptionManager = &IID_IRTCSessionDescriptionManager_Value;
pub const IRTCSessionDescriptionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EvaluateSessionDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCSessionDescriptionManager,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
                pfApplicationSession: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCSessionDescriptionManager,
                bstrContentType: ?BSTR,
                bstrSessionDescription: ?BSTR,
                pfApplicationSession: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCSessionDescriptionManager_EvaluateSessionDescription(self: *const T, bstrContentType: ?BSTR, bstrSessionDescription: ?BSTR, pfApplicationSession: ?*i16) HRESULT {
                return @as(*const IRTCSessionDescriptionManager.VTable, @ptrCast(self.vtable)).EvaluateSessionDescription(@as(*const IRTCSessionDescriptionManager, @ptrCast(self)), bstrContentType, bstrSessionDescription, pfApplicationSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCEnumPresenceDevices_Value = Guid.initString("708c2ab7-8bf8-42f8-8c7d-635197ad5539");
pub const IID_IRTCEnumPresenceDevices = &IID_IRTCEnumPresenceDevices_Value;
pub const IRTCEnumPresenceDevices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumPresenceDevices,
                celt: u32,
                ppElements: [*]?*IRTCPresenceDevice,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumPresenceDevices,
                celt: u32,
                ppElements: [*]?*IRTCPresenceDevice,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumPresenceDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumPresenceDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumPresenceDevices,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumPresenceDevices,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCEnumPresenceDevices,
                ppEnum: ?*?*IRTCEnumPresenceDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCEnumPresenceDevices,
                ppEnum: ?*?*IRTCEnumPresenceDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumPresenceDevices_Next(self: *const T, celt: u32, ppElements: [*]?*IRTCPresenceDevice, pceltFetched: ?*u32) HRESULT {
                return @as(*const IRTCEnumPresenceDevices.VTable, @ptrCast(self.vtable)).Next(@as(*const IRTCEnumPresenceDevices, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumPresenceDevices_Reset(self: *const T) HRESULT {
                return @as(*const IRTCEnumPresenceDevices.VTable, @ptrCast(self.vtable)).Reset(@as(*const IRTCEnumPresenceDevices, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumPresenceDevices_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IRTCEnumPresenceDevices.VTable, @ptrCast(self.vtable)).Skip(@as(*const IRTCEnumPresenceDevices, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCEnumPresenceDevices_Clone(self: *const T, ppEnum: ?*?*IRTCEnumPresenceDevices) HRESULT {
                return @as(*const IRTCEnumPresenceDevices.VTable, @ptrCast(self.vtable)).Clone(@as(*const IRTCEnumPresenceDevices, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCPresenceDevice_Value = Guid.initString("bc6a90dd-ad9a-48da-9b0c-2515e38521ad");
pub const IID_IRTCPresenceDevice = &IID_IRTCPresenceDevice_Value;
pub const IRTCPresenceDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceDevice,
                penStatus: ?*RTC_PRESENCE_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceDevice,
                penStatus: ?*RTC_PRESENCE_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Notes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceDevice,
                pbstrNotes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceDevice,
                pbstrNotes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PresenceProperty: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRTCPresenceDevice,
                enProperty: RTC_PRESENCE_PROPERTY,
                pbstrProperty: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRTCPresenceDevice,
                enProperty: RTC_PRESENCE_PROPERTY,
                pbstrProperty: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresenceData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRTCPresenceDevice,
                pbstrNamespace: ?*?BSTR,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRTCPresenceDevice,
                pbstrNamespace: ?*?BSTR,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceDevice_get_Status(self: *const T, penStatus: ?*RTC_PRESENCE_STATUS) HRESULT {
                return @as(*const IRTCPresenceDevice.VTable, @ptrCast(self.vtable)).get_Status(@as(*const IRTCPresenceDevice, @ptrCast(self)), penStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceDevice_get_Notes(self: *const T, pbstrNotes: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceDevice.VTable, @ptrCast(self.vtable)).get_Notes(@as(*const IRTCPresenceDevice, @ptrCast(self)), pbstrNotes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceDevice_get_PresenceProperty(self: *const T, enProperty: RTC_PRESENCE_PROPERTY, pbstrProperty: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceDevice.VTable, @ptrCast(self.vtable)).get_PresenceProperty(@as(*const IRTCPresenceDevice, @ptrCast(self)), enProperty, pbstrProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRTCPresenceDevice_GetPresenceData(self: *const T, pbstrNamespace: ?*?BSTR, pbstrData: ?*?BSTR) HRESULT {
                return @as(*const IRTCPresenceDevice.VTable, @ptrCast(self.vtable)).GetPresenceData(@as(*const IRTCPresenceDevice, @ptrCast(self)), pbstrNamespace, pbstrData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRTCDispatchEventNotification_Value = Guid.initString("176ddfbe-fec0-4d55-bc87-84cff1ef7f91");
pub const IID_IRTCDispatchEventNotification = &IID_IRTCDispatchEventNotification_Value;
pub const IRTCDispatchEventNotification = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TRANSPORT_SETTING = extern struct {
    SettingId: TRANSPORT_SETTING_ID,
    Length: ?*u32,
    Value: ?*u8,
};

const IID_ITransportSettingsInternal_Value = Guid.initString("5123e076-29e3-4bfd-84fe-0192d411e3e8");
pub const IID_ITransportSettingsInternal = &IID_ITransportSettingsInternal_Value;
pub const ITransportSettingsInternal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ApplySetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransportSettingsInternal,
                Setting: ?*TRANSPORT_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransportSettingsInternal,
                Setting: ?*TRANSPORT_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QuerySetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransportSettingsInternal,
                Setting: ?*TRANSPORT_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransportSettingsInternal,
                Setting: ?*TRANSPORT_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransportSettingsInternal_ApplySetting(self: *const T, Setting: ?*TRANSPORT_SETTING) HRESULT {
                return @as(*const ITransportSettingsInternal.VTable, @ptrCast(self.vtable)).ApplySetting(@as(*const ITransportSettingsInternal, @ptrCast(self)), Setting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransportSettingsInternal_QuerySetting(self: *const T, Setting: ?*TRANSPORT_SETTING) HRESULT {
                return @as(*const ITransportSettingsInternal.VTable, @ptrCast(self.vtable)).QuerySetting(@as(*const ITransportSettingsInternal, @ptrCast(self)), Setting);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_INetworkTransportSettings_Value = Guid.initString("5e7abb2c-f2c1-4a61-bd35-deb7a08ab0f1");
pub const IID_INetworkTransportSettings = &IID_INetworkTransportSettings_Value;
pub const INetworkTransportSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ApplySetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetworkTransportSettings,
                SettingId: ?*const TRANSPORT_SETTING_ID,
                LengthIn: u32,
                ValueIn: [*:0]const u8,
                LengthOut: ?*u32,
                ValueOut: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetworkTransportSettings,
                SettingId: ?*const TRANSPORT_SETTING_ID,
                LengthIn: u32,
                ValueIn: [*:0]const u8,
                LengthOut: ?*u32,
                ValueOut: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QuerySetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetworkTransportSettings,
                SettingId: ?*const TRANSPORT_SETTING_ID,
                LengthIn: u32,
                ValueIn: [*:0]const u8,
                LengthOut: ?*u32,
                ValueOut: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetworkTransportSettings,
                SettingId: ?*const TRANSPORT_SETTING_ID,
                LengthIn: u32,
                ValueIn: [*:0]const u8,
                LengthOut: ?*u32,
                ValueOut: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetworkTransportSettings_ApplySetting(self: *const T, SettingId: ?*const TRANSPORT_SETTING_ID, LengthIn: u32, ValueIn: [*:0]const u8, LengthOut: ?*u32, ValueOut: [*]?*u8) HRESULT {
                return @as(*const INetworkTransportSettings.VTable, @ptrCast(self.vtable)).ApplySetting(@as(*const INetworkTransportSettings, @ptrCast(self)), SettingId, LengthIn, ValueIn, LengthOut, ValueOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetworkTransportSettings_QuerySetting(self: *const T, SettingId: ?*const TRANSPORT_SETTING_ID, LengthIn: u32, ValueIn: [*:0]const u8, LengthOut: ?*u32, ValueOut: [*]?*u8) HRESULT {
                return @as(*const INetworkTransportSettings.VTable, @ptrCast(self.vtable)).QuerySetting(@as(*const INetworkTransportSettings, @ptrCast(self)), SettingId, LengthIn, ValueIn, LengthOut, ValueOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_INotificationTransportSync_Value = Guid.initString("79eb1402-0ab8-49c0-9e14-a1ae4ba93058");
pub const IID_INotificationTransportSync = &IID_INotificationTransportSync_Value;
pub const INotificationTransportSync = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompleteDelivery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INotificationTransportSync,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INotificationTransportSync,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INotificationTransportSync,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INotificationTransportSync,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INotificationTransportSync_CompleteDelivery(self: *const T) HRESULT {
                return @as(*const INotificationTransportSync.VTable, @ptrCast(self.vtable)).CompleteDelivery(@as(*const INotificationTransportSync, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INotificationTransportSync_Flush(self: *const T) HRESULT {
                return @as(*const INotificationTransportSync.VTable, @ptrCast(self.vtable)).Flush(@as(*const INotificationTransportSync, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BSTR = @import("../foundation.zig").BSTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const IVideoWindow = @import("../media/direct_show.zig").IVideoWindow;
const TRANSPORT_SETTING_ID = @import("../networking/win_sock.zig").TRANSPORT_SETTING_ID;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
