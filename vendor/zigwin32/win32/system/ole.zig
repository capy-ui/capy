//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (590)
//--------------------------------------------------------------------------------
pub const CTL_E_ILLEGALFUNCTIONCALL = @as(i32, -2146828283);
pub const CONNECT_E_FIRST = @as(i32, -2147220992);
pub const SELFREG_E_FIRST = @as(i32, -2147220992);
pub const PERPROP_E_FIRST = @as(i32, -2147220992);
pub const OLECMDERR_E_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221248));
pub const OLECMDERR_E_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221247));
pub const OLECMDERR_E_NOHELP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221246));
pub const OLECMDERR_E_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221245));
pub const OLECMDERR_E_UNKNOWNGROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221244));
pub const CONNECT_E_NOCONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const CONNECT_E_ADVISELIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const CONNECT_E_CANNOTCONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const CONNECT_E_OVERRIDDEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const SELFREG_E_TYPELIB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const SELFREG_E_CLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const PERPROP_E_NOPAGEAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const CLSID_CFontPropPage = Guid.initString("0be35200-8f91-11ce-9de3-00aa004bb851");
pub const CLSID_CColorPropPage = Guid.initString("0be35201-8f91-11ce-9de3-00aa004bb851");
pub const CLSID_CPicturePropPage = Guid.initString("0be35202-8f91-11ce-9de3-00aa004bb851");
pub const CLSID_PersistPropset = Guid.initString("fb8f0821-0164-101b-84ed-08002b2ec713");
pub const CLSID_ConvertVBX = Guid.initString("fb8f0822-0164-101b-84ed-08002b2ec713");
pub const CLSID_StdFont = Guid.initString("0be35203-8f91-11ce-9de3-00aa004bb851");
pub const CLSID_StdPicture = Guid.initString("0be35204-8f91-11ce-9de3-00aa004bb851");
pub const GUID_HIMETRIC = Guid.initString("66504300-be0f-101a-8bbb-00aa00300cab");
pub const GUID_COLOR = Guid.initString("66504301-be0f-101a-8bbb-00aa00300cab");
pub const GUID_XPOSPIXEL = Guid.initString("66504302-be0f-101a-8bbb-00aa00300cab");
pub const GUID_YPOSPIXEL = Guid.initString("66504303-be0f-101a-8bbb-00aa00300cab");
pub const GUID_XSIZEPIXEL = Guid.initString("66504304-be0f-101a-8bbb-00aa00300cab");
pub const GUID_YSIZEPIXEL = Guid.initString("66504305-be0f-101a-8bbb-00aa00300cab");
pub const GUID_XPOS = Guid.initString("66504306-be0f-101a-8bbb-00aa00300cab");
pub const GUID_YPOS = Guid.initString("66504307-be0f-101a-8bbb-00aa00300cab");
pub const GUID_XSIZE = Guid.initString("66504308-be0f-101a-8bbb-00aa00300cab");
pub const GUID_YSIZE = Guid.initString("66504309-be0f-101a-8bbb-00aa00300cab");
pub const GUID_TRISTATE = Guid.initString("6650430a-be0f-101a-8bbb-00aa00300cab");
pub const GUID_OPTIONVALUEEXCLUSIVE = Guid.initString("6650430b-be0f-101a-8bbb-00aa00300cab");
pub const GUID_CHECKVALUEEXCLUSIVE = Guid.initString("6650430c-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTNAME = Guid.initString("6650430d-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTSIZE = Guid.initString("6650430e-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTBOLD = Guid.initString("6650430f-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTITALIC = Guid.initString("66504310-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTUNDERSCORE = Guid.initString("66504311-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTSTRIKETHROUGH = Guid.initString("66504312-be0f-101a-8bbb-00aa00300cab");
pub const GUID_HANDLE = Guid.initString("66504313-be0f-101a-8bbb-00aa00300cab");
pub const PICTYPE_UNINITIALIZED = @as(i32, -1);
pub const PICTYPE_NONE = @as(u32, 0);
pub const PICTYPE_BITMAP = @as(u32, 1);
pub const PICTYPE_METAFILE = @as(u32, 2);
pub const PICTYPE_ICON = @as(u32, 3);
pub const PICTYPE_ENHMETAFILE = @as(u32, 4);
pub const CONNECT_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const CONNECT_S_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const CONNECT_S_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262671));
pub const SELFREG_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const SELFREG_S_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const SELFREG_S_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262671));
pub const PERPROP_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const PERPROP_S_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const PERPROP_S_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262671));
pub const OLEIVERB_PROPERTIES = @as(i32, -7);
pub const VT_STREAMED_PROPSET = @as(u32, 73);
pub const VT_STORED_PROPSET = @as(u32, 74);
pub const VT_BLOB_PROPSET = @as(u32, 75);
pub const VT_VERBOSE_ENUM = @as(u32, 76);
pub const OCM__BASE = @as(u32, 8192);
pub const LP_DEFAULT = @as(u32, 0);
pub const LP_MONOCHROME = @as(u32, 1);
pub const LP_VGACOLOR = @as(u32, 2);
pub const LP_COLOR = @as(u32, 4);
pub const DISPID_AUTOSIZE = @as(i32, -500);
pub const DISPID_BACKCOLOR = @as(i32, -501);
pub const DISPID_BACKSTYLE = @as(i32, -502);
pub const DISPID_BORDERCOLOR = @as(i32, -503);
pub const DISPID_BORDERSTYLE = @as(i32, -504);
pub const DISPID_BORDERWIDTH = @as(i32, -505);
pub const DISPID_DRAWMODE = @as(i32, -507);
pub const DISPID_DRAWSTYLE = @as(i32, -508);
pub const DISPID_DRAWWIDTH = @as(i32, -509);
pub const DISPID_FILLCOLOR = @as(i32, -510);
pub const DISPID_FILLSTYLE = @as(i32, -511);
pub const DISPID_FONT = @as(i32, -512);
pub const DISPID_FORECOLOR = @as(i32, -513);
pub const DISPID_ENABLED = @as(i32, -514);
pub const DISPID_HWND = @as(i32, -515);
pub const DISPID_TABSTOP = @as(i32, -516);
pub const DISPID_TEXT = @as(i32, -517);
pub const DISPID_CAPTION = @as(i32, -518);
pub const DISPID_BORDERVISIBLE = @as(i32, -519);
pub const DISPID_APPEARANCE = @as(i32, -520);
pub const DISPID_MOUSEPOINTER = @as(i32, -521);
pub const DISPID_MOUSEICON = @as(i32, -522);
pub const DISPID_PICTURE = @as(i32, -523);
pub const DISPID_VALID = @as(i32, -524);
pub const DISPID_READYSTATE = @as(i32, -525);
pub const DISPID_LISTINDEX = @as(i32, -526);
pub const DISPID_SELECTED = @as(i32, -527);
pub const DISPID_LIST = @as(i32, -528);
pub const DISPID_COLUMN = @as(i32, -529);
pub const DISPID_LISTCOUNT = @as(i32, -531);
pub const DISPID_MULTISELECT = @as(i32, -532);
pub const DISPID_MAXLENGTH = @as(i32, -533);
pub const DISPID_PASSWORDCHAR = @as(i32, -534);
pub const DISPID_SCROLLBARS = @as(i32, -535);
pub const DISPID_WORDWRAP = @as(i32, -536);
pub const DISPID_MULTILINE = @as(i32, -537);
pub const DISPID_NUMBEROFROWS = @as(i32, -538);
pub const DISPID_NUMBEROFCOLUMNS = @as(i32, -539);
pub const DISPID_DISPLAYSTYLE = @as(i32, -540);
pub const DISPID_GROUPNAME = @as(i32, -541);
pub const DISPID_IMEMODE = @as(i32, -542);
pub const DISPID_ACCELERATOR = @as(i32, -543);
pub const DISPID_ENTERKEYBEHAVIOR = @as(i32, -544);
pub const DISPID_TABKEYBEHAVIOR = @as(i32, -545);
pub const DISPID_SELTEXT = @as(i32, -546);
pub const DISPID_SELSTART = @as(i32, -547);
pub const DISPID_SELLENGTH = @as(i32, -548);
pub const DISPID_REFRESH = @as(i32, -550);
pub const DISPID_DOCLICK = @as(i32, -551);
pub const DISPID_ABOUTBOX = @as(i32, -552);
pub const DISPID_ADDITEM = @as(i32, -553);
pub const DISPID_CLEAR = @as(i32, -554);
pub const DISPID_REMOVEITEM = @as(i32, -555);
pub const DISPID_CLICK = @as(i32, -600);
pub const DISPID_DBLCLICK = @as(i32, -601);
pub const DISPID_KEYDOWN = @as(i32, -602);
pub const DISPID_KEYPRESS = @as(i32, -603);
pub const DISPID_KEYUP = @as(i32, -604);
pub const DISPID_MOUSEDOWN = @as(i32, -605);
pub const DISPID_MOUSEMOVE = @as(i32, -606);
pub const DISPID_MOUSEUP = @as(i32, -607);
pub const DISPID_ERROREVENT = @as(i32, -608);
pub const DISPID_READYSTATECHANGE = @as(i32, -609);
pub const DISPID_CLICK_VALUE = @as(i32, -610);
pub const DISPID_RIGHTTOLEFT = @as(i32, -611);
pub const DISPID_TOPTOBOTTOM = @as(i32, -612);
pub const DISPID_THIS = @as(i32, -613);
pub const DISPID_AMBIENT_BACKCOLOR = @as(i32, -701);
pub const DISPID_AMBIENT_DISPLAYNAME = @as(i32, -702);
pub const DISPID_AMBIENT_FONT = @as(i32, -703);
pub const DISPID_AMBIENT_FORECOLOR = @as(i32, -704);
pub const DISPID_AMBIENT_LOCALEID = @as(i32, -705);
pub const DISPID_AMBIENT_MESSAGEREFLECT = @as(i32, -706);
pub const DISPID_AMBIENT_SCALEUNITS = @as(i32, -707);
pub const DISPID_AMBIENT_TEXTALIGN = @as(i32, -708);
pub const DISPID_AMBIENT_USERMODE = @as(i32, -709);
pub const DISPID_AMBIENT_UIDEAD = @as(i32, -710);
pub const DISPID_AMBIENT_SHOWGRABHANDLES = @as(i32, -711);
pub const DISPID_AMBIENT_SHOWHATCHING = @as(i32, -712);
pub const DISPID_AMBIENT_DISPLAYASDEFAULT = @as(i32, -713);
pub const DISPID_AMBIENT_SUPPORTSMNEMONICS = @as(i32, -714);
pub const DISPID_AMBIENT_AUTOCLIP = @as(i32, -715);
pub const DISPID_AMBIENT_APPEARANCE = @as(i32, -716);
pub const DISPID_AMBIENT_CODEPAGE = @as(i32, -725);
pub const DISPID_AMBIENT_PALETTE = @as(i32, -726);
pub const DISPID_AMBIENT_CHARSET = @as(i32, -727);
pub const DISPID_AMBIENT_TRANSFERPRIORITY = @as(i32, -728);
pub const DISPID_AMBIENT_RIGHTTOLEFT = @as(i32, -732);
pub const DISPID_AMBIENT_TOPTOBOTTOM = @as(i32, -733);
pub const DISPID_Name = @as(i32, -800);
pub const DISPID_Delete = @as(i32, -801);
pub const DISPID_Object = @as(i32, -802);
pub const DISPID_Parent = @as(i32, -803);
pub const DISPID_FONT_NAME = @as(u32, 0);
pub const DISPID_FONT_SIZE = @as(u32, 2);
pub const DISPID_FONT_BOLD = @as(u32, 3);
pub const DISPID_FONT_ITALIC = @as(u32, 4);
pub const DISPID_FONT_UNDER = @as(u32, 5);
pub const DISPID_FONT_STRIKE = @as(u32, 6);
pub const DISPID_FONT_WEIGHT = @as(u32, 7);
pub const DISPID_FONT_CHARSET = @as(u32, 8);
pub const DISPID_FONT_CHANGED = @as(u32, 9);
pub const DISPID_PICT_HANDLE = @as(u32, 0);
pub const DISPID_PICT_HPAL = @as(u32, 2);
pub const DISPID_PICT_TYPE = @as(u32, 3);
pub const DISPID_PICT_WIDTH = @as(u32, 4);
pub const DISPID_PICT_HEIGHT = @as(u32, 5);
pub const DISPID_PICT_RENDER = @as(u32, 6);
pub const GC_WCH_SIBLING = @as(i32, 1);
pub const TIFLAGS_EXTENDDISPATCHONLY = @as(u32, 1);
pub const OLECMDERR_E_NOTSUPPORTED = @as(i32, -2147221248);
pub const MSOCMDERR_E_FIRST = @as(i32, -2147221248);
pub const MSOCMDERR_E_NOTSUPPORTED = @as(i32, -2147221248);
pub const MSOCMDERR_E_DISABLED = @as(i32, -2147221247);
pub const MSOCMDERR_E_NOHELP = @as(i32, -2147221246);
pub const MSOCMDERR_E_CANCELED = @as(i32, -2147221245);
pub const MSOCMDERR_E_UNKNOWNGROUP = @as(i32, -2147221244);
pub const OLECMD_TASKDLGID_ONBEFOREUNLOAD = @as(u32, 1);
pub const OLECMDARGINDEX_SHOWPAGEACTIONMENU_HWND = @as(u32, 0);
pub const OLECMDARGINDEX_SHOWPAGEACTIONMENU_X = @as(u32, 1);
pub const OLECMDARGINDEX_SHOWPAGEACTIONMENU_Y = @as(u32, 2);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_PUBLISHER = @as(u32, 0);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_DISPLAYNAME = @as(u32, 1);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_CLSID = @as(u32, 2);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_INSTALLSCOPE = @as(u32, 3);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_SOURCEURL = @as(u32, 4);
pub const INSTALL_SCOPE_INVALID = @as(u32, 0);
pub const INSTALL_SCOPE_MACHINE = @as(u32, 1);
pub const INSTALL_SCOPE_USER = @as(u32, 2);
pub const MK_ALT = @as(u32, 32);
pub const DROPEFFECT_NONE = @as(u32, 0);
pub const DROPEFFECT_COPY = @as(u32, 1);
pub const DROPEFFECT_MOVE = @as(u32, 2);
pub const DROPEFFECT_LINK = @as(u32, 4);
pub const DROPEFFECT_SCROLL = @as(u32, 2147483648);
pub const DD_DEFSCROLLINSET = @as(u32, 11);
pub const DD_DEFSCROLLDELAY = @as(u32, 50);
pub const DD_DEFSCROLLINTERVAL = @as(u32, 50);
pub const DD_DEFDRAGDELAY = @as(u32, 200);
pub const DD_DEFDRAGMINDIST = @as(u32, 2);
pub const OT_LINK = @as(i32, 1);
pub const OT_EMBEDDED = @as(i32, 2);
pub const OT_STATIC = @as(i32, 3);
pub const OLEVERB_PRIMARY = @as(u32, 0);
pub const OF_SET = @as(u32, 1);
pub const OF_GET = @as(u32, 2);
pub const OF_HANDLER = @as(u32, 4);
pub const WIN32 = @as(u32, 100);
pub const OLEIVERB_PRIMARY = @as(i32, 0);
pub const OLEIVERB_SHOW = @as(i32, -1);
pub const OLEIVERB_OPEN = @as(i32, -2);
pub const OLEIVERB_HIDE = @as(i32, -3);
pub const OLEIVERB_UIACTIVATE = @as(i32, -4);
pub const OLEIVERB_INPLACEACTIVATE = @as(i32, -5);
pub const OLEIVERB_DISCARDUNDOSTATE = @as(i32, -6);
pub const EMBDHLP_INPROC_HANDLER = @as(i32, 0);
pub const EMBDHLP_INPROC_SERVER = @as(i32, 1);
pub const EMBDHLP_CREATENOW = @as(i32, 0);
pub const EMBDHLP_DELAYCREATE = @as(i32, 65536);
pub const OLECREATE_LEAVERUNNING = @as(u32, 1);
pub const IDC_OLEUIHELP = @as(u32, 99);
pub const IDC_IO_CREATENEW = @as(u32, 2100);
pub const IDC_IO_CREATEFROMFILE = @as(u32, 2101);
pub const IDC_IO_LINKFILE = @as(u32, 2102);
pub const IDC_IO_OBJECTTYPELIST = @as(u32, 2103);
pub const IDC_IO_DISPLAYASICON = @as(u32, 2104);
pub const IDC_IO_CHANGEICON = @as(u32, 2105);
pub const IDC_IO_FILE = @as(u32, 2106);
pub const IDC_IO_FILEDISPLAY = @as(u32, 2107);
pub const IDC_IO_RESULTIMAGE = @as(u32, 2108);
pub const IDC_IO_RESULTTEXT = @as(u32, 2109);
pub const IDC_IO_ICONDISPLAY = @as(u32, 2110);
pub const IDC_IO_OBJECTTYPETEXT = @as(u32, 2111);
pub const IDC_IO_FILETEXT = @as(u32, 2112);
pub const IDC_IO_FILETYPE = @as(u32, 2113);
pub const IDC_IO_INSERTCONTROL = @as(u32, 2114);
pub const IDC_IO_ADDCONTROL = @as(u32, 2115);
pub const IDC_IO_CONTROLTYPELIST = @as(u32, 2116);
pub const IDC_PS_PASTE = @as(u32, 500);
pub const IDC_PS_PASTELINK = @as(u32, 501);
pub const IDC_PS_SOURCETEXT = @as(u32, 502);
pub const IDC_PS_PASTELIST = @as(u32, 503);
pub const IDC_PS_PASTELINKLIST = @as(u32, 504);
pub const IDC_PS_DISPLAYLIST = @as(u32, 505);
pub const IDC_PS_DISPLAYASICON = @as(u32, 506);
pub const IDC_PS_ICONDISPLAY = @as(u32, 507);
pub const IDC_PS_CHANGEICON = @as(u32, 508);
pub const IDC_PS_RESULTIMAGE = @as(u32, 509);
pub const IDC_PS_RESULTTEXT = @as(u32, 510);
pub const IDC_CI_GROUP = @as(u32, 120);
pub const IDC_CI_CURRENT = @as(u32, 121);
pub const IDC_CI_CURRENTICON = @as(u32, 122);
pub const IDC_CI_DEFAULT = @as(u32, 123);
pub const IDC_CI_DEFAULTICON = @as(u32, 124);
pub const IDC_CI_FROMFILE = @as(u32, 125);
pub const IDC_CI_FROMFILEEDIT = @as(u32, 126);
pub const IDC_CI_ICONLIST = @as(u32, 127);
pub const IDC_CI_LABEL = @as(u32, 128);
pub const IDC_CI_LABELEDIT = @as(u32, 129);
pub const IDC_CI_BROWSE = @as(u32, 130);
pub const IDC_CI_ICONDISPLAY = @as(u32, 131);
pub const IDC_CV_OBJECTTYPE = @as(u32, 150);
pub const IDC_CV_DISPLAYASICON = @as(u32, 152);
pub const IDC_CV_CHANGEICON = @as(u32, 153);
pub const IDC_CV_ACTIVATELIST = @as(u32, 154);
pub const IDC_CV_CONVERTTO = @as(u32, 155);
pub const IDC_CV_ACTIVATEAS = @as(u32, 156);
pub const IDC_CV_RESULTTEXT = @as(u32, 157);
pub const IDC_CV_CONVERTLIST = @as(u32, 158);
pub const IDC_CV_ICONDISPLAY = @as(u32, 165);
pub const IDC_EL_CHANGESOURCE = @as(u32, 201);
pub const IDC_EL_AUTOMATIC = @as(u32, 202);
pub const IDC_EL_CANCELLINK = @as(u32, 209);
pub const IDC_EL_UPDATENOW = @as(u32, 210);
pub const IDC_EL_OPENSOURCE = @as(u32, 211);
pub const IDC_EL_MANUAL = @as(u32, 212);
pub const IDC_EL_LINKSOURCE = @as(u32, 216);
pub const IDC_EL_LINKTYPE = @as(u32, 217);
pub const IDC_EL_LINKSLISTBOX = @as(u32, 206);
pub const IDC_EL_COL1 = @as(u32, 220);
pub const IDC_EL_COL2 = @as(u32, 221);
pub const IDC_EL_COL3 = @as(u32, 222);
pub const IDC_BZ_RETRY = @as(u32, 600);
pub const IDC_BZ_ICON = @as(u32, 601);
pub const IDC_BZ_MESSAGE1 = @as(u32, 602);
pub const IDC_BZ_SWITCHTO = @as(u32, 604);
pub const IDC_UL_METER = @as(u32, 1029);
pub const IDC_UL_STOP = @as(u32, 1030);
pub const IDC_UL_PERCENT = @as(u32, 1031);
pub const IDC_UL_PROGRESS = @as(u32, 1032);
pub const IDC_PU_LINKS = @as(u32, 900);
pub const IDC_PU_TEXT = @as(u32, 901);
pub const IDC_PU_CONVERT = @as(u32, 902);
pub const IDC_PU_ICON = @as(u32, 908);
pub const IDC_GP_OBJECTNAME = @as(u32, 1009);
pub const IDC_GP_OBJECTTYPE = @as(u32, 1010);
pub const IDC_GP_OBJECTSIZE = @as(u32, 1011);
pub const IDC_GP_CONVERT = @as(u32, 1013);
pub const IDC_GP_OBJECTICON = @as(u32, 1014);
pub const IDC_GP_OBJECTLOCATION = @as(u32, 1022);
pub const IDC_VP_PERCENT = @as(u32, 1000);
pub const IDC_VP_CHANGEICON = @as(u32, 1001);
pub const IDC_VP_EDITABLE = @as(u32, 1002);
pub const IDC_VP_ASICON = @as(u32, 1003);
pub const IDC_VP_RELATIVE = @as(u32, 1005);
pub const IDC_VP_SPIN = @as(u32, 1006);
pub const IDC_VP_SCALETXT = @as(u32, 1034);
pub const IDC_VP_ICONDISPLAY = @as(u32, 1021);
pub const IDC_VP_RESULTIMAGE = @as(u32, 1033);
pub const IDC_LP_OPENSOURCE = @as(u32, 1006);
pub const IDC_LP_UPDATENOW = @as(u32, 1007);
pub const IDC_LP_BREAKLINK = @as(u32, 1008);
pub const IDC_LP_LINKSOURCE = @as(u32, 1012);
pub const IDC_LP_CHANGESOURCE = @as(u32, 1015);
pub const IDC_LP_AUTOMATIC = @as(u32, 1016);
pub const IDC_LP_MANUAL = @as(u32, 1017);
pub const IDC_LP_DATE = @as(u32, 1018);
pub const IDC_LP_TIME = @as(u32, 1019);
pub const IDD_INSERTOBJECT = @as(u32, 1000);
pub const IDD_CHANGEICON = @as(u32, 1001);
pub const IDD_CONVERT = @as(u32, 1002);
pub const IDD_PASTESPECIAL = @as(u32, 1003);
pub const IDD_EDITLINKS = @as(u32, 1004);
pub const IDD_BUSY = @as(u32, 1006);
pub const IDD_UPDATELINKS = @as(u32, 1007);
pub const IDD_CHANGESOURCE = @as(u32, 1009);
pub const IDD_INSERTFILEBROWSE = @as(u32, 1010);
pub const IDD_CHANGEICONBROWSE = @as(u32, 1011);
pub const IDD_CONVERTONLY = @as(u32, 1012);
pub const IDD_CHANGESOURCE4 = @as(u32, 1013);
pub const IDD_GNRLPROPS = @as(u32, 1100);
pub const IDD_VIEWPROPS = @as(u32, 1101);
pub const IDD_LINKPROPS = @as(u32, 1102);
pub const IDD_CONVERT4 = @as(u32, 1103);
pub const IDD_CONVERTONLY4 = @as(u32, 1104);
pub const IDD_EDITLINKS4 = @as(u32, 1105);
pub const IDD_GNRLPROPS4 = @as(u32, 1106);
pub const IDD_LINKPROPS4 = @as(u32, 1107);
pub const IDD_PASTESPECIAL4 = @as(u32, 1108);
pub const IDD_CANNOTUPDATELINK = @as(u32, 1008);
pub const IDD_LINKSOURCEUNAVAILABLE = @as(u32, 1020);
pub const IDD_SERVERNOTFOUND = @as(u32, 1023);
pub const IDD_OUTOFMEMORY = @as(u32, 1024);
pub const IDD_SERVERNOTREGW = @as(u32, 1021);
pub const IDD_LINKTYPECHANGEDW = @as(u32, 1022);
pub const IDD_SERVERNOTREGA = @as(u32, 1025);
pub const IDD_LINKTYPECHANGEDA = @as(u32, 1026);
pub const IDD_SERVERNOTREG = @as(u32, 1021);
pub const IDD_LINKTYPECHANGED = @as(u32, 1022);
pub const ID_BROWSE_CHANGEICON = @as(u32, 1);
pub const ID_BROWSE_INSERTFILE = @as(u32, 2);
pub const ID_BROWSE_ADDCONTROL = @as(u32, 3);
pub const ID_BROWSE_CHANGESOURCE = @as(u32, 4);
pub const OLEUI_FALSE = @as(u32, 0);
pub const OLEUI_SUCCESS = @as(u32, 1);
pub const OLEUI_OK = @as(u32, 1);
pub const OLEUI_CANCEL = @as(u32, 2);
pub const OLEUI_ERR_STANDARDMIN = @as(u32, 100);
pub const OLEUI_ERR_OLEMEMALLOC = @as(u32, 100);
pub const OLEUI_ERR_STRUCTURENULL = @as(u32, 101);
pub const OLEUI_ERR_STRUCTUREINVALID = @as(u32, 102);
pub const OLEUI_ERR_CBSTRUCTINCORRECT = @as(u32, 103);
pub const OLEUI_ERR_HWNDOWNERINVALID = @as(u32, 104);
pub const OLEUI_ERR_LPSZCAPTIONINVALID = @as(u32, 105);
pub const OLEUI_ERR_LPFNHOOKINVALID = @as(u32, 106);
pub const OLEUI_ERR_HINSTANCEINVALID = @as(u32, 107);
pub const OLEUI_ERR_LPSZTEMPLATEINVALID = @as(u32, 108);
pub const OLEUI_ERR_HRESOURCEINVALID = @as(u32, 109);
pub const OLEUI_ERR_FINDTEMPLATEFAILURE = @as(u32, 110);
pub const OLEUI_ERR_LOADTEMPLATEFAILURE = @as(u32, 111);
pub const OLEUI_ERR_DIALOGFAILURE = @as(u32, 112);
pub const OLEUI_ERR_LOCALMEMALLOC = @as(u32, 113);
pub const OLEUI_ERR_GLOBALMEMALLOC = @as(u32, 114);
pub const OLEUI_ERR_LOADSTRING = @as(u32, 115);
pub const OLEUI_ERR_STANDARDMAX = @as(u32, 116);
pub const IOF_SHOWHELP = @as(i32, 1);
pub const IOF_SELECTCREATENEW = @as(i32, 2);
pub const IOF_SELECTCREATEFROMFILE = @as(i32, 4);
pub const IOF_CHECKLINK = @as(i32, 8);
pub const IOF_CHECKDISPLAYASICON = @as(i32, 16);
pub const IOF_CREATENEWOBJECT = @as(i32, 32);
pub const IOF_CREATEFILEOBJECT = @as(i32, 64);
pub const IOF_CREATELINKOBJECT = @as(i32, 128);
pub const IOF_DISABLELINK = @as(i32, 256);
pub const IOF_VERIFYSERVERSEXIST = @as(i32, 512);
pub const IOF_DISABLEDISPLAYASICON = @as(i32, 1024);
pub const IOF_HIDECHANGEICON = @as(i32, 2048);
pub const IOF_SHOWINSERTCONTROL = @as(i32, 4096);
pub const IOF_SELECTCREATECONTROL = @as(i32, 8192);
pub const OLEUI_IOERR_LPSZFILEINVALID = @as(u32, 116);
pub const OLEUI_IOERR_LPSZLABELINVALID = @as(u32, 117);
pub const OLEUI_IOERR_HICONINVALID = @as(u32, 118);
pub const OLEUI_IOERR_LPFORMATETCINVALID = @as(u32, 119);
pub const OLEUI_IOERR_PPVOBJINVALID = @as(u32, 120);
pub const OLEUI_IOERR_LPIOLECLIENTSITEINVALID = @as(u32, 121);
pub const OLEUI_IOERR_LPISTORAGEINVALID = @as(u32, 122);
pub const OLEUI_IOERR_SCODEHASERROR = @as(u32, 123);
pub const OLEUI_IOERR_LPCLSIDEXCLUDEINVALID = @as(u32, 124);
pub const OLEUI_IOERR_CCHFILEINVALID = @as(u32, 125);
pub const PS_MAXLINKTYPES = @as(u32, 8);
pub const PSF_SHOWHELP = @as(i32, 1);
pub const PSF_SELECTPASTE = @as(i32, 2);
pub const PSF_SELECTPASTELINK = @as(i32, 4);
pub const PSF_CHECKDISPLAYASICON = @as(i32, 8);
pub const PSF_DISABLEDISPLAYASICON = @as(i32, 16);
pub const PSF_HIDECHANGEICON = @as(i32, 32);
pub const PSF_STAYONCLIPBOARDCHANGE = @as(i32, 64);
pub const PSF_NOREFRESHDATAOBJECT = @as(i32, 128);
pub const OLEUI_IOERR_SRCDATAOBJECTINVALID = @as(u32, 116);
pub const OLEUI_IOERR_ARRPASTEENTRIESINVALID = @as(u32, 117);
pub const OLEUI_IOERR_ARRLINKTYPESINVALID = @as(u32, 118);
pub const OLEUI_PSERR_CLIPBOARDCHANGED = @as(u32, 119);
pub const OLEUI_PSERR_GETCLIPBOARDFAILED = @as(u32, 120);
pub const OLEUI_ELERR_LINKCNTRNULL = @as(u32, 116);
pub const OLEUI_ELERR_LINKCNTRINVALID = @as(u32, 117);
pub const ELF_SHOWHELP = @as(i32, 1);
pub const ELF_DISABLEUPDATENOW = @as(i32, 2);
pub const ELF_DISABLEOPENSOURCE = @as(i32, 4);
pub const ELF_DISABLECHANGESOURCE = @as(i32, 8);
pub const ELF_DISABLECANCELLINK = @as(i32, 16);
pub const CIF_SHOWHELP = @as(i32, 1);
pub const CIF_SELECTCURRENT = @as(i32, 2);
pub const CIF_SELECTDEFAULT = @as(i32, 4);
pub const CIF_SELECTFROMFILE = @as(i32, 8);
pub const CIF_USEICONEXE = @as(i32, 16);
pub const OLEUI_CIERR_MUSTHAVECLSID = @as(u32, 116);
pub const OLEUI_CIERR_MUSTHAVECURRENTMETAFILE = @as(u32, 117);
pub const OLEUI_CIERR_SZICONEXEINVALID = @as(u32, 118);
pub const CF_SHOWHELPBUTTON = @as(i32, 1);
pub const CF_SETCONVERTDEFAULT = @as(i32, 2);
pub const CF_SETACTIVATEDEFAULT = @as(i32, 4);
pub const CF_SELECTCONVERTTO = @as(i32, 8);
pub const CF_SELECTACTIVATEAS = @as(i32, 16);
pub const CF_DISABLEDISPLAYASICON = @as(i32, 32);
pub const CF_DISABLEACTIVATEAS = @as(i32, 64);
pub const CF_HIDECHANGEICON = @as(i32, 128);
pub const CF_CONVERTONLY = @as(i32, 256);
pub const OLEUI_CTERR_CLASSIDINVALID = @as(u32, 117);
pub const OLEUI_CTERR_DVASPECTINVALID = @as(u32, 118);
pub const OLEUI_CTERR_CBFORMATINVALID = @as(u32, 119);
pub const OLEUI_CTERR_HMETAPICTINVALID = @as(u32, 120);
pub const OLEUI_CTERR_STRINGINVALID = @as(u32, 121);
pub const BZ_DISABLECANCELBUTTON = @as(i32, 1);
pub const BZ_DISABLESWITCHTOBUTTON = @as(i32, 2);
pub const BZ_DISABLERETRYBUTTON = @as(i32, 4);
pub const BZ_NOTRESPONDINGDIALOG = @as(i32, 8);
pub const OLEUI_BZERR_HTASKINVALID = @as(u32, 116);
pub const OLEUI_BZ_SWITCHTOSELECTED = @as(u32, 117);
pub const OLEUI_BZ_RETRYSELECTED = @as(u32, 118);
pub const OLEUI_BZ_CALLUNBLOCKED = @as(u32, 119);
pub const CSF_SHOWHELP = @as(i32, 1);
pub const CSF_VALIDSOURCE = @as(i32, 2);
pub const CSF_ONLYGETSOURCE = @as(i32, 4);
pub const CSF_EXPLORER = @as(i32, 8);
pub const OLEUI_CSERR_LINKCNTRNULL = @as(u32, 116);
pub const OLEUI_CSERR_LINKCNTRINVALID = @as(u32, 117);
pub const OLEUI_CSERR_FROMNOTNULL = @as(u32, 118);
pub const OLEUI_CSERR_TONOTNULL = @as(u32, 119);
pub const OLEUI_CSERR_SOURCENULL = @as(u32, 120);
pub const OLEUI_CSERR_SOURCEINVALID = @as(u32, 121);
pub const OLEUI_CSERR_SOURCEPARSERROR = @as(u32, 122);
pub const OLEUI_CSERR_SOURCEPARSEERROR = @as(u32, 122);
pub const VPF_SELECTRELATIVE = @as(i32, 1);
pub const VPF_DISABLERELATIVE = @as(i32, 2);
pub const VPF_DISABLESCALE = @as(i32, 4);
pub const OPF_OBJECTISLINK = @as(i32, 1);
pub const OPF_NOFILLDEFAULT = @as(i32, 2);
pub const OPF_SHOWHELP = @as(i32, 4);
pub const OPF_DISABLECONVERT = @as(i32, 8);
pub const OLEUI_OPERR_SUBPROPNULL = @as(u32, 116);
pub const OLEUI_OPERR_SUBPROPINVALID = @as(u32, 117);
pub const OLEUI_OPERR_PROPSHEETNULL = @as(u32, 118);
pub const OLEUI_OPERR_PROPSHEETINVALID = @as(u32, 119);
pub const OLEUI_OPERR_SUPPROP = @as(u32, 120);
pub const OLEUI_OPERR_PROPSINVALID = @as(u32, 121);
pub const OLEUI_OPERR_PAGESINCORRECT = @as(u32, 122);
pub const OLEUI_OPERR_INVALIDPAGES = @as(u32, 123);
pub const OLEUI_OPERR_NOTSUPPORTED = @as(u32, 124);
pub const OLEUI_OPERR_DLGPROCNOTNULL = @as(u32, 125);
pub const OLEUI_OPERR_LPARAMNOTZERO = @as(u32, 126);
pub const OLEUI_GPERR_STRINGINVALID = @as(u32, 127);
pub const OLEUI_GPERR_CLASSIDINVALID = @as(u32, 128);
pub const OLEUI_GPERR_LPCLSIDEXCLUDEINVALID = @as(u32, 129);
pub const OLEUI_GPERR_CBFORMATINVALID = @as(u32, 130);
pub const OLEUI_VPERR_METAPICTINVALID = @as(u32, 131);
pub const OLEUI_VPERR_DVASPECTINVALID = @as(u32, 132);
pub const OLEUI_LPERR_LINKCNTRNULL = @as(u32, 133);
pub const OLEUI_LPERR_LINKCNTRINVALID = @as(u32, 134);
pub const OLEUI_OPERR_PROPERTYSHEET = @as(u32, 135);
pub const OLEUI_OPERR_OBJINFOINVALID = @as(u32, 136);
pub const OLEUI_OPERR_LINKINFOINVALID = @as(u32, 137);
pub const OLEUI_QUERY_GETCLASSID = @as(u32, 65280);
pub const OLEUI_QUERY_LINKBROKEN = @as(u32, 65281);
pub const FADF_AUTO = @as(u32, 1);
pub const FADF_STATIC = @as(u32, 2);
pub const FADF_EMBEDDED = @as(u32, 4);
pub const FADF_FIXEDSIZE = @as(u32, 16);
pub const FADF_RECORD = @as(u32, 32);
pub const FADF_HAVEIID = @as(u32, 64);
pub const FADF_HAVEVARTYPE = @as(u32, 128);
pub const FADF_BSTR = @as(u32, 256);
pub const FADF_UNKNOWN = @as(u32, 512);
pub const FADF_DISPATCH = @as(u32, 1024);
pub const FADF_VARIANT = @as(u32, 2048);
pub const FADF_RESERVED = @as(u32, 61448);
pub const PARAMFLAG_NONE = @as(u32, 0);
pub const PARAMFLAG_FIN = @as(u32, 1);
pub const PARAMFLAG_FOUT = @as(u32, 2);
pub const PARAMFLAG_FLCID = @as(u32, 4);
pub const PARAMFLAG_FRETVAL = @as(u32, 8);
pub const PARAMFLAG_FOPT = @as(u32, 16);
pub const PARAMFLAG_FHASDEFAULT = @as(u32, 32);
pub const PARAMFLAG_FHASCUSTDATA = @as(u32, 64);
pub const IDLFLAG_NONE = @as(u32, 0);
pub const IDLFLAG_FIN = @as(u32, 1);
pub const IDLFLAG_FOUT = @as(u32, 2);
pub const IDLFLAG_FLCID = @as(u32, 4);
pub const IDLFLAG_FRETVAL = @as(u32, 8);
pub const IMPLTYPEFLAG_FDEFAULT = @as(u32, 1);
pub const IMPLTYPEFLAG_FSOURCE = @as(u32, 2);
pub const IMPLTYPEFLAG_FRESTRICTED = @as(u32, 4);
pub const IMPLTYPEFLAG_FDEFAULTVTABLE = @as(u32, 8);
pub const DISPID_UNKNOWN = @as(i32, -1);
pub const DISPID_VALUE = @as(u32, 0);
pub const DISPID_PROPERTYPUT = @as(i32, -3);
pub const DISPID_NEWENUM = @as(i32, -4);
pub const DISPID_EVALUATE = @as(i32, -5);
pub const DISPID_CONSTRUCTOR = @as(i32, -6);
pub const DISPID_DESTRUCTOR = @as(i32, -7);
pub const DISPID_COLLECT = @as(i32, -8);
pub const STDOLE_MAJORVERNUM = @as(u32, 1);
pub const STDOLE_MINORVERNUM = @as(u32, 0);
pub const STDOLE_LCID = @as(u32, 0);
pub const STDOLE2_MAJORVERNUM = @as(u32, 2);
pub const STDOLE2_MINORVERNUM = @as(u32, 0);
pub const STDOLE2_LCID = @as(u32, 0);
pub const VARIANT_NOVALUEPROP = @as(u32, 1);
pub const VARIANT_ALPHABOOL = @as(u32, 2);
pub const VARIANT_NOUSEROVERRIDE = @as(u32, 4);
pub const VARIANT_CALENDAR_HIJRI = @as(u32, 8);
pub const VARIANT_LOCALBOOL = @as(u32, 16);
pub const VARIANT_CALENDAR_THAI = @as(u32, 32);
pub const VARIANT_CALENDAR_GREGORIAN = @as(u32, 64);
pub const VARIANT_USE_NLS = @as(u32, 128);
pub const LOCALE_USE_NLS = @as(u32, 268435456);
pub const VTDATEGRE_MAX = @as(u32, 2958465);
pub const VTDATEGRE_MIN = @as(i32, -657434);
pub const NUMPRS_LEADING_WHITE = @as(u32, 1);
pub const NUMPRS_TRAILING_WHITE = @as(u32, 2);
pub const NUMPRS_LEADING_PLUS = @as(u32, 4);
pub const NUMPRS_TRAILING_PLUS = @as(u32, 8);
pub const NUMPRS_LEADING_MINUS = @as(u32, 16);
pub const NUMPRS_TRAILING_MINUS = @as(u32, 32);
pub const NUMPRS_HEX_OCT = @as(u32, 64);
pub const NUMPRS_PARENS = @as(u32, 128);
pub const NUMPRS_DECIMAL = @as(u32, 256);
pub const NUMPRS_THOUSANDS = @as(u32, 512);
pub const NUMPRS_CURRENCY = @as(u32, 1024);
pub const NUMPRS_EXPONENT = @as(u32, 2048);
pub const NUMPRS_USE_ALL = @as(u32, 4096);
pub const NUMPRS_STD = @as(u32, 8191);
pub const NUMPRS_NEG = @as(u32, 65536);
pub const NUMPRS_INEXACT = @as(u32, 131072);
pub const VARCMP_LT = @as(u32, 0);
pub const VARCMP_EQ = @as(u32, 1);
pub const VARCMP_GT = @as(u32, 2);
pub const VARCMP_NULL = @as(u32, 3);
pub const MEMBERID_NIL = @as(i32, -1);
pub const ID_DEFAULTINST = @as(i32, -2);
pub const DISPATCH_METHOD = @as(u32, 1);
pub const DISPATCH_PROPERTYGET = @as(u32, 2);
pub const DISPATCH_PROPERTYPUT = @as(u32, 4);
pub const DISPATCH_PROPERTYPUTREF = @as(u32, 8);
pub const LOAD_TLB_AS_32BIT = @as(u32, 32);
pub const LOAD_TLB_AS_64BIT = @as(u32, 64);
pub const ACTIVEOBJECT_STRONG = @as(u32, 0);
pub const ACTIVEOBJECT_WEAK = @as(u32, 1);
pub const DISPATCH_CONSTRUCT = @as(u32, 16384);
pub const DISPID_STARTENUM = @as(i32, -1);
pub const SID_VariantConversion = Guid.initString("1f101481-bccd-11d0-9336-00a0c90dcaa9");
pub const SID_GetCaller = Guid.initString("4717cc40-bcb9-11d0-9336-00a0c90dcaa9");
pub const SID_ProvideRuntimeContext = Guid.initString("74a5040c-dd0c-48f0-ac85-194c3259180a");

//--------------------------------------------------------------------------------
// Section: Types (217)
//--------------------------------------------------------------------------------
pub const UPDFCACHE_FLAGS = enum(u32) {
    ALL = 2147483647,
    ALLBUTNODATACACHE = 2147483646,
    NORMALCACHE = 8,
    IFBLANK = 16,
    ONLYIFBLANK = 2147483648,
    NODATACACHE = 1,
    ONSAVECACHE = 2,
    ONSTOPCACHE = 4,
    IFBLANKORONSAVECACHE = 18,
    _,
    pub fn initFlags(o: struct {
        ALL: u1 = 0,
        ALLBUTNODATACACHE: u1 = 0,
        NORMALCACHE: u1 = 0,
        IFBLANK: u1 = 0,
        ONLYIFBLANK: u1 = 0,
        NODATACACHE: u1 = 0,
        ONSAVECACHE: u1 = 0,
        ONSTOPCACHE: u1 = 0,
        IFBLANKORONSAVECACHE: u1 = 0,
    }) UPDFCACHE_FLAGS {
        return @as(UPDFCACHE_FLAGS, @enumFromInt((if (o.ALL == 1) @intFromEnum(UPDFCACHE_FLAGS.ALL) else 0) | (if (o.ALLBUTNODATACACHE == 1) @intFromEnum(UPDFCACHE_FLAGS.ALLBUTNODATACACHE) else 0) | (if (o.NORMALCACHE == 1) @intFromEnum(UPDFCACHE_FLAGS.NORMALCACHE) else 0) | (if (o.IFBLANK == 1) @intFromEnum(UPDFCACHE_FLAGS.IFBLANK) else 0) | (if (o.ONLYIFBLANK == 1) @intFromEnum(UPDFCACHE_FLAGS.ONLYIFBLANK) else 0) | (if (o.NODATACACHE == 1) @intFromEnum(UPDFCACHE_FLAGS.NODATACACHE) else 0) | (if (o.ONSAVECACHE == 1) @intFromEnum(UPDFCACHE_FLAGS.ONSAVECACHE) else 0) | (if (o.ONSTOPCACHE == 1) @intFromEnum(UPDFCACHE_FLAGS.ONSTOPCACHE) else 0) | (if (o.IFBLANKORONSAVECACHE == 1) @intFromEnum(UPDFCACHE_FLAGS.IFBLANKORONSAVECACHE) else 0)));
    }
};
pub const UPDFCACHE_ALL = UPDFCACHE_FLAGS.ALL;
pub const UPDFCACHE_ALLBUTNODATACACHE = UPDFCACHE_FLAGS.ALLBUTNODATACACHE;
pub const UPDFCACHE_NORMALCACHE = UPDFCACHE_FLAGS.NORMALCACHE;
pub const UPDFCACHE_IFBLANK = UPDFCACHE_FLAGS.IFBLANK;
pub const UPDFCACHE_ONLYIFBLANK = UPDFCACHE_FLAGS.ONLYIFBLANK;
pub const UPDFCACHE_NODATACACHE = UPDFCACHE_FLAGS.NODATACACHE;
pub const UPDFCACHE_ONSAVECACHE = UPDFCACHE_FLAGS.ONSAVECACHE;
pub const UPDFCACHE_ONSTOPCACHE = UPDFCACHE_FLAGS.ONSTOPCACHE;
pub const UPDFCACHE_IFBLANKORONSAVECACHE = UPDFCACHE_FLAGS.IFBLANKORONSAVECACHE;

pub const ENUM_CONTROLS_WHICH_FLAGS = enum(u32) {
    W_WCH_SIBLING = 1,
    _WCH_CONTAINER = 2,
    _WCH_CONTAINED = 3,
    _WCH_ALL = 4,
    _WCH_FREVERSEDIR = 134217728,
    _WCH_FONLYAFTER = 268435456,
    _WCH_FONLYBEFORE = 536870912,
    _WCH_FSELECTED = 1073741824,
};
pub const GCW_WCH_SIBLING = ENUM_CONTROLS_WHICH_FLAGS.W_WCH_SIBLING;
pub const GC_WCH_CONTAINER = ENUM_CONTROLS_WHICH_FLAGS._WCH_CONTAINER;
pub const GC_WCH_CONTAINED = ENUM_CONTROLS_WHICH_FLAGS._WCH_CONTAINED;
pub const GC_WCH_ALL = ENUM_CONTROLS_WHICH_FLAGS._WCH_ALL;
pub const GC_WCH_FREVERSEDIR = ENUM_CONTROLS_WHICH_FLAGS._WCH_FREVERSEDIR;
pub const GC_WCH_FONLYAFTER = ENUM_CONTROLS_WHICH_FLAGS._WCH_FONLYAFTER;
pub const GC_WCH_FONLYBEFORE = ENUM_CONTROLS_WHICH_FLAGS._WCH_FONLYBEFORE;
pub const GC_WCH_FSELECTED = ENUM_CONTROLS_WHICH_FLAGS._WCH_FSELECTED;

pub const MULTICLASSINFO_FLAGS = enum(u32) {
    TYPEINFO = 1,
    NUMRESERVEDDISPIDS = 2,
    IIDPRIMARY = 4,
    IIDSOURCE = 8,
};
pub const MULTICLASSINFO_GETTYPEINFO = MULTICLASSINFO_FLAGS.TYPEINFO;
pub const MULTICLASSINFO_GETNUMRESERVEDDISPIDS = MULTICLASSINFO_FLAGS.NUMRESERVEDDISPIDS;
pub const MULTICLASSINFO_GETIIDPRIMARY = MULTICLASSINFO_FLAGS.IIDPRIMARY;
pub const MULTICLASSINFO_GETIIDSOURCE = MULTICLASSINFO_FLAGS.IIDSOURCE;

pub const VARENUM = enum(i32) {
    EMPTY = 0,
    NULL = 1,
    I2 = 2,
    I4 = 3,
    R4 = 4,
    R8 = 5,
    CY = 6,
    DATE = 7,
    BSTR = 8,
    DISPATCH = 9,
    ERROR = 10,
    BOOL = 11,
    VARIANT = 12,
    UNKNOWN = 13,
    DECIMAL = 14,
    I1 = 16,
    UI1 = 17,
    UI2 = 18,
    UI4 = 19,
    I8 = 20,
    UI8 = 21,
    INT = 22,
    UINT = 23,
    VOID = 24,
    HRESULT = 25,
    PTR = 26,
    SAFEARRAY = 27,
    CARRAY = 28,
    USERDEFINED = 29,
    LPSTR = 30,
    LPWSTR = 31,
    RECORD = 36,
    INT_PTR = 37,
    UINT_PTR = 38,
    FILETIME = 64,
    BLOB = 65,
    STREAM = 66,
    STORAGE = 67,
    STREAMED_OBJECT = 68,
    STORED_OBJECT = 69,
    BLOB_OBJECT = 70,
    CF = 71,
    CLSID = 72,
    VERSIONED_STREAM = 73,
    BSTR_BLOB = 4095,
    VECTOR = 4096,
    ARRAY = 8192,
    BYREF = 16384,
    RESERVED = 32768,
    ILLEGAL = 65535,
    // ILLEGALMASKED = 4095, this enum value conflicts with BSTR_BLOB
    // TYPEMASK = 4095, this enum value conflicts with BSTR_BLOB
};
pub const VT_EMPTY = VARENUM.EMPTY;
pub const VT_NULL = VARENUM.NULL;
pub const VT_I2 = VARENUM.I2;
pub const VT_I4 = VARENUM.I4;
pub const VT_R4 = VARENUM.R4;
pub const VT_R8 = VARENUM.R8;
pub const VT_CY = VARENUM.CY;
pub const VT_DATE = VARENUM.DATE;
pub const VT_BSTR = VARENUM.BSTR;
pub const VT_DISPATCH = VARENUM.DISPATCH;
pub const VT_ERROR = VARENUM.ERROR;
pub const VT_BOOL = VARENUM.BOOL;
pub const VT_VARIANT = VARENUM.VARIANT;
pub const VT_UNKNOWN = VARENUM.UNKNOWN;
pub const VT_DECIMAL = VARENUM.DECIMAL;
pub const VT_I1 = VARENUM.I1;
pub const VT_UI1 = VARENUM.UI1;
pub const VT_UI2 = VARENUM.UI2;
pub const VT_UI4 = VARENUM.UI4;
pub const VT_I8 = VARENUM.I8;
pub const VT_UI8 = VARENUM.UI8;
pub const VT_INT = VARENUM.INT;
pub const VT_UINT = VARENUM.UINT;
pub const VT_VOID = VARENUM.VOID;
pub const VT_HRESULT = VARENUM.HRESULT;
pub const VT_PTR = VARENUM.PTR;
pub const VT_SAFEARRAY = VARENUM.SAFEARRAY;
pub const VT_CARRAY = VARENUM.CARRAY;
pub const VT_USERDEFINED = VARENUM.USERDEFINED;
pub const VT_LPSTR = VARENUM.LPSTR;
pub const VT_LPWSTR = VARENUM.LPWSTR;
pub const VT_RECORD = VARENUM.RECORD;
pub const VT_INT_PTR = VARENUM.INT_PTR;
pub const VT_UINT_PTR = VARENUM.UINT_PTR;
pub const VT_FILETIME = VARENUM.FILETIME;
pub const VT_BLOB = VARENUM.BLOB;
pub const VT_STREAM = VARENUM.STREAM;
pub const VT_STORAGE = VARENUM.STORAGE;
pub const VT_STREAMED_OBJECT = VARENUM.STREAMED_OBJECT;
pub const VT_STORED_OBJECT = VARENUM.STORED_OBJECT;
pub const VT_BLOB_OBJECT = VARENUM.BLOB_OBJECT;
pub const VT_CF = VARENUM.CF;
pub const VT_CLSID = VARENUM.CLSID;
pub const VT_VERSIONED_STREAM = VARENUM.VERSIONED_STREAM;
pub const VT_BSTR_BLOB = VARENUM.BSTR_BLOB;
pub const VT_VECTOR = VARENUM.VECTOR;
pub const VT_ARRAY = VARENUM.ARRAY;
pub const VT_BYREF = VARENUM.BYREF;
pub const VT_RESERVED = VARENUM.RESERVED;
pub const VT_ILLEGAL = VARENUM.ILLEGAL;
pub const VT_ILLEGALMASKED = VARENUM.BSTR_BLOB;
pub const VT_TYPEMASK = VARENUM.BSTR_BLOB;

pub const _wireSAFEARR_BSTR = extern struct {
    Size: u32,
    aBstr: ?*?*FLAGGED_WORD_BLOB,
};

pub const _wireSAFEARR_UNKNOWN = extern struct {
    Size: u32,
    apUnknown: ?*?*IUnknown,
};

pub const _wireSAFEARR_DISPATCH = extern struct {
    Size: u32,
    apDispatch: ?*?*IDispatch,
};

pub const _wireSAFEARR_VARIANT = extern struct {
    Size: u32,
    aVariant: ?*?*_wireVARIANT,
};

pub const _wireSAFEARR_BRECORD = extern struct {
    Size: u32,
    aRecord: ?*?*_wireBRECORD,
};

pub const _wireSAFEARR_HAVEIID = extern struct {
    Size: u32,
    apUnknown: ?*?*IUnknown,
    iid: Guid,
};

pub const SF_TYPE = enum(i32) {
    ERROR = 10,
    I1 = 16,
    I2 = 2,
    I4 = 3,
    I8 = 20,
    BSTR = 8,
    UNKNOWN = 13,
    DISPATCH = 9,
    VARIANT = 12,
    RECORD = 36,
    HAVEIID = 32781,
};
pub const SF_ERROR = SF_TYPE.ERROR;
pub const SF_I1 = SF_TYPE.I1;
pub const SF_I2 = SF_TYPE.I2;
pub const SF_I4 = SF_TYPE.I4;
pub const SF_I8 = SF_TYPE.I8;
pub const SF_BSTR = SF_TYPE.BSTR;
pub const SF_UNKNOWN = SF_TYPE.UNKNOWN;
pub const SF_DISPATCH = SF_TYPE.DISPATCH;
pub const SF_VARIANT = SF_TYPE.VARIANT;
pub const SF_RECORD = SF_TYPE.RECORD;
pub const SF_HAVEIID = SF_TYPE.HAVEIID;

pub const _wireSAFEARRAY_UNION = extern struct {
    sfType: u32,
    u: extern struct {
        BstrStr: _wireSAFEARR_BSTR,
        UnknownStr: _wireSAFEARR_UNKNOWN,
        DispatchStr: _wireSAFEARR_DISPATCH,
        VariantStr: _wireSAFEARR_VARIANT,
        RecordStr: _wireSAFEARR_BRECORD,
        HaveIidStr: _wireSAFEARR_HAVEIID,
        ByteStr: BYTE_SIZEDARR,
        WordStr: SHORT_SIZEDARR,
        LongStr: LONG_SIZEDARR,
        HyperStr: HYPER_SIZEDARR,
    },
};

pub const _wireSAFEARRAY = extern struct {
    cDims: u16,
    fFeatures: u16,
    cbElements: u32,
    cLocks: u32,
    uArrayStructs: _wireSAFEARRAY_UNION,
    rgsabound: [1]SAFEARRAYBOUND,
};

pub const _wireBRECORD = extern struct {
    fFlags: u32,
    clSize: u32,
    pRecInfo: ?*IRecordInfo,
    pRecord: ?*u8,
};

pub const _wireVARIANT = extern struct {
    clSize: u32,
    rpcReserved: u32,
    vt: u16,
    wReserved1: u16,
    wReserved2: u16,
    wReserved3: u16,
    Anonymous: extern union {
        llVal: i64,
        lVal: i32,
        bVal: u8,
        iVal: i16,
        fltVal: f32,
        dblVal: f64,
        boolVal: i16,
        scode: i32,
        cyVal: CY,
        date: f64,
        bstrVal: ?*FLAGGED_WORD_BLOB,
        punkVal: ?*IUnknown,
        pdispVal: ?*IDispatch,
        parray: ?*?*_wireSAFEARRAY,
        brecVal: ?*_wireBRECORD,
        pbVal: ?*u8,
        piVal: ?*i16,
        plVal: ?*i32,
        pllVal: ?*i64,
        pfltVal: ?*f32,
        pdblVal: ?*f64,
        pboolVal: ?*i16,
        pscode: ?*i32,
        pcyVal: ?*CY,
        pdate: ?*f64,
        pbstrVal: ?*?*FLAGGED_WORD_BLOB,
        ppunkVal: ?*?*IUnknown,
        ppdispVal: ?*?*IDispatch,
        pparray: ?*?*?*_wireSAFEARRAY,
        pvarVal: ?*?*_wireVARIANT,
        cVal: CHAR,
        uiVal: u16,
        ulVal: u32,
        ullVal: u64,
        intVal: i32,
        uintVal: u32,
        decVal: DECIMAL,
        pdecVal: ?*DECIMAL,
        pcVal: ?PSTR,
        puiVal: ?*u16,
        pulVal: ?*u32,
        pullVal: ?*u64,
        pintVal: ?*i32,
        puintVal: ?*u32,
    },
};

pub const ARRAYDESC = extern struct {
    tdescElem: TYPEDESC,
    cDims: u16,
    rgbounds: [1]SAFEARRAYBOUND,
};

pub const PARAMDESCEX = extern struct {
    cBytes: u32,
    varDefaultValue: VARIANT,
};

pub const PARAMDESC = extern struct {
    pparamdescex: ?*PARAMDESCEX,
    wParamFlags: u16,
};

pub const TYPEFLAGS = enum(i32) {
    APPOBJECT = 1,
    CANCREATE = 2,
    LICENSED = 4,
    PREDECLID = 8,
    HIDDEN = 16,
    CONTROL = 32,
    DUAL = 64,
    NONEXTENSIBLE = 128,
    OLEAUTOMATION = 256,
    RESTRICTED = 512,
    AGGREGATABLE = 1024,
    REPLACEABLE = 2048,
    DISPATCHABLE = 4096,
    REVERSEBIND = 8192,
    PROXY = 16384,
};
pub const TYPEFLAG_FAPPOBJECT = TYPEFLAGS.APPOBJECT;
pub const TYPEFLAG_FCANCREATE = TYPEFLAGS.CANCREATE;
pub const TYPEFLAG_FLICENSED = TYPEFLAGS.LICENSED;
pub const TYPEFLAG_FPREDECLID = TYPEFLAGS.PREDECLID;
pub const TYPEFLAG_FHIDDEN = TYPEFLAGS.HIDDEN;
pub const TYPEFLAG_FCONTROL = TYPEFLAGS.CONTROL;
pub const TYPEFLAG_FDUAL = TYPEFLAGS.DUAL;
pub const TYPEFLAG_FNONEXTENSIBLE = TYPEFLAGS.NONEXTENSIBLE;
pub const TYPEFLAG_FOLEAUTOMATION = TYPEFLAGS.OLEAUTOMATION;
pub const TYPEFLAG_FRESTRICTED = TYPEFLAGS.RESTRICTED;
pub const TYPEFLAG_FAGGREGATABLE = TYPEFLAGS.AGGREGATABLE;
pub const TYPEFLAG_FREPLACEABLE = TYPEFLAGS.REPLACEABLE;
pub const TYPEFLAG_FDISPATCHABLE = TYPEFLAGS.DISPATCHABLE;
pub const TYPEFLAG_FREVERSEBIND = TYPEFLAGS.REVERSEBIND;
pub const TYPEFLAG_FPROXY = TYPEFLAGS.PROXY;

pub const FUNCFLAGS = enum(i32) {
    RESTRICTED = 1,
    SOURCE = 2,
    BINDABLE = 4,
    REQUESTEDIT = 8,
    DISPLAYBIND = 16,
    DEFAULTBIND = 32,
    HIDDEN = 64,
    USESGETLASTERROR = 128,
    DEFAULTCOLLELEM = 256,
    UIDEFAULT = 512,
    NONBROWSABLE = 1024,
    REPLACEABLE = 2048,
    IMMEDIATEBIND = 4096,
};
pub const FUNCFLAG_FRESTRICTED = FUNCFLAGS.RESTRICTED;
pub const FUNCFLAG_FSOURCE = FUNCFLAGS.SOURCE;
pub const FUNCFLAG_FBINDABLE = FUNCFLAGS.BINDABLE;
pub const FUNCFLAG_FREQUESTEDIT = FUNCFLAGS.REQUESTEDIT;
pub const FUNCFLAG_FDISPLAYBIND = FUNCFLAGS.DISPLAYBIND;
pub const FUNCFLAG_FDEFAULTBIND = FUNCFLAGS.DEFAULTBIND;
pub const FUNCFLAG_FHIDDEN = FUNCFLAGS.HIDDEN;
pub const FUNCFLAG_FUSESGETLASTERROR = FUNCFLAGS.USESGETLASTERROR;
pub const FUNCFLAG_FDEFAULTCOLLELEM = FUNCFLAGS.DEFAULTCOLLELEM;
pub const FUNCFLAG_FUIDEFAULT = FUNCFLAGS.UIDEFAULT;
pub const FUNCFLAG_FNONBROWSABLE = FUNCFLAGS.NONBROWSABLE;
pub const FUNCFLAG_FREPLACEABLE = FUNCFLAGS.REPLACEABLE;
pub const FUNCFLAG_FIMMEDIATEBIND = FUNCFLAGS.IMMEDIATEBIND;

pub const VARFLAGS = enum(i32) {
    READONLY = 1,
    SOURCE = 2,
    BINDABLE = 4,
    REQUESTEDIT = 8,
    DISPLAYBIND = 16,
    DEFAULTBIND = 32,
    HIDDEN = 64,
    RESTRICTED = 128,
    DEFAULTCOLLELEM = 256,
    UIDEFAULT = 512,
    NONBROWSABLE = 1024,
    REPLACEABLE = 2048,
    IMMEDIATEBIND = 4096,
};
pub const VARFLAG_FREADONLY = VARFLAGS.READONLY;
pub const VARFLAG_FSOURCE = VARFLAGS.SOURCE;
pub const VARFLAG_FBINDABLE = VARFLAGS.BINDABLE;
pub const VARFLAG_FREQUESTEDIT = VARFLAGS.REQUESTEDIT;
pub const VARFLAG_FDISPLAYBIND = VARFLAGS.DISPLAYBIND;
pub const VARFLAG_FDEFAULTBIND = VARFLAGS.DEFAULTBIND;
pub const VARFLAG_FHIDDEN = VARFLAGS.HIDDEN;
pub const VARFLAG_FRESTRICTED = VARFLAGS.RESTRICTED;
pub const VARFLAG_FDEFAULTCOLLELEM = VARFLAGS.DEFAULTCOLLELEM;
pub const VARFLAG_FUIDEFAULT = VARFLAGS.UIDEFAULT;
pub const VARFLAG_FNONBROWSABLE = VARFLAGS.NONBROWSABLE;
pub const VARFLAG_FREPLACEABLE = VARFLAGS.REPLACEABLE;
pub const VARFLAG_FIMMEDIATEBIND = VARFLAGS.IMMEDIATEBIND;

pub const CLEANLOCALSTORAGE = extern struct {
    pInterface: ?*IUnknown,
    pStorage: ?*anyopaque,
    flags: u32,
};

const IID_ICreateTypeInfo_Value = Guid.initString("00020405-0000-0000-c000-000000000046");
pub const IID_ICreateTypeInfo = &IID_ICreateTypeInfo_Value;
pub const ICreateTypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                guid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                guid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                uTypeFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                uTypeFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                pStrDoc: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                pStrDoc: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHelpContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                wMajorVerNum: u16,
                wMinorVerNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                wMajorVerNum: u16,
                wMinorVerNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRefTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                pTInfo: ?*ITypeInfo,
                phRefType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                pTInfo: ?*ITypeInfo,
                phRefType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFuncDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                pFuncDesc: ?*FUNCDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                pFuncDesc: ?*FUNCDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddImplType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                hRefType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                hRefType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplTypeFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                implTypeFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                implTypeFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                cbAlignment: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                cbAlignment: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSchema: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                pStrSchema: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                pStrSchema: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddVarDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                pVarDesc: ?*VARDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                pVarDesc: ?*VARDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFuncAndParamNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                rgszNames: [*]?PWSTR,
                cNames: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                rgszNames: [*]?PWSTR,
                cNames: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVarName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                szName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                szName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeDescAlias: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                pTDescAlias: ?*TYPEDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                pTDescAlias: ?*TYPEDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineFuncAsDllEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                szDllName: ?PWSTR,
                szProcName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                szDllName: ?PWSTR,
                szProcName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFuncDocString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                szDocString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                szDocString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVarDocString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                szDocString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                szDocString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFuncHelpContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVarHelpContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMops: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                index: u32,
                bstrMops: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                index: u32,
                bstrMops: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeIdldesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
                pIdlDesc: ?*IDLDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
                pIdlDesc: ?*IDLDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LayOut: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetGuid(self: *const T, guid: ?*const Guid) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetGuid(@as(*const ICreateTypeInfo, @ptrCast(self)), guid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetTypeFlags(self: *const T, uTypeFlags: u32) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetTypeFlags(@as(*const ICreateTypeInfo, @ptrCast(self)), uTypeFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetDocString(self: *const T, pStrDoc: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetDocString(@as(*const ICreateTypeInfo, @ptrCast(self)), pStrDoc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetHelpContext(self: *const T, dwHelpContext: u32) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetHelpContext(@as(*const ICreateTypeInfo, @ptrCast(self)), dwHelpContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetVersion(self: *const T, wMajorVerNum: u16, wMinorVerNum: u16) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetVersion(@as(*const ICreateTypeInfo, @ptrCast(self)), wMajorVerNum, wMinorVerNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_AddRefTypeInfo(self: *const T, pTInfo: ?*ITypeInfo, phRefType: ?*u32) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).AddRefTypeInfo(@as(*const ICreateTypeInfo, @ptrCast(self)), pTInfo, phRefType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_AddFuncDesc(self: *const T, index: u32, pFuncDesc: ?*FUNCDESC) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).AddFuncDesc(@as(*const ICreateTypeInfo, @ptrCast(self)), index, pFuncDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_AddImplType(self: *const T, index: u32, hRefType: u32) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).AddImplType(@as(*const ICreateTypeInfo, @ptrCast(self)), index, hRefType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetImplTypeFlags(self: *const T, index: u32, implTypeFlags: i32) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetImplTypeFlags(@as(*const ICreateTypeInfo, @ptrCast(self)), index, implTypeFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetAlignment(self: *const T, cbAlignment: u16) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetAlignment(@as(*const ICreateTypeInfo, @ptrCast(self)), cbAlignment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetSchema(self: *const T, pStrSchema: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetSchema(@as(*const ICreateTypeInfo, @ptrCast(self)), pStrSchema);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_AddVarDesc(self: *const T, index: u32, pVarDesc: ?*VARDESC) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).AddVarDesc(@as(*const ICreateTypeInfo, @ptrCast(self)), index, pVarDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetFuncAndParamNames(self: *const T, index: u32, rgszNames: [*]?PWSTR, cNames: u32) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetFuncAndParamNames(@as(*const ICreateTypeInfo, @ptrCast(self)), index, rgszNames, cNames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetVarName(self: *const T, index: u32, szName: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetVarName(@as(*const ICreateTypeInfo, @ptrCast(self)), index, szName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetTypeDescAlias(self: *const T, pTDescAlias: ?*TYPEDESC) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetTypeDescAlias(@as(*const ICreateTypeInfo, @ptrCast(self)), pTDescAlias);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_DefineFuncAsDllEntry(self: *const T, index: u32, szDllName: ?PWSTR, szProcName: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).DefineFuncAsDllEntry(@as(*const ICreateTypeInfo, @ptrCast(self)), index, szDllName, szProcName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetFuncDocString(self: *const T, index: u32, szDocString: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetFuncDocString(@as(*const ICreateTypeInfo, @ptrCast(self)), index, szDocString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetVarDocString(self: *const T, index: u32, szDocString: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetVarDocString(@as(*const ICreateTypeInfo, @ptrCast(self)), index, szDocString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetFuncHelpContext(self: *const T, index: u32, dwHelpContext: u32) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetFuncHelpContext(@as(*const ICreateTypeInfo, @ptrCast(self)), index, dwHelpContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetVarHelpContext(self: *const T, index: u32, dwHelpContext: u32) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetVarHelpContext(@as(*const ICreateTypeInfo, @ptrCast(self)), index, dwHelpContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetMops(self: *const T, index: u32, bstrMops: ?BSTR) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetMops(@as(*const ICreateTypeInfo, @ptrCast(self)), index, bstrMops);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_SetTypeIdldesc(self: *const T, pIdlDesc: ?*IDLDESC) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).SetTypeIdldesc(@as(*const ICreateTypeInfo, @ptrCast(self)), pIdlDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo_LayOut(self: *const T) HRESULT {
                return @as(*const ICreateTypeInfo.VTable, @ptrCast(self.vtable)).LayOut(@as(*const ICreateTypeInfo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateTypeInfo2_Value = Guid.initString("0002040e-0000-0000-c000-000000000046");
pub const IID_ICreateTypeInfo2 = &IID_ICreateTypeInfo2_Value;
pub const ICreateTypeInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ICreateTypeInfo.VTable,
        DeleteFuncDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteFuncDescByMemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                memid: i32,
                invKind: INVOKEKIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                memid: i32,
                invKind: INVOKEKIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteVarDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteVarDescByMemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                memid: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                memid: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteImplType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFuncCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParamCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                indexFunc: u32,
                indexParam: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                indexFunc: u32,
                indexParam: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVarCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplTypeCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHelpStringContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                dwHelpStringContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                dwHelpStringContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFuncHelpStringContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                dwHelpStringContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                dwHelpStringContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVarHelpStringContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                dwHelpStringContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                index: u32,
                dwHelpStringContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Invalidate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeInfo2,
                szName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeInfo2,
                szName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICreateTypeInfo.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_DeleteFuncDesc(self: *const T, index: u32) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).DeleteFuncDesc(@as(*const ICreateTypeInfo2, @ptrCast(self)), index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_DeleteFuncDescByMemId(self: *const T, memid: i32, invKind: INVOKEKIND) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).DeleteFuncDescByMemId(@as(*const ICreateTypeInfo2, @ptrCast(self)), memid, invKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_DeleteVarDesc(self: *const T, index: u32) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).DeleteVarDesc(@as(*const ICreateTypeInfo2, @ptrCast(self)), index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_DeleteVarDescByMemId(self: *const T, memid: i32) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).DeleteVarDescByMemId(@as(*const ICreateTypeInfo2, @ptrCast(self)), memid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_DeleteImplType(self: *const T, index: u32) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).DeleteImplType(@as(*const ICreateTypeInfo2, @ptrCast(self)), index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_SetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).SetCustData(@as(*const ICreateTypeInfo2, @ptrCast(self)), guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_SetFuncCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).SetFuncCustData(@as(*const ICreateTypeInfo2, @ptrCast(self)), index, guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_SetParamCustData(self: *const T, indexFunc: u32, indexParam: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).SetParamCustData(@as(*const ICreateTypeInfo2, @ptrCast(self)), indexFunc, indexParam, guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_SetVarCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).SetVarCustData(@as(*const ICreateTypeInfo2, @ptrCast(self)), index, guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_SetImplTypeCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).SetImplTypeCustData(@as(*const ICreateTypeInfo2, @ptrCast(self)), index, guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_SetHelpStringContext(self: *const T, dwHelpStringContext: u32) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).SetHelpStringContext(@as(*const ICreateTypeInfo2, @ptrCast(self)), dwHelpStringContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_SetFuncHelpStringContext(self: *const T, index: u32, dwHelpStringContext: u32) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).SetFuncHelpStringContext(@as(*const ICreateTypeInfo2, @ptrCast(self)), index, dwHelpStringContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_SetVarHelpStringContext(self: *const T, index: u32, dwHelpStringContext: u32) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).SetVarHelpStringContext(@as(*const ICreateTypeInfo2, @ptrCast(self)), index, dwHelpStringContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_Invalidate(self: *const T) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).Invalidate(@as(*const ICreateTypeInfo2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeInfo2_SetName(self: *const T, szName: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeInfo2.VTable, @ptrCast(self.vtable)).SetName(@as(*const ICreateTypeInfo2, @ptrCast(self)), szName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateTypeLib_Value = Guid.initString("00020406-0000-0000-c000-000000000046");
pub const IID_ICreateTypeLib = &IID_ICreateTypeLib_Value;
pub const ICreateTypeLib = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
                szName: ?PWSTR,
                tkind: TYPEKIND,
                ppCTInfo: ?*?*ICreateTypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
                szName: ?PWSTR,
                tkind: TYPEKIND,
                ppCTInfo: ?*?*ICreateTypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
                szName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
                szName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
                wMajorVerNum: u16,
                wMinorVerNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
                wMajorVerNum: u16,
                wMinorVerNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
                guid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
                guid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
                szDoc: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
                szDoc: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHelpFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
                szHelpFileName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
                szHelpFileName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHelpContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLcid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLibFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
                uLibFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
                uLibFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveAllChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_CreateTypeInfo(self: *const T, szName: ?PWSTR, tkind: TYPEKIND, ppCTInfo: ?*?*ICreateTypeInfo) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).CreateTypeInfo(@as(*const ICreateTypeLib, @ptrCast(self)), szName, tkind, ppCTInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_SetName(self: *const T, szName: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).SetName(@as(*const ICreateTypeLib, @ptrCast(self)), szName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_SetVersion(self: *const T, wMajorVerNum: u16, wMinorVerNum: u16) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).SetVersion(@as(*const ICreateTypeLib, @ptrCast(self)), wMajorVerNum, wMinorVerNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_SetGuid(self: *const T, guid: ?*const Guid) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).SetGuid(@as(*const ICreateTypeLib, @ptrCast(self)), guid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_SetDocString(self: *const T, szDoc: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).SetDocString(@as(*const ICreateTypeLib, @ptrCast(self)), szDoc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_SetHelpFileName(self: *const T, szHelpFileName: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).SetHelpFileName(@as(*const ICreateTypeLib, @ptrCast(self)), szHelpFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_SetHelpContext(self: *const T, dwHelpContext: u32) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).SetHelpContext(@as(*const ICreateTypeLib, @ptrCast(self)), dwHelpContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_SetLcid(self: *const T, lcid: u32) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).SetLcid(@as(*const ICreateTypeLib, @ptrCast(self)), lcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_SetLibFlags(self: *const T, uLibFlags: u32) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).SetLibFlags(@as(*const ICreateTypeLib, @ptrCast(self)), uLibFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib_SaveAllChanges(self: *const T) HRESULT {
                return @as(*const ICreateTypeLib.VTable, @ptrCast(self.vtable)).SaveAllChanges(@as(*const ICreateTypeLib, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateTypeLib2_Value = Guid.initString("0002040f-0000-0000-c000-000000000046");
pub const IID_ICreateTypeLib2 = &IID_ICreateTypeLib2_Value;
pub const ICreateTypeLib2 = extern struct {
    pub const VTable = extern struct {
        base: ICreateTypeLib.VTable,
        DeleteTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib2,
                szName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib2,
                szName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib2,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib2,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHelpStringContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib2,
                dwHelpStringContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib2,
                dwHelpStringContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHelpStringDll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateTypeLib2,
                szFileName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateTypeLib2,
                szFileName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICreateTypeLib.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib2_DeleteTypeInfo(self: *const T, szName: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeLib2.VTable, @ptrCast(self.vtable)).DeleteTypeInfo(@as(*const ICreateTypeLib2, @ptrCast(self)), szName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib2_SetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ICreateTypeLib2.VTable, @ptrCast(self.vtable)).SetCustData(@as(*const ICreateTypeLib2, @ptrCast(self)), guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib2_SetHelpStringContext(self: *const T, dwHelpStringContext: u32) HRESULT {
                return @as(*const ICreateTypeLib2.VTable, @ptrCast(self.vtable)).SetHelpStringContext(@as(*const ICreateTypeLib2, @ptrCast(self)), dwHelpStringContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateTypeLib2_SetHelpStringDll(self: *const T, szFileName: ?PWSTR) HRESULT {
                return @as(*const ICreateTypeLib2.VTable, @ptrCast(self.vtable)).SetHelpStringDll(@as(*const ICreateTypeLib2, @ptrCast(self)), szFileName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumVARIANT_Value = Guid.initString("00020404-0000-0000-c000-000000000046");
pub const IID_IEnumVARIANT = &IID_IEnumVARIANT_Value;
pub const IEnumVARIANT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumVARIANT,
                celt: u32,
                rgVar: [*]VARIANT,
                pCeltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumVARIANT,
                celt: u32,
                rgVar: [*]VARIANT,
                pCeltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumVARIANT,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumVARIANT,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumVARIANT,
                ppEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumVARIANT,
                ppEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumVARIANT_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pCeltFetched: ?*u32) HRESULT {
                return @as(*const IEnumVARIANT.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumVARIANT, @ptrCast(self)), celt, rgVar, pCeltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumVARIANT_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumVARIANT.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumVARIANT, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumVARIANT_Reset(self: *const T) HRESULT {
                return @as(*const IEnumVARIANT.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumVARIANT, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumVARIANT_Clone(self: *const T, ppEnum: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IEnumVARIANT.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumVARIANT, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LIBFLAGS = enum(i32) {
    RESTRICTED = 1,
    CONTROL = 2,
    HIDDEN = 4,
    HASDISKIMAGE = 8,
};
pub const LIBFLAG_FRESTRICTED = LIBFLAGS.RESTRICTED;
pub const LIBFLAG_FCONTROL = LIBFLAGS.CONTROL;
pub const LIBFLAG_FHIDDEN = LIBFLAGS.HIDDEN;
pub const LIBFLAG_FHASDISKIMAGE = LIBFLAGS.HASDISKIMAGE;

pub const CHANGEKIND = enum(i32) {
    ADDMEMBER = 0,
    DELETEMEMBER = 1,
    SETNAMES = 2,
    SETDOCUMENTATION = 3,
    GENERAL = 4,
    INVALIDATE = 5,
    CHANGEFAILED = 6,
    MAX = 7,
};
pub const CHANGEKIND_ADDMEMBER = CHANGEKIND.ADDMEMBER;
pub const CHANGEKIND_DELETEMEMBER = CHANGEKIND.DELETEMEMBER;
pub const CHANGEKIND_SETNAMES = CHANGEKIND.SETNAMES;
pub const CHANGEKIND_SETDOCUMENTATION = CHANGEKIND.SETDOCUMENTATION;
pub const CHANGEKIND_GENERAL = CHANGEKIND.GENERAL;
pub const CHANGEKIND_INVALIDATE = CHANGEKIND.INVALIDATE;
pub const CHANGEKIND_CHANGEFAILED = CHANGEKIND.CHANGEFAILED;
pub const CHANGEKIND_MAX = CHANGEKIND.MAX;

const IID_ITypeChangeEvents_Value = Guid.initString("00020410-0000-0000-c000-000000000046");
pub const IID_ITypeChangeEvents = &IID_ITypeChangeEvents_Value;
pub const ITypeChangeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestTypeChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeChangeEvents,
                changeKind: CHANGEKIND,
                pTInfoBefore: ?*ITypeInfo,
                pStrName: ?PWSTR,
                pfCancel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeChangeEvents,
                changeKind: CHANGEKIND,
                pTInfoBefore: ?*ITypeInfo,
                pStrName: ?PWSTR,
                pfCancel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AfterTypeChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeChangeEvents,
                changeKind: CHANGEKIND,
                pTInfoAfter: ?*ITypeInfo,
                pStrName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeChangeEvents,
                changeKind: CHANGEKIND,
                pTInfoAfter: ?*ITypeInfo,
                pStrName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeChangeEvents_RequestTypeChange(self: *const T, changeKind: CHANGEKIND, pTInfoBefore: ?*ITypeInfo, pStrName: ?PWSTR, pfCancel: ?*i32) HRESULT {
                return @as(*const ITypeChangeEvents.VTable, @ptrCast(self.vtable)).RequestTypeChange(@as(*const ITypeChangeEvents, @ptrCast(self)), changeKind, pTInfoBefore, pStrName, pfCancel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeChangeEvents_AfterTypeChange(self: *const T, changeKind: CHANGEKIND, pTInfoAfter: ?*ITypeInfo, pStrName: ?PWSTR) HRESULT {
                return @as(*const ITypeChangeEvents.VTable, @ptrCast(self.vtable)).AfterTypeChange(@as(*const ITypeChangeEvents, @ptrCast(self)), changeKind, pTInfoAfter, pStrName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateErrorInfo_Value = Guid.initString("22f03340-547d-101b-8e65-08002b2bd119");
pub const IID_ICreateErrorInfo = &IID_ICreateErrorInfo_Value;
pub const ICreateErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateErrorInfo,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateErrorInfo,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateErrorInfo,
                szSource: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateErrorInfo,
                szSource: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateErrorInfo,
                szDescription: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateErrorInfo,
                szDescription: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHelpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateErrorInfo,
                szHelpFile: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateErrorInfo,
                szHelpFile: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHelpContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateErrorInfo,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateErrorInfo,
                dwHelpContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateErrorInfo_SetGUID(self: *const T, rguid: ?*const Guid) HRESULT {
                return @as(*const ICreateErrorInfo.VTable, @ptrCast(self.vtable)).SetGUID(@as(*const ICreateErrorInfo, @ptrCast(self)), rguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateErrorInfo_SetSource(self: *const T, szSource: ?PWSTR) HRESULT {
                return @as(*const ICreateErrorInfo.VTable, @ptrCast(self.vtable)).SetSource(@as(*const ICreateErrorInfo, @ptrCast(self)), szSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateErrorInfo_SetDescription(self: *const T, szDescription: ?PWSTR) HRESULT {
                return @as(*const ICreateErrorInfo.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const ICreateErrorInfo, @ptrCast(self)), szDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateErrorInfo_SetHelpFile(self: *const T, szHelpFile: ?PWSTR) HRESULT {
                return @as(*const ICreateErrorInfo.VTable, @ptrCast(self.vtable)).SetHelpFile(@as(*const ICreateErrorInfo, @ptrCast(self)), szHelpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateErrorInfo_SetHelpContext(self: *const T, dwHelpContext: u32) HRESULT {
                return @as(*const ICreateErrorInfo.VTable, @ptrCast(self.vtable)).SetHelpContext(@as(*const ICreateErrorInfo, @ptrCast(self)), dwHelpContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeFactory_Value = Guid.initString("0000002e-0000-0000-c000-000000000046");
pub const IID_ITypeFactory = &IID_ITypeFactory_Value;
pub const ITypeFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateFromTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeFactory,
                pTypeInfo: ?*ITypeInfo,
                riid: ?*const Guid,
                ppv: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeFactory,
                pTypeInfo: ?*ITypeInfo,
                riid: ?*const Guid,
                ppv: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeFactory_CreateFromTypeInfo(self: *const T, pTypeInfo: ?*ITypeInfo, riid: ?*const Guid, ppv: ?*?*IUnknown) HRESULT {
                return @as(*const ITypeFactory.VTable, @ptrCast(self.vtable)).CreateFromTypeInfo(@as(*const ITypeFactory, @ptrCast(self)), pTypeInfo, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeMarshal_Value = Guid.initString("0000002d-0000-0000-c000-000000000046");
pub const IID_ITypeMarshal = &IID_ITypeMarshal_Value;
pub const ITypeMarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Size: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeMarshal,
                pvType: ?*anyopaque,
                dwDestContext: u32,
                pvDestContext: ?*anyopaque,
                pSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeMarshal,
                pvType: ?*anyopaque,
                dwDestContext: u32,
                pvDestContext: ?*anyopaque,
                pSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Marshal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeMarshal,
                pvType: ?*anyopaque,
                dwDestContext: u32,
                pvDestContext: ?*anyopaque,
                cbBufferLength: u32,
                // TODO: what to do with BytesParamIndex 3?
                pBuffer: ?*u8,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeMarshal,
                pvType: ?*anyopaque,
                dwDestContext: u32,
                pvDestContext: ?*anyopaque,
                cbBufferLength: u32,
                // TODO: what to do with BytesParamIndex 3?
                pBuffer: ?*u8,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unmarshal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeMarshal,
                pvType: ?*anyopaque,
                dwFlags: u32,
                cbBufferLength: u32,
                pBuffer: [*:0]u8,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeMarshal,
                pvType: ?*anyopaque,
                dwFlags: u32,
                cbBufferLength: u32,
                pBuffer: [*:0]u8,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Free: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeMarshal,
                pvType: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeMarshal,
                pvType: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeMarshal_Size(self: *const T, pvType: ?*anyopaque, dwDestContext: u32, pvDestContext: ?*anyopaque, pSize: ?*u32) HRESULT {
                return @as(*const ITypeMarshal.VTable, @ptrCast(self.vtable)).Size(@as(*const ITypeMarshal, @ptrCast(self)), pvType, dwDestContext, pvDestContext, pSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeMarshal_Marshal(self: *const T, pvType: ?*anyopaque, dwDestContext: u32, pvDestContext: ?*anyopaque, cbBufferLength: u32, pBuffer: ?*u8, pcbWritten: ?*u32) HRESULT {
                return @as(*const ITypeMarshal.VTable, @ptrCast(self.vtable)).Marshal(@as(*const ITypeMarshal, @ptrCast(self)), pvType, dwDestContext, pvDestContext, cbBufferLength, pBuffer, pcbWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeMarshal_Unmarshal(self: *const T, pvType: ?*anyopaque, dwFlags: u32, cbBufferLength: u32, pBuffer: [*:0]u8, pcbRead: ?*u32) HRESULT {
                return @as(*const ITypeMarshal.VTable, @ptrCast(self.vtable)).Unmarshal(@as(*const ITypeMarshal, @ptrCast(self)), pvType, dwFlags, cbBufferLength, pBuffer, pcbRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeMarshal_Free(self: *const T, pvType: ?*anyopaque) HRESULT {
                return @as(*const ITypeMarshal.VTable, @ptrCast(self.vtable)).Free(@as(*const ITypeMarshal, @ptrCast(self)), pvType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRecordInfo_Value = Guid.initString("0000002f-0000-0000-c000-000000000046");
pub const IID_IRecordInfo = &IID_IRecordInfo_Value;
pub const IRecordInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RecordInit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pvNew: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pvNew: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RecordClear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pvExisting: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pvExisting: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RecordCopy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pvExisting: ?*anyopaque,
                pvNew: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pvExisting: ?*anyopaque,
                pvNew: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                ppTypeInfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                ppTypeInfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetField: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pvData: ?*anyopaque,
                szFieldName: ?[*:0]const u16,
                pvarField: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pvData: ?*anyopaque,
                szFieldName: ?[*:0]const u16,
                pvarField: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldNoCopy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pvData: ?*anyopaque,
                szFieldName: ?[*:0]const u16,
                pvarField: ?*VARIANT,
                ppvDataCArray: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pvData: ?*anyopaque,
                szFieldName: ?[*:0]const u16,
                pvarField: ?*VARIANT,
                ppvDataCArray: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutField: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                wFlags: u32,
                pvData: ?*anyopaque,
                szFieldName: ?[*:0]const u16,
                pvarField: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                wFlags: u32,
                pvData: ?*anyopaque,
                szFieldName: ?[*:0]const u16,
                pvarField: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutFieldNoCopy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                wFlags: u32,
                pvData: ?*anyopaque,
                szFieldName: ?[*:0]const u16,
                pvarField: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                wFlags: u32,
                pvData: ?*anyopaque,
                szFieldName: ?[*:0]const u16,
                pvarField: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pcNames: ?*u32,
                rgBstrNames: [*]?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pcNames: ?*u32,
                rgBstrNames: [*]?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsMatchingType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pRecordInfo: ?*IRecordInfo,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IRecordInfo,
                pRecordInfo: ?*IRecordInfo,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        RecordCreate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn (
                self: *const IRecordInfo,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
        RecordCreateCopy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pvSource: ?*anyopaque,
                ppvDest: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pvSource: ?*anyopaque,
                ppvDest: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RecordDestroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRecordInfo,
                pvRecord: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRecordInfo,
                pvRecord: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_RecordInit(self: *const T, pvNew: ?*anyopaque) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).RecordInit(@as(*const IRecordInfo, @ptrCast(self)), pvNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_RecordClear(self: *const T, pvExisting: ?*anyopaque) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).RecordClear(@as(*const IRecordInfo, @ptrCast(self)), pvExisting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_RecordCopy(self: *const T, pvExisting: ?*anyopaque, pvNew: ?*anyopaque) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).RecordCopy(@as(*const IRecordInfo, @ptrCast(self)), pvExisting, pvNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_GetGuid(self: *const T, pguid: ?*Guid) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).GetGuid(@as(*const IRecordInfo, @ptrCast(self)), pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_GetName(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).GetName(@as(*const IRecordInfo, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_GetSize(self: *const T, pcbSize: ?*u32) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IRecordInfo, @ptrCast(self)), pcbSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_GetTypeInfo(self: *const T, ppTypeInfo: ?*?*ITypeInfo) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).GetTypeInfo(@as(*const IRecordInfo, @ptrCast(self)), ppTypeInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_GetField(self: *const T, pvData: ?*anyopaque, szFieldName: ?[*:0]const u16, pvarField: ?*VARIANT) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).GetField(@as(*const IRecordInfo, @ptrCast(self)), pvData, szFieldName, pvarField);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_GetFieldNoCopy(self: *const T, pvData: ?*anyopaque, szFieldName: ?[*:0]const u16, pvarField: ?*VARIANT, ppvDataCArray: ?*?*anyopaque) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).GetFieldNoCopy(@as(*const IRecordInfo, @ptrCast(self)), pvData, szFieldName, pvarField, ppvDataCArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_PutField(self: *const T, wFlags: u32, pvData: ?*anyopaque, szFieldName: ?[*:0]const u16, pvarField: ?*VARIANT) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).PutField(@as(*const IRecordInfo, @ptrCast(self)), wFlags, pvData, szFieldName, pvarField);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_PutFieldNoCopy(self: *const T, wFlags: u32, pvData: ?*anyopaque, szFieldName: ?[*:0]const u16, pvarField: ?*VARIANT) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).PutFieldNoCopy(@as(*const IRecordInfo, @ptrCast(self)), wFlags, pvData, szFieldName, pvarField);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_GetFieldNames(self: *const T, pcNames: ?*u32, rgBstrNames: [*]?BSTR) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).GetFieldNames(@as(*const IRecordInfo, @ptrCast(self)), pcNames, rgBstrNames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_IsMatchingType(self: *const T, pRecordInfo: ?*IRecordInfo) BOOL {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).IsMatchingType(@as(*const IRecordInfo, @ptrCast(self)), pRecordInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_RecordCreate(self: *const T) ?*anyopaque {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).RecordCreate(@as(*const IRecordInfo, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_RecordCreateCopy(self: *const T, pvSource: ?*anyopaque, ppvDest: ?*?*anyopaque) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).RecordCreateCopy(@as(*const IRecordInfo, @ptrCast(self)), pvSource, ppvDest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRecordInfo_RecordDestroy(self: *const T, pvRecord: ?*anyopaque) HRESULT {
                return @as(*const IRecordInfo.VTable, @ptrCast(self.vtable)).RecordDestroy(@as(*const IRecordInfo, @ptrCast(self)), pvRecord);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleAdviseHolder_Value = Guid.initString("00000111-0000-0000-c000-000000000046");
pub const IID_IOleAdviseHolder = &IID_IOleAdviseHolder_Value;
pub const IOleAdviseHolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleAdviseHolder,
                pAdvise: ?*IAdviseSink,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleAdviseHolder,
                pAdvise: ?*IAdviseSink,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleAdviseHolder,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleAdviseHolder,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleAdviseHolder,
                ppenumAdvise: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleAdviseHolder,
                ppenumAdvise: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendOnRename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleAdviseHolder,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleAdviseHolder,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendOnSave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleAdviseHolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleAdviseHolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendOnClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleAdviseHolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleAdviseHolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleAdviseHolder_Advise(self: *const T, pAdvise: ?*IAdviseSink, pdwConnection: ?*u32) HRESULT {
                return @as(*const IOleAdviseHolder.VTable, @ptrCast(self.vtable)).Advise(@as(*const IOleAdviseHolder, @ptrCast(self)), pAdvise, pdwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleAdviseHolder_Unadvise(self: *const T, dwConnection: u32) HRESULT {
                return @as(*const IOleAdviseHolder.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IOleAdviseHolder, @ptrCast(self)), dwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleAdviseHolder_EnumAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) HRESULT {
                return @as(*const IOleAdviseHolder.VTable, @ptrCast(self.vtable)).EnumAdvise(@as(*const IOleAdviseHolder, @ptrCast(self)), ppenumAdvise);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleAdviseHolder_SendOnRename(self: *const T, pmk: ?*IMoniker) HRESULT {
                return @as(*const IOleAdviseHolder.VTable, @ptrCast(self.vtable)).SendOnRename(@as(*const IOleAdviseHolder, @ptrCast(self)), pmk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleAdviseHolder_SendOnSave(self: *const T) HRESULT {
                return @as(*const IOleAdviseHolder.VTable, @ptrCast(self.vtable)).SendOnSave(@as(*const IOleAdviseHolder, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleAdviseHolder_SendOnClose(self: *const T) HRESULT {
                return @as(*const IOleAdviseHolder.VTable, @ptrCast(self.vtable)).SendOnClose(@as(*const IOleAdviseHolder, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleCache_Value = Guid.initString("0000011e-0000-0000-c000-000000000046");
pub const IID_IOleCache = &IID_IOleCache_Value;
pub const IOleCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCache,
                pformatetc: ?*FORMATETC,
                advf: u32,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCache,
                pformatetc: ?*FORMATETC,
                advf: u32,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Uncache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCache,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCache,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCache,
                ppenumSTATDATA: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCache,
                ppenumSTATDATA: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCache,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCache,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCache,
                pformatetc: ?*FORMATETC,
                pmedium: ?*STGMEDIUM,
                fRelease: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCache,
                pformatetc: ?*FORMATETC,
                pmedium: ?*STGMEDIUM,
                fRelease: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCache_Cache(self: *const T, pformatetc: ?*FORMATETC, advf: u32, pdwConnection: ?*u32) HRESULT {
                return @as(*const IOleCache.VTable, @ptrCast(self.vtable)).Cache(@as(*const IOleCache, @ptrCast(self)), pformatetc, advf, pdwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCache_Uncache(self: *const T, dwConnection: u32) HRESULT {
                return @as(*const IOleCache.VTable, @ptrCast(self.vtable)).Uncache(@as(*const IOleCache, @ptrCast(self)), dwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCache_EnumCache(self: *const T, ppenumSTATDATA: ?*?*IEnumSTATDATA) HRESULT {
                return @as(*const IOleCache.VTable, @ptrCast(self.vtable)).EnumCache(@as(*const IOleCache, @ptrCast(self)), ppenumSTATDATA);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCache_InitCache(self: *const T, pDataObject: ?*IDataObject) HRESULT {
                return @as(*const IOleCache.VTable, @ptrCast(self.vtable)).InitCache(@as(*const IOleCache, @ptrCast(self)), pDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCache_SetData(self: *const T, pformatetc: ?*FORMATETC, pmedium: ?*STGMEDIUM, fRelease: BOOL) HRESULT {
                return @as(*const IOleCache.VTable, @ptrCast(self.vtable)).SetData(@as(*const IOleCache, @ptrCast(self)), pformatetc, pmedium, fRelease);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DISCARDCACHE = enum(i32) {
    SAVEIFDIRTY = 0,
    NOSAVE = 1,
};
pub const DISCARDCACHE_SAVEIFDIRTY = DISCARDCACHE.SAVEIFDIRTY;
pub const DISCARDCACHE_NOSAVE = DISCARDCACHE.NOSAVE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleCache2_Value = Guid.initString("00000128-0000-0000-c000-000000000046");
pub const IID_IOleCache2 = &IID_IOleCache2_Value;
pub const IOleCache2 = extern struct {
    pub const VTable = extern struct {
        base: IOleCache.VTable,
        UpdateCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCache2,
                pDataObject: ?*IDataObject,
                grfUpdf: UPDFCACHE_FLAGS,
                pReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCache2,
                pDataObject: ?*IDataObject,
                grfUpdf: UPDFCACHE_FLAGS,
                pReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DiscardCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCache2,
                dwDiscardOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCache2,
                dwDiscardOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleCache.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCache2_UpdateCache(self: *const T, pDataObject: ?*IDataObject, grfUpdf: UPDFCACHE_FLAGS, pReserved: ?*anyopaque) HRESULT {
                return @as(*const IOleCache2.VTable, @ptrCast(self.vtable)).UpdateCache(@as(*const IOleCache2, @ptrCast(self)), pDataObject, grfUpdf, pReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCache2_DiscardCache(self: *const T, dwDiscardOptions: u32) HRESULT {
                return @as(*const IOleCache2.VTable, @ptrCast(self.vtable)).DiscardCache(@as(*const IOleCache2, @ptrCast(self)), dwDiscardOptions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleCacheControl_Value = Guid.initString("00000129-0000-0000-c000-000000000046");
pub const IID_IOleCacheControl = &IID_IOleCacheControl_Value;
pub const IOleCacheControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCacheControl,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCacheControl,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCacheControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCacheControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCacheControl_OnRun(self: *const T, pDataObject: ?*IDataObject) HRESULT {
                return @as(*const IOleCacheControl.VTable, @ptrCast(self.vtable)).OnRun(@as(*const IOleCacheControl, @ptrCast(self)), pDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCacheControl_OnStop(self: *const T) HRESULT {
                return @as(*const IOleCacheControl.VTable, @ptrCast(self.vtable)).OnStop(@as(*const IOleCacheControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IParseDisplayName_Value = Guid.initString("0000011a-0000-0000-c000-000000000046");
pub const IID_IParseDisplayName = &IID_IParseDisplayName_Value;
pub const IParseDisplayName = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IParseDisplayName,
                pbc: ?*IBindCtx,
                pszDisplayName: ?PWSTR,
                pchEaten: ?*u32,
                ppmkOut: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IParseDisplayName,
                pbc: ?*IBindCtx,
                pszDisplayName: ?PWSTR,
                pchEaten: ?*u32,
                ppmkOut: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IParseDisplayName_ParseDisplayName(self: *const T, pbc: ?*IBindCtx, pszDisplayName: ?PWSTR, pchEaten: ?*u32, ppmkOut: ?*?*IMoniker) HRESULT {
                return @as(*const IParseDisplayName.VTable, @ptrCast(self.vtable)).ParseDisplayName(@as(*const IParseDisplayName, @ptrCast(self)), pbc, pszDisplayName, pchEaten, ppmkOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleContainer_Value = Guid.initString("0000011b-0000-0000-c000-000000000046");
pub const IID_IOleContainer = &IID_IOleContainer_Value;
pub const IOleContainer = extern struct {
    pub const VTable = extern struct {
        base: IParseDisplayName.VTable,
        EnumObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleContainer,
                grfFlags: u32,
                ppenum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleContainer,
                grfFlags: u32,
                ppenum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockContainer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleContainer,
                fLock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleContainer,
                fLock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IParseDisplayName.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleContainer_EnumObjects(self: *const T, grfFlags: u32, ppenum: ?*?*IEnumUnknown) HRESULT {
                return @as(*const IOleContainer.VTable, @ptrCast(self.vtable)).EnumObjects(@as(*const IOleContainer, @ptrCast(self)), grfFlags, ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleContainer_LockContainer(self: *const T, fLock: BOOL) HRESULT {
                return @as(*const IOleContainer.VTable, @ptrCast(self.vtable)).LockContainer(@as(*const IOleContainer, @ptrCast(self)), fLock);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleClientSite_Value = Guid.initString("00000118-0000-0000-c000-000000000046");
pub const IID_IOleClientSite = &IID_IOleClientSite_Value;
pub const IOleClientSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SaveObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleClientSite,
                dwAssign: u32,
                dwWhichMoniker: u32,
                ppmk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleClientSite,
                dwAssign: u32,
                dwWhichMoniker: u32,
                ppmk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContainer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleClientSite,
                ppContainer: ?*?*IOleContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleClientSite,
                ppContainer: ?*?*IOleContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnShowWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleClientSite,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleClientSite,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestNewObjectLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleClientSite_SaveObject(self: *const T) HRESULT {
                return @as(*const IOleClientSite.VTable, @ptrCast(self.vtable)).SaveObject(@as(*const IOleClientSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleClientSite_GetMoniker(self: *const T, dwAssign: u32, dwWhichMoniker: u32, ppmk: ?*?*IMoniker) HRESULT {
                return @as(*const IOleClientSite.VTable, @ptrCast(self.vtable)).GetMoniker(@as(*const IOleClientSite, @ptrCast(self)), dwAssign, dwWhichMoniker, ppmk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleClientSite_GetContainer(self: *const T, ppContainer: ?*?*IOleContainer) HRESULT {
                return @as(*const IOleClientSite.VTable, @ptrCast(self.vtable)).GetContainer(@as(*const IOleClientSite, @ptrCast(self)), ppContainer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleClientSite_ShowObject(self: *const T) HRESULT {
                return @as(*const IOleClientSite.VTable, @ptrCast(self.vtable)).ShowObject(@as(*const IOleClientSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleClientSite_OnShowWindow(self: *const T, fShow: BOOL) HRESULT {
                return @as(*const IOleClientSite.VTable, @ptrCast(self.vtable)).OnShowWindow(@as(*const IOleClientSite, @ptrCast(self)), fShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleClientSite_RequestNewObjectLayout(self: *const T) HRESULT {
                return @as(*const IOleClientSite.VTable, @ptrCast(self.vtable)).RequestNewObjectLayout(@as(*const IOleClientSite, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLEGETMONIKER = enum(i32) {
    ONLYIFTHERE = 1,
    FORCEASSIGN = 2,
    UNASSIGN = 3,
    TEMPFORUSER = 4,
};
pub const OLEGETMONIKER_ONLYIFTHERE = OLEGETMONIKER.ONLYIFTHERE;
pub const OLEGETMONIKER_FORCEASSIGN = OLEGETMONIKER.FORCEASSIGN;
pub const OLEGETMONIKER_UNASSIGN = OLEGETMONIKER.UNASSIGN;
pub const OLEGETMONIKER_TEMPFORUSER = OLEGETMONIKER.TEMPFORUSER;

pub const OLEWHICHMK = enum(i32) {
    CONTAINER = 1,
    OBJREL = 2,
    OBJFULL = 3,
};
pub const OLEWHICHMK_CONTAINER = OLEWHICHMK.CONTAINER;
pub const OLEWHICHMK_OBJREL = OLEWHICHMK.OBJREL;
pub const OLEWHICHMK_OBJFULL = OLEWHICHMK.OBJFULL;

pub const USERCLASSTYPE = enum(i32) {
    FULL = 1,
    SHORT = 2,
    APPNAME = 3,
};
pub const USERCLASSTYPE_FULL = USERCLASSTYPE.FULL;
pub const USERCLASSTYPE_SHORT = USERCLASSTYPE.SHORT;
pub const USERCLASSTYPE_APPNAME = USERCLASSTYPE.APPNAME;

pub const OLEMISC = enum(i32) {
    RECOMPOSEONRESIZE = 1,
    ONLYICONIC = 2,
    INSERTNOTREPLACE = 4,
    STATIC = 8,
    CANTLINKINSIDE = 16,
    CANLINKBYOLE1 = 32,
    ISLINKOBJECT = 64,
    INSIDEOUT = 128,
    ACTIVATEWHENVISIBLE = 256,
    RENDERINGISDEVICEINDEPENDENT = 512,
    INVISIBLEATRUNTIME = 1024,
    ALWAYSRUN = 2048,
    ACTSLIKEBUTTON = 4096,
    ACTSLIKELABEL = 8192,
    NOUIACTIVATE = 16384,
    ALIGNABLE = 32768,
    SIMPLEFRAME = 65536,
    SETCLIENTSITEFIRST = 131072,
    IMEMODE = 262144,
    IGNOREACTIVATEWHENVISIBLE = 524288,
    WANTSTOMENUMERGE = 1048576,
    SUPPORTSMULTILEVELUNDO = 2097152,
};
// TODO: enum 'OLEMISC' has known issues with its value aliases

pub const OLECLOSE = enum(i32) {
    SAVEIFDIRTY = 0,
    NOSAVE = 1,
    PROMPTSAVE = 2,
};
pub const OLECLOSE_SAVEIFDIRTY = OLECLOSE.SAVEIFDIRTY;
pub const OLECLOSE_NOSAVE = OLECLOSE.NOSAVE;
pub const OLECLOSE_PROMPTSAVE = OLECLOSE.PROMPTSAVE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleObject_Value = Guid.initString("00000112-0000-0000-c000-000000000046");
pub const IID_IOleObject = &IID_IOleObject_Value;
pub const IOleObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetClientSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                pClientSite: ?*IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                pClientSite: ?*IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClientSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                ppClientSite: ?*?*IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                ppClientSite: ?*?*IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHostNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                szContainerApp: ?[*:0]const u16,
                szContainerObj: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                szContainerApp: ?[*:0]const u16,
                szContainerObj: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                dwSaveOption: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                dwSaveOption: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                dwWhichMoniker: u32,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                dwWhichMoniker: u32,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                dwAssign: u32,
                dwWhichMoniker: u32,
                ppmk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                dwAssign: u32,
                dwWhichMoniker: u32,
                ppmk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitFromData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                pDataObject: ?*IDataObject,
                fCreation: BOOL,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                pDataObject: ?*IDataObject,
                fCreation: BOOL,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClipboardData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                dwReserved: u32,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                dwReserved: u32,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoVerb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                iVerb: i32,
                lpmsg: ?*MSG,
                pActiveSite: ?*IOleClientSite,
                lindex: i32,
                hwndParent: ?HWND,
                lprcPosRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                iVerb: i32,
                lpmsg: ?*MSG,
                pActiveSite: ?*IOleClientSite,
                lindex: i32,
                hwndParent: ?HWND,
                lprcPosRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumVerbs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                ppEnumOleVerb: ?*?*IEnumOLEVERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                ppEnumOleVerb: ?*?*IEnumOLEVERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUpToDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserClassID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                pClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                pClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                dwFormOfType: u32,
                pszUserType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                dwFormOfType: u32,
                pszUserType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                dwDrawAspect: u32,
                psizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                dwDrawAspect: u32,
                psizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                dwDrawAspect: u32,
                psizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                dwDrawAspect: u32,
                psizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                pAdvSink: ?*IAdviseSink,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                pAdvSink: ?*IAdviseSink,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                ppenumAdvise: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                ppenumAdvise: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMiscStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                dwAspect: u32,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                dwAspect: u32,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColorScheme: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleObject,
                pLogpal: ?*LOGPALETTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleObject,
                pLogpal: ?*LOGPALETTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_SetClientSite(self: *const T, pClientSite: ?*IOleClientSite) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).SetClientSite(@as(*const IOleObject, @ptrCast(self)), pClientSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_GetClientSite(self: *const T, ppClientSite: ?*?*IOleClientSite) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).GetClientSite(@as(*const IOleObject, @ptrCast(self)), ppClientSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_SetHostNames(self: *const T, szContainerApp: ?[*:0]const u16, szContainerObj: ?[*:0]const u16) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).SetHostNames(@as(*const IOleObject, @ptrCast(self)), szContainerApp, szContainerObj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_Close(self: *const T, dwSaveOption: u32) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).Close(@as(*const IOleObject, @ptrCast(self)), dwSaveOption);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_SetMoniker(self: *const T, dwWhichMoniker: u32, pmk: ?*IMoniker) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).SetMoniker(@as(*const IOleObject, @ptrCast(self)), dwWhichMoniker, pmk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_GetMoniker(self: *const T, dwAssign: u32, dwWhichMoniker: u32, ppmk: ?*?*IMoniker) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).GetMoniker(@as(*const IOleObject, @ptrCast(self)), dwAssign, dwWhichMoniker, ppmk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_InitFromData(self: *const T, pDataObject: ?*IDataObject, fCreation: BOOL, dwReserved: u32) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).InitFromData(@as(*const IOleObject, @ptrCast(self)), pDataObject, fCreation, dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_GetClipboardData(self: *const T, dwReserved: u32, ppDataObject: ?*?*IDataObject) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).GetClipboardData(@as(*const IOleObject, @ptrCast(self)), dwReserved, ppDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_DoVerb(self: *const T, iVerb: i32, lpmsg: ?*MSG, pActiveSite: ?*IOleClientSite, lindex: i32, hwndParent: ?HWND, lprcPosRect: ?*RECT) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).DoVerb(@as(*const IOleObject, @ptrCast(self)), iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_EnumVerbs(self: *const T, ppEnumOleVerb: ?*?*IEnumOLEVERB) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).EnumVerbs(@as(*const IOleObject, @ptrCast(self)), ppEnumOleVerb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_Update(self: *const T) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).Update(@as(*const IOleObject, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_IsUpToDate(self: *const T) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).IsUpToDate(@as(*const IOleObject, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_GetUserClassID(self: *const T, pClsid: ?*Guid) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).GetUserClassID(@as(*const IOleObject, @ptrCast(self)), pClsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_GetUserType(self: *const T, dwFormOfType: u32, pszUserType: ?*?PWSTR) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).GetUserType(@as(*const IOleObject, @ptrCast(self)), dwFormOfType, pszUserType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_SetExtent(self: *const T, dwDrawAspect: u32, psizel: ?*SIZE) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).SetExtent(@as(*const IOleObject, @ptrCast(self)), dwDrawAspect, psizel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_GetExtent(self: *const T, dwDrawAspect: u32, psizel: ?*SIZE) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).GetExtent(@as(*const IOleObject, @ptrCast(self)), dwDrawAspect, psizel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_Advise(self: *const T, pAdvSink: ?*IAdviseSink, pdwConnection: ?*u32) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).Advise(@as(*const IOleObject, @ptrCast(self)), pAdvSink, pdwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_Unadvise(self: *const T, dwConnection: u32) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IOleObject, @ptrCast(self)), dwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_EnumAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).EnumAdvise(@as(*const IOleObject, @ptrCast(self)), ppenumAdvise);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_GetMiscStatus(self: *const T, dwAspect: u32, pdwStatus: ?*u32) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).GetMiscStatus(@as(*const IOleObject, @ptrCast(self)), dwAspect, pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleObject_SetColorScheme(self: *const T, pLogpal: ?*LOGPALETTE) HRESULT {
                return @as(*const IOleObject.VTable, @ptrCast(self.vtable)).SetColorScheme(@as(*const IOleObject, @ptrCast(self)), pLogpal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLERENDER = enum(i32) {
    NONE = 0,
    DRAW = 1,
    FORMAT = 2,
    ASIS = 3,
};
pub const OLERENDER_NONE = OLERENDER.NONE;
pub const OLERENDER_DRAW = OLERENDER.DRAW;
pub const OLERENDER_FORMAT = OLERENDER.FORMAT;
pub const OLERENDER_ASIS = OLERENDER.ASIS;

pub const OBJECTDESCRIPTOR = extern struct {
    cbSize: u32,
    clsid: Guid,
    dwDrawAspect: u32,
    sizel: SIZE,
    pointl: POINTL,
    dwStatus: u32,
    dwFullUserTypeName: u32,
    dwSrcOfCopy: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleWindow_Value = Guid.initString("00000114-0000-0000-c000-000000000046");
pub const IID_IOleWindow = &IID_IOleWindow_Value;
pub const IOleWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleWindow,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleWindow,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContextSensitiveHelp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleWindow,
                fEnterMode: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleWindow,
                fEnterMode: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleWindow_GetWindow(self: *const T, phwnd: ?*?HWND) HRESULT {
                return @as(*const IOleWindow.VTable, @ptrCast(self.vtable)).GetWindow(@as(*const IOleWindow, @ptrCast(self)), phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleWindow_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) HRESULT {
                return @as(*const IOleWindow.VTable, @ptrCast(self.vtable)).ContextSensitiveHelp(@as(*const IOleWindow, @ptrCast(self)), fEnterMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLEUPDATE = enum(i32) {
    ALWAYS = 1,
    ONCALL = 3,
};
pub const OLEUPDATE_ALWAYS = OLEUPDATE.ALWAYS;
pub const OLEUPDATE_ONCALL = OLEUPDATE.ONCALL;

pub const OLELINKBIND = enum(i32) {
    F = 1,
};
pub const OLELINKBIND_EVENIFCLASSDIFF = OLELINKBIND.F;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleLink_Value = Guid.initString("0000011d-0000-0000-c000-000000000046");
pub const IID_IOleLink = &IID_IOleLink_Value;
pub const IOleLink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUpdateOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
                dwUpdateOpt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
                dwUpdateOpt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUpdateOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
                pdwUpdateOpt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
                pdwUpdateOpt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourceMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
                pmk: ?*IMoniker,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
                pmk: ?*IMoniker,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
                ppmk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
                ppmk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourceDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
                pszStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
                pszStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
                ppszDisplayName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
                ppszDisplayName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
                bindflags: u32,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
                bindflags: u32,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindIfRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoundSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnbindSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleLink,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleLink,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_SetUpdateOptions(self: *const T, dwUpdateOpt: u32) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).SetUpdateOptions(@as(*const IOleLink, @ptrCast(self)), dwUpdateOpt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_GetUpdateOptions(self: *const T, pdwUpdateOpt: ?*u32) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).GetUpdateOptions(@as(*const IOleLink, @ptrCast(self)), pdwUpdateOpt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_SetSourceMoniker(self: *const T, pmk: ?*IMoniker, rclsid: ?*const Guid) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).SetSourceMoniker(@as(*const IOleLink, @ptrCast(self)), pmk, rclsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_GetSourceMoniker(self: *const T, ppmk: ?*?*IMoniker) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).GetSourceMoniker(@as(*const IOleLink, @ptrCast(self)), ppmk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_SetSourceDisplayName(self: *const T, pszStatusText: ?[*:0]const u16) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).SetSourceDisplayName(@as(*const IOleLink, @ptrCast(self)), pszStatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_GetSourceDisplayName(self: *const T, ppszDisplayName: ?*?PWSTR) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).GetSourceDisplayName(@as(*const IOleLink, @ptrCast(self)), ppszDisplayName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_BindToSource(self: *const T, bindflags: u32, pbc: ?*IBindCtx) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).BindToSource(@as(*const IOleLink, @ptrCast(self)), bindflags, pbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_BindIfRunning(self: *const T) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).BindIfRunning(@as(*const IOleLink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_GetBoundSource(self: *const T, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).GetBoundSource(@as(*const IOleLink, @ptrCast(self)), ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_UnbindSource(self: *const T) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).UnbindSource(@as(*const IOleLink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleLink_Update(self: *const T, pbc: ?*IBindCtx) HRESULT {
                return @as(*const IOleLink.VTable, @ptrCast(self.vtable)).Update(@as(*const IOleLink, @ptrCast(self)), pbc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BINDSPEED = enum(i32) {
    INDEFINITE = 1,
    MODERATE = 2,
    IMMEDIATE = 3,
};
pub const BINDSPEED_INDEFINITE = BINDSPEED.INDEFINITE;
pub const BINDSPEED_MODERATE = BINDSPEED.MODERATE;
pub const BINDSPEED_IMMEDIATE = BINDSPEED.IMMEDIATE;

pub const OLECONTF = enum(i32) {
    EMBEDDINGS = 1,
    LINKS = 2,
    OTHERS = 4,
    ONLYUSER = 8,
    ONLYIFRUNNING = 16,
};
pub const OLECONTF_EMBEDDINGS = OLECONTF.EMBEDDINGS;
pub const OLECONTF_LINKS = OLECONTF.LINKS;
pub const OLECONTF_OTHERS = OLECONTF.OTHERS;
pub const OLECONTF_ONLYUSER = OLECONTF.ONLYUSER;
pub const OLECONTF_ONLYIFRUNNING = OLECONTF.ONLYIFRUNNING;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleItemContainer_Value = Guid.initString("0000011c-0000-0000-c000-000000000046");
pub const IID_IOleItemContainer = &IID_IOleItemContainer_Value;
pub const IOleItemContainer = extern struct {
    pub const VTable = extern struct {
        base: IOleContainer.VTable,
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleItemContainer,
                pszItem: ?PWSTR,
                dwSpeedNeeded: u32,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleItemContainer,
                pszItem: ?PWSTR,
                dwSpeedNeeded: u32,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleItemContainer,
                pszItem: ?PWSTR,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppvStorage: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleItemContainer,
                pszItem: ?PWSTR,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppvStorage: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleItemContainer,
                pszItem: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleItemContainer,
                pszItem: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleContainer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleItemContainer_GetObject(self: *const T, pszItem: ?PWSTR, dwSpeedNeeded: u32, pbc: ?*IBindCtx, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IOleItemContainer.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IOleItemContainer, @ptrCast(self)), pszItem, dwSpeedNeeded, pbc, riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleItemContainer_GetObjectStorage(self: *const T, pszItem: ?PWSTR, pbc: ?*IBindCtx, riid: ?*const Guid, ppvStorage: ?*?*anyopaque) HRESULT {
                return @as(*const IOleItemContainer.VTable, @ptrCast(self.vtable)).GetObjectStorage(@as(*const IOleItemContainer, @ptrCast(self)), pszItem, pbc, riid, ppvStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleItemContainer_IsRunning(self: *const T, pszItem: ?PWSTR) HRESULT {
                return @as(*const IOleItemContainer.VTable, @ptrCast(self.vtable)).IsRunning(@as(*const IOleItemContainer, @ptrCast(self)), pszItem);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceUIWindow_Value = Guid.initString("00000115-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceUIWindow = &IID_IOleInPlaceUIWindow_Value;
pub const IOleInPlaceUIWindow = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        GetBorder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceUIWindow,
                lprectBorder: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceUIWindow,
                lprectBorder: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestBorderSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceUIWindow,
                pborderwidths: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceUIWindow,
                pborderwidths: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBorderSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceUIWindow,
                pborderwidths: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceUIWindow,
                pborderwidths: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActiveObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceUIWindow,
                pActiveObject: ?*IOleInPlaceActiveObject,
                pszObjName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceUIWindow,
                pActiveObject: ?*IOleInPlaceActiveObject,
                pszObjName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceUIWindow_GetBorder(self: *const T, lprectBorder: ?*RECT) HRESULT {
                return @as(*const IOleInPlaceUIWindow.VTable, @ptrCast(self.vtable)).GetBorder(@as(*const IOleInPlaceUIWindow, @ptrCast(self)), lprectBorder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceUIWindow_RequestBorderSpace(self: *const T, pborderwidths: ?*RECT) HRESULT {
                return @as(*const IOleInPlaceUIWindow.VTable, @ptrCast(self.vtable)).RequestBorderSpace(@as(*const IOleInPlaceUIWindow, @ptrCast(self)), pborderwidths);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceUIWindow_SetBorderSpace(self: *const T, pborderwidths: ?*RECT) HRESULT {
                return @as(*const IOleInPlaceUIWindow.VTable, @ptrCast(self.vtable)).SetBorderSpace(@as(*const IOleInPlaceUIWindow, @ptrCast(self)), pborderwidths);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceUIWindow_SetActiveObject(self: *const T, pActiveObject: ?*IOleInPlaceActiveObject, pszObjName: ?[*:0]const u16) HRESULT {
                return @as(*const IOleInPlaceUIWindow.VTable, @ptrCast(self.vtable)).SetActiveObject(@as(*const IOleInPlaceUIWindow, @ptrCast(self)), pActiveObject, pszObjName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceActiveObject_Value = Guid.initString("00000117-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceActiveObject = &IID_IOleInPlaceActiveObject_Value;
pub const IOleInPlaceActiveObject = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        TranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceActiveObject,
                lpmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceActiveObject,
                lpmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFrameWindowActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceActiveObject,
                fActivate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceActiveObject,
                fActivate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDocWindowActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceActiveObject,
                fActivate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceActiveObject,
                fActivate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResizeBorder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceActiveObject,
                prcBorder: ?*RECT,
                pUIWindow: ?*IOleInPlaceUIWindow,
                fFrameWindow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceActiveObject,
                prcBorder: ?*RECT,
                pUIWindow: ?*IOleInPlaceUIWindow,
                fFrameWindow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableModeless: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceActiveObject,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceActiveObject,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceActiveObject_TranslateAccelerator(self: *const T, lpmsg: ?*MSG) HRESULT {
                return @as(*const IOleInPlaceActiveObject.VTable, @ptrCast(self.vtable)).TranslateAccelerator(@as(*const IOleInPlaceActiveObject, @ptrCast(self)), lpmsg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceActiveObject_OnFrameWindowActivate(self: *const T, fActivate: BOOL) HRESULT {
                return @as(*const IOleInPlaceActiveObject.VTable, @ptrCast(self.vtable)).OnFrameWindowActivate(@as(*const IOleInPlaceActiveObject, @ptrCast(self)), fActivate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceActiveObject_OnDocWindowActivate(self: *const T, fActivate: BOOL) HRESULT {
                return @as(*const IOleInPlaceActiveObject.VTable, @ptrCast(self.vtable)).OnDocWindowActivate(@as(*const IOleInPlaceActiveObject, @ptrCast(self)), fActivate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceActiveObject_ResizeBorder(self: *const T, prcBorder: ?*RECT, pUIWindow: ?*IOleInPlaceUIWindow, fFrameWindow: BOOL) HRESULT {
                return @as(*const IOleInPlaceActiveObject.VTable, @ptrCast(self.vtable)).ResizeBorder(@as(*const IOleInPlaceActiveObject, @ptrCast(self)), prcBorder, pUIWindow, fFrameWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceActiveObject_EnableModeless(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IOleInPlaceActiveObject.VTable, @ptrCast(self.vtable)).EnableModeless(@as(*const IOleInPlaceActiveObject, @ptrCast(self)), fEnable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OIFI = extern struct {
    cb: u32,
    fMDIApp: BOOL,
    hwndFrame: ?HWND,
    haccel: ?HACCEL,
    cAccelEntries: u32,
};

pub const OleMenuGroupWidths = extern struct {
    width: [6]i32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceFrame_Value = Guid.initString("00000116-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceFrame = &IID_IOleInPlaceFrame_Value;
pub const IOleInPlaceFrame = extern struct {
    pub const VTable = extern struct {
        base: IOleInPlaceUIWindow.VTable,
        InsertMenus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceFrame,
                hmenuShared: ?HMENU,
                lpMenuWidths: ?*OleMenuGroupWidths,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceFrame,
                hmenuShared: ?HMENU,
                lpMenuWidths: ?*OleMenuGroupWidths,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceFrame,
                hmenuShared: ?HMENU,
                holemenu: isize,
                hwndActiveObject: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceFrame,
                hmenuShared: ?HMENU,
                holemenu: isize,
                hwndActiveObject: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveMenus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceFrame,
                hmenuShared: ?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceFrame,
                hmenuShared: ?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStatusText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceFrame,
                pszStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceFrame,
                pszStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableModeless: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceFrame,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceFrame,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceFrame,
                lpmsg: ?*MSG,
                wID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceFrame,
                lpmsg: ?*MSG,
                wID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleInPlaceUIWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceFrame_InsertMenus(self: *const T, hmenuShared: ?HMENU, lpMenuWidths: ?*OleMenuGroupWidths) HRESULT {
                return @as(*const IOleInPlaceFrame.VTable, @ptrCast(self.vtable)).InsertMenus(@as(*const IOleInPlaceFrame, @ptrCast(self)), hmenuShared, lpMenuWidths);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceFrame_SetMenu(self: *const T, hmenuShared: ?HMENU, holemenu: isize, hwndActiveObject: ?HWND) HRESULT {
                return @as(*const IOleInPlaceFrame.VTable, @ptrCast(self.vtable)).SetMenu(@as(*const IOleInPlaceFrame, @ptrCast(self)), hmenuShared, holemenu, hwndActiveObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceFrame_RemoveMenus(self: *const T, hmenuShared: ?HMENU) HRESULT {
                return @as(*const IOleInPlaceFrame.VTable, @ptrCast(self.vtable)).RemoveMenus(@as(*const IOleInPlaceFrame, @ptrCast(self)), hmenuShared);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceFrame_SetStatusText(self: *const T, pszStatusText: ?[*:0]const u16) HRESULT {
                return @as(*const IOleInPlaceFrame.VTable, @ptrCast(self.vtable)).SetStatusText(@as(*const IOleInPlaceFrame, @ptrCast(self)), pszStatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceFrame_EnableModeless(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IOleInPlaceFrame.VTable, @ptrCast(self.vtable)).EnableModeless(@as(*const IOleInPlaceFrame, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceFrame_TranslateAccelerator(self: *const T, lpmsg: ?*MSG, wID: u16) HRESULT {
                return @as(*const IOleInPlaceFrame.VTable, @ptrCast(self.vtable)).TranslateAccelerator(@as(*const IOleInPlaceFrame, @ptrCast(self)), lpmsg, wID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceObject_Value = Guid.initString("00000113-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceObject = &IID_IOleInPlaceObject_Value;
pub const IOleInPlaceObject = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        InPlaceDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UIDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetObjectRects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceObject,
                lprcPosRect: ?*RECT,
                lprcClipRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceObject,
                lprcPosRect: ?*RECT,
                lprcClipRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReactivateAndUndo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceObject_InPlaceDeactivate(self: *const T) HRESULT {
                return @as(*const IOleInPlaceObject.VTable, @ptrCast(self.vtable)).InPlaceDeactivate(@as(*const IOleInPlaceObject, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceObject_UIDeactivate(self: *const T) HRESULT {
                return @as(*const IOleInPlaceObject.VTable, @ptrCast(self.vtable)).UIDeactivate(@as(*const IOleInPlaceObject, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceObject_SetObjectRects(self: *const T, lprcPosRect: ?*RECT, lprcClipRect: ?*RECT) HRESULT {
                return @as(*const IOleInPlaceObject.VTable, @ptrCast(self.vtable)).SetObjectRects(@as(*const IOleInPlaceObject, @ptrCast(self)), lprcPosRect, lprcClipRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceObject_ReactivateAndUndo(self: *const T) HRESULT {
                return @as(*const IOleInPlaceObject.VTable, @ptrCast(self.vtable)).ReactivateAndUndo(@as(*const IOleInPlaceObject, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceSite_Value = Guid.initString("00000119-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceSite = &IID_IOleInPlaceSite_Value;
pub const IOleInPlaceSite = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        CanInPlaceActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnInPlaceActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnUIActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
                ppFrame: ?*?*IOleInPlaceFrame,
                ppDoc: ?*?*IOleInPlaceUIWindow,
                lprcPosRect: ?*RECT,
                lprcClipRect: ?*RECT,
                lpFrameInfo: ?*OIFI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
                ppFrame: ?*?*IOleInPlaceFrame,
                ppDoc: ?*?*IOleInPlaceUIWindow,
                lprcPosRect: ?*RECT,
                lprcClipRect: ?*RECT,
                lpFrameInfo: ?*OIFI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Scroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
                scrollExtant: SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
                scrollExtant: SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnUIDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
                fUndoable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
                fUndoable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnInPlaceDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DiscardUndoState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeactivateAndUndo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPosRectChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSite,
                lprcPosRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSite,
                lprcPosRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_CanInPlaceActivate(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).CanInPlaceActivate(@as(*const IOleInPlaceSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_OnInPlaceActivate(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).OnInPlaceActivate(@as(*const IOleInPlaceSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_OnUIActivate(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).OnUIActivate(@as(*const IOleInPlaceSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_GetWindowContext(self: *const T, ppFrame: ?*?*IOleInPlaceFrame, ppDoc: ?*?*IOleInPlaceUIWindow, lprcPosRect: ?*RECT, lprcClipRect: ?*RECT, lpFrameInfo: ?*OIFI) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).GetWindowContext(@as(*const IOleInPlaceSite, @ptrCast(self)), ppFrame, ppDoc, lprcPosRect, lprcClipRect, lpFrameInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_Scroll(self: *const T, scrollExtant: SIZE) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).Scroll(@as(*const IOleInPlaceSite, @ptrCast(self)), scrollExtant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_OnUIDeactivate(self: *const T, fUndoable: BOOL) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).OnUIDeactivate(@as(*const IOleInPlaceSite, @ptrCast(self)), fUndoable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_OnInPlaceDeactivate(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).OnInPlaceDeactivate(@as(*const IOleInPlaceSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_DiscardUndoState(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).DiscardUndoState(@as(*const IOleInPlaceSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_DeactivateAndUndo(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).DeactivateAndUndo(@as(*const IOleInPlaceSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSite_OnPosRectChange(self: *const T, lprcPosRect: ?*RECT) HRESULT {
                return @as(*const IOleInPlaceSite.VTable, @ptrCast(self.vtable)).OnPosRectChange(@as(*const IOleInPlaceSite, @ptrCast(self)), lprcPosRect);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IContinue_Value = Guid.initString("0000012a-0000-0000-c000-000000000046");
pub const IID_IContinue = &IID_IContinue_Value;
pub const IContinue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FContinue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContinue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContinue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContinue_FContinue(self: *const T) HRESULT {
                return @as(*const IContinue.VTable, @ptrCast(self.vtable)).FContinue(@as(*const IContinue, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IViewObject_Value = Guid.initString("0000010d-0000-0000-c000-000000000046");
pub const IID_IViewObject = &IID_IViewObject_Value;
pub const IViewObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Draw: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObject,
                dwDrawAspect: u32,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hdcTargetDev: ?HDC,
                hdcDraw: ?HDC,
                lprcBounds: ?*RECTL,
                lprcWBounds: ?*RECTL,
                pfnContinue: isize,
                dwContinue: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObject,
                dwDrawAspect: u32,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hdcTargetDev: ?HDC,
                hdcDraw: ?HDC,
                lprcBounds: ?*RECTL,
                lprcWBounds: ?*RECTL,
                pfnContinue: isize,
                dwContinue: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColorSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObject,
                dwDrawAspect: u32,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hicTargetDev: ?HDC,
                ppColorSet: ?*?*LOGPALETTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObject,
                dwDrawAspect: u32,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hicTargetDev: ?HDC,
                ppColorSet: ?*?*LOGPALETTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Freeze: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObject,
                dwDrawAspect: u32,
                lindex: i32,
                pvAspect: ?*anyopaque,
                pdwFreeze: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObject,
                dwDrawAspect: u32,
                lindex: i32,
                pvAspect: ?*anyopaque,
                pdwFreeze: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unfreeze: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObject,
                dwFreeze: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObject,
                dwFreeze: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObject,
                aspects: u32,
                advf: u32,
                pAdvSink: ?*IAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObject,
                aspects: u32,
                advf: u32,
                pAdvSink: ?*IAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObject,
                pAspects: ?*u32,
                pAdvf: ?*u32,
                ppAdvSink: ?*?*IAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObject,
                pAspects: ?*u32,
                pAdvf: ?*u32,
                ppAdvSink: ?*?*IAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObject_Draw(self: *const T, dwDrawAspect: u32, lindex: i32, pvAspect: ?*anyopaque, ptd: ?*DVTARGETDEVICE, hdcTargetDev: ?HDC, hdcDraw: ?HDC, lprcBounds: ?*RECTL, lprcWBounds: ?*RECTL, pfnContinue: isize, dwContinue: usize) HRESULT {
                return @as(*const IViewObject.VTable, @ptrCast(self.vtable)).Draw(@as(*const IViewObject, @ptrCast(self)), dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObject_GetColorSet(self: *const T, dwDrawAspect: u32, lindex: i32, pvAspect: ?*anyopaque, ptd: ?*DVTARGETDEVICE, hicTargetDev: ?HDC, ppColorSet: ?*?*LOGPALETTE) HRESULT {
                return @as(*const IViewObject.VTable, @ptrCast(self.vtable)).GetColorSet(@as(*const IViewObject, @ptrCast(self)), dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, ppColorSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObject_Freeze(self: *const T, dwDrawAspect: u32, lindex: i32, pvAspect: ?*anyopaque, pdwFreeze: ?*u32) HRESULT {
                return @as(*const IViewObject.VTable, @ptrCast(self.vtable)).Freeze(@as(*const IViewObject, @ptrCast(self)), dwDrawAspect, lindex, pvAspect, pdwFreeze);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObject_Unfreeze(self: *const T, dwFreeze: u32) HRESULT {
                return @as(*const IViewObject.VTable, @ptrCast(self.vtable)).Unfreeze(@as(*const IViewObject, @ptrCast(self)), dwFreeze);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObject_SetAdvise(self: *const T, aspects: u32, advf: u32, pAdvSink: ?*IAdviseSink) HRESULT {
                return @as(*const IViewObject.VTable, @ptrCast(self.vtable)).SetAdvise(@as(*const IViewObject, @ptrCast(self)), aspects, advf, pAdvSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObject_GetAdvise(self: *const T, pAspects: ?*u32, pAdvf: ?*u32, ppAdvSink: ?*?*IAdviseSink) HRESULT {
                return @as(*const IViewObject.VTable, @ptrCast(self.vtable)).GetAdvise(@as(*const IViewObject, @ptrCast(self)), pAspects, pAdvf, ppAdvSink);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IViewObject2_Value = Guid.initString("00000127-0000-0000-c000-000000000046");
pub const IID_IViewObject2 = &IID_IViewObject2_Value;
pub const IViewObject2 = extern struct {
    pub const VTable = extern struct {
        base: IViewObject.VTable,
        GetExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObject2,
                dwDrawAspect: u32,
                lindex: i32,
                ptd: ?*DVTARGETDEVICE,
                lpsizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObject2,
                dwDrawAspect: u32,
                lindex: i32,
                ptd: ?*DVTARGETDEVICE,
                lpsizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IViewObject.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObject2_GetExtent(self: *const T, dwDrawAspect: u32, lindex: i32, ptd: ?*DVTARGETDEVICE, lpsizel: ?*SIZE) HRESULT {
                return @as(*const IViewObject2.VTable, @ptrCast(self.vtable)).GetExtent(@as(*const IViewObject2, @ptrCast(self)), dwDrawAspect, lindex, ptd, lpsizel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDropSource_Value = Guid.initString("00000121-0000-0000-c000-000000000046");
pub const IID_IDropSource = &IID_IDropSource_Value;
pub const IDropSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContinueDrag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropSource,
                fEscapePressed: BOOL,
                grfKeyState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropSource,
                fEscapePressed: BOOL,
                grfKeyState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GiveFeedback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropSource,
                dwEffect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropSource,
                dwEffect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropSource_QueryContinueDrag(self: *const T, fEscapePressed: BOOL, grfKeyState: u32) HRESULT {
                return @as(*const IDropSource.VTable, @ptrCast(self.vtable)).QueryContinueDrag(@as(*const IDropSource, @ptrCast(self)), fEscapePressed, grfKeyState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropSource_GiveFeedback(self: *const T, dwEffect: u32) HRESULT {
                return @as(*const IDropSource.VTable, @ptrCast(self.vtable)).GiveFeedback(@as(*const IDropSource, @ptrCast(self)), dwEffect);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDropTarget_Value = Guid.initString("00000122-0000-0000-c000-000000000046");
pub const IID_IDropTarget = &IID_IDropTarget_Value;
pub const IDropTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DragEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropTarget,
                pDataObj: ?*IDataObject,
                grfKeyState: u32,
                pt: POINTL,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropTarget,
                pDataObj: ?*IDataObject,
                grfKeyState: u32,
                pt: POINTL,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DragOver: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropTarget,
                grfKeyState: u32,
                pt: POINTL,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropTarget,
                grfKeyState: u32,
                pt: POINTL,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DragLeave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Drop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropTarget,
                pDataObj: ?*IDataObject,
                grfKeyState: u32,
                pt: POINTL,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropTarget,
                pDataObj: ?*IDataObject,
                grfKeyState: u32,
                pt: POINTL,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropTarget_DragEnter(self: *const T, pDataObj: ?*IDataObject, grfKeyState: u32, pt: POINTL, pdwEffect: ?*u32) HRESULT {
                return @as(*const IDropTarget.VTable, @ptrCast(self.vtable)).DragEnter(@as(*const IDropTarget, @ptrCast(self)), pDataObj, grfKeyState, pt, pdwEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropTarget_DragOver(self: *const T, grfKeyState: u32, pt: POINTL, pdwEffect: ?*u32) HRESULT {
                return @as(*const IDropTarget.VTable, @ptrCast(self.vtable)).DragOver(@as(*const IDropTarget, @ptrCast(self)), grfKeyState, pt, pdwEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropTarget_DragLeave(self: *const T) HRESULT {
                return @as(*const IDropTarget.VTable, @ptrCast(self.vtable)).DragLeave(@as(*const IDropTarget, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropTarget_Drop(self: *const T, pDataObj: ?*IDataObject, grfKeyState: u32, pt: POINTL, pdwEffect: ?*u32) HRESULT {
                return @as(*const IDropTarget.VTable, @ptrCast(self.vtable)).Drop(@as(*const IDropTarget, @ptrCast(self)), pDataObj, grfKeyState, pt, pdwEffect);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDropSourceNotify_Value = Guid.initString("0000012b-0000-0000-c000-000000000046");
pub const IID_IDropSourceNotify = &IID_IDropSourceNotify_Value;
pub const IDropSourceNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DragEnterTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropSourceNotify,
                hwndTarget: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropSourceNotify,
                hwndTarget: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DragLeaveTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropSourceNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropSourceNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropSourceNotify_DragEnterTarget(self: *const T, hwndTarget: ?HWND) HRESULT {
                return @as(*const IDropSourceNotify.VTable, @ptrCast(self.vtable)).DragEnterTarget(@as(*const IDropSourceNotify, @ptrCast(self)), hwndTarget);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropSourceNotify_DragLeaveTarget(self: *const T) HRESULT {
                return @as(*const IDropSourceNotify.VTable, @ptrCast(self.vtable)).DragLeaveTarget(@as(*const IDropSourceNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IEnterpriseDropTarget_Value = Guid.initString("390e3878-fd55-4e18-819d-4682081c0cfd");
pub const IID_IEnterpriseDropTarget = &IID_IEnterpriseDropTarget_Value;
pub const IEnterpriseDropTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDropSourceEnterpriseId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnterpriseDropTarget,
                identity: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnterpriseDropTarget,
                identity: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEvaluatingEdpPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnterpriseDropTarget,
                value: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnterpriseDropTarget,
                value: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnterpriseDropTarget_SetDropSourceEnterpriseId(self: *const T, identity: ?[*:0]const u16) HRESULT {
                return @as(*const IEnterpriseDropTarget.VTable, @ptrCast(self.vtable)).SetDropSourceEnterpriseId(@as(*const IEnterpriseDropTarget, @ptrCast(self)), identity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnterpriseDropTarget_IsEvaluatingEdpPolicy(self: *const T, value: ?*BOOL) HRESULT {
                return @as(*const IEnterpriseDropTarget.VTable, @ptrCast(self.vtable)).IsEvaluatingEdpPolicy(@as(*const IEnterpriseDropTarget, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLEVERB = extern struct {
    lVerb: i32,
    lpszVerbName: ?PWSTR,
    fuFlags: u32,
    grfAttribs: u32,
};

pub const OLEVERBATTRIB = enum(i32) {
    NEVERDIRTIES = 1,
    ONCONTAINERMENU = 2,
};
pub const OLEVERBATTRIB_NEVERDIRTIES = OLEVERBATTRIB.NEVERDIRTIES;
pub const OLEVERBATTRIB_ONCONTAINERMENU = OLEVERBATTRIB.ONCONTAINERMENU;

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumOLEVERB_Value = Guid.initString("00000104-0000-0000-c000-000000000046");
pub const IID_IEnumOLEVERB = &IID_IEnumOLEVERB_Value;
pub const IEnumOLEVERB = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOLEVERB,
                celt: u32,
                rgelt: [*]OLEVERB,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOLEVERB,
                celt: u32,
                rgelt: [*]OLEVERB,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOLEVERB,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOLEVERB,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOLEVERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOLEVERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOLEVERB,
                ppenum: ?*?*IEnumOLEVERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOLEVERB,
                ppenum: ?*?*IEnumOLEVERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOLEVERB_Next(self: *const T, celt: u32, rgelt: [*]OLEVERB, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumOLEVERB.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumOLEVERB, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOLEVERB_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumOLEVERB.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumOLEVERB, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOLEVERB_Reset(self: *const T) HRESULT {
                return @as(*const IEnumOLEVERB.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumOLEVERB, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOLEVERB_Clone(self: *const T, ppenum: ?*?*IEnumOLEVERB) HRESULT {
                return @as(*const IEnumOLEVERB.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumOLEVERB, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NUMPARSE = extern struct {
    cDig: i32,
    dwInFlags: u32,
    dwOutFlags: u32,
    cchUsed: i32,
    nBaseShift: i32,
    nPwr10: i32,
};

pub const UDATE = extern struct {
    st: SYSTEMTIME,
    wDayOfYear: u16,
};

pub const REGKIND = enum(i32) {
    DEFAULT = 0,
    REGISTER = 1,
    NONE = 2,
};
pub const REGKIND_DEFAULT = REGKIND.DEFAULT;
pub const REGKIND_REGISTER = REGKIND.REGISTER;
pub const REGKIND_NONE = REGKIND.NONE;

pub const PARAMDATA = extern struct {
    szName: ?PWSTR,
    vt: u16,
};

pub const METHODDATA = extern struct {
    szName: ?PWSTR,
    ppdata: ?*PARAMDATA,
    dispid: i32,
    iMeth: u32,
    cc: CALLCONV,
    cArgs: u32,
    wFlags: u16,
    vtReturn: u16,
};

pub const INTERFACEDATA = extern struct {
    pmethdata: ?*METHODDATA,
    cMembers: u32,
};

pub const UASFLAGS = enum(i32) {
    NORMAL = 0,
    BLOCKED = 1,
    NOPARENTENABLE = 2,
    MASK = 3,
};
pub const UAS_NORMAL = UASFLAGS.NORMAL;
pub const UAS_BLOCKED = UASFLAGS.BLOCKED;
pub const UAS_NOPARENTENABLE = UASFLAGS.NOPARENTENABLE;
pub const UAS_MASK = UASFLAGS.MASK;

pub const READYSTATE = enum(i32) {
    UNINITIALIZED = 0,
    LOADING = 1,
    LOADED = 2,
    INTERACTIVE = 3,
    COMPLETE = 4,
};
pub const READYSTATE_UNINITIALIZED = READYSTATE.UNINITIALIZED;
pub const READYSTATE_LOADING = READYSTATE.LOADING;
pub const READYSTATE_LOADED = READYSTATE.LOADED;
pub const READYSTATE_INTERACTIVE = READYSTATE.INTERACTIVE;
pub const READYSTATE_COMPLETE = READYSTATE.COMPLETE;

pub const LICINFO = extern struct {
    cbLicInfo: i32,
    fRuntimeKeyAvail: BOOL,
    fLicVerified: BOOL,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassFactory2_Value = Guid.initString("b196b28f-bab4-101a-b69c-00aa00341d07");
pub const IID_IClassFactory2 = &IID_IClassFactory2_Value;
pub const IClassFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IClassFactory.VTable,
        GetLicInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClassFactory2,
                pLicInfo: ?*LICINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClassFactory2,
                pLicInfo: ?*LICINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestLicKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClassFactory2,
                dwReserved: u32,
                pBstrKey: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClassFactory2,
                dwReserved: u32,
                pBstrKey: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstanceLic: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClassFactory2,
                pUnkOuter: ?*IUnknown,
                pUnkReserved: ?*IUnknown,
                riid: ?*const Guid,
                bstrKey: ?BSTR,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClassFactory2,
                pUnkOuter: ?*IUnknown,
                pUnkReserved: ?*IUnknown,
                riid: ?*const Guid,
                bstrKey: ?BSTR,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IClassFactory.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClassFactory2_GetLicInfo(self: *const T, pLicInfo: ?*LICINFO) HRESULT {
                return @as(*const IClassFactory2.VTable, @ptrCast(self.vtable)).GetLicInfo(@as(*const IClassFactory2, @ptrCast(self)), pLicInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClassFactory2_RequestLicKey(self: *const T, dwReserved: u32, pBstrKey: ?*?BSTR) HRESULT {
                return @as(*const IClassFactory2.VTable, @ptrCast(self.vtable)).RequestLicKey(@as(*const IClassFactory2, @ptrCast(self)), dwReserved, pBstrKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClassFactory2_CreateInstanceLic(self: *const T, pUnkOuter: ?*IUnknown, pUnkReserved: ?*IUnknown, riid: ?*const Guid, bstrKey: ?BSTR, ppvObj: ?*?*anyopaque) HRESULT {
                return @as(*const IClassFactory2.VTable, @ptrCast(self.vtable)).CreateInstanceLic(@as(*const IClassFactory2, @ptrCast(self)), pUnkOuter, pUnkReserved, riid, bstrKey, ppvObj);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProvideClassInfo_Value = Guid.initString("b196b283-bab4-101a-b69c-00aa00341d07");
pub const IID_IProvideClassInfo = &IID_IProvideClassInfo_Value;
pub const IProvideClassInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProvideClassInfo,
                ppTI: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProvideClassInfo,
                ppTI: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProvideClassInfo_GetClassInfo(self: *const T, ppTI: ?*?*ITypeInfo) HRESULT {
                return @as(*const IProvideClassInfo.VTable, @ptrCast(self.vtable)).GetClassInfo(@as(*const IProvideClassInfo, @ptrCast(self)), ppTI);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const GUIDKIND = enum(i32) {
    D = 1,
};
pub const GUIDKIND_DEFAULT_SOURCE_DISP_IID = GUIDKIND.D;

// TODO: this type is limited to platform 'windows5.0'
const IID_IProvideClassInfo2_Value = Guid.initString("a6bc3ac0-dbaa-11ce-9de3-00aa004bb851");
pub const IID_IProvideClassInfo2 = &IID_IProvideClassInfo2_Value;
pub const IProvideClassInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IProvideClassInfo.VTable,
        GetGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProvideClassInfo2,
                dwGuidKind: u32,
                pGUID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProvideClassInfo2,
                dwGuidKind: u32,
                pGUID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IProvideClassInfo.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProvideClassInfo2_GetGUID(self: *const T, dwGuidKind: u32, pGUID: ?*Guid) HRESULT {
                return @as(*const IProvideClassInfo2.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const IProvideClassInfo2, @ptrCast(self)), dwGuidKind, pGUID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProvideMultipleClassInfo_Value = Guid.initString("a7aba9c1-8983-11cf-8f20-00805f2cd064");
pub const IID_IProvideMultipleClassInfo = &IID_IProvideMultipleClassInfo_Value;
pub const IProvideMultipleClassInfo = extern struct {
    pub const VTable = extern struct {
        base: IProvideClassInfo2.VTable,
        GetMultiTypeInfoCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProvideMultipleClassInfo,
                pcti: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProvideMultipleClassInfo,
                pcti: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfoOfIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProvideMultipleClassInfo,
                iti: u32,
                dwFlags: MULTICLASSINFO_FLAGS,
                pptiCoClass: ?*?*ITypeInfo,
                pdwTIFlags: ?*u32,
                pcdispidReserved: ?*u32,
                piidPrimary: ?*Guid,
                piidSource: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProvideMultipleClassInfo,
                iti: u32,
                dwFlags: MULTICLASSINFO_FLAGS,
                pptiCoClass: ?*?*ITypeInfo,
                pdwTIFlags: ?*u32,
                pcdispidReserved: ?*u32,
                piidPrimary: ?*Guid,
                piidSource: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IProvideClassInfo2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProvideMultipleClassInfo_GetMultiTypeInfoCount(self: *const T, pcti: ?*u32) HRESULT {
                return @as(*const IProvideMultipleClassInfo.VTable, @ptrCast(self.vtable)).GetMultiTypeInfoCount(@as(*const IProvideMultipleClassInfo, @ptrCast(self)), pcti);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProvideMultipleClassInfo_GetInfoOfIndex(self: *const T, iti: u32, dwFlags: MULTICLASSINFO_FLAGS, pptiCoClass: ?*?*ITypeInfo, pdwTIFlags: ?*u32, pcdispidReserved: ?*u32, piidPrimary: ?*Guid, piidSource: ?*Guid) HRESULT {
                return @as(*const IProvideMultipleClassInfo.VTable, @ptrCast(self.vtable)).GetInfoOfIndex(@as(*const IProvideMultipleClassInfo, @ptrCast(self)), iti, dwFlags, pptiCoClass, pdwTIFlags, pcdispidReserved, piidPrimary, piidSource);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CONTROLINFO = extern struct {
    cb: u32,
    hAccel: ?HACCEL,
    cAccel: u16,
    dwFlags: u32,
};

pub const CTRLINFO = enum(i32) {
    RETURN = 1,
    ESCAPE = 2,
};
pub const CTRLINFO_EATS_RETURN = CTRLINFO.RETURN;
pub const CTRLINFO_EATS_ESCAPE = CTRLINFO.ESCAPE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleControl_Value = Guid.initString("b196b288-bab4-101a-b69c-00aa00341d07");
pub const IID_IOleControl = &IID_IOleControl_Value;
pub const IOleControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetControlInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControl,
                pCI: ?*CONTROLINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControl,
                pCI: ?*CONTROLINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnMnemonic: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControl,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControl,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnAmbientPropertyChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControl,
                dispID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControl,
                dispID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreezeEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControl,
                bFreeze: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControl,
                bFreeze: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControl_GetControlInfo(self: *const T, pCI: ?*CONTROLINFO) HRESULT {
                return @as(*const IOleControl.VTable, @ptrCast(self.vtable)).GetControlInfo(@as(*const IOleControl, @ptrCast(self)), pCI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControl_OnMnemonic(self: *const T, pMsg: ?*MSG) HRESULT {
                return @as(*const IOleControl.VTable, @ptrCast(self.vtable)).OnMnemonic(@as(*const IOleControl, @ptrCast(self)), pMsg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControl_OnAmbientPropertyChange(self: *const T, dispID: i32) HRESULT {
                return @as(*const IOleControl.VTable, @ptrCast(self.vtable)).OnAmbientPropertyChange(@as(*const IOleControl, @ptrCast(self)), dispID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControl_FreezeEvents(self: *const T, bFreeze: BOOL) HRESULT {
                return @as(*const IOleControl.VTable, @ptrCast(self.vtable)).FreezeEvents(@as(*const IOleControl, @ptrCast(self)), bFreeze);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const POINTF = extern struct {
    x: f32,
    y: f32,
};

pub const XFORMCOORDS = enum(i32) {
    POSITION = 1,
    SIZE = 2,
    HIMETRICTOCONTAINER = 4,
    CONTAINERTOHIMETRIC = 8,
    EVENTCOMPAT = 16,
};
pub const XFORMCOORDS_POSITION = XFORMCOORDS.POSITION;
pub const XFORMCOORDS_SIZE = XFORMCOORDS.SIZE;
pub const XFORMCOORDS_HIMETRICTOCONTAINER = XFORMCOORDS.HIMETRICTOCONTAINER;
pub const XFORMCOORDS_CONTAINERTOHIMETRIC = XFORMCOORDS.CONTAINERTOHIMETRIC;
pub const XFORMCOORDS_EVENTCOMPAT = XFORMCOORDS.EVENTCOMPAT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleControlSite_Value = Guid.initString("b196b289-bab4-101a-b69c-00aa00341d07");
pub const IID_IOleControlSite = &IID_IOleControlSite_Value;
pub const IOleControlSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnControlInfoChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControlSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControlSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockInPlaceActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControlSite,
                fLock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControlSite,
                fLock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtendedControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControlSite,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControlSite,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TransformCoords: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControlSite,
                pPtlHimetric: ?*POINTL,
                pPtfContainer: ?*POINTF,
                dwFlags: XFORMCOORDS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControlSite,
                pPtlHimetric: ?*POINTL,
                pPtfContainer: ?*POINTF,
                dwFlags: XFORMCOORDS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControlSite,
                pMsg: ?*MSG,
                grfModifiers: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControlSite,
                pMsg: ?*MSG,
                grfModifiers: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControlSite,
                fGotFocus: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControlSite,
                fGotFocus: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowPropertyFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleControlSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleControlSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControlSite_OnControlInfoChanged(self: *const T) HRESULT {
                return @as(*const IOleControlSite.VTable, @ptrCast(self.vtable)).OnControlInfoChanged(@as(*const IOleControlSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControlSite_LockInPlaceActive(self: *const T, fLock: BOOL) HRESULT {
                return @as(*const IOleControlSite.VTable, @ptrCast(self.vtable)).LockInPlaceActive(@as(*const IOleControlSite, @ptrCast(self)), fLock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControlSite_GetExtendedControl(self: *const T, ppDisp: ?*?*IDispatch) HRESULT {
                return @as(*const IOleControlSite.VTable, @ptrCast(self.vtable)).GetExtendedControl(@as(*const IOleControlSite, @ptrCast(self)), ppDisp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControlSite_TransformCoords(self: *const T, pPtlHimetric: ?*POINTL, pPtfContainer: ?*POINTF, dwFlags: XFORMCOORDS) HRESULT {
                return @as(*const IOleControlSite.VTable, @ptrCast(self.vtable)).TransformCoords(@as(*const IOleControlSite, @ptrCast(self)), pPtlHimetric, pPtfContainer, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControlSite_TranslateAccelerator(self: *const T, pMsg: ?*MSG, grfModifiers: u32) HRESULT {
                return @as(*const IOleControlSite.VTable, @ptrCast(self.vtable)).TranslateAccelerator(@as(*const IOleControlSite, @ptrCast(self)), pMsg, grfModifiers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControlSite_OnFocus(self: *const T, fGotFocus: BOOL) HRESULT {
                return @as(*const IOleControlSite.VTable, @ptrCast(self.vtable)).OnFocus(@as(*const IOleControlSite, @ptrCast(self)), fGotFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleControlSite_ShowPropertyFrame(self: *const T) HRESULT {
                return @as(*const IOleControlSite.VTable, @ptrCast(self.vtable)).ShowPropertyFrame(@as(*const IOleControlSite, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PROPPAGEINFO = extern struct {
    cb: u32,
    pszTitle: ?PWSTR,
    size: SIZE,
    pszDocString: ?PWSTR,
    pszHelpFile: ?PWSTR,
    dwHelpContext: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyPage_Value = Guid.initString("b196b28d-bab4-101a-b69c-00aa00341d07");
pub const IID_IPropertyPage = &IID_IPropertyPage_Value;
pub const IPropertyPage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPageSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
                pPageSite: ?*IPropertyPageSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
                pPageSite: ?*IPropertyPageSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
                hWndParent: ?HWND,
                pRect: ?*RECT,
                bModal: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
                hWndParent: ?HWND,
                pRect: ?*RECT,
                bModal: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Deactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
                pPageInfo: ?*PROPPAGEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
                pPageInfo: ?*PROPPAGEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
                cObjects: u32,
                ppUnk: [*]?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
                cObjects: u32,
                ppUnk: [*]?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
                nCmdShow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
                nCmdShow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPageDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Apply: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Help: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
                pszHelpDir: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
                pszHelpDir: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_SetPageSite(self: *const T, pPageSite: ?*IPropertyPageSite) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).SetPageSite(@as(*const IPropertyPage, @ptrCast(self)), pPageSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_Activate(self: *const T, hWndParent: ?HWND, pRect: ?*RECT, bModal: BOOL) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).Activate(@as(*const IPropertyPage, @ptrCast(self)), hWndParent, pRect, bModal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_Deactivate(self: *const T) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const IPropertyPage, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_GetPageInfo(self: *const T, pPageInfo: ?*PROPPAGEINFO) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).GetPageInfo(@as(*const IPropertyPage, @ptrCast(self)), pPageInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_SetObjects(self: *const T, cObjects: u32, ppUnk: [*]?*IUnknown) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).SetObjects(@as(*const IPropertyPage, @ptrCast(self)), cObjects, ppUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_Show(self: *const T, nCmdShow: u32) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).Show(@as(*const IPropertyPage, @ptrCast(self)), nCmdShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_Move(self: *const T, pRect: ?*RECT) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).Move(@as(*const IPropertyPage, @ptrCast(self)), pRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_IsPageDirty(self: *const T) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).IsPageDirty(@as(*const IPropertyPage, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_Apply(self: *const T) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).Apply(@as(*const IPropertyPage, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_Help(self: *const T, pszHelpDir: ?[*:0]const u16) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).Help(@as(*const IPropertyPage, @ptrCast(self)), pszHelpDir);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage_TranslateAccelerator(self: *const T, pMsg: ?*MSG) HRESULT {
                return @as(*const IPropertyPage.VTable, @ptrCast(self.vtable)).TranslateAccelerator(@as(*const IPropertyPage, @ptrCast(self)), pMsg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyPage2_Value = Guid.initString("01e44665-24ac-101b-84ed-08002b2ec713");
pub const IID_IPropertyPage2 = &IID_IPropertyPage2_Value;
pub const IPropertyPage2 = extern struct {
    pub const VTable = extern struct {
        base: IPropertyPage.VTable,
        EditProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPage2,
                dispID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPage2,
                dispID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPropertyPage.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPage2_EditProperty(self: *const T, dispID: i32) HRESULT {
                return @as(*const IPropertyPage2.VTable, @ptrCast(self.vtable)).EditProperty(@as(*const IPropertyPage2, @ptrCast(self)), dispID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PROPPAGESTATUS = enum(i32) {
    DIRTY = 1,
    VALIDATE = 2,
    CLEAN = 4,
};
pub const PROPPAGESTATUS_DIRTY = PROPPAGESTATUS.DIRTY;
pub const PROPPAGESTATUS_VALIDATE = PROPPAGESTATUS.VALIDATE;
pub const PROPPAGESTATUS_CLEAN = PROPPAGESTATUS.CLEAN;

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyPageSite_Value = Guid.initString("b196b28c-bab4-101a-b69c-00aa00341d07");
pub const IID_IPropertyPageSite = &IID_IPropertyPageSite_Value;
pub const IPropertyPageSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPageSite,
                dwFlags: PROPPAGESTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPageSite,
                dwFlags: PROPPAGESTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocaleID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPageSite,
                pLocaleID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPageSite,
                pLocaleID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageContainer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPageSite,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPageSite,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyPageSite,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyPageSite,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPageSite_OnStatusChange(self: *const T, dwFlags: PROPPAGESTATUS) HRESULT {
                return @as(*const IPropertyPageSite.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const IPropertyPageSite, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPageSite_GetLocaleID(self: *const T, pLocaleID: ?*u32) HRESULT {
                return @as(*const IPropertyPageSite.VTable, @ptrCast(self.vtable)).GetLocaleID(@as(*const IPropertyPageSite, @ptrCast(self)), pLocaleID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPageSite_GetPageContainer(self: *const T, ppUnk: ?*?*IUnknown) HRESULT {
                return @as(*const IPropertyPageSite.VTable, @ptrCast(self.vtable)).GetPageContainer(@as(*const IPropertyPageSite, @ptrCast(self)), ppUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyPageSite_TranslateAccelerator(self: *const T, pMsg: ?*MSG) HRESULT {
                return @as(*const IPropertyPageSite.VTable, @ptrCast(self.vtable)).TranslateAccelerator(@as(*const IPropertyPageSite, @ptrCast(self)), pMsg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyNotifySink_Value = Guid.initString("9bfbbc02-eff1-101a-84ed-00aa00341d07");
pub const IID_IPropertyNotifySink = &IID_IPropertyNotifySink_Value;
pub const IPropertyNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyNotifySink,
                dispID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyNotifySink,
                dispID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnRequestEdit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyNotifySink,
                dispID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyNotifySink,
                dispID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyNotifySink_OnChanged(self: *const T, dispID: i32) HRESULT {
                return @as(*const IPropertyNotifySink.VTable, @ptrCast(self.vtable)).OnChanged(@as(*const IPropertyNotifySink, @ptrCast(self)), dispID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyNotifySink_OnRequestEdit(self: *const T, dispID: i32) HRESULT {
                return @as(*const IPropertyNotifySink.VTable, @ptrCast(self.vtable)).OnRequestEdit(@as(*const IPropertyNotifySink, @ptrCast(self)), dispID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CAUUID = extern struct {
    cElems: u32,
    pElems: ?*Guid,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISpecifyPropertyPages_Value = Guid.initString("b196b28b-bab4-101a-b69c-00aa00341d07");
pub const IID_ISpecifyPropertyPages = &IID_ISpecifyPropertyPages_Value;
pub const ISpecifyPropertyPages = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpecifyPropertyPages,
                pPages: ?*CAUUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpecifyPropertyPages,
                pPages: ?*CAUUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpecifyPropertyPages_GetPages(self: *const T, pPages: ?*CAUUID) HRESULT {
                return @as(*const ISpecifyPropertyPages.VTable, @ptrCast(self.vtable)).GetPages(@as(*const ISpecifyPropertyPages, @ptrCast(self)), pPages);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPersistPropertyBag_Value = Guid.initString("37d84f60-42cb-11ce-8135-00aa004bb851");
pub const IID_IPersistPropertyBag = &IID_IPersistPropertyBag_Value;
pub const IPersistPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistPropertyBag,
                pPropBag: ?*IPropertyBag,
                pErrorLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistPropertyBag,
                pPropBag: ?*IPropertyBag,
                pErrorLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistPropertyBag,
                pPropBag: ?*IPropertyBag,
                fClearDirty: BOOL,
                fSaveAllProperties: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistPropertyBag,
                pPropBag: ?*IPropertyBag,
                fClearDirty: BOOL,
                fSaveAllProperties: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistPropertyBag_InitNew(self: *const T) HRESULT {
                return @as(*const IPersistPropertyBag.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistPropertyBag, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistPropertyBag_Load(self: *const T, pPropBag: ?*IPropertyBag, pErrorLog: ?*IErrorLog) HRESULT {
                return @as(*const IPersistPropertyBag.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistPropertyBag, @ptrCast(self)), pPropBag, pErrorLog);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistPropertyBag_Save(self: *const T, pPropBag: ?*IPropertyBag, fClearDirty: BOOL, fSaveAllProperties: BOOL) HRESULT {
                return @as(*const IPersistPropertyBag.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistPropertyBag, @ptrCast(self)), pPropBag, fClearDirty, fSaveAllProperties);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISimpleFrameSite_Value = Guid.initString("742b0e01-14e6-101b-914e-00aa00300cab");
pub const IID_ISimpleFrameSite = &IID_ISimpleFrameSite_Value;
pub const ISimpleFrameSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreMessageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleFrameSite,
                hWnd: ?HWND,
                msg: u32,
                wp: WPARAM,
                lp: LPARAM,
                plResult: ?*LRESULT,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleFrameSite,
                hWnd: ?HWND,
                msg: u32,
                wp: WPARAM,
                lp: LPARAM,
                plResult: ?*LRESULT,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostMessageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleFrameSite,
                hWnd: ?HWND,
                msg: u32,
                wp: WPARAM,
                lp: LPARAM,
                plResult: ?*LRESULT,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleFrameSite,
                hWnd: ?HWND,
                msg: u32,
                wp: WPARAM,
                lp: LPARAM,
                plResult: ?*LRESULT,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleFrameSite_PreMessageFilter(self: *const T, hWnd: ?HWND, msg: u32, wp: WPARAM, lp: LPARAM, plResult: ?*LRESULT, pdwCookie: ?*u32) HRESULT {
                return @as(*const ISimpleFrameSite.VTable, @ptrCast(self.vtable)).PreMessageFilter(@as(*const ISimpleFrameSite, @ptrCast(self)), hWnd, msg, wp, lp, plResult, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleFrameSite_PostMessageFilter(self: *const T, hWnd: ?HWND, msg: u32, wp: WPARAM, lp: LPARAM, plResult: ?*LRESULT, dwCookie: u32) HRESULT {
                return @as(*const ISimpleFrameSite.VTable, @ptrCast(self.vtable)).PostMessageFilter(@as(*const ISimpleFrameSite, @ptrCast(self)), hWnd, msg, wp, lp, plResult, dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFont_Value = Guid.initString("bef6e002-a874-101a-8bba-00aa00300cab");
pub const IID_IFont = &IID_IFont_Value;
pub const IFont = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Size: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                pSize: ?*CY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                pSize: ?*CY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Size: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                size: CY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                size: CY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bold: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                pBold: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                pBold: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bold: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                bold: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                bold: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Italic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                pItalic: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                pItalic: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Italic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                italic: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                italic: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Underline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                pUnderline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                pUnderline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Underline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                underline: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                underline: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strikethrough: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                pStrikethrough: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                pStrikethrough: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Strikethrough: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                strikethrough: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                strikethrough: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Weight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                pWeight: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                pWeight: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Weight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                weight: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                weight: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Charset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                pCharset: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                pCharset: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Charset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                charset: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                charset: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hFont: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFont,
                phFont: ?*?HFONT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFont,
                phFont: ?*?HFONT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFont,
                ppFont: ?*?*IFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFont,
                ppFont: ?*?*IFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFont,
                pFontOther: ?*IFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFont,
                pFontOther: ?*IFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFont,
                cyLogical: i32,
                cyHimetric: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFont,
                cyLogical: i32,
                cyHimetric: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryTextMetrics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFont,
                pTM: ?*TEXTMETRICW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFont,
                pTM: ?*TEXTMETRICW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRefHfont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFont,
                hFont: ?HFONT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFont,
                hFont: ?HFONT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseHfont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFont,
                hFont: ?HFONT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFont,
                hFont: ?HFONT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHdc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFont,
                hDC: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFont,
                hDC: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_get_Name(self: *const T, pName: ?*?BSTR) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IFont, @ptrCast(self)), pName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_put_Name(self: *const T, name: ?BSTR) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).put_Name(@as(*const IFont, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_get_Size(self: *const T, pSize: ?*CY) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).get_Size(@as(*const IFont, @ptrCast(self)), pSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_put_Size(self: *const T, size: CY) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).put_Size(@as(*const IFont, @ptrCast(self)), size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_get_Bold(self: *const T, pBold: ?*BOOL) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).get_Bold(@as(*const IFont, @ptrCast(self)), pBold);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_put_Bold(self: *const T, bold: BOOL) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).put_Bold(@as(*const IFont, @ptrCast(self)), bold);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_get_Italic(self: *const T, pItalic: ?*BOOL) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).get_Italic(@as(*const IFont, @ptrCast(self)), pItalic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_put_Italic(self: *const T, italic: BOOL) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).put_Italic(@as(*const IFont, @ptrCast(self)), italic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_get_Underline(self: *const T, pUnderline: ?*BOOL) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).get_Underline(@as(*const IFont, @ptrCast(self)), pUnderline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_put_Underline(self: *const T, underline: BOOL) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).put_Underline(@as(*const IFont, @ptrCast(self)), underline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_get_Strikethrough(self: *const T, pStrikethrough: ?*BOOL) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).get_Strikethrough(@as(*const IFont, @ptrCast(self)), pStrikethrough);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_put_Strikethrough(self: *const T, strikethrough: BOOL) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).put_Strikethrough(@as(*const IFont, @ptrCast(self)), strikethrough);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_get_Weight(self: *const T, pWeight: ?*i16) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).get_Weight(@as(*const IFont, @ptrCast(self)), pWeight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_put_Weight(self: *const T, weight: i16) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).put_Weight(@as(*const IFont, @ptrCast(self)), weight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_get_Charset(self: *const T, pCharset: ?*i16) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).get_Charset(@as(*const IFont, @ptrCast(self)), pCharset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_put_Charset(self: *const T, charset: i16) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).put_Charset(@as(*const IFont, @ptrCast(self)), charset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_get_hFont(self: *const T, phFont: ?*?HFONT) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).get_hFont(@as(*const IFont, @ptrCast(self)), phFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_Clone(self: *const T, ppFont: ?*?*IFont) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).Clone(@as(*const IFont, @ptrCast(self)), ppFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_IsEqual(self: *const T, pFontOther: ?*IFont) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IFont, @ptrCast(self)), pFontOther);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_SetRatio(self: *const T, cyLogical: i32, cyHimetric: i32) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).SetRatio(@as(*const IFont, @ptrCast(self)), cyLogical, cyHimetric);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_QueryTextMetrics(self: *const T, pTM: ?*TEXTMETRICW) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).QueryTextMetrics(@as(*const IFont, @ptrCast(self)), pTM);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_AddRefHfont(self: *const T, hFont: ?HFONT) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).AddRefHfont(@as(*const IFont, @ptrCast(self)), hFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_ReleaseHfont(self: *const T, hFont: ?HFONT) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).ReleaseHfont(@as(*const IFont, @ptrCast(self)), hFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFont_SetHdc(self: *const T, hDC: ?HDC) HRESULT {
                return @as(*const IFont.VTable, @ptrCast(self.vtable)).SetHdc(@as(*const IFont, @ptrCast(self)), hDC);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PictureAttributes = enum(i32) {
    SCALABLE = 1,
    TRANSPARENT = 2,
};
pub const PICTURE_SCALABLE = PictureAttributes.SCALABLE;
pub const PICTURE_TRANSPARENT = PictureAttributes.TRANSPARENT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IPicture_Value = Guid.initString("7bf80980-bf32-101a-8bbb-00aa00300cab");
pub const IID_IPicture = &IID_IPicture_Value;
pub const IPicture = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Handle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture,
                pHandle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture,
                pHandle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hPal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture,
                phPal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture,
                phPal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture,
                pType: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture,
                pType: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Render: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture,
                hDC: ?HDC,
                x: i32,
                y: i32,
                cx: i32,
                cy: i32,
                xSrc: i32,
                ySrc: i32,
                cxSrc: i32,
                cySrc: i32,
                pRcWBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture,
                hDC: ?HDC,
                x: i32,
                y: i32,
                cx: i32,
                cy: i32,
                xSrc: i32,
                ySrc: i32,
                cxSrc: i32,
                cySrc: i32,
                pRcWBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        set_hPal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture,
                hPal: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture,
                hPal: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurDC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture,
                phDC: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture,
                phDC: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectPicture: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture,
                hDCIn: ?HDC,
                phDCOut: ?*?HDC,
                phBmpOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture,
                hDCIn: ?HDC,
                phDCOut: ?*?HDC,
                phBmpOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeepOriginalFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture,
                pKeep: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture,
                pKeep: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeepOriginalFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture,
                keep: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture,
                keep: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PictureChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveAsFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture,
                pStream: ?*IStream,
                fSaveMemCopy: BOOL,
                pCbSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture,
                pStream: ?*IStream,
                fSaveMemCopy: BOOL,
                pCbSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Attributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture,
                pDwAttr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture,
                pDwAttr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_get_Handle(self: *const T, pHandle: ?*u32) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).get_Handle(@as(*const IPicture, @ptrCast(self)), pHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_get_hPal(self: *const T, phPal: ?*u32) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).get_hPal(@as(*const IPicture, @ptrCast(self)), phPal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_get_Type(self: *const T, pType: ?*i16) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IPicture, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_get_Width(self: *const T, pWidth: ?*i32) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IPicture, @ptrCast(self)), pWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_get_Height(self: *const T, pHeight: ?*i32) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IPicture, @ptrCast(self)), pHeight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_Render(self: *const T, hDC: ?HDC, x: i32, y: i32, cx: i32, cy: i32, xSrc: i32, ySrc: i32, cxSrc: i32, cySrc: i32, pRcWBounds: ?*RECT) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).Render(@as(*const IPicture, @ptrCast(self)), hDC, x, y, cx, cy, xSrc, ySrc, cxSrc, cySrc, pRcWBounds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_set_hPal(self: *const T, hPal: u32) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).set_hPal(@as(*const IPicture, @ptrCast(self)), hPal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_get_CurDC(self: *const T, phDC: ?*?HDC) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).get_CurDC(@as(*const IPicture, @ptrCast(self)), phDC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_SelectPicture(self: *const T, hDCIn: ?HDC, phDCOut: ?*?HDC, phBmpOut: ?*u32) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).SelectPicture(@as(*const IPicture, @ptrCast(self)), hDCIn, phDCOut, phBmpOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_get_KeepOriginalFormat(self: *const T, pKeep: ?*BOOL) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).get_KeepOriginalFormat(@as(*const IPicture, @ptrCast(self)), pKeep);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_put_KeepOriginalFormat(self: *const T, keep: BOOL) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).put_KeepOriginalFormat(@as(*const IPicture, @ptrCast(self)), keep);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_PictureChanged(self: *const T) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).PictureChanged(@as(*const IPicture, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_SaveAsFile(self: *const T, pStream: ?*IStream, fSaveMemCopy: BOOL, pCbSize: ?*i32) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).SaveAsFile(@as(*const IPicture, @ptrCast(self)), pStream, fSaveMemCopy, pCbSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture_get_Attributes(self: *const T, pDwAttr: ?*u32) HRESULT {
                return @as(*const IPicture.VTable, @ptrCast(self.vtable)).get_Attributes(@as(*const IPicture, @ptrCast(self)), pDwAttr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPicture2_Value = Guid.initString("f5185dd8-2012-4b0b-aad9-f052c6bd482b");
pub const IID_IPicture2 = &IID_IPicture2_Value;
pub const IPicture2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Handle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture2,
                pHandle: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture2,
                pHandle: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hPal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture2,
                phPal: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture2,
                phPal: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture2,
                pType: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture2,
                pType: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture2,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture2,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture2,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture2,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Render: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture2,
                hDC: ?HDC,
                x: i32,
                y: i32,
                cx: i32,
                cy: i32,
                xSrc: i32,
                ySrc: i32,
                cxSrc: i32,
                cySrc: i32,
                pRcWBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture2,
                hDC: ?HDC,
                x: i32,
                y: i32,
                cx: i32,
                cy: i32,
                xSrc: i32,
                ySrc: i32,
                cxSrc: i32,
                cySrc: i32,
                pRcWBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        set_hPal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture2,
                hPal: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture2,
                hPal: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurDC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture2,
                phDC: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture2,
                phDC: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectPicture: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture2,
                hDCIn: ?HDC,
                phDCOut: ?*?HDC,
                phBmpOut: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture2,
                hDCIn: ?HDC,
                phDCOut: ?*?HDC,
                phBmpOut: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeepOriginalFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture2,
                pKeep: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture2,
                pKeep: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeepOriginalFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture2,
                keep: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture2,
                keep: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PictureChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveAsFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPicture2,
                pStream: ?*IStream,
                fSaveMemCopy: BOOL,
                pCbSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPicture2,
                pStream: ?*IStream,
                fSaveMemCopy: BOOL,
                pCbSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Attributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPicture2,
                pDwAttr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPicture2,
                pDwAttr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_get_Handle(self: *const T, pHandle: ?*usize) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).get_Handle(@as(*const IPicture2, @ptrCast(self)), pHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_get_hPal(self: *const T, phPal: ?*usize) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).get_hPal(@as(*const IPicture2, @ptrCast(self)), phPal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_get_Type(self: *const T, pType: ?*i16) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IPicture2, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_get_Width(self: *const T, pWidth: ?*i32) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IPicture2, @ptrCast(self)), pWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_get_Height(self: *const T, pHeight: ?*i32) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IPicture2, @ptrCast(self)), pHeight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_Render(self: *const T, hDC: ?HDC, x: i32, y: i32, cx: i32, cy: i32, xSrc: i32, ySrc: i32, cxSrc: i32, cySrc: i32, pRcWBounds: ?*RECT) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).Render(@as(*const IPicture2, @ptrCast(self)), hDC, x, y, cx, cy, xSrc, ySrc, cxSrc, cySrc, pRcWBounds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_set_hPal(self: *const T, hPal: usize) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).set_hPal(@as(*const IPicture2, @ptrCast(self)), hPal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_get_CurDC(self: *const T, phDC: ?*?HDC) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).get_CurDC(@as(*const IPicture2, @ptrCast(self)), phDC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_SelectPicture(self: *const T, hDCIn: ?HDC, phDCOut: ?*?HDC, phBmpOut: ?*usize) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).SelectPicture(@as(*const IPicture2, @ptrCast(self)), hDCIn, phDCOut, phBmpOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_get_KeepOriginalFormat(self: *const T, pKeep: ?*BOOL) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).get_KeepOriginalFormat(@as(*const IPicture2, @ptrCast(self)), pKeep);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_put_KeepOriginalFormat(self: *const T, keep: BOOL) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).put_KeepOriginalFormat(@as(*const IPicture2, @ptrCast(self)), keep);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_PictureChanged(self: *const T) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).PictureChanged(@as(*const IPicture2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_SaveAsFile(self: *const T, pStream: ?*IStream, fSaveMemCopy: BOOL, pCbSize: ?*i32) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).SaveAsFile(@as(*const IPicture2, @ptrCast(self)), pStream, fSaveMemCopy, pCbSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPicture2_get_Attributes(self: *const T, pDwAttr: ?*u32) HRESULT {
                return @as(*const IPicture2.VTable, @ptrCast(self.vtable)).get_Attributes(@as(*const IPicture2, @ptrCast(self)), pDwAttr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFontEventsDisp_Value = Guid.initString("4ef6100a-af88-11d0-9846-00c04fc29993");
pub const IID_IFontEventsDisp = &IID_IFontEventsDisp_Value;
pub const IFontEventsDisp = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFontDisp_Value = Guid.initString("bef6e003-a874-101a-8bba-00aa00300cab");
pub const IID_IFontDisp = &IID_IFontDisp_Value;
pub const IFontDisp = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPictureDisp_Value = Guid.initString("7bf80981-bf32-101a-8bbb-00aa00300cab");
pub const IID_IPictureDisp = &IID_IPictureDisp_Value;
pub const IPictureDisp = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceObjectWindowless_Value = Guid.initString("1c2056cc-5ef4-101b-8bc8-00aa003e3b29");
pub const IID_IOleInPlaceObjectWindowless = &IID_IOleInPlaceObjectWindowless_Value;
pub const IOleInPlaceObjectWindowless = extern struct {
    pub const VTable = extern struct {
        base: IOleInPlaceObject.VTable,
        OnWindowMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceObjectWindowless,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceObjectWindowless,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDropTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceObjectWindowless,
                ppDropTarget: ?*?*IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceObjectWindowless,
                ppDropTarget: ?*?*IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleInPlaceObject.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceObjectWindowless_OnWindowMessage(self: *const T, msg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) HRESULT {
                return @as(*const IOleInPlaceObjectWindowless.VTable, @ptrCast(self.vtable)).OnWindowMessage(@as(*const IOleInPlaceObjectWindowless, @ptrCast(self)), msg, wParam, lParam, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceObjectWindowless_GetDropTarget(self: *const T, ppDropTarget: ?*?*IDropTarget) HRESULT {
                return @as(*const IOleInPlaceObjectWindowless.VTable, @ptrCast(self.vtable)).GetDropTarget(@as(*const IOleInPlaceObjectWindowless, @ptrCast(self)), ppDropTarget);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ACTIVATEFLAGS = enum(i32) {
    S = 1,
};
pub const ACTIVATE_WINDOWLESS = ACTIVATEFLAGS.S;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceSiteEx_Value = Guid.initString("9c2cad80-3424-11cf-b670-00aa004cd6d8");
pub const IID_IOleInPlaceSiteEx = &IID_IOleInPlaceSiteEx_Value;
pub const IOleInPlaceSiteEx = extern struct {
    pub const VTable = extern struct {
        base: IOleInPlaceSite.VTable,
        OnInPlaceActivateEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteEx,
                pfNoRedraw: ?*BOOL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteEx,
                pfNoRedraw: ?*BOOL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnInPlaceDeactivateEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteEx,
                fNoRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteEx,
                fNoRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestUIActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleInPlaceSite.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteEx_OnInPlaceActivateEx(self: *const T, pfNoRedraw: ?*BOOL, dwFlags: u32) HRESULT {
                return @as(*const IOleInPlaceSiteEx.VTable, @ptrCast(self.vtable)).OnInPlaceActivateEx(@as(*const IOleInPlaceSiteEx, @ptrCast(self)), pfNoRedraw, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteEx_OnInPlaceDeactivateEx(self: *const T, fNoRedraw: BOOL) HRESULT {
                return @as(*const IOleInPlaceSiteEx.VTable, @ptrCast(self.vtable)).OnInPlaceDeactivateEx(@as(*const IOleInPlaceSiteEx, @ptrCast(self)), fNoRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteEx_RequestUIActivate(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSiteEx.VTable, @ptrCast(self.vtable)).RequestUIActivate(@as(*const IOleInPlaceSiteEx, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLEDCFLAGS = enum(i32) {
    NODRAW = 1,
    PAINTBKGND = 2,
    OFFSCREEN = 4,
};
pub const OLEDC_NODRAW = OLEDCFLAGS.NODRAW;
pub const OLEDC_PAINTBKGND = OLEDCFLAGS.PAINTBKGND;
pub const OLEDC_OFFSCREEN = OLEDCFLAGS.OFFSCREEN;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceSiteWindowless_Value = Guid.initString("922eada0-3424-11cf-b670-00aa004cd6d8");
pub const IID_IOleInPlaceSiteWindowless = &IID_IOleInPlaceSiteWindowless_Value;
pub const IOleInPlaceSiteWindowless = extern struct {
    pub const VTable = extern struct {
        base: IOleInPlaceSiteEx.VTable,
        CanWindowlessActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapture: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCapture: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
                fCapture: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
                fCapture: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
                fFocus: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
                fFocus: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
                pRect: ?*RECT,
                grfFlags: u32,
                phDC: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
                pRect: ?*RECT,
                grfFlags: u32,
                phDC: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseDC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
                hDC: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
                hDC: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvalidateRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
                pRect: ?*RECT,
                fErase: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
                pRect: ?*RECT,
                fErase: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvalidateRgn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
                hRGN: ?HRGN,
                fErase: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
                hRGN: ?HRGN,
                fErase: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScrollRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
                dx: i32,
                dy: i32,
                pRectScroll: ?*RECT,
                pRectClip: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
                dx: i32,
                dy: i32,
                pRectScroll: ?*RECT,
                pRectClip: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdjustRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDefWindowMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleInPlaceSiteWindowless,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleInPlaceSiteWindowless,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleInPlaceSiteEx.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_CanWindowlessActivate(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).CanWindowlessActivate(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_GetCapture(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).GetCapture(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_SetCapture(self: *const T, fCapture: BOOL) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).SetCapture(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)), fCapture);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_GetFocus(self: *const T) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).GetFocus(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_SetFocus(self: *const T, fFocus: BOOL) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).SetFocus(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)), fFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_GetDC(self: *const T, pRect: ?*RECT, grfFlags: u32, phDC: ?*?HDC) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).GetDC(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)), pRect, grfFlags, phDC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_ReleaseDC(self: *const T, hDC: ?HDC) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).ReleaseDC(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)), hDC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_InvalidateRect(self: *const T, pRect: ?*RECT, fErase: BOOL) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).InvalidateRect(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)), pRect, fErase);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_InvalidateRgn(self: *const T, hRGN: ?HRGN, fErase: BOOL) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).InvalidateRgn(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)), hRGN, fErase);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_ScrollRect(self: *const T, dx: i32, dy: i32, pRectScroll: ?*RECT, pRectClip: ?*RECT) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).ScrollRect(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)), dx, dy, pRectScroll, pRectClip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_AdjustRect(self: *const T, prc: ?*RECT) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).AdjustRect(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)), prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleInPlaceSiteWindowless_OnDefWindowMessage(self: *const T, msg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) HRESULT {
                return @as(*const IOleInPlaceSiteWindowless.VTable, @ptrCast(self.vtable)).OnDefWindowMessage(@as(*const IOleInPlaceSiteWindowless, @ptrCast(self)), msg, wParam, lParam, plResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VIEWSTATUS = enum(i32) {
    OPAQUE = 1,
    SOLIDBKGND = 2,
    DVASPECTOPAQUE = 4,
    DVASPECTTRANSPARENT = 8,
    SURFACE = 16,
    @"3DSURFACE" = 32,
};
pub const VIEWSTATUS_OPAQUE = VIEWSTATUS.OPAQUE;
pub const VIEWSTATUS_SOLIDBKGND = VIEWSTATUS.SOLIDBKGND;
pub const VIEWSTATUS_DVASPECTOPAQUE = VIEWSTATUS.DVASPECTOPAQUE;
pub const VIEWSTATUS_DVASPECTTRANSPARENT = VIEWSTATUS.DVASPECTTRANSPARENT;
pub const VIEWSTATUS_SURFACE = VIEWSTATUS.SURFACE;
pub const VIEWSTATUS_3DSURFACE = VIEWSTATUS.@"3DSURFACE";

pub const HITRESULT = enum(i32) {
    OUTSIDE = 0,
    TRANSPARENT = 1,
    CLOSE = 2,
    HIT = 3,
};
pub const HITRESULT_OUTSIDE = HITRESULT.OUTSIDE;
pub const HITRESULT_TRANSPARENT = HITRESULT.TRANSPARENT;
pub const HITRESULT_CLOSE = HITRESULT.CLOSE;
pub const HITRESULT_HIT = HITRESULT.HIT;

pub const DVASPECT2 = enum(i32) {
    OPAQUE = 16,
    TRANSPARENT = 32,
};
pub const DVASPECT_OPAQUE = DVASPECT2.OPAQUE;
pub const DVASPECT_TRANSPARENT = DVASPECT2.TRANSPARENT;

pub const ExtentInfo = extern struct {
    cb: u32,
    dwExtentMode: u32,
    sizelProposed: SIZE,
};

pub const ExtentMode = enum(i32) {
    CONTENT = 0,
    INTEGRAL = 1,
};
pub const DVEXTENT_CONTENT = ExtentMode.CONTENT;
pub const DVEXTENT_INTEGRAL = ExtentMode.INTEGRAL;

pub const AspectInfoFlag = enum(i32) {
    E = 1,
};
pub const DVASPECTINFOFLAG_CANOPTIMIZE = AspectInfoFlag.E;

pub const AspectInfo = extern struct {
    cb: u32,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IViewObjectEx_Value = Guid.initString("3af24292-0c96-11ce-a0cf-00aa00600ab8");
pub const IID_IViewObjectEx = &IID_IViewObjectEx_Value;
pub const IViewObjectEx = extern struct {
    pub const VTable = extern struct {
        base: IViewObject2.VTable,
        GetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObjectEx,
                dwAspect: u32,
                pRect: ?*RECTL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObjectEx,
                dwAspect: u32,
                pRect: ?*RECTL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObjectEx,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObjectEx,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryHitPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObjectEx,
                dwAspect: u32,
                pRectBounds: ?*RECT,
                ptlLoc: POINT,
                lCloseHint: i32,
                pHitResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObjectEx,
                dwAspect: u32,
                pRectBounds: ?*RECT,
                ptlLoc: POINT,
                lCloseHint: i32,
                pHitResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryHitRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObjectEx,
                dwAspect: u32,
                pRectBounds: ?*RECT,
                pRectLoc: ?*RECT,
                lCloseHint: i32,
                pHitResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObjectEx,
                dwAspect: u32,
                pRectBounds: ?*RECT,
                pRectLoc: ?*RECT,
                lCloseHint: i32,
                pHitResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNaturalExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IViewObjectEx,
                dwAspect: DVASPECT,
                lindex: i32,
                ptd: ?*DVTARGETDEVICE,
                hicTargetDev: ?HDC,
                pExtentInfo: ?*ExtentInfo,
                pSizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IViewObjectEx,
                dwAspect: DVASPECT,
                lindex: i32,
                ptd: ?*DVTARGETDEVICE,
                hicTargetDev: ?HDC,
                pExtentInfo: ?*ExtentInfo,
                pSizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IViewObject2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObjectEx_GetRect(self: *const T, dwAspect: u32, pRect: ?*RECTL) HRESULT {
                return @as(*const IViewObjectEx.VTable, @ptrCast(self.vtable)).GetRect(@as(*const IViewObjectEx, @ptrCast(self)), dwAspect, pRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObjectEx_GetViewStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IViewObjectEx.VTable, @ptrCast(self.vtable)).GetViewStatus(@as(*const IViewObjectEx, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObjectEx_QueryHitPoint(self: *const T, dwAspect: u32, pRectBounds: ?*RECT, ptlLoc: POINT, lCloseHint: i32, pHitResult: ?*u32) HRESULT {
                return @as(*const IViewObjectEx.VTable, @ptrCast(self.vtable)).QueryHitPoint(@as(*const IViewObjectEx, @ptrCast(self)), dwAspect, pRectBounds, ptlLoc, lCloseHint, pHitResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObjectEx_QueryHitRect(self: *const T, dwAspect: u32, pRectBounds: ?*RECT, pRectLoc: ?*RECT, lCloseHint: i32, pHitResult: ?*u32) HRESULT {
                return @as(*const IViewObjectEx.VTable, @ptrCast(self.vtable)).QueryHitRect(@as(*const IViewObjectEx, @ptrCast(self)), dwAspect, pRectBounds, pRectLoc, lCloseHint, pHitResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IViewObjectEx_GetNaturalExtent(self: *const T, dwAspect: DVASPECT, lindex: i32, ptd: ?*DVTARGETDEVICE, hicTargetDev: ?HDC, pExtentInfo: ?*ExtentInfo, pSizel: ?*SIZE) HRESULT {
                return @as(*const IViewObjectEx.VTable, @ptrCast(self.vtable)).GetNaturalExtent(@as(*const IViewObjectEx, @ptrCast(self)), dwAspect, lindex, ptd, hicTargetDev, pExtentInfo, pSizel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleUndoUnit_Value = Guid.initString("894ad3b0-ef97-11ce-9bc9-00aa00608e01");
pub const IID_IOleUndoUnit = &IID_IOleUndoUnit_Value;
pub const IOleUndoUnit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Do: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoUnit,
                pUndoManager: ?*IOleUndoManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoUnit,
                pUndoManager: ?*IOleUndoManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoUnit,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoUnit,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUnitType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoUnit,
                pClsid: ?*Guid,
                plID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoUnit,
                pClsid: ?*Guid,
                plID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnNextAdd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoUnit_Do(self: *const T, pUndoManager: ?*IOleUndoManager) HRESULT {
                return @as(*const IOleUndoUnit.VTable, @ptrCast(self.vtable)).Do(@as(*const IOleUndoUnit, @ptrCast(self)), pUndoManager);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoUnit_GetDescription(self: *const T, pBstr: ?*?BSTR) HRESULT {
                return @as(*const IOleUndoUnit.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IOleUndoUnit, @ptrCast(self)), pBstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoUnit_GetUnitType(self: *const T, pClsid: ?*Guid, plID: ?*i32) HRESULT {
                return @as(*const IOleUndoUnit.VTable, @ptrCast(self.vtable)).GetUnitType(@as(*const IOleUndoUnit, @ptrCast(self)), pClsid, plID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoUnit_OnNextAdd(self: *const T) HRESULT {
                return @as(*const IOleUndoUnit.VTable, @ptrCast(self.vtable)).OnNextAdd(@as(*const IOleUndoUnit, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleParentUndoUnit_Value = Guid.initString("a1faf330-ef97-11ce-9bc9-00aa00608e01");
pub const IID_IOleParentUndoUnit = &IID_IOleParentUndoUnit_Value;
pub const IOleParentUndoUnit = extern struct {
    pub const VTable = extern struct {
        base: IOleUndoUnit.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleParentUndoUnit,
                pPUU: ?*IOleParentUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleParentUndoUnit,
                pPUU: ?*IOleParentUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleParentUndoUnit,
                pPUU: ?*IOleParentUndoUnit,
                fCommit: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleParentUndoUnit,
                pPUU: ?*IOleParentUndoUnit,
                fCommit: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleParentUndoUnit,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleParentUndoUnit,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleParentUndoUnit,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleParentUndoUnit,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleParentUndoUnit,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleParentUndoUnit,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleUndoUnit.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleParentUndoUnit_Open(self: *const T, pPUU: ?*IOleParentUndoUnit) HRESULT {
                return @as(*const IOleParentUndoUnit.VTable, @ptrCast(self.vtable)).Open(@as(*const IOleParentUndoUnit, @ptrCast(self)), pPUU);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleParentUndoUnit_Close(self: *const T, pPUU: ?*IOleParentUndoUnit, fCommit: BOOL) HRESULT {
                return @as(*const IOleParentUndoUnit.VTable, @ptrCast(self.vtable)).Close(@as(*const IOleParentUndoUnit, @ptrCast(self)), pPUU, fCommit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleParentUndoUnit_Add(self: *const T, pUU: ?*IOleUndoUnit) HRESULT {
                return @as(*const IOleParentUndoUnit.VTable, @ptrCast(self.vtable)).Add(@as(*const IOleParentUndoUnit, @ptrCast(self)), pUU);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleParentUndoUnit_FindUnit(self: *const T, pUU: ?*IOleUndoUnit) HRESULT {
                return @as(*const IOleParentUndoUnit.VTable, @ptrCast(self.vtable)).FindUnit(@as(*const IOleParentUndoUnit, @ptrCast(self)), pUU);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleParentUndoUnit_GetParentState(self: *const T, pdwState: ?*u32) HRESULT {
                return @as(*const IOleParentUndoUnit.VTable, @ptrCast(self.vtable)).GetParentState(@as(*const IOleParentUndoUnit, @ptrCast(self)), pdwState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumOleUndoUnits_Value = Guid.initString("b3e7c340-ef97-11ce-9bc9-00aa00608e01");
pub const IID_IEnumOleUndoUnits = &IID_IEnumOleUndoUnits_Value;
pub const IEnumOleUndoUnits = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOleUndoUnits,
                cElt: u32,
                rgElt: [*]?*IOleUndoUnit,
                pcEltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOleUndoUnits,
                cElt: u32,
                rgElt: [*]?*IOleUndoUnit,
                pcEltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOleUndoUnits,
                cElt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOleUndoUnits,
                cElt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOleUndoUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOleUndoUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOleUndoUnits,
                ppEnum: ?*?*IEnumOleUndoUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOleUndoUnits,
                ppEnum: ?*?*IEnumOleUndoUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOleUndoUnits_Next(self: *const T, cElt: u32, rgElt: [*]?*IOleUndoUnit, pcEltFetched: ?*u32) HRESULT {
                return @as(*const IEnumOleUndoUnits.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumOleUndoUnits, @ptrCast(self)), cElt, rgElt, pcEltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOleUndoUnits_Skip(self: *const T, cElt: u32) HRESULT {
                return @as(*const IEnumOleUndoUnits.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumOleUndoUnits, @ptrCast(self)), cElt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOleUndoUnits_Reset(self: *const T) HRESULT {
                return @as(*const IEnumOleUndoUnits.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumOleUndoUnits, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOleUndoUnits_Clone(self: *const T, ppEnum: ?*?*IEnumOleUndoUnits) HRESULT {
                return @as(*const IEnumOleUndoUnits.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumOleUndoUnits, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleUndoManager_Value = Guid.initString("d001f200-ef97-11ce-9bc9-00aa00608e01");
pub const IID_IOleUndoManager = &IID_IOleUndoManager_Value;
pub const IOleUndoManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                pPUU: ?*IOleParentUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                pPUU: ?*IOleParentUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                pPUU: ?*IOleParentUndoUnit,
                fCommit: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                pPUU: ?*IOleParentUndoUnit,
                fCommit: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOpenParentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DiscardFrom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UndoTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RedoTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                pUU: ?*IOleUndoUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumUndoable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                ppEnum: ?*?*IEnumOleUndoUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                ppEnum: ?*?*IEnumOleUndoUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumRedoable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                ppEnum: ?*?*IEnumOleUndoUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                ppEnum: ?*?*IEnumOleUndoUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastUndoDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastRedoDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUndoManager,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUndoManager,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_Open(self: *const T, pPUU: ?*IOleParentUndoUnit) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).Open(@as(*const IOleUndoManager, @ptrCast(self)), pPUU);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_Close(self: *const T, pPUU: ?*IOleParentUndoUnit, fCommit: BOOL) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).Close(@as(*const IOleUndoManager, @ptrCast(self)), pPUU, fCommit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_Add(self: *const T, pUU: ?*IOleUndoUnit) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).Add(@as(*const IOleUndoManager, @ptrCast(self)), pUU);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_GetOpenParentState(self: *const T, pdwState: ?*u32) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).GetOpenParentState(@as(*const IOleUndoManager, @ptrCast(self)), pdwState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_DiscardFrom(self: *const T, pUU: ?*IOleUndoUnit) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).DiscardFrom(@as(*const IOleUndoManager, @ptrCast(self)), pUU);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_UndoTo(self: *const T, pUU: ?*IOleUndoUnit) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).UndoTo(@as(*const IOleUndoManager, @ptrCast(self)), pUU);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_RedoTo(self: *const T, pUU: ?*IOleUndoUnit) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).RedoTo(@as(*const IOleUndoManager, @ptrCast(self)), pUU);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_EnumUndoable(self: *const T, ppEnum: ?*?*IEnumOleUndoUnits) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).EnumUndoable(@as(*const IOleUndoManager, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_EnumRedoable(self: *const T, ppEnum: ?*?*IEnumOleUndoUnits) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).EnumRedoable(@as(*const IOleUndoManager, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_GetLastUndoDescription(self: *const T, pBstr: ?*?BSTR) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).GetLastUndoDescription(@as(*const IOleUndoManager, @ptrCast(self)), pBstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_GetLastRedoDescription(self: *const T, pBstr: ?*?BSTR) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).GetLastRedoDescription(@as(*const IOleUndoManager, @ptrCast(self)), pBstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUndoManager_Enable(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IOleUndoManager.VTable, @ptrCast(self.vtable)).Enable(@as(*const IOleUndoManager, @ptrCast(self)), fEnable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const POINTERINACTIVE = enum(i32) {
    ACTIVATEONENTRY = 1,
    DEACTIVATEONLEAVE = 2,
    ACTIVATEONDRAG = 4,
};
pub const POINTERINACTIVE_ACTIVATEONENTRY = POINTERINACTIVE.ACTIVATEONENTRY;
pub const POINTERINACTIVE_DEACTIVATEONLEAVE = POINTERINACTIVE.DEACTIVATEONLEAVE;
pub const POINTERINACTIVE_ACTIVATEONDRAG = POINTERINACTIVE.ACTIVATEONDRAG;

// TODO: this type is limited to platform 'windows5.0'
const IID_IPointerInactive_Value = Guid.initString("55980ba0-35aa-11cf-b671-00aa004cd6d8");
pub const IID_IPointerInactive = &IID_IPointerInactive_Value;
pub const IPointerInactive = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActivationPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPointerInactive,
                pdwPolicy: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPointerInactive,
                pdwPolicy: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnInactiveMouseMove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPointerInactive,
                pRectBounds: ?*RECT,
                x: i32,
                y: i32,
                grfKeyState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPointerInactive,
                pRectBounds: ?*RECT,
                x: i32,
                y: i32,
                grfKeyState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnInactiveSetCursor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPointerInactive,
                pRectBounds: ?*RECT,
                x: i32,
                y: i32,
                dwMouseMsg: u32,
                fSetAlways: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPointerInactive,
                pRectBounds: ?*RECT,
                x: i32,
                y: i32,
                dwMouseMsg: u32,
                fSetAlways: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPointerInactive_GetActivationPolicy(self: *const T, pdwPolicy: ?*u32) HRESULT {
                return @as(*const IPointerInactive.VTable, @ptrCast(self.vtable)).GetActivationPolicy(@as(*const IPointerInactive, @ptrCast(self)), pdwPolicy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPointerInactive_OnInactiveMouseMove(self: *const T, pRectBounds: ?*RECT, x: i32, y: i32, grfKeyState: u32) HRESULT {
                return @as(*const IPointerInactive.VTable, @ptrCast(self.vtable)).OnInactiveMouseMove(@as(*const IPointerInactive, @ptrCast(self)), pRectBounds, x, y, grfKeyState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPointerInactive_OnInactiveSetCursor(self: *const T, pRectBounds: ?*RECT, x: i32, y: i32, dwMouseMsg: u32, fSetAlways: BOOL) HRESULT {
                return @as(*const IPointerInactive.VTable, @ptrCast(self.vtable)).OnInactiveSetCursor(@as(*const IPointerInactive, @ptrCast(self)), pRectBounds, x, y, dwMouseMsg, fSetAlways);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IObjectWithSite_Value = Guid.initString("fc4801a3-2ba9-11cf-a229-00aa003d7352");
pub const IID_IObjectWithSite = &IID_IObjectWithSite_Value;
pub const IObjectWithSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithSite,
                pUnkSite: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithSite,
                pUnkSite: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithSite,
                riid: ?*const Guid,
                ppvSite: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithSite,
                riid: ?*const Guid,
                ppvSite: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithSite_SetSite(self: *const T, pUnkSite: ?*IUnknown) HRESULT {
                return @as(*const IObjectWithSite.VTable, @ptrCast(self.vtable)).SetSite(@as(*const IObjectWithSite, @ptrCast(self)), pUnkSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithSite_GetSite(self: *const T, riid: ?*const Guid, ppvSite: ?*?*anyopaque) HRESULT {
                return @as(*const IObjectWithSite.VTable, @ptrCast(self.vtable)).GetSite(@as(*const IObjectWithSite, @ptrCast(self)), riid, ppvSite);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CALPOLESTR = extern struct {
    cElems: u32,
    pElems: ?*?PWSTR,
};

pub const CADWORD = extern struct {
    cElems: u32,
    pElems: ?*u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPerPropertyBrowsing_Value = Guid.initString("376bd3aa-3845-101b-84ed-08002b2ec713");
pub const IID_IPerPropertyBrowsing = &IID_IPerPropertyBrowsing_Value;
pub const IPerPropertyBrowsing = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerPropertyBrowsing,
                dispID: i32,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerPropertyBrowsing,
                dispID: i32,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapPropertyToPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerPropertyBrowsing,
                dispID: i32,
                pClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerPropertyBrowsing,
                dispID: i32,
                pClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPredefinedStrings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerPropertyBrowsing,
                dispID: i32,
                pCaStringsOut: ?*CALPOLESTR,
                pCaCookiesOut: ?*CADWORD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerPropertyBrowsing,
                dispID: i32,
                pCaStringsOut: ?*CALPOLESTR,
                pCaCookiesOut: ?*CADWORD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPredefinedValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerPropertyBrowsing,
                dispID: i32,
                dwCookie: u32,
                pVarOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerPropertyBrowsing,
                dispID: i32,
                dwCookie: u32,
                pVarOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerPropertyBrowsing_GetDisplayString(self: *const T, dispID: i32, pBstr: ?*?BSTR) HRESULT {
                return @as(*const IPerPropertyBrowsing.VTable, @ptrCast(self.vtable)).GetDisplayString(@as(*const IPerPropertyBrowsing, @ptrCast(self)), dispID, pBstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerPropertyBrowsing_MapPropertyToPage(self: *const T, dispID: i32, pClsid: ?*Guid) HRESULT {
                return @as(*const IPerPropertyBrowsing.VTable, @ptrCast(self.vtable)).MapPropertyToPage(@as(*const IPerPropertyBrowsing, @ptrCast(self)), dispID, pClsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerPropertyBrowsing_GetPredefinedStrings(self: *const T, dispID: i32, pCaStringsOut: ?*CALPOLESTR, pCaCookiesOut: ?*CADWORD) HRESULT {
                return @as(*const IPerPropertyBrowsing.VTable, @ptrCast(self.vtable)).GetPredefinedStrings(@as(*const IPerPropertyBrowsing, @ptrCast(self)), dispID, pCaStringsOut, pCaCookiesOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerPropertyBrowsing_GetPredefinedValue(self: *const T, dispID: i32, dwCookie: u32, pVarOut: ?*VARIANT) HRESULT {
                return @as(*const IPerPropertyBrowsing.VTable, @ptrCast(self.vtable)).GetPredefinedValue(@as(*const IPerPropertyBrowsing, @ptrCast(self)), dispID, dwCookie, pVarOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PROPBAG2_TYPE = enum(i32) {
    UNDEFINED = 0,
    DATA = 1,
    URL = 2,
    OBJECT = 3,
    STREAM = 4,
    STORAGE = 5,
    MONIKER = 6,
};
pub const PROPBAG2_TYPE_UNDEFINED = PROPBAG2_TYPE.UNDEFINED;
pub const PROPBAG2_TYPE_DATA = PROPBAG2_TYPE.DATA;
pub const PROPBAG2_TYPE_URL = PROPBAG2_TYPE.URL;
pub const PROPBAG2_TYPE_OBJECT = PROPBAG2_TYPE.OBJECT;
pub const PROPBAG2_TYPE_STREAM = PROPBAG2_TYPE.STREAM;
pub const PROPBAG2_TYPE_STORAGE = PROPBAG2_TYPE.STORAGE;
pub const PROPBAG2_TYPE_MONIKER = PROPBAG2_TYPE.MONIKER;

const IID_IPersistPropertyBag2_Value = Guid.initString("22f55881-280b-11d0-a8a9-00a0c90c2004");
pub const IID_IPersistPropertyBag2 = &IID_IPersistPropertyBag2_Value;
pub const IPersistPropertyBag2 = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistPropertyBag2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistPropertyBag2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistPropertyBag2,
                pPropBag: ?*IPropertyBag2,
                pErrLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistPropertyBag2,
                pPropBag: ?*IPropertyBag2,
                pErrLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistPropertyBag2,
                pPropBag: ?*IPropertyBag2,
                fClearDirty: BOOL,
                fSaveAllProperties: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistPropertyBag2,
                pPropBag: ?*IPropertyBag2,
                fClearDirty: BOOL,
                fSaveAllProperties: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistPropertyBag2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistPropertyBag2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistPropertyBag2_InitNew(self: *const T) HRESULT {
                return @as(*const IPersistPropertyBag2.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistPropertyBag2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistPropertyBag2_Load(self: *const T, pPropBag: ?*IPropertyBag2, pErrLog: ?*IErrorLog) HRESULT {
                return @as(*const IPersistPropertyBag2.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistPropertyBag2, @ptrCast(self)), pPropBag, pErrLog);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistPropertyBag2_Save(self: *const T, pPropBag: ?*IPropertyBag2, fClearDirty: BOOL, fSaveAllProperties: BOOL) HRESULT {
                return @as(*const IPersistPropertyBag2.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistPropertyBag2, @ptrCast(self)), pPropBag, fClearDirty, fSaveAllProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistPropertyBag2_IsDirty(self: *const T) HRESULT {
                return @as(*const IPersistPropertyBag2.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistPropertyBag2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSinkEx_Value = Guid.initString("3af24290-0c96-11ce-a0cf-00aa00600ab8");
pub const IID_IAdviseSinkEx = &IID_IAdviseSinkEx_Value;
pub const IAdviseSinkEx = extern struct {
    pub const VTable = extern struct {
        base: IAdviseSink.VTable,
        OnViewStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdviseSinkEx,
                dwViewStatus: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IAdviseSinkEx,
                dwViewStatus: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAdviseSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdviseSinkEx_OnViewStatusChange(self: *const T, dwViewStatus: u32) void {
                return @as(*const IAdviseSinkEx.VTable, @ptrCast(self.vtable)).OnViewStatusChange(@as(*const IAdviseSinkEx, @ptrCast(self)), dwViewStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const QACONTAINERFLAGS = enum(i32) {
    SHOWHATCHING = 1,
    SHOWGRABHANDLES = 2,
    USERMODE = 4,
    DISPLAYASDEFAULT = 8,
    UIDEAD = 16,
    AUTOCLIP = 32,
    MESSAGEREFLECT = 64,
    SUPPORTSMNEMONICS = 128,
};
pub const QACONTAINER_SHOWHATCHING = QACONTAINERFLAGS.SHOWHATCHING;
pub const QACONTAINER_SHOWGRABHANDLES = QACONTAINERFLAGS.SHOWGRABHANDLES;
pub const QACONTAINER_USERMODE = QACONTAINERFLAGS.USERMODE;
pub const QACONTAINER_DISPLAYASDEFAULT = QACONTAINERFLAGS.DISPLAYASDEFAULT;
pub const QACONTAINER_UIDEAD = QACONTAINERFLAGS.UIDEAD;
pub const QACONTAINER_AUTOCLIP = QACONTAINERFLAGS.AUTOCLIP;
pub const QACONTAINER_MESSAGEREFLECT = QACONTAINERFLAGS.MESSAGEREFLECT;
pub const QACONTAINER_SUPPORTSMNEMONICS = QACONTAINERFLAGS.SUPPORTSMNEMONICS;

pub const QACONTAINER = extern struct {
    cbSize: u32,
    pClientSite: ?*IOleClientSite,
    pAdviseSink: ?*IAdviseSinkEx,
    pPropertyNotifySink: ?*IPropertyNotifySink,
    pUnkEventSink: ?*IUnknown,
    dwAmbientFlags: u32,
    colorFore: u32,
    colorBack: u32,
    pFont: ?*IFont,
    pUndoMgr: ?*IOleUndoManager,
    dwAppearance: u32,
    lcid: i32,
    hpal: ?HPALETTE,
    pBindHost: ?*IBindHost,
    pOleControlSite: ?*IOleControlSite,
    pServiceProvider: ?*IServiceProvider,
};

pub const QACONTROL = extern struct {
    cbSize: u32,
    dwMiscStatus: u32,
    dwViewStatus: u32,
    dwEventCookie: u32,
    dwPropNotifyCookie: u32,
    dwPointerActivationPolicy: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQuickActivate_Value = Guid.initString("cf51ed10-62fe-11cf-bf86-00a0c9034836");
pub const IID_IQuickActivate = &IID_IQuickActivate_Value;
pub const IQuickActivate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QuickActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQuickActivate,
                pQaContainer: ?*QACONTAINER,
                pQaControl: ?*QACONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQuickActivate,
                pQaContainer: ?*QACONTAINER,
                pQaControl: ?*QACONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetContentExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQuickActivate,
                pSizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQuickActivate,
                pSizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContentExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQuickActivate,
                pSizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQuickActivate,
                pSizel: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQuickActivate_QuickActivate(self: *const T, pQaContainer: ?*QACONTAINER, pQaControl: ?*QACONTROL) HRESULT {
                return @as(*const IQuickActivate.VTable, @ptrCast(self.vtable)).QuickActivate(@as(*const IQuickActivate, @ptrCast(self)), pQaContainer, pQaControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQuickActivate_SetContentExtent(self: *const T, pSizel: ?*SIZE) HRESULT {
                return @as(*const IQuickActivate.VTable, @ptrCast(self.vtable)).SetContentExtent(@as(*const IQuickActivate, @ptrCast(self)), pSizel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQuickActivate_GetContentExtent(self: *const T, pSizel: ?*SIZE) HRESULT {
                return @as(*const IQuickActivate.VTable, @ptrCast(self.vtable)).GetContentExtent(@as(*const IQuickActivate, @ptrCast(self)), pSizel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OCPFIPARAMS = extern struct {
    cbStructSize: u32,
    hWndOwner: ?HWND,
    x: i32,
    y: i32,
    lpszCaption: ?[*:0]const u16,
    cObjects: u32,
    lplpUnk: ?*?*IUnknown,
    cPages: u32,
    lpPages: ?*Guid,
    lcid: u32,
    dispidInitialProperty: i32,
};

pub const FONTDESC = extern struct {
    cbSizeofstruct: u32,
    lpstrName: ?PWSTR,
    cySize: CY,
    sWeight: i16,
    sCharset: i16,
    fItalic: BOOL,
    fUnderline: BOOL,
    fStrikethrough: BOOL,
};

pub const PICTDESC = extern struct {
    cbSizeofstruct: u32,
    picType: u32,
    Anonymous: extern union {
        bmp: extern struct {
            hbitmap: ?HBITMAP,
            hpal: ?HPALETTE,
        },
        wmf: extern struct {
            hmeta: ?HMETAFILE,
            xExt: i32,
            yExt: i32,
        },
        icon: extern struct {
            hicon: ?HICON,
        },
        emf: extern struct {
            hemf: ?HENHMETAFILE,
        },
    },
};

pub const OLE_TRISTATE = enum(i32) {
    Unchecked = 0,
    Checked = 1,
    Gray = 2,
};
pub const triUnchecked = OLE_TRISTATE.Unchecked;
pub const triChecked = OLE_TRISTATE.Checked;
pub const triGray = OLE_TRISTATE.Gray;

const IID_IVBGetControl_Value = Guid.initString("40a050a0-3c31-101b-a82e-08002b2b2337");
pub const IID_IVBGetControl = &IID_IVBGetControl_Value;
pub const IVBGetControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumControls: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVBGetControl,
                dwOleContF: OLECONTF,
                dwWhich: ENUM_CONTROLS_WHICH_FLAGS,
                ppenumUnk: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVBGetControl,
                dwOleContF: OLECONTF,
                dwWhich: ENUM_CONTROLS_WHICH_FLAGS,
                ppenumUnk: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVBGetControl_EnumControls(self: *const T, dwOleContF: OLECONTF, dwWhich: ENUM_CONTROLS_WHICH_FLAGS, ppenumUnk: ?*?*IEnumUnknown) HRESULT {
                return @as(*const IVBGetControl.VTable, @ptrCast(self.vtable)).EnumControls(@as(*const IVBGetControl, @ptrCast(self)), dwOleContF, dwWhich, ppenumUnk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetOleObject_Value = Guid.initString("8a701da0-4feb-101b-a82e-08002b2b2337");
pub const IID_IGetOleObject = &IID_IGetOleObject_Value;
pub const IGetOleObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOleObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGetOleObject,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGetOleObject,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGetOleObject_GetOleObject(self: *const T, riid: ?*const Guid, ppvObj: ?*?*anyopaque) HRESULT {
                return @as(*const IGetOleObject.VTable, @ptrCast(self.vtable)).GetOleObject(@as(*const IGetOleObject, @ptrCast(self)), riid, ppvObj);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBFormat_Value = Guid.initString("9849fd60-3768-101b-8d72-ae6164ffe3cf");
pub const IID_IVBFormat = &IID_IVBFormat_Value;
pub const IVBFormat = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Format: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVBFormat,
                vData: ?*VARIANT,
                bstrFormat: ?BSTR,
                lpBuffer: ?*anyopaque,
                cb: u16,
                lcid: i32,
                sFirstDayOfWeek: i16,
                sFirstWeekOfYear: u16,
                rcb: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVBFormat,
                vData: ?*VARIANT,
                bstrFormat: ?BSTR,
                lpBuffer: ?*anyopaque,
                cb: u16,
                lcid: i32,
                sFirstDayOfWeek: i16,
                sFirstWeekOfYear: u16,
                rcb: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVBFormat_Format(self: *const T, vData: ?*VARIANT, bstrFormat: ?BSTR, lpBuffer: ?*anyopaque, cb: u16, lcid: i32, sFirstDayOfWeek: i16, sFirstWeekOfYear: u16, rcb: ?*u16) HRESULT {
                return @as(*const IVBFormat.VTable, @ptrCast(self.vtable)).Format(@as(*const IVBFormat, @ptrCast(self)), vData, bstrFormat, lpBuffer, cb, lcid, sFirstDayOfWeek, sFirstWeekOfYear, rcb);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetVBAObject_Value = Guid.initString("91733a60-3f4c-101b-a3f6-00aa0034e4e9");
pub const IID_IGetVBAObject = &IID_IGetVBAObject_Value;
pub const IGetVBAObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGetVBAObject,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGetVBAObject,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGetVBAObject_GetObject(self: *const T, riid: ?*const Guid, ppvObj: ?*?*anyopaque, dwReserved: u32) HRESULT {
                return @as(*const IGetVBAObject.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IGetVBAObject, @ptrCast(self)), riid, ppvObj, dwReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DOCMISC = enum(i32) {
    CANCREATEMULTIPLEVIEWS = 1,
    SUPPORTCOMPLEXRECTANGLES = 2,
    CANTOPENEDIT = 4,
    NOFILESUPPORT = 8,
};
pub const DOCMISC_CANCREATEMULTIPLEVIEWS = DOCMISC.CANCREATEMULTIPLEVIEWS;
pub const DOCMISC_SUPPORTCOMPLEXRECTANGLES = DOCMISC.SUPPORTCOMPLEXRECTANGLES;
pub const DOCMISC_CANTOPENEDIT = DOCMISC.CANTOPENEDIT;
pub const DOCMISC_NOFILESUPPORT = DOCMISC.NOFILESUPPORT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleDocument_Value = Guid.initString("b722bcc5-4e68-101b-a2bc-00aa00404770");
pub const IID_IOleDocument = &IID_IOleDocument_Value;
pub const IOleDocument = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocument,
                pIPSite: ?*IOleInPlaceSite,
                pstm: ?*IStream,
                dwReserved: u32,
                ppView: ?*?*IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocument,
                pIPSite: ?*IOleInPlaceSite,
                pstm: ?*IStream,
                dwReserved: u32,
                ppView: ?*?*IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocMiscStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocument,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocument,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumViews: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocument,
                ppEnum: ?*?*IEnumOleDocumentViews,
                ppView: ?*?*IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocument,
                ppEnum: ?*?*IEnumOleDocumentViews,
                ppView: ?*?*IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocument_CreateView(self: *const T, pIPSite: ?*IOleInPlaceSite, pstm: ?*IStream, dwReserved: u32, ppView: ?*?*IOleDocumentView) HRESULT {
                return @as(*const IOleDocument.VTable, @ptrCast(self.vtable)).CreateView(@as(*const IOleDocument, @ptrCast(self)), pIPSite, pstm, dwReserved, ppView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocument_GetDocMiscStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IOleDocument.VTable, @ptrCast(self.vtable)).GetDocMiscStatus(@as(*const IOleDocument, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocument_EnumViews(self: *const T, ppEnum: ?*?*IEnumOleDocumentViews, ppView: ?*?*IOleDocumentView) HRESULT {
                return @as(*const IOleDocument.VTable, @ptrCast(self.vtable)).EnumViews(@as(*const IOleDocument, @ptrCast(self)), ppEnum, ppView);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleDocumentSite_Value = Guid.initString("b722bcc7-4e68-101b-a2bc-00aa00404770");
pub const IID_IOleDocumentSite = &IID_IOleDocumentSite_Value;
pub const IOleDocumentSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateMe: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentSite,
                pViewToActivate: ?*IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentSite,
                pViewToActivate: ?*IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentSite_ActivateMe(self: *const T, pViewToActivate: ?*IOleDocumentView) HRESULT {
                return @as(*const IOleDocumentSite.VTable, @ptrCast(self.vtable)).ActivateMe(@as(*const IOleDocumentSite, @ptrCast(self)), pViewToActivate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleDocumentView_Value = Guid.initString("b722bcc6-4e68-101b-a2bc-00aa00404770");
pub const IID_IOleDocumentView = &IID_IOleDocumentView_Value;
pub const IOleDocumentView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetInPlaceSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                pIPSite: ?*IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                pIPSite: ?*IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInPlaceSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                ppIPSite: ?*?*IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                ppIPSite: ?*?*IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                prcView: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                prcView: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                prcView: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                prcView: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRectComplex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                prcView: ?*RECT,
                prcHScroll: ?*RECT,
                prcVScroll: ?*RECT,
                prcSizeBox: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                prcView: ?*RECT,
                prcHScroll: ?*RECT,
                prcVScroll: ?*RECT,
                prcSizeBox: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UIActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                fUIActivate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                fUIActivate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveViewState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                pstm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                pstm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ApplyViewState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                pstm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                pstm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleDocumentView,
                pIPSiteNew: ?*IOleInPlaceSite,
                ppViewNew: ?*?*IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleDocumentView,
                pIPSiteNew: ?*IOleInPlaceSite,
                ppViewNew: ?*?*IOleDocumentView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_SetInPlaceSite(self: *const T, pIPSite: ?*IOleInPlaceSite) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).SetInPlaceSite(@as(*const IOleDocumentView, @ptrCast(self)), pIPSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_GetInPlaceSite(self: *const T, ppIPSite: ?*?*IOleInPlaceSite) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).GetInPlaceSite(@as(*const IOleDocumentView, @ptrCast(self)), ppIPSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_GetDocument(self: *const T, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).GetDocument(@as(*const IOleDocumentView, @ptrCast(self)), ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_SetRect(self: *const T, prcView: ?*RECT) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).SetRect(@as(*const IOleDocumentView, @ptrCast(self)), prcView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_GetRect(self: *const T, prcView: ?*RECT) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).GetRect(@as(*const IOleDocumentView, @ptrCast(self)), prcView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_SetRectComplex(self: *const T, prcView: ?*RECT, prcHScroll: ?*RECT, prcVScroll: ?*RECT, prcSizeBox: ?*RECT) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).SetRectComplex(@as(*const IOleDocumentView, @ptrCast(self)), prcView, prcHScroll, prcVScroll, prcSizeBox);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_Show(self: *const T, fShow: BOOL) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).Show(@as(*const IOleDocumentView, @ptrCast(self)), fShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_UIActivate(self: *const T, fUIActivate: BOOL) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).UIActivate(@as(*const IOleDocumentView, @ptrCast(self)), fUIActivate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_Open(self: *const T) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).Open(@as(*const IOleDocumentView, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_CloseView(self: *const T, dwReserved: u32) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).CloseView(@as(*const IOleDocumentView, @ptrCast(self)), dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_SaveViewState(self: *const T, pstm: ?*IStream) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).SaveViewState(@as(*const IOleDocumentView, @ptrCast(self)), pstm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_ApplyViewState(self: *const T, pstm: ?*IStream) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).ApplyViewState(@as(*const IOleDocumentView, @ptrCast(self)), pstm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleDocumentView_Clone(self: *const T, pIPSiteNew: ?*IOleInPlaceSite, ppViewNew: ?*?*IOleDocumentView) HRESULT {
                return @as(*const IOleDocumentView.VTable, @ptrCast(self.vtable)).Clone(@as(*const IOleDocumentView, @ptrCast(self)), pIPSiteNew, ppViewNew);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumOleDocumentViews_Value = Guid.initString("b722bcc8-4e68-101b-a2bc-00aa00404770");
pub const IID_IEnumOleDocumentViews = &IID_IEnumOleDocumentViews_Value;
pub const IEnumOleDocumentViews = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOleDocumentViews,
                cViews: u32,
                rgpView: ?*?*IOleDocumentView,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOleDocumentViews,
                cViews: u32,
                rgpView: ?*?*IOleDocumentView,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOleDocumentViews,
                cViews: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOleDocumentViews,
                cViews: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOleDocumentViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOleDocumentViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumOleDocumentViews,
                ppEnum: ?*?*IEnumOleDocumentViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumOleDocumentViews,
                ppEnum: ?*?*IEnumOleDocumentViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOleDocumentViews_Next(self: *const T, cViews: u32, rgpView: ?*?*IOleDocumentView, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumOleDocumentViews.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumOleDocumentViews, @ptrCast(self)), cViews, rgpView, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOleDocumentViews_Skip(self: *const T, cViews: u32) HRESULT {
                return @as(*const IEnumOleDocumentViews.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumOleDocumentViews, @ptrCast(self)), cViews);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOleDocumentViews_Reset(self: *const T) HRESULT {
                return @as(*const IEnumOleDocumentViews.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumOleDocumentViews, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumOleDocumentViews_Clone(self: *const T, ppEnum: ?*?*IEnumOleDocumentViews) HRESULT {
                return @as(*const IEnumOleDocumentViews.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumOleDocumentViews, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IContinueCallback_Value = Guid.initString("b722bcca-4e68-101b-a2bc-00aa00404770");
pub const IID_IContinueCallback = &IID_IContinueCallback_Value;
pub const IContinueCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FContinue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContinueCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContinueCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FContinuePrinting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContinueCallback,
                nCntPrinted: i32,
                nCurPage: i32,
                pwszPrintStatus: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContinueCallback,
                nCntPrinted: i32,
                nCurPage: i32,
                pwszPrintStatus: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContinueCallback_FContinue(self: *const T) HRESULT {
                return @as(*const IContinueCallback.VTable, @ptrCast(self.vtable)).FContinue(@as(*const IContinueCallback, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContinueCallback_FContinuePrinting(self: *const T, nCntPrinted: i32, nCurPage: i32, pwszPrintStatus: ?PWSTR) HRESULT {
                return @as(*const IContinueCallback.VTable, @ptrCast(self.vtable)).FContinuePrinting(@as(*const IContinueCallback, @ptrCast(self)), nCntPrinted, nCurPage, pwszPrintStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PRINTFLAG = enum(u32) {
    MAYBOTHERUSER = 1,
    PROMPTUSER = 2,
    USERMAYCHANGEPRINTER = 4,
    RECOMPOSETODEVICE = 8,
    DONTACTUALLYPRINT = 16,
    FORCEPROPERTIES = 32,
    PRINTTOFILE = 64,
    _,
    pub fn initFlags(o: struct {
        MAYBOTHERUSER: u1 = 0,
        PROMPTUSER: u1 = 0,
        USERMAYCHANGEPRINTER: u1 = 0,
        RECOMPOSETODEVICE: u1 = 0,
        DONTACTUALLYPRINT: u1 = 0,
        FORCEPROPERTIES: u1 = 0,
        PRINTTOFILE: u1 = 0,
    }) PRINTFLAG {
        return @as(PRINTFLAG, @enumFromInt((if (o.MAYBOTHERUSER == 1) @intFromEnum(PRINTFLAG.MAYBOTHERUSER) else 0) | (if (o.PROMPTUSER == 1) @intFromEnum(PRINTFLAG.PROMPTUSER) else 0) | (if (o.USERMAYCHANGEPRINTER == 1) @intFromEnum(PRINTFLAG.USERMAYCHANGEPRINTER) else 0) | (if (o.RECOMPOSETODEVICE == 1) @intFromEnum(PRINTFLAG.RECOMPOSETODEVICE) else 0) | (if (o.DONTACTUALLYPRINT == 1) @intFromEnum(PRINTFLAG.DONTACTUALLYPRINT) else 0) | (if (o.FORCEPROPERTIES == 1) @intFromEnum(PRINTFLAG.FORCEPROPERTIES) else 0) | (if (o.PRINTTOFILE == 1) @intFromEnum(PRINTFLAG.PRINTTOFILE) else 0)));
    }
};
pub const PRINTFLAG_MAYBOTHERUSER = PRINTFLAG.MAYBOTHERUSER;
pub const PRINTFLAG_PROMPTUSER = PRINTFLAG.PROMPTUSER;
pub const PRINTFLAG_USERMAYCHANGEPRINTER = PRINTFLAG.USERMAYCHANGEPRINTER;
pub const PRINTFLAG_RECOMPOSETODEVICE = PRINTFLAG.RECOMPOSETODEVICE;
pub const PRINTFLAG_DONTACTUALLYPRINT = PRINTFLAG.DONTACTUALLYPRINT;
pub const PRINTFLAG_FORCEPROPERTIES = PRINTFLAG.FORCEPROPERTIES;
pub const PRINTFLAG_PRINTTOFILE = PRINTFLAG.PRINTTOFILE;

pub const PAGERANGE = extern struct {
    nFromPage: i32,
    nToPage: i32,
};

pub const PAGESET = extern struct {
    cbStruct: u32,
    fOddPages: BOOL,
    fEvenPages: BOOL,
    cPageRange: u32,
    rgPages: [1]PAGERANGE,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPrint_Value = Guid.initString("b722bcc9-4e68-101b-a2bc-00aa00404770");
pub const IID_IPrint = &IID_IPrint_Value;
pub const IPrint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetInitialPageNum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPrint,
                nFirstPage: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPrint,
                nFirstPage: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPrint,
                pnFirstPage: ?*i32,
                pcPages: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPrint,
                pnFirstPage: ?*i32,
                pcPages: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Print: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPrint,
                grfFlags: u32,
                pptd: ?*?*DVTARGETDEVICE,
                ppPageSet: ?*?*PAGESET,
                pstgmOptions: ?*STGMEDIUM,
                pcallback: ?*IContinueCallback,
                nFirstPage: i32,
                pcPagesPrinted: ?*i32,
                pnLastPage: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPrint,
                grfFlags: u32,
                pptd: ?*?*DVTARGETDEVICE,
                ppPageSet: ?*?*PAGESET,
                pstgmOptions: ?*STGMEDIUM,
                pcallback: ?*IContinueCallback,
                nFirstPage: i32,
                pcPagesPrinted: ?*i32,
                pnLastPage: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPrint_SetInitialPageNum(self: *const T, nFirstPage: i32) HRESULT {
                return @as(*const IPrint.VTable, @ptrCast(self.vtable)).SetInitialPageNum(@as(*const IPrint, @ptrCast(self)), nFirstPage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPrint_GetPageInfo(self: *const T, pnFirstPage: ?*i32, pcPages: ?*i32) HRESULT {
                return @as(*const IPrint.VTable, @ptrCast(self.vtable)).GetPageInfo(@as(*const IPrint, @ptrCast(self)), pnFirstPage, pcPages);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPrint_Print(self: *const T, grfFlags: u32, pptd: ?*?*DVTARGETDEVICE, ppPageSet: ?*?*PAGESET, pstgmOptions: ?*STGMEDIUM, pcallback: ?*IContinueCallback, nFirstPage: i32, pcPagesPrinted: ?*i32, pnLastPage: ?*i32) HRESULT {
                return @as(*const IPrint.VTable, @ptrCast(self.vtable)).Print(@as(*const IPrint, @ptrCast(self)), grfFlags, pptd, ppPageSet, pstgmOptions, pcallback, nFirstPage, pcPagesPrinted, pnLastPage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLECMDF = enum(i32) {
    SUPPORTED = 1,
    ENABLED = 2,
    LATCHED = 4,
    NINCHED = 8,
    INVISIBLE = 16,
    DEFHIDEONCTXTMENU = 32,
};
pub const OLECMDF_SUPPORTED = OLECMDF.SUPPORTED;
pub const OLECMDF_ENABLED = OLECMDF.ENABLED;
pub const OLECMDF_LATCHED = OLECMDF.LATCHED;
pub const OLECMDF_NINCHED = OLECMDF.NINCHED;
pub const OLECMDF_INVISIBLE = OLECMDF.INVISIBLE;
pub const OLECMDF_DEFHIDEONCTXTMENU = OLECMDF.DEFHIDEONCTXTMENU;

pub const OLECMD = extern struct {
    cmdID: u32,
    cmdf: u32,
};

pub const OLECMDTEXT = extern struct {
    cmdtextf: u32,
    cwActual: u32,
    cwBuf: u32,
    rgwz: [1]u16,
};

pub const OLECMDTEXTF = enum(i32) {
    NONE = 0,
    NAME = 1,
    STATUS = 2,
};
pub const OLECMDTEXTF_NONE = OLECMDTEXTF.NONE;
pub const OLECMDTEXTF_NAME = OLECMDTEXTF.NAME;
pub const OLECMDTEXTF_STATUS = OLECMDTEXTF.STATUS;

pub const OLECMDEXECOPT = enum(i32) {
    DODEFAULT = 0,
    PROMPTUSER = 1,
    DONTPROMPTUSER = 2,
    SHOWHELP = 3,
};
pub const OLECMDEXECOPT_DODEFAULT = OLECMDEXECOPT.DODEFAULT;
pub const OLECMDEXECOPT_PROMPTUSER = OLECMDEXECOPT.PROMPTUSER;
pub const OLECMDEXECOPT_DONTPROMPTUSER = OLECMDEXECOPT.DONTPROMPTUSER;
pub const OLECMDEXECOPT_SHOWHELP = OLECMDEXECOPT.SHOWHELP;

pub const OLECMDID = enum(i32) {
    OPEN = 1,
    NEW = 2,
    SAVE = 3,
    SAVEAS = 4,
    SAVECOPYAS = 5,
    PRINT = 6,
    PRINTPREVIEW = 7,
    PAGESETUP = 8,
    SPELL = 9,
    PROPERTIES = 10,
    CUT = 11,
    COPY = 12,
    PASTE = 13,
    PASTESPECIAL = 14,
    UNDO = 15,
    REDO = 16,
    SELECTALL = 17,
    CLEARSELECTION = 18,
    ZOOM = 19,
    GETZOOMRANGE = 20,
    UPDATECOMMANDS = 21,
    REFRESH = 22,
    STOP = 23,
    HIDETOOLBARS = 24,
    SETPROGRESSMAX = 25,
    SETPROGRESSPOS = 26,
    SETPROGRESSTEXT = 27,
    SETTITLE = 28,
    SETDOWNLOADSTATE = 29,
    STOPDOWNLOAD = 30,
    ONTOOLBARACTIVATED = 31,
    FIND = 32,
    DELETE = 33,
    HTTPEQUIV = 34,
    HTTPEQUIV_DONE = 35,
    ENABLE_INTERACTION = 36,
    ONUNLOAD = 37,
    PROPERTYBAG2 = 38,
    PREREFRESH = 39,
    SHOWSCRIPTERROR = 40,
    SHOWMESSAGE = 41,
    SHOWFIND = 42,
    SHOWPAGESETUP = 43,
    SHOWPRINT = 44,
    CLOSE = 45,
    ALLOWUILESSSAVEAS = 46,
    DONTDOWNLOADCSS = 47,
    UPDATEPAGESTATUS = 48,
    PRINT2 = 49,
    PRINTPREVIEW2 = 50,
    SETPRINTTEMPLATE = 51,
    GETPRINTTEMPLATE = 52,
    PAGEACTIONBLOCKED = 55,
    PAGEACTIONUIQUERY = 56,
    FOCUSVIEWCONTROLS = 57,
    FOCUSVIEWCONTROLSQUERY = 58,
    SHOWPAGEACTIONMENU = 59,
    ADDTRAVELENTRY = 60,
    UPDATETRAVELENTRY = 61,
    UPDATEBACKFORWARDSTATE = 62,
    OPTICAL_ZOOM = 63,
    OPTICAL_GETZOOMRANGE = 64,
    WINDOWSTATECHANGED = 65,
    ACTIVEXINSTALLSCOPE = 66,
    UPDATETRAVELENTRY_DATARECOVERY = 67,
    SHOWTASKDLG = 68,
    POPSTATEEVENT = 69,
    VIEWPORT_MODE = 70,
    LAYOUT_VIEWPORT_WIDTH = 71,
    VISUAL_VIEWPORT_EXCLUDE_BOTTOM = 72,
    USER_OPTICAL_ZOOM = 73,
    PAGEAVAILABLE = 74,
    GETUSERSCALABLE = 75,
    UPDATE_CARET = 76,
    ENABLE_VISIBILITY = 77,
    MEDIA_PLAYBACK = 78,
    SETFAVICON = 79,
    SET_HOST_FULLSCREENMODE = 80,
    EXITFULLSCREEN = 81,
    SCROLLCOMPLETE = 82,
    ONBEFOREUNLOAD = 83,
    SHOWMESSAGE_BLOCKABLE = 84,
    SHOWTASKDLG_BLOCKABLE = 85,
};
pub const OLECMDID_OPEN = OLECMDID.OPEN;
pub const OLECMDID_NEW = OLECMDID.NEW;
pub const OLECMDID_SAVE = OLECMDID.SAVE;
pub const OLECMDID_SAVEAS = OLECMDID.SAVEAS;
pub const OLECMDID_SAVECOPYAS = OLECMDID.SAVECOPYAS;
pub const OLECMDID_PRINT = OLECMDID.PRINT;
pub const OLECMDID_PRINTPREVIEW = OLECMDID.PRINTPREVIEW;
pub const OLECMDID_PAGESETUP = OLECMDID.PAGESETUP;
pub const OLECMDID_SPELL = OLECMDID.SPELL;
pub const OLECMDID_PROPERTIES = OLECMDID.PROPERTIES;
pub const OLECMDID_CUT = OLECMDID.CUT;
pub const OLECMDID_COPY = OLECMDID.COPY;
pub const OLECMDID_PASTE = OLECMDID.PASTE;
pub const OLECMDID_PASTESPECIAL = OLECMDID.PASTESPECIAL;
pub const OLECMDID_UNDO = OLECMDID.UNDO;
pub const OLECMDID_REDO = OLECMDID.REDO;
pub const OLECMDID_SELECTALL = OLECMDID.SELECTALL;
pub const OLECMDID_CLEARSELECTION = OLECMDID.CLEARSELECTION;
pub const OLECMDID_ZOOM = OLECMDID.ZOOM;
pub const OLECMDID_GETZOOMRANGE = OLECMDID.GETZOOMRANGE;
pub const OLECMDID_UPDATECOMMANDS = OLECMDID.UPDATECOMMANDS;
pub const OLECMDID_REFRESH = OLECMDID.REFRESH;
pub const OLECMDID_STOP = OLECMDID.STOP;
pub const OLECMDID_HIDETOOLBARS = OLECMDID.HIDETOOLBARS;
pub const OLECMDID_SETPROGRESSMAX = OLECMDID.SETPROGRESSMAX;
pub const OLECMDID_SETPROGRESSPOS = OLECMDID.SETPROGRESSPOS;
pub const OLECMDID_SETPROGRESSTEXT = OLECMDID.SETPROGRESSTEXT;
pub const OLECMDID_SETTITLE = OLECMDID.SETTITLE;
pub const OLECMDID_SETDOWNLOADSTATE = OLECMDID.SETDOWNLOADSTATE;
pub const OLECMDID_STOPDOWNLOAD = OLECMDID.STOPDOWNLOAD;
pub const OLECMDID_ONTOOLBARACTIVATED = OLECMDID.ONTOOLBARACTIVATED;
pub const OLECMDID_FIND = OLECMDID.FIND;
pub const OLECMDID_DELETE = OLECMDID.DELETE;
pub const OLECMDID_HTTPEQUIV = OLECMDID.HTTPEQUIV;
pub const OLECMDID_HTTPEQUIV_DONE = OLECMDID.HTTPEQUIV_DONE;
pub const OLECMDID_ENABLE_INTERACTION = OLECMDID.ENABLE_INTERACTION;
pub const OLECMDID_ONUNLOAD = OLECMDID.ONUNLOAD;
pub const OLECMDID_PROPERTYBAG2 = OLECMDID.PROPERTYBAG2;
pub const OLECMDID_PREREFRESH = OLECMDID.PREREFRESH;
pub const OLECMDID_SHOWSCRIPTERROR = OLECMDID.SHOWSCRIPTERROR;
pub const OLECMDID_SHOWMESSAGE = OLECMDID.SHOWMESSAGE;
pub const OLECMDID_SHOWFIND = OLECMDID.SHOWFIND;
pub const OLECMDID_SHOWPAGESETUP = OLECMDID.SHOWPAGESETUP;
pub const OLECMDID_SHOWPRINT = OLECMDID.SHOWPRINT;
pub const OLECMDID_CLOSE = OLECMDID.CLOSE;
pub const OLECMDID_ALLOWUILESSSAVEAS = OLECMDID.ALLOWUILESSSAVEAS;
pub const OLECMDID_DONTDOWNLOADCSS = OLECMDID.DONTDOWNLOADCSS;
pub const OLECMDID_UPDATEPAGESTATUS = OLECMDID.UPDATEPAGESTATUS;
pub const OLECMDID_PRINT2 = OLECMDID.PRINT2;
pub const OLECMDID_PRINTPREVIEW2 = OLECMDID.PRINTPREVIEW2;
pub const OLECMDID_SETPRINTTEMPLATE = OLECMDID.SETPRINTTEMPLATE;
pub const OLECMDID_GETPRINTTEMPLATE = OLECMDID.GETPRINTTEMPLATE;
pub const OLECMDID_PAGEACTIONBLOCKED = OLECMDID.PAGEACTIONBLOCKED;
pub const OLECMDID_PAGEACTIONUIQUERY = OLECMDID.PAGEACTIONUIQUERY;
pub const OLECMDID_FOCUSVIEWCONTROLS = OLECMDID.FOCUSVIEWCONTROLS;
pub const OLECMDID_FOCUSVIEWCONTROLSQUERY = OLECMDID.FOCUSVIEWCONTROLSQUERY;
pub const OLECMDID_SHOWPAGEACTIONMENU = OLECMDID.SHOWPAGEACTIONMENU;
pub const OLECMDID_ADDTRAVELENTRY = OLECMDID.ADDTRAVELENTRY;
pub const OLECMDID_UPDATETRAVELENTRY = OLECMDID.UPDATETRAVELENTRY;
pub const OLECMDID_UPDATEBACKFORWARDSTATE = OLECMDID.UPDATEBACKFORWARDSTATE;
pub const OLECMDID_OPTICAL_ZOOM = OLECMDID.OPTICAL_ZOOM;
pub const OLECMDID_OPTICAL_GETZOOMRANGE = OLECMDID.OPTICAL_GETZOOMRANGE;
pub const OLECMDID_WINDOWSTATECHANGED = OLECMDID.WINDOWSTATECHANGED;
pub const OLECMDID_ACTIVEXINSTALLSCOPE = OLECMDID.ACTIVEXINSTALLSCOPE;
pub const OLECMDID_UPDATETRAVELENTRY_DATARECOVERY = OLECMDID.UPDATETRAVELENTRY_DATARECOVERY;
pub const OLECMDID_SHOWTASKDLG = OLECMDID.SHOWTASKDLG;
pub const OLECMDID_POPSTATEEVENT = OLECMDID.POPSTATEEVENT;
pub const OLECMDID_VIEWPORT_MODE = OLECMDID.VIEWPORT_MODE;
pub const OLECMDID_LAYOUT_VIEWPORT_WIDTH = OLECMDID.LAYOUT_VIEWPORT_WIDTH;
pub const OLECMDID_VISUAL_VIEWPORT_EXCLUDE_BOTTOM = OLECMDID.VISUAL_VIEWPORT_EXCLUDE_BOTTOM;
pub const OLECMDID_USER_OPTICAL_ZOOM = OLECMDID.USER_OPTICAL_ZOOM;
pub const OLECMDID_PAGEAVAILABLE = OLECMDID.PAGEAVAILABLE;
pub const OLECMDID_GETUSERSCALABLE = OLECMDID.GETUSERSCALABLE;
pub const OLECMDID_UPDATE_CARET = OLECMDID.UPDATE_CARET;
pub const OLECMDID_ENABLE_VISIBILITY = OLECMDID.ENABLE_VISIBILITY;
pub const OLECMDID_MEDIA_PLAYBACK = OLECMDID.MEDIA_PLAYBACK;
pub const OLECMDID_SETFAVICON = OLECMDID.SETFAVICON;
pub const OLECMDID_SET_HOST_FULLSCREENMODE = OLECMDID.SET_HOST_FULLSCREENMODE;
pub const OLECMDID_EXITFULLSCREEN = OLECMDID.EXITFULLSCREEN;
pub const OLECMDID_SCROLLCOMPLETE = OLECMDID.SCROLLCOMPLETE;
pub const OLECMDID_ONBEFOREUNLOAD = OLECMDID.ONBEFOREUNLOAD;
pub const OLECMDID_SHOWMESSAGE_BLOCKABLE = OLECMDID.SHOWMESSAGE_BLOCKABLE;
pub const OLECMDID_SHOWTASKDLG_BLOCKABLE = OLECMDID.SHOWTASKDLG_BLOCKABLE;

pub const MEDIAPLAYBACK_STATE = enum(i32) {
    RESUME = 0,
    PAUSE = 1,
    PAUSE_AND_SUSPEND = 2,
    RESUME_FROM_SUSPEND = 3,
};
pub const MEDIAPLAYBACK_RESUME = MEDIAPLAYBACK_STATE.RESUME;
pub const MEDIAPLAYBACK_PAUSE = MEDIAPLAYBACK_STATE.PAUSE;
pub const MEDIAPLAYBACK_PAUSE_AND_SUSPEND = MEDIAPLAYBACK_STATE.PAUSE_AND_SUSPEND;
pub const MEDIAPLAYBACK_RESUME_FROM_SUSPEND = MEDIAPLAYBACK_STATE.RESUME_FROM_SUSPEND;

pub const IGNOREMIME = enum(i32) {
    PROMPT = 1,
    TEXT = 2,
};
pub const IGNOREMIME_PROMPT = IGNOREMIME.PROMPT;
pub const IGNOREMIME_TEXT = IGNOREMIME.TEXT;

pub const WPCSETTING = enum(i32) {
    LOGGING_ENABLED = 1,
    FILEDOWNLOAD_BLOCKED = 2,
};
pub const WPCSETTING_LOGGING_ENABLED = WPCSETTING.LOGGING_ENABLED;
pub const WPCSETTING_FILEDOWNLOAD_BLOCKED = WPCSETTING.FILEDOWNLOAD_BLOCKED;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleCommandTarget_Value = Guid.initString("b722bccb-4e68-101b-a2bc-00aa00404770");
pub const IID_IOleCommandTarget = &IID_IOleCommandTarget_Value;
pub const IOleCommandTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCommandTarget,
                pguidCmdGroup: ?*const Guid,
                cCmds: u32,
                prgCmds: ?*OLECMD,
                pCmdText: ?*OLECMDTEXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCommandTarget,
                pguidCmdGroup: ?*const Guid,
                cCmds: u32,
                prgCmds: ?*OLECMD,
                pCmdText: ?*OLECMDTEXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Exec: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleCommandTarget,
                pguidCmdGroup: ?*const Guid,
                nCmdID: u32,
                nCmdexecopt: u32,
                pvaIn: ?*VARIANT,
                pvaOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleCommandTarget,
                pguidCmdGroup: ?*const Guid,
                nCmdID: u32,
                nCmdexecopt: u32,
                pvaIn: ?*VARIANT,
                pvaOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCommandTarget_QueryStatus(self: *const T, pguidCmdGroup: ?*const Guid, cCmds: u32, prgCmds: ?*OLECMD, pCmdText: ?*OLECMDTEXT) HRESULT {
                return @as(*const IOleCommandTarget.VTable, @ptrCast(self.vtable)).QueryStatus(@as(*const IOleCommandTarget, @ptrCast(self)), pguidCmdGroup, cCmds, prgCmds, pCmdText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleCommandTarget_Exec(self: *const T, pguidCmdGroup: ?*const Guid, nCmdID: u32, nCmdexecopt: u32, pvaIn: ?*VARIANT, pvaOut: ?*VARIANT) HRESULT {
                return @as(*const IOleCommandTarget.VTable, @ptrCast(self.vtable)).Exec(@as(*const IOleCommandTarget, @ptrCast(self)), pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLECMDID_REFRESHFLAG = enum(i32) {
    NORMAL = 0,
    IFEXPIRED = 1,
    CONTINUE = 2,
    COMPLETELY = 3,
    NO_CACHE = 4,
    RELOAD = 5,
    LEVELMASK = 255,
    CLEARUSERINPUT = 4096,
    PROMPTIFOFFLINE = 8192,
    THROUGHSCRIPT = 16384,
    SKIPBEFOREUNLOADEVENT = 32768,
    PAGEACTION_ACTIVEXINSTALL = 65536,
    PAGEACTION_FILEDOWNLOAD = 131072,
    PAGEACTION_LOCALMACHINE = 262144,
    PAGEACTION_POPUPWINDOW = 524288,
    PAGEACTION_PROTLOCKDOWNLOCALMACHINE = 1048576,
    PAGEACTION_PROTLOCKDOWNTRUSTED = 2097152,
    PAGEACTION_PROTLOCKDOWNINTRANET = 4194304,
    PAGEACTION_PROTLOCKDOWNINTERNET = 8388608,
    PAGEACTION_PROTLOCKDOWNRESTRICTED = 16777216,
    PAGEACTION_MIXEDCONTENT = 33554432,
    PAGEACTION_INVALID_CERT = 67108864,
    PAGEACTION_ALLOW_VERSION = 134217728,
};
pub const OLECMDIDF_REFRESH_NORMAL = OLECMDID_REFRESHFLAG.NORMAL;
pub const OLECMDIDF_REFRESH_IFEXPIRED = OLECMDID_REFRESHFLAG.IFEXPIRED;
pub const OLECMDIDF_REFRESH_CONTINUE = OLECMDID_REFRESHFLAG.CONTINUE;
pub const OLECMDIDF_REFRESH_COMPLETELY = OLECMDID_REFRESHFLAG.COMPLETELY;
pub const OLECMDIDF_REFRESH_NO_CACHE = OLECMDID_REFRESHFLAG.NO_CACHE;
pub const OLECMDIDF_REFRESH_RELOAD = OLECMDID_REFRESHFLAG.RELOAD;
pub const OLECMDIDF_REFRESH_LEVELMASK = OLECMDID_REFRESHFLAG.LEVELMASK;
pub const OLECMDIDF_REFRESH_CLEARUSERINPUT = OLECMDID_REFRESHFLAG.CLEARUSERINPUT;
pub const OLECMDIDF_REFRESH_PROMPTIFOFFLINE = OLECMDID_REFRESHFLAG.PROMPTIFOFFLINE;
pub const OLECMDIDF_REFRESH_THROUGHSCRIPT = OLECMDID_REFRESHFLAG.THROUGHSCRIPT;
pub const OLECMDIDF_REFRESH_SKIPBEFOREUNLOADEVENT = OLECMDID_REFRESHFLAG.SKIPBEFOREUNLOADEVENT;
pub const OLECMDIDF_REFRESH_PAGEACTION_ACTIVEXINSTALL = OLECMDID_REFRESHFLAG.PAGEACTION_ACTIVEXINSTALL;
pub const OLECMDIDF_REFRESH_PAGEACTION_FILEDOWNLOAD = OLECMDID_REFRESHFLAG.PAGEACTION_FILEDOWNLOAD;
pub const OLECMDIDF_REFRESH_PAGEACTION_LOCALMACHINE = OLECMDID_REFRESHFLAG.PAGEACTION_LOCALMACHINE;
pub const OLECMDIDF_REFRESH_PAGEACTION_POPUPWINDOW = OLECMDID_REFRESHFLAG.PAGEACTION_POPUPWINDOW;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNLOCALMACHINE = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNLOCALMACHINE;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNTRUSTED = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNTRUSTED;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTRANET = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNINTRANET;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTERNET = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNINTERNET;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNRESTRICTED = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNRESTRICTED;
pub const OLECMDIDF_REFRESH_PAGEACTION_MIXEDCONTENT = OLECMDID_REFRESHFLAG.PAGEACTION_MIXEDCONTENT;
pub const OLECMDIDF_REFRESH_PAGEACTION_INVALID_CERT = OLECMDID_REFRESHFLAG.PAGEACTION_INVALID_CERT;
pub const OLECMDIDF_REFRESH_PAGEACTION_ALLOW_VERSION = OLECMDID_REFRESHFLAG.PAGEACTION_ALLOW_VERSION;

pub const OLECMDID_PAGEACTIONFLAG = enum(i32) {
    FILEDOWNLOAD = 1,
    ACTIVEXINSTALL = 2,
    ACTIVEXTRUSTFAIL = 4,
    ACTIVEXUSERDISABLE = 8,
    ACTIVEXDISALLOW = 16,
    ACTIVEXUNSAFE = 32,
    POPUPWINDOW = 64,
    LOCALMACHINE = 128,
    MIMETEXTPLAIN = 256,
    SCRIPTNAVIGATE = 512,
    // SCRIPTNAVIGATE_ACTIVEXINSTALL = 512, this enum value conflicts with SCRIPTNAVIGATE
    PROTLOCKDOWNLOCALMACHINE = 1024,
    PROTLOCKDOWNTRUSTED = 2048,
    PROTLOCKDOWNINTRANET = 4096,
    PROTLOCKDOWNINTERNET = 8192,
    PROTLOCKDOWNRESTRICTED = 16384,
    PROTLOCKDOWNDENY = 32768,
    POPUPALLOWED = 65536,
    SCRIPTPROMPT = 131072,
    ACTIVEXUSERAPPROVAL = 262144,
    MIXEDCONTENT = 524288,
    INVALID_CERT = 1048576,
    INTRANETZONEREQUEST = 2097152,
    XSSFILTERED = 4194304,
    SPOOFABLEIDNHOST = 8388608,
    ACTIVEX_EPM_INCOMPATIBLE = 16777216,
    SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL = 33554432,
    WPCBLOCKED = 67108864,
    WPCBLOCKED_ACTIVEX = 134217728,
    EXTENSION_COMPAT_BLOCKED = 268435456,
    NORESETACTIVEX = 536870912,
    GENERIC_STATE = 1073741824,
    RESET = -2147483648,
};
pub const OLECMDIDF_PAGEACTION_FILEDOWNLOAD = OLECMDID_PAGEACTIONFLAG.FILEDOWNLOAD;
pub const OLECMDIDF_PAGEACTION_ACTIVEXINSTALL = OLECMDID_PAGEACTIONFLAG.ACTIVEXINSTALL;
pub const OLECMDIDF_PAGEACTION_ACTIVEXTRUSTFAIL = OLECMDID_PAGEACTIONFLAG.ACTIVEXTRUSTFAIL;
pub const OLECMDIDF_PAGEACTION_ACTIVEXUSERDISABLE = OLECMDID_PAGEACTIONFLAG.ACTIVEXUSERDISABLE;
pub const OLECMDIDF_PAGEACTION_ACTIVEXDISALLOW = OLECMDID_PAGEACTIONFLAG.ACTIVEXDISALLOW;
pub const OLECMDIDF_PAGEACTION_ACTIVEXUNSAFE = OLECMDID_PAGEACTIONFLAG.ACTIVEXUNSAFE;
pub const OLECMDIDF_PAGEACTION_POPUPWINDOW = OLECMDID_PAGEACTIONFLAG.POPUPWINDOW;
pub const OLECMDIDF_PAGEACTION_LOCALMACHINE = OLECMDID_PAGEACTIONFLAG.LOCALMACHINE;
pub const OLECMDIDF_PAGEACTION_MIMETEXTPLAIN = OLECMDID_PAGEACTIONFLAG.MIMETEXTPLAIN;
pub const OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE = OLECMDID_PAGEACTIONFLAG.SCRIPTNAVIGATE;
pub const OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXINSTALL = OLECMDID_PAGEACTIONFLAG.SCRIPTNAVIGATE;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNLOCALMACHINE = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNLOCALMACHINE;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNTRUSTED = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNTRUSTED;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTRANET = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNINTRANET;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTERNET = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNINTERNET;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNRESTRICTED = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNRESTRICTED;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNDENY = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNDENY;
pub const OLECMDIDF_PAGEACTION_POPUPALLOWED = OLECMDID_PAGEACTIONFLAG.POPUPALLOWED;
pub const OLECMDIDF_PAGEACTION_SCRIPTPROMPT = OLECMDID_PAGEACTIONFLAG.SCRIPTPROMPT;
pub const OLECMDIDF_PAGEACTION_ACTIVEXUSERAPPROVAL = OLECMDID_PAGEACTIONFLAG.ACTIVEXUSERAPPROVAL;
pub const OLECMDIDF_PAGEACTION_MIXEDCONTENT = OLECMDID_PAGEACTIONFLAG.MIXEDCONTENT;
pub const OLECMDIDF_PAGEACTION_INVALID_CERT = OLECMDID_PAGEACTIONFLAG.INVALID_CERT;
pub const OLECMDIDF_PAGEACTION_INTRANETZONEREQUEST = OLECMDID_PAGEACTIONFLAG.INTRANETZONEREQUEST;
pub const OLECMDIDF_PAGEACTION_XSSFILTERED = OLECMDID_PAGEACTIONFLAG.XSSFILTERED;
pub const OLECMDIDF_PAGEACTION_SPOOFABLEIDNHOST = OLECMDID_PAGEACTIONFLAG.SPOOFABLEIDNHOST;
pub const OLECMDIDF_PAGEACTION_ACTIVEX_EPM_INCOMPATIBLE = OLECMDID_PAGEACTIONFLAG.ACTIVEX_EPM_INCOMPATIBLE;
pub const OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL = OLECMDID_PAGEACTIONFLAG.SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL;
pub const OLECMDIDF_PAGEACTION_WPCBLOCKED = OLECMDID_PAGEACTIONFLAG.WPCBLOCKED;
pub const OLECMDIDF_PAGEACTION_WPCBLOCKED_ACTIVEX = OLECMDID_PAGEACTIONFLAG.WPCBLOCKED_ACTIVEX;
pub const OLECMDIDF_PAGEACTION_EXTENSION_COMPAT_BLOCKED = OLECMDID_PAGEACTIONFLAG.EXTENSION_COMPAT_BLOCKED;
pub const OLECMDIDF_PAGEACTION_NORESETACTIVEX = OLECMDID_PAGEACTIONFLAG.NORESETACTIVEX;
pub const OLECMDIDF_PAGEACTION_GENERIC_STATE = OLECMDID_PAGEACTIONFLAG.GENERIC_STATE;
pub const OLECMDIDF_PAGEACTION_RESET = OLECMDID_PAGEACTIONFLAG.RESET;

pub const OLECMDID_BROWSERSTATEFLAG = enum(i32) {
    EXTENSIONSOFF = 1,
    IESECURITY = 2,
    PROTECTEDMODE_OFF = 4,
    RESET = 8,
    REQUIRESACTIVEX = 16,
    DESKTOPHTMLDIALOG = 32,
    BLOCKEDVERSION = 64,
};
pub const OLECMDIDF_BROWSERSTATE_EXTENSIONSOFF = OLECMDID_BROWSERSTATEFLAG.EXTENSIONSOFF;
pub const OLECMDIDF_BROWSERSTATE_IESECURITY = OLECMDID_BROWSERSTATEFLAG.IESECURITY;
pub const OLECMDIDF_BROWSERSTATE_PROTECTEDMODE_OFF = OLECMDID_BROWSERSTATEFLAG.PROTECTEDMODE_OFF;
pub const OLECMDIDF_BROWSERSTATE_RESET = OLECMDID_BROWSERSTATEFLAG.RESET;
pub const OLECMDIDF_BROWSERSTATE_REQUIRESACTIVEX = OLECMDID_BROWSERSTATEFLAG.REQUIRESACTIVEX;
pub const OLECMDIDF_BROWSERSTATE_DESKTOPHTMLDIALOG = OLECMDID_BROWSERSTATEFLAG.DESKTOPHTMLDIALOG;
pub const OLECMDIDF_BROWSERSTATE_BLOCKEDVERSION = OLECMDID_BROWSERSTATEFLAG.BLOCKEDVERSION;

pub const OLECMDID_OPTICAL_ZOOMFLAG = enum(i32) {
    NOPERSIST = 1,
    NOLAYOUT = 16,
    NOTRANSIENT = 32,
    RELOADFORNEWTAB = 64,
};
pub const OLECMDIDF_OPTICAL_ZOOM_NOPERSIST = OLECMDID_OPTICAL_ZOOMFLAG.NOPERSIST;
pub const OLECMDIDF_OPTICAL_ZOOM_NOLAYOUT = OLECMDID_OPTICAL_ZOOMFLAG.NOLAYOUT;
pub const OLECMDIDF_OPTICAL_ZOOM_NOTRANSIENT = OLECMDID_OPTICAL_ZOOMFLAG.NOTRANSIENT;
pub const OLECMDIDF_OPTICAL_ZOOM_RELOADFORNEWTAB = OLECMDID_OPTICAL_ZOOMFLAG.RELOADFORNEWTAB;

pub const PAGEACTION_UI = enum(i32) {
    DEFAULT = 0,
    MODAL = 1,
    MODELESS = 2,
    SILENT = 3,
};
pub const PAGEACTION_UI_DEFAULT = PAGEACTION_UI.DEFAULT;
pub const PAGEACTION_UI_MODAL = PAGEACTION_UI.MODAL;
pub const PAGEACTION_UI_MODELESS = PAGEACTION_UI.MODELESS;
pub const PAGEACTION_UI_SILENT = PAGEACTION_UI.SILENT;

pub const OLECMDID_WINDOWSTATE_FLAG = enum(i32) {
    USERVISIBLE = 1,
    ENABLED = 2,
    USERVISIBLE_VALID = 65536,
    ENABLED_VALID = 131072,
};
pub const OLECMDIDF_WINDOWSTATE_USERVISIBLE = OLECMDID_WINDOWSTATE_FLAG.USERVISIBLE;
pub const OLECMDIDF_WINDOWSTATE_ENABLED = OLECMDID_WINDOWSTATE_FLAG.ENABLED;
pub const OLECMDIDF_WINDOWSTATE_USERVISIBLE_VALID = OLECMDID_WINDOWSTATE_FLAG.USERVISIBLE_VALID;
pub const OLECMDIDF_WINDOWSTATE_ENABLED_VALID = OLECMDID_WINDOWSTATE_FLAG.ENABLED_VALID;

pub const OLECMDID_VIEWPORT_MODE_FLAG = enum(i32) {
    FIXED_LAYOUT_WIDTH = 1,
    EXCLUDE_VISUAL_BOTTOM = 2,
    FIXED_LAYOUT_WIDTH_VALID = 65536,
    EXCLUDE_VISUAL_BOTTOM_VALID = 131072,
};
pub const OLECMDIDF_VIEWPORTMODE_FIXED_LAYOUT_WIDTH = OLECMDID_VIEWPORT_MODE_FLAG.FIXED_LAYOUT_WIDTH;
pub const OLECMDIDF_VIEWPORTMODE_EXCLUDE_VISUAL_BOTTOM = OLECMDID_VIEWPORT_MODE_FLAG.EXCLUDE_VISUAL_BOTTOM;
pub const OLECMDIDF_VIEWPORTMODE_FIXED_LAYOUT_WIDTH_VALID = OLECMDID_VIEWPORT_MODE_FLAG.FIXED_LAYOUT_WIDTH_VALID;
pub const OLECMDIDF_VIEWPORTMODE_EXCLUDE_VISUAL_BOTTOM_VALID = OLECMDID_VIEWPORT_MODE_FLAG.EXCLUDE_VISUAL_BOTTOM_VALID;

const IID_IZoomEvents_Value = Guid.initString("41b68150-904c-4e17-a0ba-a438182e359d");
pub const IID_IZoomEvents = &IID_IZoomEvents_Value;
pub const IZoomEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnZoomPercentChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IZoomEvents,
                ulZoomPercent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IZoomEvents,
                ulZoomPercent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IZoomEvents_OnZoomPercentChanged(self: *const T, ulZoomPercent: u32) HRESULT {
                return @as(*const IZoomEvents.VTable, @ptrCast(self.vtable)).OnZoomPercentChanged(@as(*const IZoomEvents, @ptrCast(self)), ulZoomPercent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IProtectFocus_Value = Guid.initString("d81f90a3-8156-44f7-ad28-5abb87003274");
pub const IID_IProtectFocus = &IID_IProtectFocus_Value;
pub const IProtectFocus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllowFocusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProtectFocus,
                pfAllow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProtectFocus,
                pfAllow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProtectFocus_AllowFocusChange(self: *const T, pfAllow: ?*BOOL) HRESULT {
                return @as(*const IProtectFocus.VTable, @ptrCast(self.vtable)).AllowFocusChange(@as(*const IProtectFocus, @ptrCast(self)), pfAllow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IProtectedModeMenuServices_Value = Guid.initString("73c105ee-9dff-4a07-b83c-7eff290c266e");
pub const IID_IProtectedModeMenuServices = &IID_IProtectedModeMenuServices_Value;
pub const IProtectedModeMenuServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProtectedModeMenuServices,
                phMenu: ?*?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProtectedModeMenuServices,
                phMenu: ?*?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProtectedModeMenuServices,
                pszModuleName: ?[*:0]const u16,
                pszMenuName: ?[*:0]const u16,
                phMenu: ?*?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProtectedModeMenuServices,
                pszModuleName: ?[*:0]const u16,
                pszMenuName: ?[*:0]const u16,
                phMenu: ?*?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadMenuID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProtectedModeMenuServices,
                pszModuleName: ?[*:0]const u16,
                wResourceID: u16,
                phMenu: ?*?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProtectedModeMenuServices,
                pszModuleName: ?[*:0]const u16,
                wResourceID: u16,
                phMenu: ?*?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProtectedModeMenuServices_CreateMenu(self: *const T, phMenu: ?*?HMENU) HRESULT {
                return @as(*const IProtectedModeMenuServices.VTable, @ptrCast(self.vtable)).CreateMenu(@as(*const IProtectedModeMenuServices, @ptrCast(self)), phMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProtectedModeMenuServices_LoadMenu(self: *const T, pszModuleName: ?[*:0]const u16, pszMenuName: ?[*:0]const u16, phMenu: ?*?HMENU) HRESULT {
                return @as(*const IProtectedModeMenuServices.VTable, @ptrCast(self.vtable)).LoadMenu(@as(*const IProtectedModeMenuServices, @ptrCast(self)), pszModuleName, pszMenuName, phMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProtectedModeMenuServices_LoadMenuID(self: *const T, pszModuleName: ?[*:0]const u16, wResourceID: u16, phMenu: ?*?HMENU) HRESULT {
                return @as(*const IProtectedModeMenuServices.VTable, @ptrCast(self.vtable)).LoadMenuID(@as(*const IProtectedModeMenuServices, @ptrCast(self)), pszModuleName, wResourceID, phMenu);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LPFNOLEUIHOOK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?HWND,
        param1: u32,
        param2: WPARAM,
        param3: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        param0: ?HWND,
        param1: u32,
        param2: WPARAM,
        param3: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const OLEUIINSERTOBJECTW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    clsid: Guid,
    lpszFile: ?PWSTR,
    cchFile: u32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    iid: Guid,
    oleRender: u32,
    lpFormatEtc: ?*FORMATETC,
    lpIOleClientSite: ?*IOleClientSite,
    lpIStorage: ?*IStorage,
    ppvObj: ?*?*anyopaque,
    sc: i32,
    hMetaPict: isize,
};

pub const OLEUIINSERTOBJECTA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    clsid: Guid,
    lpszFile: ?PSTR,
    cchFile: u32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    iid: Guid,
    oleRender: u32,
    lpFormatEtc: ?*FORMATETC,
    lpIOleClientSite: ?*IOleClientSite,
    lpIStorage: ?*IStorage,
    ppvObj: ?*?*anyopaque,
    sc: i32,
    hMetaPict: isize,
};

pub const OLEUIPASTEFLAG = enum(i32) {
    ENABLEICON = 2048,
    PASTEONLY = 0,
    PASTE = 512,
    LINKANYTYPE = 1024,
    LINKTYPE1 = 1,
    LINKTYPE2 = 2,
    LINKTYPE3 = 4,
    LINKTYPE4 = 8,
    LINKTYPE5 = 16,
    LINKTYPE6 = 32,
    LINKTYPE7 = 64,
    LINKTYPE8 = 128,
};
pub const OLEUIPASTE_ENABLEICON = OLEUIPASTEFLAG.ENABLEICON;
pub const OLEUIPASTE_PASTEONLY = OLEUIPASTEFLAG.PASTEONLY;
pub const OLEUIPASTE_PASTE = OLEUIPASTEFLAG.PASTE;
pub const OLEUIPASTE_LINKANYTYPE = OLEUIPASTEFLAG.LINKANYTYPE;
pub const OLEUIPASTE_LINKTYPE1 = OLEUIPASTEFLAG.LINKTYPE1;
pub const OLEUIPASTE_LINKTYPE2 = OLEUIPASTEFLAG.LINKTYPE2;
pub const OLEUIPASTE_LINKTYPE3 = OLEUIPASTEFLAG.LINKTYPE3;
pub const OLEUIPASTE_LINKTYPE4 = OLEUIPASTEFLAG.LINKTYPE4;
pub const OLEUIPASTE_LINKTYPE5 = OLEUIPASTEFLAG.LINKTYPE5;
pub const OLEUIPASTE_LINKTYPE6 = OLEUIPASTEFLAG.LINKTYPE6;
pub const OLEUIPASTE_LINKTYPE7 = OLEUIPASTEFLAG.LINKTYPE7;
pub const OLEUIPASTE_LINKTYPE8 = OLEUIPASTEFLAG.LINKTYPE8;

pub const OLEUIPASTEENTRYW = extern struct {
    fmtetc: FORMATETC,
    lpstrFormatName: ?[*:0]const u16,
    lpstrResultText: ?[*:0]const u16,
    dwFlags: u32,
    dwScratchSpace: u32,
};

pub const OLEUIPASTEENTRYA = extern struct {
    fmtetc: FORMATETC,
    lpstrFormatName: ?[*:0]const u8,
    lpstrResultText: ?[*:0]const u8,
    dwFlags: u32,
    dwScratchSpace: u32,
};

pub const OLEUIPASTESPECIALW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    lpSrcDataObj: ?*IDataObject,
    arrPasteEntries: ?*OLEUIPASTEENTRYW,
    cPasteEntries: i32,
    arrLinkTypes: ?*u32,
    cLinkTypes: i32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    nSelectedIndex: i32,
    fLink: BOOL,
    hMetaPict: isize,
    sizel: SIZE,
};

pub const OLEUIPASTESPECIALA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    lpSrcDataObj: ?*IDataObject,
    arrPasteEntries: ?*OLEUIPASTEENTRYA,
    cPasteEntries: i32,
    arrLinkTypes: ?*u32,
    cLinkTypes: i32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    nSelectedIndex: i32,
    fLink: BOOL,
    hMetaPict: isize,
    sizel: SIZE,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUILinkContainerW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        SetLinkUpdateOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                dwUpdateOpt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                dwUpdateOpt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLinkUpdateOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                lpdwUpdateOpt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                lpdwUpdateOpt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLinkSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                lpszDisplayName: ?PWSTR,
                lenFileName: u32,
                pchEaten: ?*u32,
                fValidateSource: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                lpszDisplayName: ?PWSTR,
                lenFileName: u32,
                pchEaten: ?*u32,
                fValidateSource: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLinkSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                lplpszDisplayName: ?*?PWSTR,
                lplenFileName: ?*u32,
                lplpszFullLinkType: ?*?PWSTR,
                lplpszShortLinkType: ?*?PWSTR,
                lpfSourceAvailable: ?*BOOL,
                lpfIsSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                lplpszDisplayName: ?*?PWSTR,
                lplenFileName: ?*u32,
                lplpszFullLinkType: ?*?PWSTR,
                lplpszShortLinkType: ?*?PWSTR,
                lpfSourceAvailable: ?*BOOL,
                lpfIsSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLinkSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                fErrorMessage: BOOL,
                fReserved: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
                fErrorMessage: BOOL,
                fReserved: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerW,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerW_GetNextLink(self: *const T, dwLink: u32) u32 {
                return @as(*const IOleUILinkContainerW.VTable, @ptrCast(self.vtable)).GetNextLink(@as(*const IOleUILinkContainerW, @ptrCast(self)), dwLink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerW_SetLinkUpdateOptions(self: *const T, dwLink: u32, dwUpdateOpt: u32) HRESULT {
                return @as(*const IOleUILinkContainerW.VTable, @ptrCast(self.vtable)).SetLinkUpdateOptions(@as(*const IOleUILinkContainerW, @ptrCast(self)), dwLink, dwUpdateOpt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerW_GetLinkUpdateOptions(self: *const T, dwLink: u32, lpdwUpdateOpt: ?*u32) HRESULT {
                return @as(*const IOleUILinkContainerW.VTable, @ptrCast(self.vtable)).GetLinkUpdateOptions(@as(*const IOleUILinkContainerW, @ptrCast(self)), dwLink, lpdwUpdateOpt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerW_SetLinkSource(self: *const T, dwLink: u32, lpszDisplayName: ?PWSTR, lenFileName: u32, pchEaten: ?*u32, fValidateSource: BOOL) HRESULT {
                return @as(*const IOleUILinkContainerW.VTable, @ptrCast(self.vtable)).SetLinkSource(@as(*const IOleUILinkContainerW, @ptrCast(self)), dwLink, lpszDisplayName, lenFileName, pchEaten, fValidateSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerW_GetLinkSource(self: *const T, dwLink: u32, lplpszDisplayName: ?*?PWSTR, lplenFileName: ?*u32, lplpszFullLinkType: ?*?PWSTR, lplpszShortLinkType: ?*?PWSTR, lpfSourceAvailable: ?*BOOL, lpfIsSelected: ?*BOOL) HRESULT {
                return @as(*const IOleUILinkContainerW.VTable, @ptrCast(self.vtable)).GetLinkSource(@as(*const IOleUILinkContainerW, @ptrCast(self)), dwLink, lplpszDisplayName, lplenFileName, lplpszFullLinkType, lplpszShortLinkType, lpfSourceAvailable, lpfIsSelected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerW_OpenLinkSource(self: *const T, dwLink: u32) HRESULT {
                return @as(*const IOleUILinkContainerW.VTable, @ptrCast(self.vtable)).OpenLinkSource(@as(*const IOleUILinkContainerW, @ptrCast(self)), dwLink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerW_UpdateLink(self: *const T, dwLink: u32, fErrorMessage: BOOL, fReserved: BOOL) HRESULT {
                return @as(*const IOleUILinkContainerW.VTable, @ptrCast(self.vtable)).UpdateLink(@as(*const IOleUILinkContainerW, @ptrCast(self)), dwLink, fErrorMessage, fReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerW_CancelLink(self: *const T, dwLink: u32) HRESULT {
                return @as(*const IOleUILinkContainerW.VTable, @ptrCast(self.vtable)).CancelLink(@as(*const IOleUILinkContainerW, @ptrCast(self)), dwLink);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUILinkContainerA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        SetLinkUpdateOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                dwUpdateOpt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                dwUpdateOpt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLinkUpdateOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                lpdwUpdateOpt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                lpdwUpdateOpt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLinkSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                lpszDisplayName: ?PSTR,
                lenFileName: u32,
                pchEaten: ?*u32,
                fValidateSource: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                lpszDisplayName: ?PSTR,
                lenFileName: u32,
                pchEaten: ?*u32,
                fValidateSource: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLinkSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                lplpszDisplayName: ?*?PSTR,
                lplenFileName: ?*u32,
                lplpszFullLinkType: ?*?PSTR,
                lplpszShortLinkType: ?*?PSTR,
                lpfSourceAvailable: ?*BOOL,
                lpfIsSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                lplpszDisplayName: ?*?PSTR,
                lplenFileName: ?*u32,
                lplpszFullLinkType: ?*?PSTR,
                lplpszShortLinkType: ?*?PSTR,
                lpfSourceAvailable: ?*BOOL,
                lpfIsSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLinkSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                fErrorMessage: BOOL,
                fReserved: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
                fErrorMessage: BOOL,
                fReserved: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkContainerA,
                dwLink: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerA_GetNextLink(self: *const T, dwLink: u32) u32 {
                return @as(*const IOleUILinkContainerA.VTable, @ptrCast(self.vtable)).GetNextLink(@as(*const IOleUILinkContainerA, @ptrCast(self)), dwLink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerA_SetLinkUpdateOptions(self: *const T, dwLink: u32, dwUpdateOpt: u32) HRESULT {
                return @as(*const IOleUILinkContainerA.VTable, @ptrCast(self.vtable)).SetLinkUpdateOptions(@as(*const IOleUILinkContainerA, @ptrCast(self)), dwLink, dwUpdateOpt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerA_GetLinkUpdateOptions(self: *const T, dwLink: u32, lpdwUpdateOpt: ?*u32) HRESULT {
                return @as(*const IOleUILinkContainerA.VTable, @ptrCast(self.vtable)).GetLinkUpdateOptions(@as(*const IOleUILinkContainerA, @ptrCast(self)), dwLink, lpdwUpdateOpt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerA_SetLinkSource(self: *const T, dwLink: u32, lpszDisplayName: ?PSTR, lenFileName: u32, pchEaten: ?*u32, fValidateSource: BOOL) HRESULT {
                return @as(*const IOleUILinkContainerA.VTable, @ptrCast(self.vtable)).SetLinkSource(@as(*const IOleUILinkContainerA, @ptrCast(self)), dwLink, lpszDisplayName, lenFileName, pchEaten, fValidateSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerA_GetLinkSource(self: *const T, dwLink: u32, lplpszDisplayName: ?*?PSTR, lplenFileName: ?*u32, lplpszFullLinkType: ?*?PSTR, lplpszShortLinkType: ?*?PSTR, lpfSourceAvailable: ?*BOOL, lpfIsSelected: ?*BOOL) HRESULT {
                return @as(*const IOleUILinkContainerA.VTable, @ptrCast(self.vtable)).GetLinkSource(@as(*const IOleUILinkContainerA, @ptrCast(self)), dwLink, lplpszDisplayName, lplenFileName, lplpszFullLinkType, lplpszShortLinkType, lpfSourceAvailable, lpfIsSelected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerA_OpenLinkSource(self: *const T, dwLink: u32) HRESULT {
                return @as(*const IOleUILinkContainerA.VTable, @ptrCast(self.vtable)).OpenLinkSource(@as(*const IOleUILinkContainerA, @ptrCast(self)), dwLink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerA_UpdateLink(self: *const T, dwLink: u32, fErrorMessage: BOOL, fReserved: BOOL) HRESULT {
                return @as(*const IOleUILinkContainerA.VTable, @ptrCast(self.vtable)).UpdateLink(@as(*const IOleUILinkContainerA, @ptrCast(self)), dwLink, fErrorMessage, fReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkContainerA_CancelLink(self: *const T, dwLink: u32) HRESULT {
                return @as(*const IOleUILinkContainerA.VTable, @ptrCast(self.vtable)).CancelLink(@as(*const IOleUILinkContainerA, @ptrCast(self)), dwLink);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLEUIEDITLINKSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    lpOleUILinkContainer: ?*IOleUILinkContainerW,
};

pub const OLEUIEDITLINKSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    lpOleUILinkContainer: ?*IOleUILinkContainerA,
};

pub const OLEUICHANGEICONW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    hMetaPict: isize,
    clsid: Guid,
    szIconExe: [260]u16,
    cchIconExe: i32,
};

pub const OLEUICHANGEICONA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    hMetaPict: isize,
    clsid: Guid,
    szIconExe: [260]CHAR,
    cchIconExe: i32,
};

pub const OLEUICONVERTW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    clsid: Guid,
    clsidConvertDefault: Guid,
    clsidActivateDefault: Guid,
    clsidNew: Guid,
    dvAspect: u32,
    wFormat: u16,
    fIsLinkedObject: BOOL,
    hMetaPict: isize,
    lpszUserType: ?PWSTR,
    fObjectsIconChanged: BOOL,
    lpszDefLabel: ?PWSTR,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
};

pub const OLEUICONVERTA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    clsid: Guid,
    clsidConvertDefault: Guid,
    clsidActivateDefault: Guid,
    clsidNew: Guid,
    dvAspect: u32,
    wFormat: u16,
    fIsLinkedObject: BOOL,
    hMetaPict: isize,
    lpszUserType: ?PSTR,
    fObjectsIconChanged: BOOL,
    lpszDefLabel: ?PSTR,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
};

pub const OLEUIBUSYW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    hTask: ?HTASK,
    lphWndDialog: ?*?HWND,
};

pub const OLEUIBUSYA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    hTask: ?HTASK,
    lphWndDialog: ?*?HWND,
};

pub const OLEUICHANGESOURCEW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    lpOFN: ?*OPENFILENAMEW,
    dwReserved1: [4]u32,
    lpOleUILinkContainer: ?*IOleUILinkContainerW,
    dwLink: u32,
    lpszDisplayName: ?PWSTR,
    nFileLength: u32,
    lpszFrom: ?PWSTR,
    lpszTo: ?PWSTR,
};

pub const OLEUICHANGESOURCEA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    lpOFN: ?*OPENFILENAMEA,
    dwReserved1: [4]u32,
    lpOleUILinkContainer: ?*IOleUILinkContainerA,
    dwLink: u32,
    lpszDisplayName: ?PSTR,
    nFileLength: u32,
    lpszFrom: ?PSTR,
    lpszTo: ?PSTR,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUIObjInfoW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                lpdwObjSize: ?*u32,
                lplpszLabel: ?*?PWSTR,
                lplpszType: ?*?PWSTR,
                lplpszShortType: ?*?PWSTR,
                lplpszLocation: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                lpdwObjSize: ?*u32,
                lplpszLabel: ?*?PWSTR,
                lplpszType: ?*?PWSTR,
                lplpszShortType: ?*?PWSTR,
                lplpszLocation: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConvertInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                lpClassID: ?*Guid,
                lpwFormat: ?*u16,
                lpConvertDefaultClassID: ?*Guid,
                lplpClsidExclude: ?*?*Guid,
                lpcClsidExclude: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                lpClassID: ?*Guid,
                lpwFormat: ?*u16,
                lpConvertDefaultClassID: ?*Guid,
                lplpClsidExclude: ?*?*Guid,
                lpcClsidExclude: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                clsidNew: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                clsidNew: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                phMetaPict: ?*isize,
                pdvAspect: ?*u32,
                pnCurrentScale: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                phMetaPict: ?*isize,
                pdvAspect: ?*u32,
                pnCurrentScale: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetViewInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                hMetaPict: isize,
                dvAspect: u32,
                nCurrentScale: i32,
                bRelativeToOrig: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoW,
                dwObject: u32,
                hMetaPict: isize,
                dvAspect: u32,
                nCurrentScale: i32,
                bRelativeToOrig: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoW_GetObjectInfo(self: *const T, dwObject: u32, lpdwObjSize: ?*u32, lplpszLabel: ?*?PWSTR, lplpszType: ?*?PWSTR, lplpszShortType: ?*?PWSTR, lplpszLocation: ?*?PWSTR) HRESULT {
                return @as(*const IOleUIObjInfoW.VTable, @ptrCast(self.vtable)).GetObjectInfo(@as(*const IOleUIObjInfoW, @ptrCast(self)), dwObject, lpdwObjSize, lplpszLabel, lplpszType, lplpszShortType, lplpszLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoW_GetConvertInfo(self: *const T, dwObject: u32, lpClassID: ?*Guid, lpwFormat: ?*u16, lpConvertDefaultClassID: ?*Guid, lplpClsidExclude: ?*?*Guid, lpcClsidExclude: ?*u32) HRESULT {
                return @as(*const IOleUIObjInfoW.VTable, @ptrCast(self.vtable)).GetConvertInfo(@as(*const IOleUIObjInfoW, @ptrCast(self)), dwObject, lpClassID, lpwFormat, lpConvertDefaultClassID, lplpClsidExclude, lpcClsidExclude);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoW_ConvertObject(self: *const T, dwObject: u32, clsidNew: ?*const Guid) HRESULT {
                return @as(*const IOleUIObjInfoW.VTable, @ptrCast(self.vtable)).ConvertObject(@as(*const IOleUIObjInfoW, @ptrCast(self)), dwObject, clsidNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoW_GetViewInfo(self: *const T, dwObject: u32, phMetaPict: ?*isize, pdvAspect: ?*u32, pnCurrentScale: ?*i32) HRESULT {
                return @as(*const IOleUIObjInfoW.VTable, @ptrCast(self.vtable)).GetViewInfo(@as(*const IOleUIObjInfoW, @ptrCast(self)), dwObject, phMetaPict, pdvAspect, pnCurrentScale);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoW_SetViewInfo(self: *const T, dwObject: u32, hMetaPict: isize, dvAspect: u32, nCurrentScale: i32, bRelativeToOrig: BOOL) HRESULT {
                return @as(*const IOleUIObjInfoW.VTable, @ptrCast(self.vtable)).SetViewInfo(@as(*const IOleUIObjInfoW, @ptrCast(self)), dwObject, hMetaPict, dvAspect, nCurrentScale, bRelativeToOrig);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUIObjInfoA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                lpdwObjSize: ?*u32,
                lplpszLabel: ?*?PSTR,
                lplpszType: ?*?PSTR,
                lplpszShortType: ?*?PSTR,
                lplpszLocation: ?*?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                lpdwObjSize: ?*u32,
                lplpszLabel: ?*?PSTR,
                lplpszType: ?*?PSTR,
                lplpszShortType: ?*?PSTR,
                lplpszLocation: ?*?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConvertInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                lpClassID: ?*Guid,
                lpwFormat: ?*u16,
                lpConvertDefaultClassID: ?*Guid,
                lplpClsidExclude: ?*?*Guid,
                lpcClsidExclude: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                lpClassID: ?*Guid,
                lpwFormat: ?*u16,
                lpConvertDefaultClassID: ?*Guid,
                lplpClsidExclude: ?*?*Guid,
                lpcClsidExclude: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                clsidNew: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                clsidNew: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                phMetaPict: ?*isize,
                pdvAspect: ?*u32,
                pnCurrentScale: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                phMetaPict: ?*isize,
                pdvAspect: ?*u32,
                pnCurrentScale: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetViewInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                hMetaPict: isize,
                dvAspect: u32,
                nCurrentScale: i32,
                bRelativeToOrig: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUIObjInfoA,
                dwObject: u32,
                hMetaPict: isize,
                dvAspect: u32,
                nCurrentScale: i32,
                bRelativeToOrig: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoA_GetObjectInfo(self: *const T, dwObject: u32, lpdwObjSize: ?*u32, lplpszLabel: ?*?PSTR, lplpszType: ?*?PSTR, lplpszShortType: ?*?PSTR, lplpszLocation: ?*?PSTR) HRESULT {
                return @as(*const IOleUIObjInfoA.VTable, @ptrCast(self.vtable)).GetObjectInfo(@as(*const IOleUIObjInfoA, @ptrCast(self)), dwObject, lpdwObjSize, lplpszLabel, lplpszType, lplpszShortType, lplpszLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoA_GetConvertInfo(self: *const T, dwObject: u32, lpClassID: ?*Guid, lpwFormat: ?*u16, lpConvertDefaultClassID: ?*Guid, lplpClsidExclude: ?*?*Guid, lpcClsidExclude: ?*u32) HRESULT {
                return @as(*const IOleUIObjInfoA.VTable, @ptrCast(self.vtable)).GetConvertInfo(@as(*const IOleUIObjInfoA, @ptrCast(self)), dwObject, lpClassID, lpwFormat, lpConvertDefaultClassID, lplpClsidExclude, lpcClsidExclude);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoA_ConvertObject(self: *const T, dwObject: u32, clsidNew: ?*const Guid) HRESULT {
                return @as(*const IOleUIObjInfoA.VTable, @ptrCast(self.vtable)).ConvertObject(@as(*const IOleUIObjInfoA, @ptrCast(self)), dwObject, clsidNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoA_GetViewInfo(self: *const T, dwObject: u32, phMetaPict: ?*isize, pdvAspect: ?*u32, pnCurrentScale: ?*i32) HRESULT {
                return @as(*const IOleUIObjInfoA.VTable, @ptrCast(self.vtable)).GetViewInfo(@as(*const IOleUIObjInfoA, @ptrCast(self)), dwObject, phMetaPict, pdvAspect, pnCurrentScale);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUIObjInfoA_SetViewInfo(self: *const T, dwObject: u32, hMetaPict: isize, dvAspect: u32, nCurrentScale: i32, bRelativeToOrig: BOOL) HRESULT {
                return @as(*const IOleUIObjInfoA.VTable, @ptrCast(self.vtable)).SetViewInfo(@as(*const IOleUIObjInfoA, @ptrCast(self)), dwObject, hMetaPict, dvAspect, nCurrentScale, bRelativeToOrig);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUILinkInfoW = extern struct {
    pub const VTable = extern struct {
        base: IOleUILinkContainerW.VTable,
        GetLastUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkInfoW,
                dwLink: u32,
                lpLastUpdate: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkInfoW,
                dwLink: u32,
                lpLastUpdate: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleUILinkContainerW.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkInfoW_GetLastUpdate(self: *const T, dwLink: u32, lpLastUpdate: ?*FILETIME) HRESULT {
                return @as(*const IOleUILinkInfoW.VTable, @ptrCast(self.vtable)).GetLastUpdate(@as(*const IOleUILinkInfoW, @ptrCast(self)), dwLink, lpLastUpdate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUILinkInfoA = extern struct {
    pub const VTable = extern struct {
        base: IOleUILinkContainerA.VTable,
        GetLastUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOleUILinkInfoA,
                dwLink: u32,
                lpLastUpdate: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOleUILinkInfoA,
                dwLink: u32,
                lpLastUpdate: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleUILinkContainerA.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOleUILinkInfoA_GetLastUpdate(self: *const T, dwLink: u32, lpLastUpdate: ?*FILETIME) HRESULT {
                return @as(*const IOleUILinkInfoA.VTable, @ptrCast(self.vtable)).GetLastUpdate(@as(*const IOleUILinkInfoA, @ptrCast(self)), dwLink, lpLastUpdate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLEUIGNRLPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSW,
};

pub const OLEUIGNRLPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSA,
};

pub const OLEUIVIEWPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSW,
    nScaleMin: i32,
    nScaleMax: i32,
};

pub const OLEUIVIEWPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSA,
    nScaleMin: i32,
    nScaleMax: i32,
};

pub const OLEUILINKPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSW,
};

pub const OLEUILINKPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSA,
};

pub const OLEUIOBJECTPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    lpPS: ?*PROPSHEETHEADERW_V2,
    dwObject: u32,
    lpObjInfo: ?*IOleUIObjInfoW,
    dwLink: u32,
    lpLinkInfo: ?*IOleUILinkInfoW,
    lpGP: ?*OLEUIGNRLPROPSW,
    lpVP: ?*OLEUIVIEWPROPSW,
    lpLP: ?*OLEUILINKPROPSW,
};

pub const OLEUIOBJECTPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    lpPS: ?*PROPSHEETHEADERA_V2,
    dwObject: u32,
    lpObjInfo: ?*IOleUIObjInfoA,
    dwLink: u32,
    lpLinkInfo: ?*IOleUILinkInfoA,
    lpGP: ?*OLEUIGNRLPROPSA,
    lpVP: ?*OLEUIVIEWPROPSA,
    lpLP: ?*OLEUILINKPROPSA,
};

const IID_IDispatchEx_Value = Guid.initString("a6ef9860-c720-11d0-9337-00a0c90dcaa9");
pub const IID_IDispatchEx = &IID_IDispatchEx_Value;
pub const IDispatchEx = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDispID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatchEx,
                bstrName: ?BSTR,
                grfdex: u32,
                pid: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatchEx,
                bstrName: ?BSTR,
                grfdex: u32,
                pid: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatchEx,
                id: i32,
                lcid: u32,
                wFlags: u16,
                pdp: ?*DISPPARAMS,
                pvarRes: ?*VARIANT,
                pei: ?*EXCEPINFO,
                pspCaller: ?*IServiceProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatchEx,
                id: i32,
                lcid: u32,
                wFlags: u16,
                pdp: ?*DISPPARAMS,
                pvarRes: ?*VARIANT,
                pei: ?*EXCEPINFO,
                pspCaller: ?*IServiceProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteMemberByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatchEx,
                bstrName: ?BSTR,
                grfdex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatchEx,
                bstrName: ?BSTR,
                grfdex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteMemberByDispID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatchEx,
                id: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatchEx,
                id: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemberProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatchEx,
                id: i32,
                grfdexFetch: u32,
                pgrfdex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatchEx,
                id: i32,
                grfdexFetch: u32,
                pgrfdex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemberName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatchEx,
                id: i32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatchEx,
                id: i32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextDispID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatchEx,
                grfdex: u32,
                id: i32,
                pid: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatchEx,
                grfdex: u32,
                id: i32,
                pid: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameSpaceParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatchEx,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatchEx,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatchEx_GetDispID(self: *const T, bstrName: ?BSTR, grfdex: u32, pid: ?*i32) HRESULT {
                return @as(*const IDispatchEx.VTable, @ptrCast(self.vtable)).GetDispID(@as(*const IDispatchEx, @ptrCast(self)), bstrName, grfdex, pid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatchEx_InvokeEx(self: *const T, id: i32, lcid: u32, wFlags: u16, pdp: ?*DISPPARAMS, pvarRes: ?*VARIANT, pei: ?*EXCEPINFO, pspCaller: ?*IServiceProvider) HRESULT {
                return @as(*const IDispatchEx.VTable, @ptrCast(self.vtable)).InvokeEx(@as(*const IDispatchEx, @ptrCast(self)), id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatchEx_DeleteMemberByName(self: *const T, bstrName: ?BSTR, grfdex: u32) HRESULT {
                return @as(*const IDispatchEx.VTable, @ptrCast(self.vtable)).DeleteMemberByName(@as(*const IDispatchEx, @ptrCast(self)), bstrName, grfdex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatchEx_DeleteMemberByDispID(self: *const T, id: i32) HRESULT {
                return @as(*const IDispatchEx.VTable, @ptrCast(self.vtable)).DeleteMemberByDispID(@as(*const IDispatchEx, @ptrCast(self)), id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatchEx_GetMemberProperties(self: *const T, id: i32, grfdexFetch: u32, pgrfdex: ?*u32) HRESULT {
                return @as(*const IDispatchEx.VTable, @ptrCast(self.vtable)).GetMemberProperties(@as(*const IDispatchEx, @ptrCast(self)), id, grfdexFetch, pgrfdex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatchEx_GetMemberName(self: *const T, id: i32, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IDispatchEx.VTable, @ptrCast(self.vtable)).GetMemberName(@as(*const IDispatchEx, @ptrCast(self)), id, pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatchEx_GetNextDispID(self: *const T, grfdex: u32, id: i32, pid: ?*i32) HRESULT {
                return @as(*const IDispatchEx.VTable, @ptrCast(self.vtable)).GetNextDispID(@as(*const IDispatchEx, @ptrCast(self)), grfdex, id, pid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatchEx_GetNameSpaceParent(self: *const T, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IDispatchEx.VTable, @ptrCast(self.vtable)).GetNameSpaceParent(@as(*const IDispatchEx, @ptrCast(self)), ppunk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDispError_Value = Guid.initString("a6ef9861-c720-11d0-9337-00a0c90dcaa9");
pub const IID_IDispError = &IID_IDispError_Value;
pub const IDispError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispError,
                guidErrorType: Guid,
                ppde: ?*?*IDispError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispError,
                guidErrorType: Guid,
                ppde: ?*?*IDispError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispError,
                ppde: ?*?*IDispError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispError,
                ppde: ?*?*IDispError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHresult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispError,
                phr: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispError,
                phr: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispError,
                pbstrSource: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispError,
                pbstrSource: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHelpInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispError,
                pbstrFileName: ?*?BSTR,
                pdwContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispError,
                pbstrFileName: ?*?BSTR,
                pdwContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispError,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispError,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispError_QueryErrorInfo(self: *const T, guidErrorType: Guid, ppde: ?*?*IDispError) HRESULT {
                return @as(*const IDispError.VTable, @ptrCast(self.vtable)).QueryErrorInfo(@as(*const IDispError, @ptrCast(self)), guidErrorType, ppde);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispError_GetNext(self: *const T, ppde: ?*?*IDispError) HRESULT {
                return @as(*const IDispError.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDispError, @ptrCast(self)), ppde);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispError_GetHresult(self: *const T, phr: ?*HRESULT) HRESULT {
                return @as(*const IDispError.VTable, @ptrCast(self.vtable)).GetHresult(@as(*const IDispError, @ptrCast(self)), phr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispError_GetSource(self: *const T, pbstrSource: ?*?BSTR) HRESULT {
                return @as(*const IDispError.VTable, @ptrCast(self.vtable)).GetSource(@as(*const IDispError, @ptrCast(self)), pbstrSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispError_GetHelpInfo(self: *const T, pbstrFileName: ?*?BSTR, pdwContext: ?*u32) HRESULT {
                return @as(*const IDispError.VTable, @ptrCast(self.vtable)).GetHelpInfo(@as(*const IDispError, @ptrCast(self)), pbstrFileName, pdwContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispError_GetDescription(self: *const T, pbstrDescription: ?*?BSTR) HRESULT {
                return @as(*const IDispError.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IDispError, @ptrCast(self)), pbstrDescription);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IVariantChangeType_Value = Guid.initString("a6ef9862-c720-11d0-9337-00a0c90dcaa9");
pub const IID_IVariantChangeType = &IID_IVariantChangeType_Value;
pub const IVariantChangeType = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ChangeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVariantChangeType,
                pvarDst: ?*VARIANT,
                pvarSrc: ?*VARIANT,
                lcid: u32,
                vtNew: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVariantChangeType,
                pvarDst: ?*VARIANT,
                pvarSrc: ?*VARIANT,
                lcid: u32,
                vtNew: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVariantChangeType_ChangeType(self: *const T, pvarDst: ?*VARIANT, pvarSrc: ?*VARIANT, lcid: u32, vtNew: u16) HRESULT {
                return @as(*const IVariantChangeType.VTable, @ptrCast(self.vtable)).ChangeType(@as(*const IVariantChangeType, @ptrCast(self)), pvarDst, pvarSrc, lcid, vtNew);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IObjectIdentity_Value = Guid.initString("ca04b7e6-0d21-11d1-8cc5-00c04fc2b085");
pub const IID_IObjectIdentity = &IID_IObjectIdentity_Value;
pub const IObjectIdentity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsEqualObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectIdentity,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectIdentity,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectIdentity_IsEqualObject(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IObjectIdentity.VTable, @ptrCast(self.vtable)).IsEqualObject(@as(*const IObjectIdentity, @ptrCast(self)), punk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanHandleException_Value = Guid.initString("c5598e60-b307-11d1-b27d-006008c3fbfb");
pub const IID_ICanHandleException = &IID_ICanHandleException_Value;
pub const ICanHandleException = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanHandleException: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICanHandleException,
                pExcepInfo: ?*EXCEPINFO,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICanHandleException,
                pExcepInfo: ?*EXCEPINFO,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICanHandleException_CanHandleException(self: *const T, pExcepInfo: ?*EXCEPINFO, pvar: ?*VARIANT) HRESULT {
                return @as(*const ICanHandleException.VTable, @ptrCast(self.vtable)).CanHandleException(@as(*const ICanHandleException, @ptrCast(self)), pExcepInfo, pvar);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IProvideRuntimeContext_Value = Guid.initString("10e2414a-ec59-49d2-bc51-5add2c36febc");
pub const IID_IProvideRuntimeContext = &IID_IProvideRuntimeContext_Value;
pub const IProvideRuntimeContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentSourceContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProvideRuntimeContext,
                pdwContext: ?*usize,
                pfExecutingGlobalCode: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProvideRuntimeContext,
                pdwContext: ?*usize,
                pfExecutingGlobalCode: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProvideRuntimeContext_GetCurrentSourceContext(self: *const T, pdwContext: ?*usize, pfExecutingGlobalCode: ?*i16) HRESULT {
                return @as(*const IProvideRuntimeContext.VTable, @ptrCast(self.vtable)).GetCurrentSourceContext(@as(*const IProvideRuntimeContext, @ptrCast(self)), pdwContext, pfExecutingGlobalCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (456)
//--------------------------------------------------------------------------------
pub extern "oleaut32" fn DosDateTimeToVariantTime(
    wDosDate: u16,
    wDosTime: u16,
    pvtime: ?*f64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "oleaut32" fn VariantTimeToDosDateTime(
    vtime: f64,
    pwDosDate: ?*u16,
    pwDosTime: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "oleaut32" fn SystemTimeToVariantTime(
    lpSystemTime: ?*SYSTEMTIME,
    pvtime: ?*f64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "oleaut32" fn VariantTimeToSystemTime(
    vtime: f64,
    lpSystemTime: ?*SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "oleaut32" fn SafeArrayAllocDescriptor(
    cDims: u32,
    ppsaOut: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayAllocDescriptorEx(
    vt: u16,
    cDims: u32,
    ppsaOut: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayAllocData(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayCreate(
    vt: u16,
    cDims: u32,
    rgsabound: ?*SAFEARRAYBOUND,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

pub extern "oleaut32" fn SafeArrayCreateEx(
    vt: u16,
    cDims: u32,
    rgsabound: ?*SAFEARRAYBOUND,
    pvExtra: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

pub extern "oleaut32" fn SafeArrayCopyData(
    psaSource: ?*SAFEARRAY,
    psaTarget: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "oleaut32" fn SafeArrayReleaseDescriptor(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "oleaut32" fn SafeArrayDestroyDescriptor(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "oleaut32" fn SafeArrayReleaseData(
    pData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "oleaut32" fn SafeArrayDestroyData(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "oleaut32" fn SafeArrayAddRef(
    psa: ?*SAFEARRAY,
    ppDataToRelease: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayDestroy(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayRedim(
    psa: ?*SAFEARRAY,
    psaboundNew: ?*SAFEARRAYBOUND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayGetDim(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "oleaut32" fn SafeArrayGetElemsize(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "oleaut32" fn SafeArrayGetUBound(
    psa: ?*SAFEARRAY,
    nDim: u32,
    plUbound: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayGetLBound(
    psa: ?*SAFEARRAY,
    nDim: u32,
    plLbound: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayLock(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayUnlock(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayAccessData(
    psa: ?*SAFEARRAY,
    ppvData: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayUnaccessData(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayGetElement(
    psa: ?*SAFEARRAY,
    rgIndices: ?*i32,
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayPutElement(
    psa: ?*SAFEARRAY,
    rgIndices: ?*i32,
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayCopy(
    psa: ?*SAFEARRAY,
    ppsaOut: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayPtrOfIndex(
    psa: ?*SAFEARRAY,
    rgIndices: ?*i32,
    ppvData: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArraySetRecordInfo(
    psa: ?*SAFEARRAY,
    prinfo: ?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayGetRecordInfo(
    psa: ?*SAFEARRAY,
    prinfo: ?*?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArraySetIID(
    psa: ?*SAFEARRAY,
    guid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayGetIID(
    psa: ?*SAFEARRAY,
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayGetVartype(
    psa: ?*SAFEARRAY,
    pvt: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SafeArrayCreateVector(
    vt: u16,
    lLbound: i32,
    cElements: u32,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

pub extern "oleaut32" fn SafeArrayCreateVectorEx(
    vt: u16,
    lLbound: i32,
    cElements: u32,
    pvExtra: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

pub extern "oleaut32" fn VariantInit(
    pvarg: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "oleaut32" fn VariantClear(
    pvarg: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VariantCopy(
    pvargDest: ?*VARIANT,
    pvargSrc: ?*const VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VariantCopyInd(
    pvarDest: ?*VARIANT,
    pvargSrc: ?*const VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VariantChangeType(
    pvargDest: ?*VARIANT,
    pvarSrc: ?*const VARIANT,
    wFlags: u16,
    vt: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VariantChangeTypeEx(
    pvargDest: ?*VARIANT,
    pvarSrc: ?*const VARIANT,
    lcid: u32,
    wFlags: u16,
    vt: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VectorFromBstr(
    bstr: ?BSTR,
    ppsa: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn BstrFromVector(
    psa: ?*SAFEARRAY,
    pbstr: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromI2(
    sIn: i16,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromI4(
    lIn: i32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromI8(
    i64In: i64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromR4(
    fltIn: f32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromR8(
    dblIn: f64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromCy(
    cyIn: CY,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromDate(
    dateIn: f64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromBool(
    boolIn: i16,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromI1(
    cIn: CHAR,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromUI2(
    uiIn: u16,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromUI4(
    ulIn: u32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromUI8(
    ui64In: u64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI1FromDec(
    pdecIn: ?*const DECIMAL,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromUI1(
    bIn: u8,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromI4(
    lIn: i32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromI8(
    i64In: i64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromR4(
    fltIn: f32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromR8(
    dblIn: f64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromCy(
    cyIn: CY,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromDate(
    dateIn: f64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromBool(
    boolIn: i16,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromI1(
    cIn: CHAR,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromUI2(
    uiIn: u16,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromUI4(
    ulIn: u32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromUI8(
    ui64In: u64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI2FromDec(
    pdecIn: ?*const DECIMAL,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromUI1(
    bIn: u8,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromI2(
    sIn: i16,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromI8(
    i64In: i64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromR4(
    fltIn: f32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromR8(
    dblIn: f64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromCy(
    cyIn: CY,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromDate(
    dateIn: f64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromBool(
    boolIn: i16,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromI1(
    cIn: CHAR,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromUI2(
    uiIn: u16,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromUI4(
    ulIn: u32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromUI8(
    ui64In: u64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI4FromDec(
    pdecIn: ?*const DECIMAL,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromUI1(
    bIn: u8,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromI2(
    sIn: i16,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromR4(
    fltIn: f32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromR8(
    dblIn: f64,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromCy(
    cyIn: CY,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromDate(
    dateIn: f64,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromBool(
    boolIn: i16,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromI1(
    cIn: CHAR,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromUI2(
    uiIn: u16,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromUI4(
    ulIn: u32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromUI8(
    ui64In: u64,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI8FromDec(
    pdecIn: ?*const DECIMAL,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromUI1(
    bIn: u8,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromI2(
    sIn: i16,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromI4(
    lIn: i32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromI8(
    i64In: i64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromR8(
    dblIn: f64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromCy(
    cyIn: CY,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromDate(
    dateIn: f64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromBool(
    boolIn: i16,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromI1(
    cIn: CHAR,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromUI2(
    uiIn: u16,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromUI4(
    ulIn: u32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromUI8(
    ui64In: u64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4FromDec(
    pdecIn: ?*const DECIMAL,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromUI1(
    bIn: u8,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromI2(
    sIn: i16,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromI4(
    lIn: i32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromI8(
    i64In: i64,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromR4(
    fltIn: f32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromCy(
    cyIn: CY,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromDate(
    dateIn: f64,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromBool(
    boolIn: i16,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromI1(
    cIn: CHAR,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromUI2(
    uiIn: u16,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromUI4(
    ulIn: u32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromUI8(
    ui64In: u64,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8FromDec(
    pdecIn: ?*const DECIMAL,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromUI1(
    bIn: u8,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromI2(
    sIn: i16,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromI4(
    lIn: i32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromI8(
    i64In: i64,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromR4(
    fltIn: f32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromR8(
    dblIn: f64,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromCy(
    cyIn: CY,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromBool(
    boolIn: i16,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromI1(
    cIn: CHAR,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromUI2(
    uiIn: u16,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromUI4(
    ulIn: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromUI8(
    ui64In: u64,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromDec(
    pdecIn: ?*const DECIMAL,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromUI1(
    bIn: u8,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromI2(
    sIn: i16,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromI4(
    lIn: i32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromI8(
    i64In: i64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromR4(
    fltIn: f32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromR8(
    dblIn: f64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromDate(
    dateIn: f64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromBool(
    boolIn: i16,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromI1(
    cIn: CHAR,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromUI2(
    uiIn: u16,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromUI4(
    ulIn: u32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromUI8(
    ui64In: u64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFromDec(
    pdecIn: ?*const DECIMAL,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromUI1(
    bVal: u8,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromI2(
    iVal: i16,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromI4(
    lIn: i32,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromI8(
    i64In: i64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromR4(
    fltIn: f32,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromR8(
    dblIn: f64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromCy(
    cyIn: CY,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromDate(
    dateIn: f64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromBool(
    boolIn: i16,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromI1(
    cIn: CHAR,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromUI2(
    uiIn: u16,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromUI4(
    ulIn: u32,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromUI8(
    ui64In: u64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrFromDec(
    pdecIn: ?*const DECIMAL,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromUI1(
    bIn: u8,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromI2(
    sIn: i16,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromI4(
    lIn: i32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromI8(
    i64In: i64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromR4(
    fltIn: f32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromR8(
    dblIn: f64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromDate(
    dateIn: f64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromCy(
    cyIn: CY,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromI1(
    cIn: CHAR,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromUI2(
    uiIn: u16,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromUI4(
    ulIn: u32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromUI8(
    i64In: u64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBoolFromDec(
    pdecIn: ?*const DECIMAL,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromUI1(
    bIn: u8,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromI2(
    uiIn: i16,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromI4(
    lIn: i32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromI8(
    i64In: i64,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromR4(
    fltIn: f32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromR8(
    dblIn: f64,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromDate(
    dateIn: f64,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromCy(
    cyIn: CY,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromBool(
    boolIn: i16,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromUI2(
    uiIn: u16,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromUI4(
    ulIn: u32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromUI8(
    i64In: u64,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarI1FromDec(
    pdecIn: ?*const DECIMAL,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromUI1(
    bIn: u8,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromI2(
    uiIn: i16,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromI4(
    lIn: i32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromI8(
    i64In: i64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromR4(
    fltIn: f32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromR8(
    dblIn: f64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromDate(
    dateIn: f64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromCy(
    cyIn: CY,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromBool(
    boolIn: i16,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromI1(
    cIn: CHAR,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromUI4(
    ulIn: u32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromUI8(
    i64In: u64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI2FromDec(
    pdecIn: ?*const DECIMAL,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromUI1(
    bIn: u8,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromI2(
    uiIn: i16,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromI4(
    lIn: i32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromI8(
    i64In: i64,
    plOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromR4(
    fltIn: f32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromR8(
    dblIn: f64,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromDate(
    dateIn: f64,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromCy(
    cyIn: CY,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromBool(
    boolIn: i16,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromI1(
    cIn: CHAR,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromUI2(
    uiIn: u16,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromUI8(
    ui64In: u64,
    plOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI4FromDec(
    pdecIn: ?*const DECIMAL,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromUI1(
    bIn: u8,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromI2(
    sIn: i16,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromI8(
    ui64In: i64,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromR4(
    fltIn: f32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromR8(
    dblIn: f64,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromCy(
    cyIn: CY,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromDate(
    dateIn: f64,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromBool(
    boolIn: i16,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromI1(
    cIn: CHAR,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromUI2(
    uiIn: u16,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromUI4(
    ulIn: u32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUI8FromDec(
    pdecIn: ?*const DECIMAL,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromUI1(
    bIn: u8,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromI2(
    uiIn: i16,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromI4(
    lIn: i32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromI8(
    i64In: i64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromR4(
    fltIn: f32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromR8(
    dblIn: f64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromDate(
    dateIn: f64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromCy(
    cyIn: CY,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromBool(
    boolIn: i16,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromI1(
    cIn: CHAR,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromUI2(
    uiIn: u16,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromUI4(
    ulIn: u32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFromUI8(
    ui64In: u64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarParseNumFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pnumprs: ?*NUMPARSE,
    rgbDig: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarNumFromParseNum(
    pnumprs: ?*NUMPARSE,
    rgbDig: ?*u8,
    dwVtBits: u32,
    pvar: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarAdd(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarAnd(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCat(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDiv(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarEqv(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarIdiv(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarImp(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarMod(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarMul(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarOr(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarPow(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarSub(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarXor(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarAbs(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarFix(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarInt(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarNeg(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarNot(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarRound(
    pvarIn: ?*VARIANT,
    cDecimals: i32,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCmp(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    lcid: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecAdd(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecDiv(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecMul(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecSub(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecAbs(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecFix(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecInt(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecNeg(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecRound(
    pdecIn: ?*DECIMAL,
    cDecimals: i32,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecCmp(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDecCmpR8(
    pdecLeft: ?*DECIMAL,
    dblRight: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyAdd(
    cyLeft: CY,
    cyRight: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyMul(
    cyLeft: CY,
    cyRight: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyMulI4(
    cyLeft: CY,
    lRight: i32,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyMulI8(
    cyLeft: CY,
    lRight: i64,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCySub(
    cyLeft: CY,
    cyRight: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyAbs(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyFix(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyInt(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyNeg(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyRound(
    cyIn: CY,
    cDecimals: i32,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyCmp(
    cyLeft: CY,
    cyRight: CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarCyCmpR8(
    cyLeft: CY,
    dblRight: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrCat(
    bstrLeft: ?BSTR,
    bstrRight: ?BSTR,
    pbstrResult: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarBstrCmp(
    bstrLeft: ?BSTR,
    bstrRight: ?BSTR,
    lcid: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8Pow(
    dblLeft: f64,
    dblRight: f64,
    pdblResult: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR4CmpR8(
    fltLeft: f32,
    dblRight: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarR8Round(
    dblIn: f64,
    cDecimals: i32,
    pdblResult: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromUdate(
    pudateIn: ?*UDATE,
    dwFlags: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarDateFromUdateEx(
    pudateIn: ?*UDATE,
    lcid: u32,
    dwFlags: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarUdateFromDate(
    dateIn: f64,
    dwFlags: u32,
    pudateOut: ?*UDATE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn GetAltMonthNames(
    lcid: u32,
    prgp: ?*?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarFormat(
    pvarIn: ?*VARIANT,
    pstrFormat: ?PWSTR,
    iFirstDay: i32,
    iFirstWeek: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarFormatDateTime(
    pvarIn: ?*VARIANT,
    iNamedFormat: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarFormatNumber(
    pvarIn: ?*VARIANT,
    iNumDig: i32,
    iIncLead: i32,
    iUseParens: i32,
    iGroup: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarFormatPercent(
    pvarIn: ?*VARIANT,
    iNumDig: i32,
    iIncLead: i32,
    iUseParens: i32,
    iGroup: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarFormatCurrency(
    pvarIn: ?*VARIANT,
    iNumDig: i32,
    iIncLead: i32,
    iUseParens: i32,
    iGroup: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarWeekdayName(
    iWeekday: i32,
    fAbbrev: i32,
    iFirstDay: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarMonthName(
    iMonth: i32,
    fAbbrev: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarFormatFromTokens(
    pvarIn: ?*VARIANT,
    pstrFormat: ?PWSTR,
    pbTokCur: ?*u8,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
    lcid: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn VarTokenizeFormatString(
    pstrFormat: ?PWSTR,
    rgbTok: [*:0]u8,
    cbTok: i32,
    iFirstDay: i32,
    iFirstWeek: i32,
    lcid: u32,
    pcbActual: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn LHashValOfNameSysA(
    syskind: SYSKIND,
    lcid: u32,
    szName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "oleaut32" fn LHashValOfNameSys(
    syskind: SYSKIND,
    lcid: u32,
    szName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "oleaut32" fn LoadTypeLib(
    szFile: ?[*:0]const u16,
    pptlib: ?*?*ITypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn LoadTypeLibEx(
    szFile: ?[*:0]const u16,
    regkind: REGKIND,
    pptlib: ?*?*ITypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn LoadRegTypeLib(
    rguid: ?*const Guid,
    wVerMajor: u16,
    wVerMinor: u16,
    lcid: u32,
    pptlib: ?*?*ITypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn QueryPathOfRegTypeLib(
    guid: ?*const Guid,
    wMaj: u16,
    wMin: u16,
    lcid: u32,
    lpbstrPathName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn RegisterTypeLib(
    ptlib: ?*ITypeLib,
    szFullPath: ?[*:0]const u16,
    szHelpDir: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn UnRegisterTypeLib(
    libID: ?*const Guid,
    wVerMajor: u16,
    wVerMinor: u16,
    lcid: u32,
    syskind: SYSKIND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn RegisterTypeLibForUser(
    ptlib: ?*ITypeLib,
    szFullPath: ?PWSTR,
    szHelpDir: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn UnRegisterTypeLibForUser(
    libID: ?*const Guid,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    lcid: u32,
    syskind: SYSKIND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn CreateTypeLib(
    syskind: SYSKIND,
    szFile: ?[*:0]const u16,
    ppctlib: ?*?*ICreateTypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn CreateTypeLib2(
    syskind: SYSKIND,
    szFile: ?[*:0]const u16,
    ppctlib: ?*?*ICreateTypeLib2,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn DispGetParam(
    pdispparams: ?*DISPPARAMS,
    position: u32,
    vtTarg: u16,
    pvarResult: ?*VARIANT,
    puArgErr: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn DispGetIDsOfNames(
    ptinfo: ?*ITypeInfo,
    rgszNames: [*]?PWSTR,
    cNames: u32,
    rgdispid: [*]i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn DispInvoke(
    _this: ?*anyopaque,
    ptinfo: ?*ITypeInfo,
    dispidMember: i32,
    wFlags: u16,
    pparams: ?*DISPPARAMS,
    pvarResult: ?*VARIANT,
    pexcepinfo: ?*EXCEPINFO,
    puArgErr: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn CreateDispTypeInfo(
    pidata: ?*INTERFACEDATA,
    lcid: u32,
    pptinfo: ?*?*ITypeInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn CreateStdDispatch(
    punkOuter: ?*IUnknown,
    pvThis: ?*anyopaque,
    ptinfo: ?*ITypeInfo,
    ppunkStdDisp: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn DispCallFunc(
    pvInstance: ?*anyopaque,
    oVft: usize,
    cc: CALLCONV,
    vtReturn: u16,
    cActuals: u32,
    prgvt: [*:0]u16,
    prgpvarg: [*]?*VARIANT,
    pvargResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn RegisterActiveObject(
    punk: ?*IUnknown,
    rclsid: ?*const Guid,
    dwFlags: u32,
    pdwRegister: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn RevokeActiveObject(
    dwRegister: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn GetActiveObject(
    rclsid: ?*const Guid,
    pvReserved: ?*anyopaque,
    ppunk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn CreateErrorInfo(
    pperrinfo: ?*?*ICreateErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn GetRecordInfoFromTypeInfo(
    pTypeInfo: ?*ITypeInfo,
    ppRecInfo: ?*?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn GetRecordInfoFromGuids(
    rGuidTypeLib: ?*const Guid,
    uVerMajor: u32,
    uVerMinor: u32,
    lcid: u32,
    rGuidTypeInfo: ?*const Guid,
    ppRecInfo: ?*?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn OaBuildVersion() callconv(@import("std").os.windows.WINAPI) u32;

pub extern "oleaut32" fn ClearCustData(
    pCustData: ?*CUSTDATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "oleaut32" fn OaEnablePerUserTLibRegistration() callconv(@import("std").os.windows.WINAPI) void;

pub extern "ole32" fn OleBuildVersion() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleInitialize(
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleUninitialize() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleQueryLinkFromData(
    pSrcDataObject: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleQueryCreateFromData(
    pSrcDataObject: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreate(
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateEx(
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateFromData(
    pSrcDataObj: ?*IDataObject,
    riid: ?*const Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateFromDataEx(
    pSrcDataObj: ?*IDataObject,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLinkFromData(
    pSrcDataObj: ?*IDataObject,
    riid: ?*const Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLinkFromDataEx(
    pSrcDataObj: ?*IDataObject,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateStaticFromData(
    pSrcDataObj: ?*IDataObject,
    iid: ?*const Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLink(
    pmkLinkSrc: ?*IMoniker,
    riid: ?*const Guid,
    renderopt: u32,
    lpFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLinkEx(
    pmkLinkSrc: ?*IMoniker,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLinkToFile(
    lpszFileName: ?[*:0]const u16,
    riid: ?*const Guid,
    renderopt: u32,
    lpFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLinkToFileEx(
    lpszFileName: ?[*:0]const u16,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateFromFile(
    rclsid: ?*const Guid,
    lpszFileName: ?[*:0]const u16,
    riid: ?*const Guid,
    renderopt: u32,
    lpFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateFromFileEx(
    rclsid: ?*const Guid,
    lpszFileName: ?[*:0]const u16,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleLoad(
    pStg: ?*IStorage,
    riid: ?*const Guid,
    pClientSite: ?*IOleClientSite,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleSave(
    pPS: ?*IPersistStorage,
    pStg: ?*IStorage,
    fSameAsLoad: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleLoadFromStream(
    pStm: ?*IStream,
    iidInterface: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleSaveToStream(
    pPStm: ?*IPersistStream,
    pStm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleSetContainedObject(
    pUnknown: ?*IUnknown,
    fContained: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleNoteObjectVisible(
    pUnknown: ?*IUnknown,
    fVisible: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn RegisterDragDrop(
    hwnd: ?HWND,
    pDropTarget: ?*IDropTarget,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn RevokeDragDrop(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn DoDragDrop(
    pDataObj: ?*IDataObject,
    pDropSource: ?*IDropSource,
    dwOKEffects: u32,
    pdwEffect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleSetClipboard(
    pDataObj: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleGetClipboard(
    ppDataObj: ?*?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ole32" fn OleGetClipboardWithEnterpriseInfo(
    dataObject: ?*?*IDataObject,
    dataEnterpriseId: ?*?PWSTR,
    sourceDescription: ?*?PWSTR,
    targetDescription: ?*?PWSTR,
    dataDescription: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleFlushClipboard() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleIsCurrentClipboard(
    pDataObj: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateMenuDescriptor(
    hmenuCombined: ?HMENU,
    lpMenuWidths: ?*OleMenuGroupWidths,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleSetMenuDescriptor(
    holemenu: isize,
    hwndFrame: ?HWND,
    hwndActiveObject: ?HWND,
    lpFrame: ?*IOleInPlaceFrame,
    lpActiveObj: ?*IOleInPlaceActiveObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleDestroyMenuDescriptor(
    holemenu: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleTranslateAccelerator(
    lpFrame: ?*IOleInPlaceFrame,
    lpFrameInfo: ?*OIFI,
    lpmsg: ?*MSG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleDuplicateData(
    hSrc: ?HANDLE,
    cfFormat: u16,
    uiFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleDraw(
    pUnknown: ?*IUnknown,
    dwAspect: u32,
    hdcDraw: ?HDC,
    lprcBounds: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleRun(
    pUnknown: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleIsRunning(
    pObject: ?*IOleObject,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleLockRunning(
    pUnknown: ?*IUnknown,
    fLock: BOOL,
    fLastUnlockCloses: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReleaseStgMedium(
    param0: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateOleAdviseHolder(
    ppOAHolder: ?*?*IOleAdviseHolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateDefaultHandler(
    clsid: ?*const Guid,
    pUnkOuter: ?*IUnknown,
    riid: ?*const Guid,
    lplpObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateEmbeddingHelper(
    clsid: ?*const Guid,
    pUnkOuter: ?*IUnknown,
    flags: u32,
    pCF: ?*IClassFactory,
    riid: ?*const Guid,
    lplpObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn IsAccelerator(
    hAccel: ?HACCEL,
    cAccelEntries: i32,
    lpMsg: ?*MSG,
    lpwCmd: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleGetIconOfFile(
    lpszPath: ?PWSTR,
    fUseFileAsLabel: BOOL,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleGetIconOfClass(
    rclsid: ?*const Guid,
    lpszLabel: ?PWSTR,
    fUseTypeAsLabel: BOOL,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleMetafilePictFromIconAndLabel(
    hIcon: ?HICON,
    lpszLabel: ?PWSTR,
    lpszSourceFile: ?PWSTR,
    iIconIndex: u32,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleRegGetUserType(
    clsid: ?*const Guid,
    dwFormOfType: u32,
    pszUserType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleRegGetMiscStatus(
    clsid: ?*const Guid,
    dwAspect: u32,
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleRegEnumFormatEtc(
    clsid: ?*const Guid,
    dwDirection: u32,
    ppenum: ?*?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleRegEnumVerbs(
    clsid: ?*const Guid,
    ppenum: ?*?*IEnumOLEVERB,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleDoAutoConvert(
    pStg: ?*IStorage,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleGetAutoConvert(
    clsidOld: ?*const Guid,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleSetAutoConvert(
    clsidOld: ?*const Guid,
    clsidNew: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn HRGN_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ole32" fn HRGN_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn HRGN_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn HRGN_UserFree(
    param0: ?*u32,
    param1: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-marshal-l1-1-0" fn HRGN_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-marshal-l1-1-0" fn HRGN_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "api-ms-win-core-marshal-l1-1-0" fn HRGN_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "api-ms-win-core-marshal-l1-1-0" fn HRGN_UserFree64(
    param0: ?*u32,
    param1: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleaut32" fn OleCreatePropertyFrame(
    hwndOwner: ?HWND,
    x: u32,
    y: u32,
    lpszCaption: ?[*:0]const u16,
    cObjects: u32,
    ppUnk: ?*?*IUnknown,
    cPages: u32,
    pPageClsID: ?*Guid,
    lcid: u32,
    dwReserved: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleaut32" fn OleCreatePropertyFrameIndirect(
    lpParams: ?*OCPFIPARAMS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleaut32" fn OleTranslateColor(
    clr: u32,
    hpal: ?HPALETTE,
    lpcolorref: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleaut32" fn OleCreateFontIndirect(
    lpFontDesc: ?*FONTDESC,
    riid: ?*const Guid,
    lplpvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleaut32" fn OleCreatePictureIndirect(
    lpPictDesc: ?*PICTDESC,
    riid: ?*const Guid,
    fOwn: BOOL,
    lplpvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleaut32" fn OleLoadPicture(
    lpstream: ?*IStream,
    lSize: i32,
    fRunmode: BOOL,
    riid: ?*const Guid,
    lplpvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleaut32" fn OleLoadPictureEx(
    lpstream: ?*IStream,
    lSize: i32,
    fRunmode: BOOL,
    riid: ?*const Guid,
    xSizeDesired: u32,
    ySizeDesired: u32,
    dwFlags: u32,
    lplpvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleaut32" fn OleLoadPicturePath(
    szURLorPath: ?PWSTR,
    punkCaller: ?*IUnknown,
    dwReserved: u32,
    clrReserved: u32,
    riid: ?*const Guid,
    ppvRet: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn OleLoadPictureFile(
    varFileName: VARIANT,
    lplpdispPicture: ?*?*IDispatch,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn OleLoadPictureFileEx(
    varFileName: VARIANT,
    xSizeDesired: u32,
    ySizeDesired: u32,
    dwFlags: u32,
    lplpdispPicture: ?*?*IDispatch,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn OleSavePictureFile(
    lpdispPicture: ?*IDispatch,
    bstrFileName: ?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleaut32" fn OleIconToCursor(
    hinstExe: ?HINSTANCE,
    hIcon: ?HICON,
) callconv(@import("std").os.windows.WINAPI) ?HCURSOR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIAddVerbMenuW(
    lpOleObj: ?*IOleObject,
    lpszShortType: ?[*:0]const u16,
    hMenu: ?HMENU,
    uPos: u32,
    uIDVerbMin: u32,
    uIDVerbMax: u32,
    bAddConvert: BOOL,
    idConvert: u32,
    lphMenu: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIAddVerbMenuA(
    lpOleObj: ?*IOleObject,
    lpszShortType: ?[*:0]const u8,
    hMenu: ?HMENU,
    uPos: u32,
    uIDVerbMin: u32,
    uIDVerbMax: u32,
    bAddConvert: BOOL,
    idConvert: u32,
    lphMenu: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIInsertObjectW(
    param0: ?*OLEUIINSERTOBJECTW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIInsertObjectA(
    param0: ?*OLEUIINSERTOBJECTA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIPasteSpecialW(
    param0: ?*OLEUIPASTESPECIALW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIPasteSpecialA(
    param0: ?*OLEUIPASTESPECIALA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIEditLinksW(
    param0: ?*OLEUIEDITLINKSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIEditLinksA(
    param0: ?*OLEUIEDITLINKSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIChangeIconW(
    param0: ?*OLEUICHANGEICONW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIChangeIconA(
    param0: ?*OLEUICHANGEICONA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIConvertW(
    param0: ?*OLEUICONVERTW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIConvertA(
    param0: ?*OLEUICONVERTA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUICanConvertOrActivateAs(
    rClsid: ?*const Guid,
    fIsLinkedObject: BOOL,
    wFormat: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIBusyW(
    param0: ?*OLEUIBUSYW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIBusyA(
    param0: ?*OLEUIBUSYA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIChangeSourceW(
    param0: ?*OLEUICHANGESOURCEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIChangeSourceA(
    param0: ?*OLEUICHANGESOURCEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIObjectPropertiesW(
    param0: ?*OLEUIOBJECTPROPSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIObjectPropertiesA(
    param0: ?*OLEUIOBJECTPROPSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIPromptUserW(
    nTemplate: i32,
    hwndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIPromptUserA(
    nTemplate: i32,
    hwndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIUpdateLinksW(
    lpOleUILinkCntr: ?*IOleUILinkContainerW,
    hwndParent: ?HWND,
    lpszTitle: ?PWSTR,
    cLinks: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIUpdateLinksA(
    lpOleUILinkCntr: ?*IOleUILinkContainerA,
    hwndParent: ?HWND,
    lpszTitle: ?PSTR,
    cLinks: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (26)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const OLEUIINSERTOBJECT = thismodule.OLEUIINSERTOBJECTA;
        pub const OLEUIPASTEENTRY = thismodule.OLEUIPASTEENTRYA;
        pub const OLEUIPASTESPECIAL = thismodule.OLEUIPASTESPECIALA;
        pub const IOleUILinkContainer = thismodule.IOleUILinkContainerA;
        pub const OLEUIEDITLINKS = thismodule.OLEUIEDITLINKSA;
        pub const OLEUICHANGEICON = thismodule.OLEUICHANGEICONA;
        pub const OLEUICONVERT = thismodule.OLEUICONVERTA;
        pub const OLEUIBUSY = thismodule.OLEUIBUSYA;
        pub const OLEUICHANGESOURCE = thismodule.OLEUICHANGESOURCEA;
        pub const IOleUIObjInfo = thismodule.IOleUIObjInfoA;
        pub const IOleUILinkInfo = thismodule.IOleUILinkInfoA;
        pub const OLEUIGNRLPROPS = thismodule.OLEUIGNRLPROPSA;
        pub const OLEUIVIEWPROPS = thismodule.OLEUIVIEWPROPSA;
        pub const OLEUILINKPROPS = thismodule.OLEUILINKPROPSA;
        pub const OLEUIOBJECTPROPS = thismodule.OLEUIOBJECTPROPSA;
        pub const OleUIAddVerbMenu = thismodule.OleUIAddVerbMenuA;
        pub const OleUIInsertObject = thismodule.OleUIInsertObjectA;
        pub const OleUIPasteSpecial = thismodule.OleUIPasteSpecialA;
        pub const OleUIEditLinks = thismodule.OleUIEditLinksA;
        pub const OleUIChangeIcon = thismodule.OleUIChangeIconA;
        pub const OleUIConvert = thismodule.OleUIConvertA;
        pub const OleUIBusy = thismodule.OleUIBusyA;
        pub const OleUIChangeSource = thismodule.OleUIChangeSourceA;
        pub const OleUIObjectProperties = thismodule.OleUIObjectPropertiesA;
        pub const OleUIPromptUser = thismodule.OleUIPromptUserA;
        pub const OleUIUpdateLinks = thismodule.OleUIUpdateLinksA;
    },
    .wide => struct {
        pub const OLEUIINSERTOBJECT = thismodule.OLEUIINSERTOBJECTW;
        pub const OLEUIPASTEENTRY = thismodule.OLEUIPASTEENTRYW;
        pub const OLEUIPASTESPECIAL = thismodule.OLEUIPASTESPECIALW;
        pub const IOleUILinkContainer = thismodule.IOleUILinkContainerW;
        pub const OLEUIEDITLINKS = thismodule.OLEUIEDITLINKSW;
        pub const OLEUICHANGEICON = thismodule.OLEUICHANGEICONW;
        pub const OLEUICONVERT = thismodule.OLEUICONVERTW;
        pub const OLEUIBUSY = thismodule.OLEUIBUSYW;
        pub const OLEUICHANGESOURCE = thismodule.OLEUICHANGESOURCEW;
        pub const IOleUIObjInfo = thismodule.IOleUIObjInfoW;
        pub const IOleUILinkInfo = thismodule.IOleUILinkInfoW;
        pub const OLEUIGNRLPROPS = thismodule.OLEUIGNRLPROPSW;
        pub const OLEUIVIEWPROPS = thismodule.OLEUIVIEWPROPSW;
        pub const OLEUILINKPROPS = thismodule.OLEUILINKPROPSW;
        pub const OLEUIOBJECTPROPS = thismodule.OLEUIOBJECTPROPSW;
        pub const OleUIAddVerbMenu = thismodule.OleUIAddVerbMenuW;
        pub const OleUIInsertObject = thismodule.OleUIInsertObjectW;
        pub const OleUIPasteSpecial = thismodule.OleUIPasteSpecialW;
        pub const OleUIEditLinks = thismodule.OleUIEditLinksW;
        pub const OleUIChangeIcon = thismodule.OleUIChangeIconW;
        pub const OleUIConvert = thismodule.OleUIConvertW;
        pub const OleUIBusy = thismodule.OleUIBusyW;
        pub const OleUIChangeSource = thismodule.OleUIChangeSourceW;
        pub const OleUIObjectProperties = thismodule.OleUIObjectPropertiesW;
        pub const OleUIPromptUser = thismodule.OleUIPromptUserW;
        pub const OleUIUpdateLinks = thismodule.OleUIUpdateLinksW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const OLEUIINSERTOBJECT = *opaque {};
        pub const OLEUIPASTEENTRY = *opaque {};
        pub const OLEUIPASTESPECIAL = *opaque {};
        pub const IOleUILinkContainer = *opaque {};
        pub const OLEUIEDITLINKS = *opaque {};
        pub const OLEUICHANGEICON = *opaque {};
        pub const OLEUICONVERT = *opaque {};
        pub const OLEUIBUSY = *opaque {};
        pub const OLEUICHANGESOURCE = *opaque {};
        pub const IOleUIObjInfo = *opaque {};
        pub const IOleUILinkInfo = *opaque {};
        pub const OLEUIGNRLPROPS = *opaque {};
        pub const OLEUIVIEWPROPS = *opaque {};
        pub const OLEUILINKPROPS = *opaque {};
        pub const OLEUIOBJECTPROPS = *opaque {};
        pub const OleUIAddVerbMenu = *opaque {};
        pub const OleUIInsertObject = *opaque {};
        pub const OleUIPasteSpecial = *opaque {};
        pub const OleUIEditLinks = *opaque {};
        pub const OleUIChangeIcon = *opaque {};
        pub const OleUIConvert = *opaque {};
        pub const OleUIBusy = *opaque {};
        pub const OleUIChangeSource = *opaque {};
        pub const OleUIObjectProperties = *opaque {};
        pub const OleUIPromptUser = *opaque {};
        pub const OleUIUpdateLinks = *opaque {};
    } else struct {
        pub const OLEUIINSERTOBJECT = @compileError("'OLEUIINSERTOBJECT' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIPASTEENTRY = @compileError("'OLEUIPASTEENTRY' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIPASTESPECIAL = @compileError("'OLEUIPASTESPECIAL' requires that UNICODE be set to true or false in the root module");
        pub const IOleUILinkContainer = @compileError("'IOleUILinkContainer' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIEDITLINKS = @compileError("'OLEUIEDITLINKS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUICHANGEICON = @compileError("'OLEUICHANGEICON' requires that UNICODE be set to true or false in the root module");
        pub const OLEUICONVERT = @compileError("'OLEUICONVERT' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIBUSY = @compileError("'OLEUIBUSY' requires that UNICODE be set to true or false in the root module");
        pub const OLEUICHANGESOURCE = @compileError("'OLEUICHANGESOURCE' requires that UNICODE be set to true or false in the root module");
        pub const IOleUIObjInfo = @compileError("'IOleUIObjInfo' requires that UNICODE be set to true or false in the root module");
        pub const IOleUILinkInfo = @compileError("'IOleUILinkInfo' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIGNRLPROPS = @compileError("'OLEUIGNRLPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIVIEWPROPS = @compileError("'OLEUIVIEWPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUILINKPROPS = @compileError("'OLEUILINKPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIOBJECTPROPS = @compileError("'OLEUIOBJECTPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OleUIAddVerbMenu = @compileError("'OleUIAddVerbMenu' requires that UNICODE be set to true or false in the root module");
        pub const OleUIInsertObject = @compileError("'OleUIInsertObject' requires that UNICODE be set to true or false in the root module");
        pub const OleUIPasteSpecial = @compileError("'OleUIPasteSpecial' requires that UNICODE be set to true or false in the root module");
        pub const OleUIEditLinks = @compileError("'OleUIEditLinks' requires that UNICODE be set to true or false in the root module");
        pub const OleUIChangeIcon = @compileError("'OleUIChangeIcon' requires that UNICODE be set to true or false in the root module");
        pub const OleUIConvert = @compileError("'OleUIConvert' requires that UNICODE be set to true or false in the root module");
        pub const OleUIBusy = @compileError("'OleUIBusy' requires that UNICODE be set to true or false in the root module");
        pub const OleUIChangeSource = @compileError("'OleUIChangeSource' requires that UNICODE be set to true or false in the root module");
        pub const OleUIObjectProperties = @compileError("'OleUIObjectProperties' requires that UNICODE be set to true or false in the root module");
        pub const OleUIPromptUser = @compileError("'OleUIPromptUser' requires that UNICODE be set to true or false in the root module");
        pub const OleUIUpdateLinks = @compileError("'OleUIUpdateLinks' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (87)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const BYTE_SIZEDARR = @import("../system/com.zig").BYTE_SIZEDARR;
const CALLCONV = @import("../system/com.zig").CALLCONV;
const CHAR = @import("../foundation.zig").CHAR;
const CUSTDATA = @import("../system/com.zig").CUSTDATA;
const CY = @import("../system/com.zig").CY;
const DECIMAL = @import("../foundation.zig").DECIMAL;
const DISPPARAMS = @import("../system/com.zig").DISPPARAMS;
const DVASPECT = @import("../system/com.zig").DVASPECT;
const DVTARGETDEVICE = @import("../system/com.zig").DVTARGETDEVICE;
const EXCEPINFO = @import("../system/com.zig").EXCEPINFO;
const FILETIME = @import("../foundation.zig").FILETIME;
const FLAGGED_WORD_BLOB = @import("../system/com.zig").FLAGGED_WORD_BLOB;
const FORMATETC = @import("../system/com.zig").FORMATETC;
const FUNCDESC = @import("../system/com.zig").FUNCDESC;
const HACCEL = @import("../ui/windows_and_messaging.zig").HACCEL;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HCURSOR = @import("../ui/windows_and_messaging.zig").HCURSOR;
const HDC = @import("../graphics/gdi.zig").HDC;
const HENHMETAFILE = @import("../graphics/gdi.zig").HENHMETAFILE;
const HFONT = @import("../graphics/gdi.zig").HFONT;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HMENU = @import("../ui/windows_and_messaging.zig").HMENU;
const HMETAFILE = @import("../graphics/gdi.zig").HMETAFILE;
const HPALETTE = @import("../graphics/gdi.zig").HPALETTE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HRGN = @import("../graphics/gdi.zig").HRGN;
const HRSRC = @import("../foundation.zig").HRSRC;
const HTASK = @import("../media.zig").HTASK;
const HWND = @import("../foundation.zig").HWND;
const HYPER_SIZEDARR = @import("../system/com.zig").HYPER_SIZEDARR;
const IAdviseSink = @import("../system/com.zig").IAdviseSink;
const IBindCtx = @import("../system/com.zig").IBindCtx;
const IBindHost = @import("../system/com.zig").IBindHost;
const IClassFactory = @import("../system/com.zig").IClassFactory;
const IDataObject = @import("../system/com.zig").IDataObject;
const IDispatch = @import("../system/com.zig").IDispatch;
const IDLDESC = @import("../system/com.zig").IDLDESC;
const IEnumFORMATETC = @import("../system/com.zig").IEnumFORMATETC;
const IEnumSTATDATA = @import("../system/com.zig").IEnumSTATDATA;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IErrorLog = @import("../system/com.zig").IErrorLog;
const IMoniker = @import("../system/com.zig").IMoniker;
const INVOKEKIND = @import("../system/com.zig").INVOKEKIND;
const IPersist = @import("../system/com.zig").IPersist;
const IPersistStorage = @import("../system/com/structured_storage.zig").IPersistStorage;
const IPersistStream = @import("../system/com.zig").IPersistStream;
const IPropertyBag = @import("../system/com/structured_storage.zig").IPropertyBag;
const IPropertyBag2 = @import("../system/com/structured_storage.zig").IPropertyBag2;
const IServiceProvider = @import("../system/com.zig").IServiceProvider;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const ITypeInfo = @import("../system/com.zig").ITypeInfo;
const ITypeLib = @import("../system/com.zig").ITypeLib;
const IUnknown = @import("../system/com.zig").IUnknown;
const LOGPALETTE = @import("../graphics/gdi.zig").LOGPALETTE;
const LONG_SIZEDARR = @import("../system/com.zig").LONG_SIZEDARR;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const MSG = @import("../ui/windows_and_messaging.zig").MSG;
const OPENFILENAMEA = @import("../ui/controls/dialogs.zig").OPENFILENAMEA;
const OPENFILENAMEW = @import("../ui/controls/dialogs.zig").OPENFILENAMEW;
const POINT = @import("../foundation.zig").POINT;
const POINTL = @import("../foundation.zig").POINTL;
const PROPSHEETHEADERA_V2 = @import("../ui/controls.zig").PROPSHEETHEADERA_V2;
const PROPSHEETHEADERW_V2 = @import("../ui/controls.zig").PROPSHEETHEADERW_V2;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const RECTL = @import("../foundation.zig").RECTL;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const SAFEARRAYBOUND = @import("../system/com.zig").SAFEARRAYBOUND;
const SHORT_SIZEDARR = @import("../system/com.zig").SHORT_SIZEDARR;
const SIZE = @import("../foundation.zig").SIZE;
const STGMEDIUM = @import("../system/com.zig").STGMEDIUM;
const SYSKIND = @import("../system/com.zig").SYSKIND;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const TEXTMETRICW = @import("../graphics/gdi.zig").TEXTMETRICW;
const TYPEDESC = @import("../system/com.zig").TYPEDESC;
const TYPEKIND = @import("../system/com.zig").TYPEKIND;
const VARDESC = @import("../system/com.zig").VARDESC;
const VARIANT = @import("../system/com.zig").VARIANT;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPFNOLEUIHOOK")) {
        _ = LPFNOLEUIHOOK;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
