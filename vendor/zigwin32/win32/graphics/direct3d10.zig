//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (286)
//--------------------------------------------------------------------------------
pub const D3D10_16BIT_INDEX_STRIP_CUT_VALUE = @as(u32, 65535);
pub const D3D10_32BIT_INDEX_STRIP_CUT_VALUE = @as(u32, 4294967295);
pub const D3D10_8BIT_INDEX_STRIP_CUT_VALUE = @as(u32, 255);
pub const D3D10_ARRAY_AXIS_ADDRESS_RANGE_BIT_COUNT = @as(u32, 9);
pub const D3D10_CLIP_OR_CULL_DISTANCE_COUNT = @as(u32, 8);
pub const D3D10_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT = @as(u32, 2);
pub const D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT = @as(u32, 14);
pub const D3D10_COMMONSHADER_CONSTANT_BUFFER_COMPONENTS = @as(u32, 4);
pub const D3D10_COMMONSHADER_CONSTANT_BUFFER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_COMMONSHADER_CONSTANT_BUFFER_HW_SLOT_COUNT = @as(u32, 15);
pub const D3D10_COMMONSHADER_CONSTANT_BUFFER_REGISTER_COMPONENTS = @as(u32, 4);
pub const D3D10_COMMONSHADER_CONSTANT_BUFFER_REGISTER_COUNT = @as(u32, 15);
pub const D3D10_COMMONSHADER_CONSTANT_BUFFER_REGISTER_READS_PER_INST = @as(u32, 1);
pub const D3D10_COMMONSHADER_CONSTANT_BUFFER_REGISTER_READ_PORTS = @as(u32, 1);
pub const D3D10_COMMONSHADER_FLOWCONTROL_NESTING_LIMIT = @as(u32, 64);
pub const D3D10_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_COMPONENTS = @as(u32, 4);
pub const D3D10_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_COUNT = @as(u32, 1);
pub const D3D10_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_READS_PER_INST = @as(u32, 1);
pub const D3D10_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_READ_PORTS = @as(u32, 1);
pub const D3D10_COMMONSHADER_IMMEDIATE_VALUE_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_COMMONSHADER_INPUT_RESOURCE_REGISTER_COMPONENTS = @as(u32, 1);
pub const D3D10_COMMONSHADER_INPUT_RESOURCE_REGISTER_COUNT = @as(u32, 128);
pub const D3D10_COMMONSHADER_INPUT_RESOURCE_REGISTER_READS_PER_INST = @as(u32, 1);
pub const D3D10_COMMONSHADER_INPUT_RESOURCE_REGISTER_READ_PORTS = @as(u32, 1);
pub const D3D10_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT = @as(u32, 128);
pub const D3D10_COMMONSHADER_SAMPLER_REGISTER_COMPONENTS = @as(u32, 1);
pub const D3D10_COMMONSHADER_SAMPLER_REGISTER_COUNT = @as(u32, 16);
pub const D3D10_COMMONSHADER_SAMPLER_REGISTER_READS_PER_INST = @as(u32, 1);
pub const D3D10_COMMONSHADER_SAMPLER_REGISTER_READ_PORTS = @as(u32, 1);
pub const D3D10_COMMONSHADER_SAMPLER_SLOT_COUNT = @as(u32, 16);
pub const D3D10_COMMONSHADER_SUBROUTINE_NESTING_LIMIT = @as(u32, 32);
pub const D3D10_COMMONSHADER_TEMP_REGISTER_COMPONENTS = @as(u32, 4);
pub const D3D10_COMMONSHADER_TEMP_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_COMMONSHADER_TEMP_REGISTER_COUNT = @as(u32, 4096);
pub const D3D10_COMMONSHADER_TEMP_REGISTER_READS_PER_INST = @as(u32, 3);
pub const D3D10_COMMONSHADER_TEMP_REGISTER_READ_PORTS = @as(u32, 3);
pub const D3D10_COMMONSHADER_TEXCOORD_RANGE_REDUCTION_MAX = @as(u32, 10);
pub const D3D10_COMMONSHADER_TEXCOORD_RANGE_REDUCTION_MIN = @as(i32, -10);
pub const D3D10_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE = @as(i32, -8);
pub const D3D10_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE = @as(u32, 7);
pub const D3D10_DEFAULT_BLEND_FACTOR_ALPHA = @as(f32, 1);
pub const D3D10_DEFAULT_BLEND_FACTOR_BLUE = @as(f32, 1);
pub const D3D10_DEFAULT_BLEND_FACTOR_GREEN = @as(f32, 1);
pub const D3D10_DEFAULT_BLEND_FACTOR_RED = @as(f32, 1);
pub const D3D10_DEFAULT_BORDER_COLOR_COMPONENT = @as(f32, 0);
pub const D3D10_DEFAULT_DEPTH_BIAS = @as(u32, 0);
pub const D3D10_DEFAULT_DEPTH_BIAS_CLAMP = @as(f32, 0);
pub const D3D10_DEFAULT_MAX_ANISOTROPY = @as(f32, 16);
pub const D3D10_DEFAULT_MIP_LOD_BIAS = @as(f32, 0);
pub const D3D10_DEFAULT_RENDER_TARGET_ARRAY_INDEX = @as(u32, 0);
pub const D3D10_DEFAULT_SAMPLE_MASK = @as(u32, 4294967295);
pub const D3D10_DEFAULT_SCISSOR_ENDX = @as(u32, 0);
pub const D3D10_DEFAULT_SCISSOR_ENDY = @as(u32, 0);
pub const D3D10_DEFAULT_SCISSOR_STARTX = @as(u32, 0);
pub const D3D10_DEFAULT_SCISSOR_STARTY = @as(u32, 0);
pub const D3D10_DEFAULT_SLOPE_SCALED_DEPTH_BIAS = @as(f32, 0);
pub const D3D10_DEFAULT_STENCIL_READ_MASK = @as(u32, 255);
pub const D3D10_DEFAULT_STENCIL_REFERENCE = @as(u32, 0);
pub const D3D10_DEFAULT_STENCIL_WRITE_MASK = @as(u32, 255);
pub const D3D10_DEFAULT_VIEWPORT_AND_SCISSORRECT_INDEX = @as(u32, 0);
pub const D3D10_DEFAULT_VIEWPORT_HEIGHT = @as(u32, 0);
pub const D3D10_DEFAULT_VIEWPORT_MAX_DEPTH = @as(f32, 0);
pub const D3D10_DEFAULT_VIEWPORT_MIN_DEPTH = @as(f32, 0);
pub const D3D10_DEFAULT_VIEWPORT_TOPLEFTX = @as(u32, 0);
pub const D3D10_DEFAULT_VIEWPORT_TOPLEFTY = @as(u32, 0);
pub const D3D10_DEFAULT_VIEWPORT_WIDTH = @as(u32, 0);
pub const D3D10_FLOAT16_FUSED_TOLERANCE_IN_ULP = @as(f64, 6.0e-01);
pub const D3D10_FLOAT32_MAX = @as(f32, 3.4028235e+38);
pub const D3D10_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP = @as(f32, 6.0e-01);
pub const D3D10_FLOAT_TO_SRGB_EXPONENT_DENOMINATOR = @as(f32, 2.4e+00);
pub const D3D10_FLOAT_TO_SRGB_EXPONENT_NUMERATOR = @as(f32, 1);
pub const D3D10_FLOAT_TO_SRGB_OFFSET = @as(f32, 5.5e-02);
pub const D3D10_FLOAT_TO_SRGB_SCALE_1 = @as(f32, 1.292e+01);
pub const D3D10_FLOAT_TO_SRGB_SCALE_2 = @as(f32, 1.055e+00);
pub const D3D10_FLOAT_TO_SRGB_THRESHOLD = @as(f32, 3.1308e-03);
pub const D3D10_FTOI_INSTRUCTION_MAX_INPUT = @as(f32, 2.1474836e+09);
pub const D3D10_FTOI_INSTRUCTION_MIN_INPUT = @as(f32, -2.1474836e+09);
pub const D3D10_FTOU_INSTRUCTION_MAX_INPUT = @as(f32, 4.2949673e+09);
pub const D3D10_FTOU_INSTRUCTION_MIN_INPUT = @as(f32, 0);
pub const D3D10_GS_INPUT_PRIM_CONST_REGISTER_COMPONENTS = @as(u32, 1);
pub const D3D10_GS_INPUT_PRIM_CONST_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_GS_INPUT_PRIM_CONST_REGISTER_COUNT = @as(u32, 1);
pub const D3D10_GS_INPUT_PRIM_CONST_REGISTER_READS_PER_INST = @as(u32, 2);
pub const D3D10_GS_INPUT_PRIM_CONST_REGISTER_READ_PORTS = @as(u32, 1);
pub const D3D10_GS_INPUT_REGISTER_COMPONENTS = @as(u32, 4);
pub const D3D10_GS_INPUT_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_GS_INPUT_REGISTER_COUNT = @as(u32, 16);
pub const D3D10_GS_INPUT_REGISTER_READS_PER_INST = @as(u32, 2);
pub const D3D10_GS_INPUT_REGISTER_READ_PORTS = @as(u32, 1);
pub const D3D10_GS_INPUT_REGISTER_VERTICES = @as(u32, 6);
pub const D3D10_GS_OUTPUT_ELEMENTS = @as(u32, 32);
pub const D3D10_GS_OUTPUT_REGISTER_COMPONENTS = @as(u32, 4);
pub const D3D10_GS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_GS_OUTPUT_REGISTER_COUNT = @as(u32, 32);
pub const D3D10_IA_DEFAULT_INDEX_BUFFER_OFFSET_IN_BYTES = @as(u32, 0);
pub const D3D10_IA_DEFAULT_PRIMITIVE_TOPOLOGY = @as(u32, 0);
pub const D3D10_IA_DEFAULT_VERTEX_BUFFER_OFFSET_IN_BYTES = @as(u32, 0);
pub const D3D10_IA_INDEX_INPUT_RESOURCE_SLOT_COUNT = @as(u32, 1);
pub const D3D10_IA_INSTANCE_ID_BIT_COUNT = @as(u32, 32);
pub const D3D10_IA_INTEGER_ARITHMETIC_BIT_COUNT = @as(u32, 32);
pub const D3D10_IA_PRIMITIVE_ID_BIT_COUNT = @as(u32, 32);
pub const D3D10_IA_VERTEX_ID_BIT_COUNT = @as(u32, 32);
pub const D3D10_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT = @as(u32, 16);
pub const D3D10_IA_VERTEX_INPUT_STRUCTURE_ELEMENTS_COMPONENTS = @as(u32, 64);
pub const D3D10_IA_VERTEX_INPUT_STRUCTURE_ELEMENT_COUNT = @as(u32, 16);
pub const D3D10_INTEGER_DIVIDE_BY_ZERO_QUOTIENT = @as(u32, 4294967295);
pub const D3D10_INTEGER_DIVIDE_BY_ZERO_REMAINDER = @as(u32, 4294967295);
pub const D3D10_LINEAR_GAMMA = @as(f32, 1);
pub const D3D10_MAX_BORDER_COLOR_COMPONENT = @as(f32, 1);
pub const D3D10_MAX_DEPTH = @as(f32, 1);
pub const D3D10_MAX_MAXANISOTROPY = @as(u32, 16);
pub const D3D10_MAX_MULTISAMPLE_SAMPLE_COUNT = @as(u32, 32);
pub const D3D10_MAX_POSITION_VALUE = @as(f32, 3.4028236e+34);
pub const D3D10_MAX_TEXTURE_DIMENSION_2_TO_EXP = @as(u32, 17);
pub const D3D10_MIN_BORDER_COLOR_COMPONENT = @as(f32, 0);
pub const D3D10_MIN_DEPTH = @as(f32, 0);
pub const D3D10_MIN_MAXANISOTROPY = @as(u32, 0);
pub const D3D10_MIP_LOD_BIAS_MAX = @as(f32, 1.599e+01);
pub const D3D10_MIP_LOD_BIAS_MIN = @as(f32, -16);
pub const D3D10_MIP_LOD_FRACTIONAL_BIT_COUNT = @as(u32, 6);
pub const D3D10_MIP_LOD_RANGE_BIT_COUNT = @as(u32, 8);
pub const D3D10_MULTISAMPLE_ANTIALIAS_LINE_WIDTH = @as(f32, 1.4e+00);
pub const D3D10_NONSAMPLE_FETCH_OUT_OF_RANGE_ACCESS_RESULT = @as(u32, 0);
pub const D3D10_PIXEL_ADDRESS_RANGE_BIT_COUNT = @as(u32, 13);
pub const D3D10_PRE_SCISSOR_PIXEL_ADDRESS_RANGE_BIT_COUNT = @as(u32, 15);
pub const D3D10_PS_FRONTFACING_DEFAULT_VALUE = @as(u32, 4294967295);
pub const D3D10_PS_FRONTFACING_FALSE_VALUE = @as(u32, 0);
pub const D3D10_PS_FRONTFACING_TRUE_VALUE = @as(u32, 4294967295);
pub const D3D10_PS_INPUT_REGISTER_COMPONENTS = @as(u32, 4);
pub const D3D10_PS_INPUT_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_PS_INPUT_REGISTER_COUNT = @as(u32, 32);
pub const D3D10_PS_INPUT_REGISTER_READS_PER_INST = @as(u32, 2);
pub const D3D10_PS_INPUT_REGISTER_READ_PORTS = @as(u32, 1);
pub const D3D10_PS_LEGACY_PIXEL_CENTER_FRACTIONAL_COMPONENT = @as(f32, 0);
pub const D3D10_PS_OUTPUT_DEPTH_REGISTER_COMPONENTS = @as(u32, 1);
pub const D3D10_PS_OUTPUT_DEPTH_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_PS_OUTPUT_DEPTH_REGISTER_COUNT = @as(u32, 1);
pub const D3D10_PS_OUTPUT_REGISTER_COMPONENTS = @as(u32, 4);
pub const D3D10_PS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_PS_OUTPUT_REGISTER_COUNT = @as(u32, 8);
pub const D3D10_PS_PIXEL_CENTER_FRACTIONAL_COMPONENT = @as(f32, 5.0e-01);
pub const D3D10_REQ_BLEND_OBJECT_COUNT_PER_CONTEXT = @as(u32, 4096);
pub const D3D10_REQ_BUFFER_RESOURCE_TEXEL_COUNT_2_TO_EXP = @as(u32, 27);
pub const D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT = @as(u32, 4096);
pub const D3D10_REQ_DEPTH_STENCIL_OBJECT_COUNT_PER_CONTEXT = @as(u32, 4096);
pub const D3D10_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP = @as(u32, 32);
pub const D3D10_REQ_DRAW_VERTEX_COUNT_2_TO_EXP = @as(u32, 32);
pub const D3D10_REQ_FILTERING_HW_ADDRESSABLE_RESOURCE_DIMENSION = @as(u32, 8192);
pub const D3D10_REQ_GS_INVOCATION_32BIT_OUTPUT_COMPONENT_LIMIT = @as(u32, 1024);
pub const D3D10_REQ_IMMEDIATE_CONSTANT_BUFFER_ELEMENT_COUNT = @as(u32, 4096);
pub const D3D10_REQ_MAXANISOTROPY = @as(u32, 16);
pub const D3D10_REQ_MIP_LEVELS = @as(u32, 14);
pub const D3D10_REQ_MULTI_ELEMENT_STRUCTURE_SIZE_IN_BYTES = @as(u32, 2048);
pub const D3D10_REQ_RASTERIZER_OBJECT_COUNT_PER_CONTEXT = @as(u32, 4096);
pub const D3D10_REQ_RENDER_TO_BUFFER_WINDOW_WIDTH = @as(u32, 8192);
pub const D3D10_REQ_RESOURCE_SIZE_IN_MEGABYTES = @as(u32, 128);
pub const D3D10_REQ_RESOURCE_VIEW_COUNT_PER_CONTEXT_2_TO_EXP = @as(u32, 20);
pub const D3D10_REQ_SAMPLER_OBJECT_COUNT_PER_CONTEXT = @as(u32, 4096);
pub const D3D10_REQ_TEXTURE1D_ARRAY_AXIS_DIMENSION = @as(u32, 512);
pub const D3D10_REQ_TEXTURE1D_U_DIMENSION = @as(u32, 8192);
pub const D3D10_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION = @as(u32, 512);
pub const D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION = @as(u32, 8192);
pub const D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION = @as(u32, 2048);
pub const D3D10_REQ_TEXTURECUBE_DIMENSION = @as(u32, 8192);
pub const D3D10_RESINFO_INSTRUCTION_MISSING_COMPONENT_RETVAL = @as(u32, 0);
pub const D3D10_SHADER_MAJOR_VERSION = @as(u32, 4);
pub const D3D10_SHADER_MINOR_VERSION = @as(u32, 0);
pub const D3D10_SHIFT_INSTRUCTION_PAD_VALUE = @as(u32, 0);
pub const D3D10_SHIFT_INSTRUCTION_SHIFT_VALUE_BIT_COUNT = @as(u32, 5);
pub const D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT = @as(u32, 8);
pub const D3D10_SO_BUFFER_MAX_STRIDE_IN_BYTES = @as(u32, 2048);
pub const D3D10_SO_BUFFER_MAX_WRITE_WINDOW_IN_BYTES = @as(u32, 256);
pub const D3D10_SO_BUFFER_SLOT_COUNT = @as(u32, 4);
pub const D3D10_SO_DDI_REGISTER_INDEX_DENOTING_GAP = @as(u32, 4294967295);
pub const D3D10_SO_MULTIPLE_BUFFER_ELEMENTS_PER_BUFFER = @as(u32, 1);
pub const D3D10_SO_SINGLE_BUFFER_COMPONENT_LIMIT = @as(u32, 64);
pub const D3D10_SRGB_GAMMA = @as(f32, 2.2e+00);
pub const D3D10_SRGB_TO_FLOAT_DENOMINATOR_1 = @as(f32, 1.292e+01);
pub const D3D10_SRGB_TO_FLOAT_DENOMINATOR_2 = @as(f32, 1.055e+00);
pub const D3D10_SRGB_TO_FLOAT_EXPONENT = @as(f32, 2.4e+00);
pub const D3D10_SRGB_TO_FLOAT_OFFSET = @as(f32, 5.5e-02);
pub const D3D10_SRGB_TO_FLOAT_THRESHOLD = @as(f32, 4.045e-02);
pub const D3D10_SRGB_TO_FLOAT_TOLERANCE_IN_ULP = @as(f32, 5.0e-01);
pub const D3D10_STANDARD_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_STANDARD_COMPONENT_BIT_COUNT_DOUBLED = @as(u32, 64);
pub const D3D10_STANDARD_MAXIMUM_ELEMENT_ALIGNMENT_BYTE_MULTIPLE = @as(u32, 4);
pub const D3D10_STANDARD_PIXEL_COMPONENT_COUNT = @as(u32, 128);
pub const D3D10_STANDARD_PIXEL_ELEMENT_COUNT = @as(u32, 32);
pub const D3D10_STANDARD_VECTOR_SIZE = @as(u32, 4);
pub const D3D10_STANDARD_VERTEX_ELEMENT_COUNT = @as(u32, 16);
pub const D3D10_STANDARD_VERTEX_TOTAL_COMPONENT_COUNT = @as(u32, 64);
pub const D3D10_SUBPIXEL_FRACTIONAL_BIT_COUNT = @as(u32, 8);
pub const D3D10_SUBTEXEL_FRACTIONAL_BIT_COUNT = @as(u32, 6);
pub const D3D10_TEXEL_ADDRESS_RANGE_BIT_COUNT = @as(u32, 18);
pub const D3D10_UNBOUND_MEMORY_ACCESS_RESULT = @as(u32, 0);
pub const D3D10_VIEWPORT_AND_SCISSORRECT_MAX_INDEX = @as(u32, 15);
pub const D3D10_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE = @as(u32, 16);
pub const D3D10_VIEWPORT_BOUNDS_MAX = @as(u32, 16383);
pub const D3D10_VIEWPORT_BOUNDS_MIN = @as(i32, -16384);
pub const D3D10_VS_INPUT_REGISTER_COMPONENTS = @as(u32, 4);
pub const D3D10_VS_INPUT_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_VS_INPUT_REGISTER_COUNT = @as(u32, 16);
pub const D3D10_VS_INPUT_REGISTER_READS_PER_INST = @as(u32, 2);
pub const D3D10_VS_INPUT_REGISTER_READ_PORTS = @as(u32, 1);
pub const D3D10_VS_OUTPUT_REGISTER_COMPONENTS = @as(u32, 4);
pub const D3D10_VS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_VS_OUTPUT_REGISTER_COUNT = @as(u32, 16);
pub const D3D10_WHQL_CONTEXT_COUNT_FOR_RESOURCE_LIMIT = @as(u32, 10);
pub const D3D10_WHQL_DRAWINDEXED_INDEX_COUNT_2_TO_EXP = @as(u32, 25);
pub const D3D10_WHQL_DRAW_VERTEX_COUNT_2_TO_EXP = @as(u32, 25);
pub const D3D_MAJOR_VERSION = @as(u32, 10);
pub const D3D_MINOR_VERSION = @as(u32, 0);
pub const D3D_SPEC_DATE_DAY = @as(u32, 8);
pub const D3D_SPEC_DATE_MONTH = @as(u32, 8);
pub const D3D_SPEC_DATE_YEAR = @as(u32, 2006);
pub const D3D_SPEC_VERSION = @as(f64, 1.050005e+00);
pub const D3D10_1_IA_VERTEX_INPUT_STRUCTURE_ELEMENT_COUNT = @as(u32, 16);
pub const D3D10_1_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT = @as(u32, 16);
pub const _FACD3D10 = @as(u32, 2169);
pub const D3D10_APPEND_ALIGNED_ELEMENT = @as(u32, 4294967295);
pub const D3D10_FILTER_TYPE_MASK = @as(u32, 3);
pub const D3D10_MIN_FILTER_SHIFT = @as(u32, 4);
pub const D3D10_MAG_FILTER_SHIFT = @as(u32, 2);
pub const D3D10_MIP_FILTER_SHIFT = @as(u32, 0);
pub const D3D10_COMPARISON_FILTERING_BIT = @as(u32, 128);
pub const D3D10_ANISOTROPIC_FILTERING_BIT = @as(u32, 64);
pub const D3D10_TEXT_1BIT_BIT = @as(u32, 2147483648);
pub const D3D10_SDK_VERSION = @as(u32, 29);
pub const D3D10_1_DEFAULT_SAMPLE_MASK = @as(u32, 4294967295);
pub const D3D10_1_FLOAT16_FUSED_TOLERANCE_IN_ULP = @as(f64, 6.0e-01);
pub const D3D10_1_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP = @as(f32, 6.0e-01);
pub const D3D10_1_GS_INPUT_REGISTER_COUNT = @as(u32, 32);
pub const D3D10_1_IA_VERTEX_INPUT_STRUCTURE_ELEMENTS_COMPONENTS = @as(u32, 128);
pub const D3D10_1_PS_OUTPUT_MASK_REGISTER_COMPONENTS = @as(u32, 1);
pub const D3D10_1_PS_OUTPUT_MASK_REGISTER_COMPONENT_BIT_COUNT = @as(u32, 32);
pub const D3D10_1_PS_OUTPUT_MASK_REGISTER_COUNT = @as(u32, 1);
pub const D3D10_1_SHADER_MAJOR_VERSION = @as(u32, 4);
pub const D3D10_1_SHADER_MINOR_VERSION = @as(u32, 1);
pub const D3D10_1_SO_BUFFER_MAX_STRIDE_IN_BYTES = @as(u32, 2048);
pub const D3D10_1_SO_BUFFER_MAX_WRITE_WINDOW_IN_BYTES = @as(u32, 256);
pub const D3D10_1_SO_BUFFER_SLOT_COUNT = @as(u32, 4);
pub const D3D10_1_SO_MULTIPLE_BUFFER_ELEMENTS_PER_BUFFER = @as(u32, 1);
pub const D3D10_1_SO_SINGLE_BUFFER_COMPONENT_LIMIT = @as(u32, 64);
pub const D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT = @as(u32, 32);
pub const D3D10_1_SUBPIXEL_FRACTIONAL_BIT_COUNT = @as(u32, 8);
pub const D3D10_1_VS_INPUT_REGISTER_COUNT = @as(u32, 32);
pub const D3D10_1_VS_OUTPUT_REGISTER_COUNT = @as(u32, 32);
pub const D3D10_SDK_LAYERS_VERSION = @as(u32, 11);
pub const D3D10_DEBUG_FEATURE_FLUSH_PER_RENDER_OP = @as(u32, 1);
pub const D3D10_DEBUG_FEATURE_FINISH_PER_RENDER_OP = @as(u32, 2);
pub const D3D10_DEBUG_FEATURE_PRESENT_PER_RENDER_OP = @as(u32, 4);
pub const DXGI_DEBUG_D3D10 = Guid.initString("243b4c52-3606-4d3a-99d7-a7e7b33ed706");
pub const D3D10_INFO_QUEUE_DEFAULT_MESSAGE_COUNT_LIMIT = @as(u32, 1024);
pub const D3D10_SHADER_DEBUG = @as(u32, 1);
pub const D3D10_SHADER_SKIP_VALIDATION = @as(u32, 2);
pub const D3D10_SHADER_SKIP_OPTIMIZATION = @as(u32, 4);
pub const D3D10_SHADER_PACK_MATRIX_ROW_MAJOR = @as(u32, 8);
pub const D3D10_SHADER_PACK_MATRIX_COLUMN_MAJOR = @as(u32, 16);
pub const D3D10_SHADER_PARTIAL_PRECISION = @as(u32, 32);
pub const D3D10_SHADER_FORCE_VS_SOFTWARE_NO_OPT = @as(u32, 64);
pub const D3D10_SHADER_FORCE_PS_SOFTWARE_NO_OPT = @as(u32, 128);
pub const D3D10_SHADER_NO_PRESHADER = @as(u32, 256);
pub const D3D10_SHADER_AVOID_FLOW_CONTROL = @as(u32, 512);
pub const D3D10_SHADER_PREFER_FLOW_CONTROL = @as(u32, 1024);
pub const D3D10_SHADER_ENABLE_STRICTNESS = @as(u32, 2048);
pub const D3D10_SHADER_ENABLE_BACKWARDS_COMPATIBILITY = @as(u32, 4096);
pub const D3D10_SHADER_IEEE_STRICTNESS = @as(u32, 8192);
pub const D3D10_SHADER_WARNINGS_ARE_ERRORS = @as(u32, 262144);
pub const D3D10_SHADER_RESOURCES_MAY_ALIAS = @as(u32, 524288);
pub const D3D10_ENABLE_UNBOUNDED_DESCRIPTOR_TABLES = @as(u32, 1048576);
pub const D3D10_ALL_RESOURCES_BOUND = @as(u32, 2097152);
pub const D3D10_SHADER_DEBUG_NAME_FOR_SOURCE = @as(u32, 4194304);
pub const D3D10_SHADER_DEBUG_NAME_FOR_BINARY = @as(u32, 8388608);
pub const D3D10_SHADER_OPTIMIZATION_LEVEL0 = @as(u32, 16384);
pub const D3D10_SHADER_OPTIMIZATION_LEVEL1 = @as(u32, 0);
pub const D3D10_SHADER_OPTIMIZATION_LEVEL3 = @as(u32, 32768);
pub const D3D10_SHADER_FLAGS2_FORCE_ROOT_SIGNATURE_LATEST = @as(u32, 0);
pub const D3D10_SHADER_FLAGS2_FORCE_ROOT_SIGNATURE_1_0 = @as(u32, 16);
pub const D3D10_SHADER_FLAGS2_FORCE_ROOT_SIGNATURE_1_1 = @as(u32, 32);
pub const D3D10_EFFECT_COMPILE_CHILD_EFFECT = @as(u32, 1);
pub const D3D10_EFFECT_COMPILE_ALLOW_SLOW_OPS = @as(u32, 2);
pub const D3D10_EFFECT_SINGLE_THREADED = @as(u32, 8);
pub const D3D10_EFFECT_VARIABLE_POOLED = @as(u32, 1);
pub const D3D10_EFFECT_VARIABLE_ANNOTATION = @as(u32, 2);
pub const D3D10_EFFECT_VARIABLE_EXPLICIT_BIND_POINT = @as(u32, 4);
pub const GUID_DeviceType = Guid.initString("d722fb4d-7a68-437a-b20c-5804ee2494a6");

//--------------------------------------------------------------------------------
// Section: Types (177)
//--------------------------------------------------------------------------------
pub const D3D10_INPUT_CLASSIFICATION = enum(i32) {
    VERTEX_DATA = 0,
    INSTANCE_DATA = 1,
};
pub const D3D10_INPUT_PER_VERTEX_DATA = D3D10_INPUT_CLASSIFICATION.VERTEX_DATA;
pub const D3D10_INPUT_PER_INSTANCE_DATA = D3D10_INPUT_CLASSIFICATION.INSTANCE_DATA;

pub const D3D10_INPUT_ELEMENT_DESC = extern struct {
    SemanticName: ?[*:0]const u8,
    SemanticIndex: u32,
    Format: DXGI_FORMAT,
    InputSlot: u32,
    AlignedByteOffset: u32,
    InputSlotClass: D3D10_INPUT_CLASSIFICATION,
    InstanceDataStepRate: u32,
};

pub const D3D10_FILL_MODE = enum(i32) {
    WIREFRAME = 2,
    SOLID = 3,
};
pub const D3D10_FILL_WIREFRAME = D3D10_FILL_MODE.WIREFRAME;
pub const D3D10_FILL_SOLID = D3D10_FILL_MODE.SOLID;

pub const D3D10_CULL_MODE = enum(i32) {
    NONE = 1,
    FRONT = 2,
    BACK = 3,
};
pub const D3D10_CULL_NONE = D3D10_CULL_MODE.NONE;
pub const D3D10_CULL_FRONT = D3D10_CULL_MODE.FRONT;
pub const D3D10_CULL_BACK = D3D10_CULL_MODE.BACK;

pub const D3D10_SO_DECLARATION_ENTRY = extern struct {
    SemanticName: ?[*:0]const u8,
    SemanticIndex: u32,
    StartComponent: u8,
    ComponentCount: u8,
    OutputSlot: u8,
};

pub const D3D10_VIEWPORT = extern struct {
    TopLeftX: i32,
    TopLeftY: i32,
    Width: u32,
    Height: u32,
    MinDepth: f32,
    MaxDepth: f32,
};

pub const D3D10_RESOURCE_DIMENSION = enum(i32) {
    UNKNOWN = 0,
    BUFFER = 1,
    TEXTURE1D = 2,
    TEXTURE2D = 3,
    TEXTURE3D = 4,
};
pub const D3D10_RESOURCE_DIMENSION_UNKNOWN = D3D10_RESOURCE_DIMENSION.UNKNOWN;
pub const D3D10_RESOURCE_DIMENSION_BUFFER = D3D10_RESOURCE_DIMENSION.BUFFER;
pub const D3D10_RESOURCE_DIMENSION_TEXTURE1D = D3D10_RESOURCE_DIMENSION.TEXTURE1D;
pub const D3D10_RESOURCE_DIMENSION_TEXTURE2D = D3D10_RESOURCE_DIMENSION.TEXTURE2D;
pub const D3D10_RESOURCE_DIMENSION_TEXTURE3D = D3D10_RESOURCE_DIMENSION.TEXTURE3D;

pub const D3D10_DSV_DIMENSION = enum(i32) {
    UNKNOWN = 0,
    TEXTURE1D = 1,
    TEXTURE1DARRAY = 2,
    TEXTURE2D = 3,
    TEXTURE2DARRAY = 4,
    TEXTURE2DMS = 5,
    TEXTURE2DMSARRAY = 6,
};
pub const D3D10_DSV_DIMENSION_UNKNOWN = D3D10_DSV_DIMENSION.UNKNOWN;
pub const D3D10_DSV_DIMENSION_TEXTURE1D = D3D10_DSV_DIMENSION.TEXTURE1D;
pub const D3D10_DSV_DIMENSION_TEXTURE1DARRAY = D3D10_DSV_DIMENSION.TEXTURE1DARRAY;
pub const D3D10_DSV_DIMENSION_TEXTURE2D = D3D10_DSV_DIMENSION.TEXTURE2D;
pub const D3D10_DSV_DIMENSION_TEXTURE2DARRAY = D3D10_DSV_DIMENSION.TEXTURE2DARRAY;
pub const D3D10_DSV_DIMENSION_TEXTURE2DMS = D3D10_DSV_DIMENSION.TEXTURE2DMS;
pub const D3D10_DSV_DIMENSION_TEXTURE2DMSARRAY = D3D10_DSV_DIMENSION.TEXTURE2DMSARRAY;

pub const D3D10_RTV_DIMENSION = enum(i32) {
    UNKNOWN = 0,
    BUFFER = 1,
    TEXTURE1D = 2,
    TEXTURE1DARRAY = 3,
    TEXTURE2D = 4,
    TEXTURE2DARRAY = 5,
    TEXTURE2DMS = 6,
    TEXTURE2DMSARRAY = 7,
    TEXTURE3D = 8,
};
pub const D3D10_RTV_DIMENSION_UNKNOWN = D3D10_RTV_DIMENSION.UNKNOWN;
pub const D3D10_RTV_DIMENSION_BUFFER = D3D10_RTV_DIMENSION.BUFFER;
pub const D3D10_RTV_DIMENSION_TEXTURE1D = D3D10_RTV_DIMENSION.TEXTURE1D;
pub const D3D10_RTV_DIMENSION_TEXTURE1DARRAY = D3D10_RTV_DIMENSION.TEXTURE1DARRAY;
pub const D3D10_RTV_DIMENSION_TEXTURE2D = D3D10_RTV_DIMENSION.TEXTURE2D;
pub const D3D10_RTV_DIMENSION_TEXTURE2DARRAY = D3D10_RTV_DIMENSION.TEXTURE2DARRAY;
pub const D3D10_RTV_DIMENSION_TEXTURE2DMS = D3D10_RTV_DIMENSION.TEXTURE2DMS;
pub const D3D10_RTV_DIMENSION_TEXTURE2DMSARRAY = D3D10_RTV_DIMENSION.TEXTURE2DMSARRAY;
pub const D3D10_RTV_DIMENSION_TEXTURE3D = D3D10_RTV_DIMENSION.TEXTURE3D;

pub const D3D10_USAGE = enum(i32) {
    DEFAULT = 0,
    IMMUTABLE = 1,
    DYNAMIC = 2,
    STAGING = 3,
};
pub const D3D10_USAGE_DEFAULT = D3D10_USAGE.DEFAULT;
pub const D3D10_USAGE_IMMUTABLE = D3D10_USAGE.IMMUTABLE;
pub const D3D10_USAGE_DYNAMIC = D3D10_USAGE.DYNAMIC;
pub const D3D10_USAGE_STAGING = D3D10_USAGE.STAGING;

pub const D3D10_BIND_FLAG = enum(i32) {
    VERTEX_BUFFER = 1,
    INDEX_BUFFER = 2,
    CONSTANT_BUFFER = 4,
    SHADER_RESOURCE = 8,
    STREAM_OUTPUT = 16,
    RENDER_TARGET = 32,
    DEPTH_STENCIL = 64,
};
pub const D3D10_BIND_VERTEX_BUFFER = D3D10_BIND_FLAG.VERTEX_BUFFER;
pub const D3D10_BIND_INDEX_BUFFER = D3D10_BIND_FLAG.INDEX_BUFFER;
pub const D3D10_BIND_CONSTANT_BUFFER = D3D10_BIND_FLAG.CONSTANT_BUFFER;
pub const D3D10_BIND_SHADER_RESOURCE = D3D10_BIND_FLAG.SHADER_RESOURCE;
pub const D3D10_BIND_STREAM_OUTPUT = D3D10_BIND_FLAG.STREAM_OUTPUT;
pub const D3D10_BIND_RENDER_TARGET = D3D10_BIND_FLAG.RENDER_TARGET;
pub const D3D10_BIND_DEPTH_STENCIL = D3D10_BIND_FLAG.DEPTH_STENCIL;

pub const D3D10_CPU_ACCESS_FLAG = enum(i32) {
    WRITE = 65536,
    READ = 131072,
};
pub const D3D10_CPU_ACCESS_WRITE = D3D10_CPU_ACCESS_FLAG.WRITE;
pub const D3D10_CPU_ACCESS_READ = D3D10_CPU_ACCESS_FLAG.READ;

pub const D3D10_RESOURCE_MISC_FLAG = enum(i32) {
    GENERATE_MIPS = 1,
    SHARED = 2,
    TEXTURECUBE = 4,
    SHARED_KEYEDMUTEX = 16,
    GDI_COMPATIBLE = 32,
};
pub const D3D10_RESOURCE_MISC_GENERATE_MIPS = D3D10_RESOURCE_MISC_FLAG.GENERATE_MIPS;
pub const D3D10_RESOURCE_MISC_SHARED = D3D10_RESOURCE_MISC_FLAG.SHARED;
pub const D3D10_RESOURCE_MISC_TEXTURECUBE = D3D10_RESOURCE_MISC_FLAG.TEXTURECUBE;
pub const D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX = D3D10_RESOURCE_MISC_FLAG.SHARED_KEYEDMUTEX;
pub const D3D10_RESOURCE_MISC_GDI_COMPATIBLE = D3D10_RESOURCE_MISC_FLAG.GDI_COMPATIBLE;

pub const D3D10_MAP = enum(i32) {
    READ = 1,
    WRITE = 2,
    READ_WRITE = 3,
    WRITE_DISCARD = 4,
    WRITE_NO_OVERWRITE = 5,
};
pub const D3D10_MAP_READ = D3D10_MAP.READ;
pub const D3D10_MAP_WRITE = D3D10_MAP.WRITE;
pub const D3D10_MAP_READ_WRITE = D3D10_MAP.READ_WRITE;
pub const D3D10_MAP_WRITE_DISCARD = D3D10_MAP.WRITE_DISCARD;
pub const D3D10_MAP_WRITE_NO_OVERWRITE = D3D10_MAP.WRITE_NO_OVERWRITE;

pub const D3D10_MAP_FLAG = enum(i32) {
    T = 1048576,
};
pub const D3D10_MAP_FLAG_DO_NOT_WAIT = D3D10_MAP_FLAG.T;

pub const D3D10_RAISE_FLAG = enum(i32) {
    R = 1,
};
pub const D3D10_RAISE_FLAG_DRIVER_INTERNAL_ERROR = D3D10_RAISE_FLAG.R;

pub const D3D10_CLEAR_FLAG = enum(i32) {
    DEPTH = 1,
    STENCIL = 2,
};
pub const D3D10_CLEAR_DEPTH = D3D10_CLEAR_FLAG.DEPTH;
pub const D3D10_CLEAR_STENCIL = D3D10_CLEAR_FLAG.STENCIL;

pub const D3D10_BOX = extern struct {
    left: u32,
    top: u32,
    front: u32,
    right: u32,
    bottom: u32,
    back: u32,
};

const IID_ID3D10DeviceChild_Value = Guid.initString("9b7e4c00-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10DeviceChild = &IID_ID3D10DeviceChild_Value;
pub const ID3D10DeviceChild = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10DeviceChild,
                ppDevice: ?*?*ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10DeviceChild,
                ppDevice: ?*?*ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetPrivateData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10DeviceChild,
                guid: ?*const Guid,
                pDataSize: ?*u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10DeviceChild,
                guid: ?*const Guid,
                pDataSize: ?*u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPrivateData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10DeviceChild,
                guid: ?*const Guid,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10DeviceChild,
                guid: ?*const Guid,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPrivateDataInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10DeviceChild,
                guid: ?*const Guid,
                pData: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10DeviceChild,
                guid: ?*const Guid,
                pData: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10DeviceChild_GetDevice(self: *const T, ppDevice: ?*?*ID3D10Device) callconv(.Inline) void {
            return @ptrCast(*const ID3D10DeviceChild.VTable, self.vtable).GetDevice(@ptrCast(*const ID3D10DeviceChild, self), ppDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10DeviceChild_GetPrivateData(self: *const T, guid: ?*const Guid, pDataSize: ?*u32, pData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10DeviceChild.VTable, self.vtable).GetPrivateData(@ptrCast(*const ID3D10DeviceChild, self), guid, pDataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10DeviceChild_SetPrivateData(self: *const T, guid: ?*const Guid, DataSize: u32, pData: ?*const anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10DeviceChild.VTable, self.vtable).SetPrivateData(@ptrCast(*const ID3D10DeviceChild, self), guid, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10DeviceChild_SetPrivateDataInterface(self: *const T, guid: ?*const Guid, pData: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10DeviceChild.VTable, self.vtable).SetPrivateDataInterface(@ptrCast(*const ID3D10DeviceChild, self), guid, pData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_COMPARISON_FUNC = enum(i32) {
    NEVER = 1,
    LESS = 2,
    EQUAL = 3,
    LESS_EQUAL = 4,
    GREATER = 5,
    NOT_EQUAL = 6,
    GREATER_EQUAL = 7,
    ALWAYS = 8,
};
pub const D3D10_COMPARISON_NEVER = D3D10_COMPARISON_FUNC.NEVER;
pub const D3D10_COMPARISON_LESS = D3D10_COMPARISON_FUNC.LESS;
pub const D3D10_COMPARISON_EQUAL = D3D10_COMPARISON_FUNC.EQUAL;
pub const D3D10_COMPARISON_LESS_EQUAL = D3D10_COMPARISON_FUNC.LESS_EQUAL;
pub const D3D10_COMPARISON_GREATER = D3D10_COMPARISON_FUNC.GREATER;
pub const D3D10_COMPARISON_NOT_EQUAL = D3D10_COMPARISON_FUNC.NOT_EQUAL;
pub const D3D10_COMPARISON_GREATER_EQUAL = D3D10_COMPARISON_FUNC.GREATER_EQUAL;
pub const D3D10_COMPARISON_ALWAYS = D3D10_COMPARISON_FUNC.ALWAYS;

pub const D3D10_DEPTH_WRITE_MASK = enum(i32) {
    ZERO = 0,
    ALL = 1,
};
pub const D3D10_DEPTH_WRITE_MASK_ZERO = D3D10_DEPTH_WRITE_MASK.ZERO;
pub const D3D10_DEPTH_WRITE_MASK_ALL = D3D10_DEPTH_WRITE_MASK.ALL;

pub const D3D10_STENCIL_OP = enum(i32) {
    KEEP = 1,
    ZERO = 2,
    REPLACE = 3,
    INCR_SAT = 4,
    DECR_SAT = 5,
    INVERT = 6,
    INCR = 7,
    DECR = 8,
};
pub const D3D10_STENCIL_OP_KEEP = D3D10_STENCIL_OP.KEEP;
pub const D3D10_STENCIL_OP_ZERO = D3D10_STENCIL_OP.ZERO;
pub const D3D10_STENCIL_OP_REPLACE = D3D10_STENCIL_OP.REPLACE;
pub const D3D10_STENCIL_OP_INCR_SAT = D3D10_STENCIL_OP.INCR_SAT;
pub const D3D10_STENCIL_OP_DECR_SAT = D3D10_STENCIL_OP.DECR_SAT;
pub const D3D10_STENCIL_OP_INVERT = D3D10_STENCIL_OP.INVERT;
pub const D3D10_STENCIL_OP_INCR = D3D10_STENCIL_OP.INCR;
pub const D3D10_STENCIL_OP_DECR = D3D10_STENCIL_OP.DECR;

pub const D3D10_DEPTH_STENCILOP_DESC = extern struct {
    StencilFailOp: D3D10_STENCIL_OP,
    StencilDepthFailOp: D3D10_STENCIL_OP,
    StencilPassOp: D3D10_STENCIL_OP,
    StencilFunc: D3D10_COMPARISON_FUNC,
};

pub const D3D10_DEPTH_STENCIL_DESC = extern struct {
    DepthEnable: BOOL,
    DepthWriteMask: D3D10_DEPTH_WRITE_MASK,
    DepthFunc: D3D10_COMPARISON_FUNC,
    StencilEnable: BOOL,
    StencilReadMask: u8,
    StencilWriteMask: u8,
    FrontFace: D3D10_DEPTH_STENCILOP_DESC,
    BackFace: D3D10_DEPTH_STENCILOP_DESC,
};

const IID_ID3D10DepthStencilState_Value = Guid.initString("2b4b1cc8-a4ad-41f8-8322-ca86fc3ec675");
pub const IID_ID3D10DepthStencilState = &IID_ID3D10DepthStencilState_Value;
pub const ID3D10DepthStencilState = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10DepthStencilState,
                pDesc: ?*D3D10_DEPTH_STENCIL_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10DepthStencilState,
                pDesc: ?*D3D10_DEPTH_STENCIL_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10DepthStencilState_GetDesc(self: *const T, pDesc: ?*D3D10_DEPTH_STENCIL_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10DepthStencilState.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10DepthStencilState, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_BLEND = enum(i32) {
    ZERO = 1,
    ONE = 2,
    SRC_COLOR = 3,
    INV_SRC_COLOR = 4,
    SRC_ALPHA = 5,
    INV_SRC_ALPHA = 6,
    DEST_ALPHA = 7,
    INV_DEST_ALPHA = 8,
    DEST_COLOR = 9,
    INV_DEST_COLOR = 10,
    SRC_ALPHA_SAT = 11,
    BLEND_FACTOR = 14,
    INV_BLEND_FACTOR = 15,
    SRC1_COLOR = 16,
    INV_SRC1_COLOR = 17,
    SRC1_ALPHA = 18,
    INV_SRC1_ALPHA = 19,
};
pub const D3D10_BLEND_ZERO = D3D10_BLEND.ZERO;
pub const D3D10_BLEND_ONE = D3D10_BLEND.ONE;
pub const D3D10_BLEND_SRC_COLOR = D3D10_BLEND.SRC_COLOR;
pub const D3D10_BLEND_INV_SRC_COLOR = D3D10_BLEND.INV_SRC_COLOR;
pub const D3D10_BLEND_SRC_ALPHA = D3D10_BLEND.SRC_ALPHA;
pub const D3D10_BLEND_INV_SRC_ALPHA = D3D10_BLEND.INV_SRC_ALPHA;
pub const D3D10_BLEND_DEST_ALPHA = D3D10_BLEND.DEST_ALPHA;
pub const D3D10_BLEND_INV_DEST_ALPHA = D3D10_BLEND.INV_DEST_ALPHA;
pub const D3D10_BLEND_DEST_COLOR = D3D10_BLEND.DEST_COLOR;
pub const D3D10_BLEND_INV_DEST_COLOR = D3D10_BLEND.INV_DEST_COLOR;
pub const D3D10_BLEND_SRC_ALPHA_SAT = D3D10_BLEND.SRC_ALPHA_SAT;
pub const D3D10_BLEND_BLEND_FACTOR = D3D10_BLEND.BLEND_FACTOR;
pub const D3D10_BLEND_INV_BLEND_FACTOR = D3D10_BLEND.INV_BLEND_FACTOR;
pub const D3D10_BLEND_SRC1_COLOR = D3D10_BLEND.SRC1_COLOR;
pub const D3D10_BLEND_INV_SRC1_COLOR = D3D10_BLEND.INV_SRC1_COLOR;
pub const D3D10_BLEND_SRC1_ALPHA = D3D10_BLEND.SRC1_ALPHA;
pub const D3D10_BLEND_INV_SRC1_ALPHA = D3D10_BLEND.INV_SRC1_ALPHA;

pub const D3D10_BLEND_OP = enum(i32) {
    ADD = 1,
    SUBTRACT = 2,
    REV_SUBTRACT = 3,
    MIN = 4,
    MAX = 5,
};
pub const D3D10_BLEND_OP_ADD = D3D10_BLEND_OP.ADD;
pub const D3D10_BLEND_OP_SUBTRACT = D3D10_BLEND_OP.SUBTRACT;
pub const D3D10_BLEND_OP_REV_SUBTRACT = D3D10_BLEND_OP.REV_SUBTRACT;
pub const D3D10_BLEND_OP_MIN = D3D10_BLEND_OP.MIN;
pub const D3D10_BLEND_OP_MAX = D3D10_BLEND_OP.MAX;

pub const D3D10_COLOR_WRITE_ENABLE = enum(i32) {
    RED = 1,
    GREEN = 2,
    BLUE = 4,
    ALPHA = 8,
    ALL = 15,
};
pub const D3D10_COLOR_WRITE_ENABLE_RED = D3D10_COLOR_WRITE_ENABLE.RED;
pub const D3D10_COLOR_WRITE_ENABLE_GREEN = D3D10_COLOR_WRITE_ENABLE.GREEN;
pub const D3D10_COLOR_WRITE_ENABLE_BLUE = D3D10_COLOR_WRITE_ENABLE.BLUE;
pub const D3D10_COLOR_WRITE_ENABLE_ALPHA = D3D10_COLOR_WRITE_ENABLE.ALPHA;
pub const D3D10_COLOR_WRITE_ENABLE_ALL = D3D10_COLOR_WRITE_ENABLE.ALL;

pub const D3D10_BLEND_DESC = extern struct {
    AlphaToCoverageEnable: BOOL,
    BlendEnable: [8]BOOL,
    SrcBlend: D3D10_BLEND,
    DestBlend: D3D10_BLEND,
    BlendOp: D3D10_BLEND_OP,
    SrcBlendAlpha: D3D10_BLEND,
    DestBlendAlpha: D3D10_BLEND,
    BlendOpAlpha: D3D10_BLEND_OP,
    RenderTargetWriteMask: [8]u8,
};

const IID_ID3D10BlendState_Value = Guid.initString("edad8d19-8a35-4d6d-8566-2ea276cde161");
pub const IID_ID3D10BlendState = &IID_ID3D10BlendState_Value;
pub const ID3D10BlendState = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10BlendState,
                pDesc: ?*D3D10_BLEND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10BlendState,
                pDesc: ?*D3D10_BLEND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10BlendState_GetDesc(self: *const T, pDesc: ?*D3D10_BLEND_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10BlendState.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10BlendState, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_RASTERIZER_DESC = extern struct {
    FillMode: D3D10_FILL_MODE,
    CullMode: D3D10_CULL_MODE,
    FrontCounterClockwise: BOOL,
    DepthBias: i32,
    DepthBiasClamp: f32,
    SlopeScaledDepthBias: f32,
    DepthClipEnable: BOOL,
    ScissorEnable: BOOL,
    MultisampleEnable: BOOL,
    AntialiasedLineEnable: BOOL,
};

const IID_ID3D10RasterizerState_Value = Guid.initString("a2a07292-89af-4345-be2e-c53d9fbb6e9f");
pub const IID_ID3D10RasterizerState = &IID_ID3D10RasterizerState_Value;
pub const ID3D10RasterizerState = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10RasterizerState,
                pDesc: ?*D3D10_RASTERIZER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10RasterizerState,
                pDesc: ?*D3D10_RASTERIZER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10RasterizerState_GetDesc(self: *const T, pDesc: ?*D3D10_RASTERIZER_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10RasterizerState.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10RasterizerState, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_SUBRESOURCE_DATA = extern struct {
    pSysMem: ?*const anyopaque,
    SysMemPitch: u32,
    SysMemSlicePitch: u32,
};

const IID_ID3D10Resource_Value = Guid.initString("9b7e4c01-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Resource = &IID_ID3D10Resource_Value;
pub const ID3D10Resource = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Resource,
                rType: ?*D3D10_RESOURCE_DIMENSION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Resource,
                rType: ?*D3D10_RESOURCE_DIMENSION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetEvictionPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Resource,
                EvictionPriority: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Resource,
                EvictionPriority: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetEvictionPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Resource,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID3D10Resource,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Resource_GetType(self: *const T, rType: ?*D3D10_RESOURCE_DIMENSION) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Resource.VTable, self.vtable).GetType(@ptrCast(*const ID3D10Resource, self), rType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Resource_SetEvictionPriority(self: *const T, EvictionPriority: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Resource.VTable, self.vtable).SetEvictionPriority(@ptrCast(*const ID3D10Resource, self), EvictionPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Resource_GetEvictionPriority(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D10Resource.VTable, self.vtable).GetEvictionPriority(@ptrCast(*const ID3D10Resource, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_BUFFER_DESC = extern struct {
    ByteWidth: u32,
    Usage: D3D10_USAGE,
    BindFlags: u32,
    CPUAccessFlags: u32,
    MiscFlags: u32,
};

const IID_ID3D10Buffer_Value = Guid.initString("9b7e4c02-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Buffer = &IID_ID3D10Buffer_Value;
pub const ID3D10Buffer = extern struct {
    pub const VTable = extern struct {
        base: ID3D10Resource.VTable,
        Map: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Buffer,
                MapType: D3D10_MAP,
                MapFlags: u32,
                ppData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Buffer,
                MapType: D3D10_MAP,
                MapFlags: u32,
                ppData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Buffer,
                pDesc: ?*D3D10_BUFFER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Buffer,
                pDesc: ?*D3D10_BUFFER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Buffer_Map(self: *const T, MapType: D3D10_MAP, MapFlags: u32, ppData: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Buffer.VTable, self.vtable).Map(@ptrCast(*const ID3D10Buffer, self), MapType, MapFlags, ppData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Buffer_Unmap(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Buffer.VTable, self.vtable).Unmap(@ptrCast(*const ID3D10Buffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Buffer_GetDesc(self: *const T, pDesc: ?*D3D10_BUFFER_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Buffer.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10Buffer, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_TEXTURE1D_DESC = extern struct {
    Width: u32,
    MipLevels: u32,
    ArraySize: u32,
    Format: DXGI_FORMAT,
    Usage: D3D10_USAGE,
    BindFlags: u32,
    CPUAccessFlags: u32,
    MiscFlags: u32,
};

const IID_ID3D10Texture1D_Value = Guid.initString("9b7e4c03-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Texture1D = &IID_ID3D10Texture1D_Value;
pub const ID3D10Texture1D = extern struct {
    pub const VTable = extern struct {
        base: ID3D10Resource.VTable,
        Map: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Texture1D,
                Subresource: u32,
                MapType: D3D10_MAP,
                MapFlags: u32,
                ppData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Texture1D,
                Subresource: u32,
                MapType: D3D10_MAP,
                MapFlags: u32,
                ppData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Texture1D,
                Subresource: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Texture1D,
                Subresource: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Texture1D,
                pDesc: ?*D3D10_TEXTURE1D_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Texture1D,
                pDesc: ?*D3D10_TEXTURE1D_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Texture1D_Map(self: *const T, Subresource: u32, MapType: D3D10_MAP, MapFlags: u32, ppData: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Texture1D.VTable, self.vtable).Map(@ptrCast(*const ID3D10Texture1D, self), Subresource, MapType, MapFlags, ppData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Texture1D_Unmap(self: *const T, Subresource: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Texture1D.VTable, self.vtable).Unmap(@ptrCast(*const ID3D10Texture1D, self), Subresource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Texture1D_GetDesc(self: *const T, pDesc: ?*D3D10_TEXTURE1D_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Texture1D.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10Texture1D, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_TEXTURE2D_DESC = extern struct {
    Width: u32,
    Height: u32,
    MipLevels: u32,
    ArraySize: u32,
    Format: DXGI_FORMAT,
    SampleDesc: DXGI_SAMPLE_DESC,
    Usage: D3D10_USAGE,
    BindFlags: u32,
    CPUAccessFlags: u32,
    MiscFlags: u32,
};

pub const D3D10_MAPPED_TEXTURE2D = extern struct {
    pData: ?*anyopaque,
    RowPitch: u32,
};

const IID_ID3D10Texture2D_Value = Guid.initString("9b7e4c04-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Texture2D = &IID_ID3D10Texture2D_Value;
pub const ID3D10Texture2D = extern struct {
    pub const VTable = extern struct {
        base: ID3D10Resource.VTable,
        Map: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Texture2D,
                Subresource: u32,
                MapType: D3D10_MAP,
                MapFlags: u32,
                pMappedTex2D: ?*D3D10_MAPPED_TEXTURE2D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Texture2D,
                Subresource: u32,
                MapType: D3D10_MAP,
                MapFlags: u32,
                pMappedTex2D: ?*D3D10_MAPPED_TEXTURE2D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Texture2D,
                Subresource: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Texture2D,
                Subresource: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Texture2D,
                pDesc: ?*D3D10_TEXTURE2D_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Texture2D,
                pDesc: ?*D3D10_TEXTURE2D_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Texture2D_Map(self: *const T, Subresource: u32, MapType: D3D10_MAP, MapFlags: u32, pMappedTex2D: ?*D3D10_MAPPED_TEXTURE2D) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Texture2D.VTable, self.vtable).Map(@ptrCast(*const ID3D10Texture2D, self), Subresource, MapType, MapFlags, pMappedTex2D);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Texture2D_Unmap(self: *const T, Subresource: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Texture2D.VTable, self.vtable).Unmap(@ptrCast(*const ID3D10Texture2D, self), Subresource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Texture2D_GetDesc(self: *const T, pDesc: ?*D3D10_TEXTURE2D_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Texture2D.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10Texture2D, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_TEXTURE3D_DESC = extern struct {
    Width: u32,
    Height: u32,
    Depth: u32,
    MipLevels: u32,
    Format: DXGI_FORMAT,
    Usage: D3D10_USAGE,
    BindFlags: u32,
    CPUAccessFlags: u32,
    MiscFlags: u32,
};

pub const D3D10_MAPPED_TEXTURE3D = extern struct {
    pData: ?*anyopaque,
    RowPitch: u32,
    DepthPitch: u32,
};

const IID_ID3D10Texture3D_Value = Guid.initString("9b7e4c05-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Texture3D = &IID_ID3D10Texture3D_Value;
pub const ID3D10Texture3D = extern struct {
    pub const VTable = extern struct {
        base: ID3D10Resource.VTable,
        Map: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Texture3D,
                Subresource: u32,
                MapType: D3D10_MAP,
                MapFlags: u32,
                pMappedTex3D: ?*D3D10_MAPPED_TEXTURE3D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Texture3D,
                Subresource: u32,
                MapType: D3D10_MAP,
                MapFlags: u32,
                pMappedTex3D: ?*D3D10_MAPPED_TEXTURE3D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Texture3D,
                Subresource: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Texture3D,
                Subresource: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Texture3D,
                pDesc: ?*D3D10_TEXTURE3D_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Texture3D,
                pDesc: ?*D3D10_TEXTURE3D_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Texture3D_Map(self: *const T, Subresource: u32, MapType: D3D10_MAP, MapFlags: u32, pMappedTex3D: ?*D3D10_MAPPED_TEXTURE3D) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Texture3D.VTable, self.vtable).Map(@ptrCast(*const ID3D10Texture3D, self), Subresource, MapType, MapFlags, pMappedTex3D);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Texture3D_Unmap(self: *const T, Subresource: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Texture3D.VTable, self.vtable).Unmap(@ptrCast(*const ID3D10Texture3D, self), Subresource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Texture3D_GetDesc(self: *const T, pDesc: ?*D3D10_TEXTURE3D_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Texture3D.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10Texture3D, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_TEXTURECUBE_FACE = enum(i32) {
    POSITIVE_X = 0,
    NEGATIVE_X = 1,
    POSITIVE_Y = 2,
    NEGATIVE_Y = 3,
    POSITIVE_Z = 4,
    NEGATIVE_Z = 5,
};
pub const D3D10_TEXTURECUBE_FACE_POSITIVE_X = D3D10_TEXTURECUBE_FACE.POSITIVE_X;
pub const D3D10_TEXTURECUBE_FACE_NEGATIVE_X = D3D10_TEXTURECUBE_FACE.NEGATIVE_X;
pub const D3D10_TEXTURECUBE_FACE_POSITIVE_Y = D3D10_TEXTURECUBE_FACE.POSITIVE_Y;
pub const D3D10_TEXTURECUBE_FACE_NEGATIVE_Y = D3D10_TEXTURECUBE_FACE.NEGATIVE_Y;
pub const D3D10_TEXTURECUBE_FACE_POSITIVE_Z = D3D10_TEXTURECUBE_FACE.POSITIVE_Z;
pub const D3D10_TEXTURECUBE_FACE_NEGATIVE_Z = D3D10_TEXTURECUBE_FACE.NEGATIVE_Z;

const IID_ID3D10View_Value = Guid.initString("c902b03f-60a7-49ba-9936-2a3ab37a7e33");
pub const IID_ID3D10View = &IID_ID3D10View_Value;
pub const ID3D10View = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
        GetResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10View,
                ppResource: ?*?*ID3D10Resource,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10View,
                ppResource: ?*?*ID3D10Resource,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10View_GetResource(self: *const T, ppResource: ?*?*ID3D10Resource) callconv(.Inline) void {
            return @ptrCast(*const ID3D10View.VTable, self.vtable).GetResource(@ptrCast(*const ID3D10View, self), ppResource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_BUFFER_SRV = extern struct {
    Anonymous1: extern union {
        FirstElement: u32,
        ElementOffset: u32,
    },
    Anonymous2: extern union {
        NumElements: u32,
        ElementWidth: u32,
    },
};

pub const D3D10_TEX1D_SRV = extern struct {
    MostDetailedMip: u32,
    MipLevels: u32,
};

pub const D3D10_TEX1D_ARRAY_SRV = extern struct {
    MostDetailedMip: u32,
    MipLevels: u32,
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D10_TEX2D_SRV = extern struct {
    MostDetailedMip: u32,
    MipLevels: u32,
};

pub const D3D10_TEX2D_ARRAY_SRV = extern struct {
    MostDetailedMip: u32,
    MipLevels: u32,
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D10_TEX3D_SRV = extern struct {
    MostDetailedMip: u32,
    MipLevels: u32,
};

pub const D3D10_TEXCUBE_SRV = extern struct {
    MostDetailedMip: u32,
    MipLevels: u32,
};

pub const D3D10_TEX2DMS_SRV = extern struct {
    UnusedField_NothingToDefine: u32,
};

pub const D3D10_TEX2DMS_ARRAY_SRV = extern struct {
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D10_SHADER_RESOURCE_VIEW_DESC = extern struct {
    Format: DXGI_FORMAT,
    ViewDimension: D3D_SRV_DIMENSION,
    Anonymous: extern union {
        Buffer: D3D10_BUFFER_SRV,
        Texture1D: D3D10_TEX1D_SRV,
        Texture1DArray: D3D10_TEX1D_ARRAY_SRV,
        Texture2D: D3D10_TEX2D_SRV,
        Texture2DArray: D3D10_TEX2D_ARRAY_SRV,
        Texture2DMS: D3D10_TEX2DMS_SRV,
        Texture2DMSArray: D3D10_TEX2DMS_ARRAY_SRV,
        Texture3D: D3D10_TEX3D_SRV,
        TextureCube: D3D10_TEXCUBE_SRV,
    },
};

const IID_ID3D10ShaderResourceView_Value = Guid.initString("9b7e4c07-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10ShaderResourceView = &IID_ID3D10ShaderResourceView_Value;
pub const ID3D10ShaderResourceView = extern struct {
    pub const VTable = extern struct {
        base: ID3D10View.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderResourceView,
                pDesc: ?*D3D10_SHADER_RESOURCE_VIEW_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10ShaderResourceView,
                pDesc: ?*D3D10_SHADER_RESOURCE_VIEW_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10View.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderResourceView_GetDesc(self: *const T, pDesc: ?*D3D10_SHADER_RESOURCE_VIEW_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10ShaderResourceView.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10ShaderResourceView, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_BUFFER_RTV = extern struct {
    Anonymous1: extern union {
        FirstElement: u32,
        ElementOffset: u32,
    },
    Anonymous2: extern union {
        NumElements: u32,
        ElementWidth: u32,
    },
};

pub const D3D10_TEX1D_RTV = extern struct {
    MipSlice: u32,
};

pub const D3D10_TEX1D_ARRAY_RTV = extern struct {
    MipSlice: u32,
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D10_TEX2D_RTV = extern struct {
    MipSlice: u32,
};

pub const D3D10_TEX2DMS_RTV = extern struct {
    UnusedField_NothingToDefine: u32,
};

pub const D3D10_TEX2D_ARRAY_RTV = extern struct {
    MipSlice: u32,
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D10_TEX2DMS_ARRAY_RTV = extern struct {
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D10_TEX3D_RTV = extern struct {
    MipSlice: u32,
    FirstWSlice: u32,
    WSize: u32,
};

pub const D3D10_RENDER_TARGET_VIEW_DESC = extern struct {
    Format: DXGI_FORMAT,
    ViewDimension: D3D10_RTV_DIMENSION,
    Anonymous: extern union {
        Buffer: D3D10_BUFFER_RTV,
        Texture1D: D3D10_TEX1D_RTV,
        Texture1DArray: D3D10_TEX1D_ARRAY_RTV,
        Texture2D: D3D10_TEX2D_RTV,
        Texture2DArray: D3D10_TEX2D_ARRAY_RTV,
        Texture2DMS: D3D10_TEX2DMS_RTV,
        Texture2DMSArray: D3D10_TEX2DMS_ARRAY_RTV,
        Texture3D: D3D10_TEX3D_RTV,
    },
};

const IID_ID3D10RenderTargetView_Value = Guid.initString("9b7e4c08-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10RenderTargetView = &IID_ID3D10RenderTargetView_Value;
pub const ID3D10RenderTargetView = extern struct {
    pub const VTable = extern struct {
        base: ID3D10View.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10RenderTargetView,
                pDesc: ?*D3D10_RENDER_TARGET_VIEW_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10RenderTargetView,
                pDesc: ?*D3D10_RENDER_TARGET_VIEW_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10View.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10RenderTargetView_GetDesc(self: *const T, pDesc: ?*D3D10_RENDER_TARGET_VIEW_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10RenderTargetView.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10RenderTargetView, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_TEX1D_DSV = extern struct {
    MipSlice: u32,
};

pub const D3D10_TEX1D_ARRAY_DSV = extern struct {
    MipSlice: u32,
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D10_TEX2D_DSV = extern struct {
    MipSlice: u32,
};

pub const D3D10_TEX2D_ARRAY_DSV = extern struct {
    MipSlice: u32,
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D10_TEX2DMS_DSV = extern struct {
    UnusedField_NothingToDefine: u32,
};

pub const D3D10_TEX2DMS_ARRAY_DSV = extern struct {
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D10_DEPTH_STENCIL_VIEW_DESC = extern struct {
    Format: DXGI_FORMAT,
    ViewDimension: D3D10_DSV_DIMENSION,
    Anonymous: extern union {
        Texture1D: D3D10_TEX1D_DSV,
        Texture1DArray: D3D10_TEX1D_ARRAY_DSV,
        Texture2D: D3D10_TEX2D_DSV,
        Texture2DArray: D3D10_TEX2D_ARRAY_DSV,
        Texture2DMS: D3D10_TEX2DMS_DSV,
        Texture2DMSArray: D3D10_TEX2DMS_ARRAY_DSV,
    },
};

const IID_ID3D10DepthStencilView_Value = Guid.initString("9b7e4c09-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10DepthStencilView = &IID_ID3D10DepthStencilView_Value;
pub const ID3D10DepthStencilView = extern struct {
    pub const VTable = extern struct {
        base: ID3D10View.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10DepthStencilView,
                pDesc: ?*D3D10_DEPTH_STENCIL_VIEW_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10DepthStencilView,
                pDesc: ?*D3D10_DEPTH_STENCIL_VIEW_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10View.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10DepthStencilView_GetDesc(self: *const T, pDesc: ?*D3D10_DEPTH_STENCIL_VIEW_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10DepthStencilView.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10DepthStencilView, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10VertexShader_Value = Guid.initString("9b7e4c0a-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10VertexShader = &IID_ID3D10VertexShader_Value;
pub const ID3D10VertexShader = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10GeometryShader_Value = Guid.initString("6316be88-54cd-4040-ab44-20461bc81f68");
pub const IID_ID3D10GeometryShader = &IID_ID3D10GeometryShader_Value;
pub const ID3D10GeometryShader = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10PixelShader_Value = Guid.initString("4968b601-9d00-4cde-8346-8e7f675819b6");
pub const IID_ID3D10PixelShader = &IID_ID3D10PixelShader_Value;
pub const ID3D10PixelShader = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10InputLayout_Value = Guid.initString("9b7e4c0b-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10InputLayout = &IID_ID3D10InputLayout_Value;
pub const ID3D10InputLayout = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_FILTER = enum(i32) {
    MIN_MAG_MIP_POINT = 0,
    MIN_MAG_POINT_MIP_LINEAR = 1,
    MIN_POINT_MAG_LINEAR_MIP_POINT = 4,
    MIN_POINT_MAG_MIP_LINEAR = 5,
    MIN_LINEAR_MAG_MIP_POINT = 16,
    MIN_LINEAR_MAG_POINT_MIP_LINEAR = 17,
    MIN_MAG_LINEAR_MIP_POINT = 20,
    MIN_MAG_MIP_LINEAR = 21,
    ANISOTROPIC = 85,
    COMPARISON_MIN_MAG_MIP_POINT = 128,
    COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 129,
    COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 132,
    COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 133,
    COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 144,
    COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 145,
    COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 148,
    COMPARISON_MIN_MAG_MIP_LINEAR = 149,
    COMPARISON_ANISOTROPIC = 213,
    TEXT_1BIT = -2147483648,
};
pub const D3D10_FILTER_MIN_MAG_MIP_POINT = D3D10_FILTER.MIN_MAG_MIP_POINT;
pub const D3D10_FILTER_MIN_MAG_POINT_MIP_LINEAR = D3D10_FILTER.MIN_MAG_POINT_MIP_LINEAR;
pub const D3D10_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT = D3D10_FILTER.MIN_POINT_MAG_LINEAR_MIP_POINT;
pub const D3D10_FILTER_MIN_POINT_MAG_MIP_LINEAR = D3D10_FILTER.MIN_POINT_MAG_MIP_LINEAR;
pub const D3D10_FILTER_MIN_LINEAR_MAG_MIP_POINT = D3D10_FILTER.MIN_LINEAR_MAG_MIP_POINT;
pub const D3D10_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = D3D10_FILTER.MIN_LINEAR_MAG_POINT_MIP_LINEAR;
pub const D3D10_FILTER_MIN_MAG_LINEAR_MIP_POINT = D3D10_FILTER.MIN_MAG_LINEAR_MIP_POINT;
pub const D3D10_FILTER_MIN_MAG_MIP_LINEAR = D3D10_FILTER.MIN_MAG_MIP_LINEAR;
pub const D3D10_FILTER_ANISOTROPIC = D3D10_FILTER.ANISOTROPIC;
pub const D3D10_FILTER_COMPARISON_MIN_MAG_MIP_POINT = D3D10_FILTER.COMPARISON_MIN_MAG_MIP_POINT;
pub const D3D10_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR = D3D10_FILTER.COMPARISON_MIN_MAG_POINT_MIP_LINEAR;
pub const D3D10_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = D3D10_FILTER.COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT;
pub const D3D10_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR = D3D10_FILTER.COMPARISON_MIN_POINT_MAG_MIP_LINEAR;
pub const D3D10_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT = D3D10_FILTER.COMPARISON_MIN_LINEAR_MAG_MIP_POINT;
pub const D3D10_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = D3D10_FILTER.COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR;
pub const D3D10_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT = D3D10_FILTER.COMPARISON_MIN_MAG_LINEAR_MIP_POINT;
pub const D3D10_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR = D3D10_FILTER.COMPARISON_MIN_MAG_MIP_LINEAR;
pub const D3D10_FILTER_COMPARISON_ANISOTROPIC = D3D10_FILTER.COMPARISON_ANISOTROPIC;
pub const D3D10_FILTER_TEXT_1BIT = D3D10_FILTER.TEXT_1BIT;

pub const D3D10_FILTER_TYPE = enum(i32) {
    POINT = 0,
    LINEAR = 1,
};
pub const D3D10_FILTER_TYPE_POINT = D3D10_FILTER_TYPE.POINT;
pub const D3D10_FILTER_TYPE_LINEAR = D3D10_FILTER_TYPE.LINEAR;

pub const D3D10_TEXTURE_ADDRESS_MODE = enum(i32) {
    WRAP = 1,
    MIRROR = 2,
    CLAMP = 3,
    BORDER = 4,
    MIRROR_ONCE = 5,
};
pub const D3D10_TEXTURE_ADDRESS_WRAP = D3D10_TEXTURE_ADDRESS_MODE.WRAP;
pub const D3D10_TEXTURE_ADDRESS_MIRROR = D3D10_TEXTURE_ADDRESS_MODE.MIRROR;
pub const D3D10_TEXTURE_ADDRESS_CLAMP = D3D10_TEXTURE_ADDRESS_MODE.CLAMP;
pub const D3D10_TEXTURE_ADDRESS_BORDER = D3D10_TEXTURE_ADDRESS_MODE.BORDER;
pub const D3D10_TEXTURE_ADDRESS_MIRROR_ONCE = D3D10_TEXTURE_ADDRESS_MODE.MIRROR_ONCE;

pub const D3D10_SAMPLER_DESC = extern struct {
    Filter: D3D10_FILTER,
    AddressU: D3D10_TEXTURE_ADDRESS_MODE,
    AddressV: D3D10_TEXTURE_ADDRESS_MODE,
    AddressW: D3D10_TEXTURE_ADDRESS_MODE,
    MipLODBias: f32,
    MaxAnisotropy: u32,
    ComparisonFunc: D3D10_COMPARISON_FUNC,
    BorderColor: [4]f32,
    MinLOD: f32,
    MaxLOD: f32,
};

const IID_ID3D10SamplerState_Value = Guid.initString("9b7e4c0c-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10SamplerState = &IID_ID3D10SamplerState_Value;
pub const ID3D10SamplerState = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10SamplerState,
                pDesc: ?*D3D10_SAMPLER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10SamplerState,
                pDesc: ?*D3D10_SAMPLER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10SamplerState_GetDesc(self: *const T, pDesc: ?*D3D10_SAMPLER_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10SamplerState.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10SamplerState, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_FORMAT_SUPPORT = enum(i32) {
    BUFFER = 1,
    IA_VERTEX_BUFFER = 2,
    IA_INDEX_BUFFER = 4,
    SO_BUFFER = 8,
    TEXTURE1D = 16,
    TEXTURE2D = 32,
    TEXTURE3D = 64,
    TEXTURECUBE = 128,
    SHADER_LOAD = 256,
    SHADER_SAMPLE = 512,
    SHADER_SAMPLE_COMPARISON = 1024,
    SHADER_SAMPLE_MONO_TEXT = 2048,
    MIP = 4096,
    MIP_AUTOGEN = 8192,
    RENDER_TARGET = 16384,
    BLENDABLE = 32768,
    DEPTH_STENCIL = 65536,
    CPU_LOCKABLE = 131072,
    MULTISAMPLE_RESOLVE = 262144,
    DISPLAY = 524288,
    CAST_WITHIN_BIT_LAYOUT = 1048576,
    MULTISAMPLE_RENDERTARGET = 2097152,
    MULTISAMPLE_LOAD = 4194304,
    SHADER_GATHER = 8388608,
    BACK_BUFFER_CAST = 16777216,
};
pub const D3D10_FORMAT_SUPPORT_BUFFER = D3D10_FORMAT_SUPPORT.BUFFER;
pub const D3D10_FORMAT_SUPPORT_IA_VERTEX_BUFFER = D3D10_FORMAT_SUPPORT.IA_VERTEX_BUFFER;
pub const D3D10_FORMAT_SUPPORT_IA_INDEX_BUFFER = D3D10_FORMAT_SUPPORT.IA_INDEX_BUFFER;
pub const D3D10_FORMAT_SUPPORT_SO_BUFFER = D3D10_FORMAT_SUPPORT.SO_BUFFER;
pub const D3D10_FORMAT_SUPPORT_TEXTURE1D = D3D10_FORMAT_SUPPORT.TEXTURE1D;
pub const D3D10_FORMAT_SUPPORT_TEXTURE2D = D3D10_FORMAT_SUPPORT.TEXTURE2D;
pub const D3D10_FORMAT_SUPPORT_TEXTURE3D = D3D10_FORMAT_SUPPORT.TEXTURE3D;
pub const D3D10_FORMAT_SUPPORT_TEXTURECUBE = D3D10_FORMAT_SUPPORT.TEXTURECUBE;
pub const D3D10_FORMAT_SUPPORT_SHADER_LOAD = D3D10_FORMAT_SUPPORT.SHADER_LOAD;
pub const D3D10_FORMAT_SUPPORT_SHADER_SAMPLE = D3D10_FORMAT_SUPPORT.SHADER_SAMPLE;
pub const D3D10_FORMAT_SUPPORT_SHADER_SAMPLE_COMPARISON = D3D10_FORMAT_SUPPORT.SHADER_SAMPLE_COMPARISON;
pub const D3D10_FORMAT_SUPPORT_SHADER_SAMPLE_MONO_TEXT = D3D10_FORMAT_SUPPORT.SHADER_SAMPLE_MONO_TEXT;
pub const D3D10_FORMAT_SUPPORT_MIP = D3D10_FORMAT_SUPPORT.MIP;
pub const D3D10_FORMAT_SUPPORT_MIP_AUTOGEN = D3D10_FORMAT_SUPPORT.MIP_AUTOGEN;
pub const D3D10_FORMAT_SUPPORT_RENDER_TARGET = D3D10_FORMAT_SUPPORT.RENDER_TARGET;
pub const D3D10_FORMAT_SUPPORT_BLENDABLE = D3D10_FORMAT_SUPPORT.BLENDABLE;
pub const D3D10_FORMAT_SUPPORT_DEPTH_STENCIL = D3D10_FORMAT_SUPPORT.DEPTH_STENCIL;
pub const D3D10_FORMAT_SUPPORT_CPU_LOCKABLE = D3D10_FORMAT_SUPPORT.CPU_LOCKABLE;
pub const D3D10_FORMAT_SUPPORT_MULTISAMPLE_RESOLVE = D3D10_FORMAT_SUPPORT.MULTISAMPLE_RESOLVE;
pub const D3D10_FORMAT_SUPPORT_DISPLAY = D3D10_FORMAT_SUPPORT.DISPLAY;
pub const D3D10_FORMAT_SUPPORT_CAST_WITHIN_BIT_LAYOUT = D3D10_FORMAT_SUPPORT.CAST_WITHIN_BIT_LAYOUT;
pub const D3D10_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET = D3D10_FORMAT_SUPPORT.MULTISAMPLE_RENDERTARGET;
pub const D3D10_FORMAT_SUPPORT_MULTISAMPLE_LOAD = D3D10_FORMAT_SUPPORT.MULTISAMPLE_LOAD;
pub const D3D10_FORMAT_SUPPORT_SHADER_GATHER = D3D10_FORMAT_SUPPORT.SHADER_GATHER;
pub const D3D10_FORMAT_SUPPORT_BACK_BUFFER_CAST = D3D10_FORMAT_SUPPORT.BACK_BUFFER_CAST;

const IID_ID3D10Asynchronous_Value = Guid.initString("9b7e4c0d-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Asynchronous = &IID_ID3D10Asynchronous_Value;
pub const ID3D10Asynchronous = extern struct {
    pub const VTable = extern struct {
        base: ID3D10DeviceChild.VTable,
        Begin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Asynchronous,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Asynchronous,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        End: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Asynchronous,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Asynchronous,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Asynchronous,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
                DataSize: u32,
                GetDataFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Asynchronous,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
                DataSize: u32,
                GetDataFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Asynchronous,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID3D10Asynchronous,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Asynchronous_Begin(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Asynchronous.VTable, self.vtable).Begin(@ptrCast(*const ID3D10Asynchronous, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Asynchronous_End(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Asynchronous.VTable, self.vtable).End(@ptrCast(*const ID3D10Asynchronous, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Asynchronous_GetData(self: *const T, pData: ?*anyopaque, DataSize: u32, GetDataFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Asynchronous.VTable, self.vtable).GetData(@ptrCast(*const ID3D10Asynchronous, self), pData, DataSize, GetDataFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Asynchronous_GetDataSize(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D10Asynchronous.VTable, self.vtable).GetDataSize(@ptrCast(*const ID3D10Asynchronous, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_ASYNC_GETDATA_FLAG = enum(i32) {
    H = 1,
};
pub const D3D10_ASYNC_GETDATA_DONOTFLUSH = D3D10_ASYNC_GETDATA_FLAG.H;

pub const D3D10_QUERY = enum(i32) {
    EVENT = 0,
    OCCLUSION = 1,
    TIMESTAMP = 2,
    TIMESTAMP_DISJOINT = 3,
    PIPELINE_STATISTICS = 4,
    OCCLUSION_PREDICATE = 5,
    SO_STATISTICS = 6,
    SO_OVERFLOW_PREDICATE = 7,
};
pub const D3D10_QUERY_EVENT = D3D10_QUERY.EVENT;
pub const D3D10_QUERY_OCCLUSION = D3D10_QUERY.OCCLUSION;
pub const D3D10_QUERY_TIMESTAMP = D3D10_QUERY.TIMESTAMP;
pub const D3D10_QUERY_TIMESTAMP_DISJOINT = D3D10_QUERY.TIMESTAMP_DISJOINT;
pub const D3D10_QUERY_PIPELINE_STATISTICS = D3D10_QUERY.PIPELINE_STATISTICS;
pub const D3D10_QUERY_OCCLUSION_PREDICATE = D3D10_QUERY.OCCLUSION_PREDICATE;
pub const D3D10_QUERY_SO_STATISTICS = D3D10_QUERY.SO_STATISTICS;
pub const D3D10_QUERY_SO_OVERFLOW_PREDICATE = D3D10_QUERY.SO_OVERFLOW_PREDICATE;

pub const D3D10_QUERY_MISC_FLAG = enum(i32) {
    T = 1,
};
pub const D3D10_QUERY_MISC_PREDICATEHINT = D3D10_QUERY_MISC_FLAG.T;

pub const D3D10_QUERY_DESC = extern struct {
    Query: D3D10_QUERY,
    MiscFlags: u32,
};

const IID_ID3D10Query_Value = Guid.initString("9b7e4c0e-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Query = &IID_ID3D10Query_Value;
pub const ID3D10Query = extern struct {
    pub const VTable = extern struct {
        base: ID3D10Asynchronous.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Query,
                pDesc: ?*D3D10_QUERY_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Query,
                pDesc: ?*D3D10_QUERY_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10Asynchronous.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Query_GetDesc(self: *const T, pDesc: ?*D3D10_QUERY_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Query.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10Query, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10Predicate_Value = Guid.initString("9b7e4c10-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Predicate = &IID_ID3D10Predicate_Value;
pub const ID3D10Predicate = extern struct {
    pub const VTable = extern struct {
        base: ID3D10Query.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10Query.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_QUERY_DATA_TIMESTAMP_DISJOINT = extern struct {
    Frequency: u64,
    Disjoint: BOOL,
};

pub const D3D10_QUERY_DATA_PIPELINE_STATISTICS = extern struct {
    IAVertices: u64,
    IAPrimitives: u64,
    VSInvocations: u64,
    GSInvocations: u64,
    GSPrimitives: u64,
    CInvocations: u64,
    CPrimitives: u64,
    PSInvocations: u64,
};

pub const D3D10_QUERY_DATA_SO_STATISTICS = extern struct {
    NumPrimitivesWritten: u64,
    PrimitivesStorageNeeded: u64,
};

pub const D3D10_COUNTER = enum(i32) {
    GPU_IDLE = 0,
    VERTEX_PROCESSING = 1,
    GEOMETRY_PROCESSING = 2,
    PIXEL_PROCESSING = 3,
    OTHER_GPU_PROCESSING = 4,
    HOST_ADAPTER_BANDWIDTH_UTILIZATION = 5,
    LOCAL_VIDMEM_BANDWIDTH_UTILIZATION = 6,
    VERTEX_THROUGHPUT_UTILIZATION = 7,
    TRIANGLE_SETUP_THROUGHPUT_UTILIZATION = 8,
    FILLRATE_THROUGHPUT_UTILIZATION = 9,
    VS_MEMORY_LIMITED = 10,
    VS_COMPUTATION_LIMITED = 11,
    GS_MEMORY_LIMITED = 12,
    GS_COMPUTATION_LIMITED = 13,
    PS_MEMORY_LIMITED = 14,
    PS_COMPUTATION_LIMITED = 15,
    POST_TRANSFORM_CACHE_HIT_RATE = 16,
    TEXTURE_CACHE_HIT_RATE = 17,
    DEVICE_DEPENDENT_0 = 1073741824,
};
pub const D3D10_COUNTER_GPU_IDLE = D3D10_COUNTER.GPU_IDLE;
pub const D3D10_COUNTER_VERTEX_PROCESSING = D3D10_COUNTER.VERTEX_PROCESSING;
pub const D3D10_COUNTER_GEOMETRY_PROCESSING = D3D10_COUNTER.GEOMETRY_PROCESSING;
pub const D3D10_COUNTER_PIXEL_PROCESSING = D3D10_COUNTER.PIXEL_PROCESSING;
pub const D3D10_COUNTER_OTHER_GPU_PROCESSING = D3D10_COUNTER.OTHER_GPU_PROCESSING;
pub const D3D10_COUNTER_HOST_ADAPTER_BANDWIDTH_UTILIZATION = D3D10_COUNTER.HOST_ADAPTER_BANDWIDTH_UTILIZATION;
pub const D3D10_COUNTER_LOCAL_VIDMEM_BANDWIDTH_UTILIZATION = D3D10_COUNTER.LOCAL_VIDMEM_BANDWIDTH_UTILIZATION;
pub const D3D10_COUNTER_VERTEX_THROUGHPUT_UTILIZATION = D3D10_COUNTER.VERTEX_THROUGHPUT_UTILIZATION;
pub const D3D10_COUNTER_TRIANGLE_SETUP_THROUGHPUT_UTILIZATION = D3D10_COUNTER.TRIANGLE_SETUP_THROUGHPUT_UTILIZATION;
pub const D3D10_COUNTER_FILLRATE_THROUGHPUT_UTILIZATION = D3D10_COUNTER.FILLRATE_THROUGHPUT_UTILIZATION;
pub const D3D10_COUNTER_VS_MEMORY_LIMITED = D3D10_COUNTER.VS_MEMORY_LIMITED;
pub const D3D10_COUNTER_VS_COMPUTATION_LIMITED = D3D10_COUNTER.VS_COMPUTATION_LIMITED;
pub const D3D10_COUNTER_GS_MEMORY_LIMITED = D3D10_COUNTER.GS_MEMORY_LIMITED;
pub const D3D10_COUNTER_GS_COMPUTATION_LIMITED = D3D10_COUNTER.GS_COMPUTATION_LIMITED;
pub const D3D10_COUNTER_PS_MEMORY_LIMITED = D3D10_COUNTER.PS_MEMORY_LIMITED;
pub const D3D10_COUNTER_PS_COMPUTATION_LIMITED = D3D10_COUNTER.PS_COMPUTATION_LIMITED;
pub const D3D10_COUNTER_POST_TRANSFORM_CACHE_HIT_RATE = D3D10_COUNTER.POST_TRANSFORM_CACHE_HIT_RATE;
pub const D3D10_COUNTER_TEXTURE_CACHE_HIT_RATE = D3D10_COUNTER.TEXTURE_CACHE_HIT_RATE;
pub const D3D10_COUNTER_DEVICE_DEPENDENT_0 = D3D10_COUNTER.DEVICE_DEPENDENT_0;

pub const D3D10_COUNTER_TYPE = enum(i32) {
    FLOAT32 = 0,
    UINT16 = 1,
    UINT32 = 2,
    UINT64 = 3,
};
pub const D3D10_COUNTER_TYPE_FLOAT32 = D3D10_COUNTER_TYPE.FLOAT32;
pub const D3D10_COUNTER_TYPE_UINT16 = D3D10_COUNTER_TYPE.UINT16;
pub const D3D10_COUNTER_TYPE_UINT32 = D3D10_COUNTER_TYPE.UINT32;
pub const D3D10_COUNTER_TYPE_UINT64 = D3D10_COUNTER_TYPE.UINT64;

pub const D3D10_COUNTER_DESC = extern struct {
    Counter: D3D10_COUNTER,
    MiscFlags: u32,
};

pub const D3D10_COUNTER_INFO = extern struct {
    LastDeviceDependentCounter: D3D10_COUNTER,
    NumSimultaneousCounters: u32,
    NumDetectableParallelUnits: u8,
};

const IID_ID3D10Counter_Value = Guid.initString("9b7e4c11-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Counter = &IID_ID3D10Counter_Value;
pub const ID3D10Counter = extern struct {
    pub const VTable = extern struct {
        base: ID3D10Asynchronous.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Counter,
                pDesc: ?*D3D10_COUNTER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Counter,
                pDesc: ?*D3D10_COUNTER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10Asynchronous.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Counter_GetDesc(self: *const T, pDesc: ?*D3D10_COUNTER_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Counter.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10Counter, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10Device_Value = Guid.initString("9b7e4c0f-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Device = &IID_ID3D10Device_Value;
pub const ID3D10Device = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        VSSetConstantBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PSSetShaderResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PSSetShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pPixelShader: ?*ID3D10PixelShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pPixelShader: ?*ID3D10PixelShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PSSetSamplers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        VSSetShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pVertexShader: ?*ID3D10VertexShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pVertexShader: ?*ID3D10VertexShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawIndexed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                IndexCount: u32,
                StartIndexLocation: u32,
                BaseVertexLocation: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                IndexCount: u32,
                StartIndexLocation: u32,
                BaseVertexLocation: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Draw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                VertexCount: u32,
                StartVertexLocation: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                VertexCount: u32,
                StartVertexLocation: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PSSetConstantBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        IASetInputLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pInputLayout: ?*ID3D10InputLayout,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pInputLayout: ?*ID3D10InputLayout,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        IASetVertexBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppVertexBuffers: ?[*]?*ID3D10Buffer,
                pStrides: ?[*]const u32,
                pOffsets: ?[*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppVertexBuffers: ?[*]?*ID3D10Buffer,
                pStrides: ?[*]const u32,
                pOffsets: ?[*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        IASetIndexBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pIndexBuffer: ?*ID3D10Buffer,
                Format: DXGI_FORMAT,
                Offset: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pIndexBuffer: ?*ID3D10Buffer,
                Format: DXGI_FORMAT,
                Offset: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawIndexedInstanced: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                IndexCountPerInstance: u32,
                InstanceCount: u32,
                StartIndexLocation: u32,
                BaseVertexLocation: i32,
                StartInstanceLocation: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                IndexCountPerInstance: u32,
                InstanceCount: u32,
                StartIndexLocation: u32,
                BaseVertexLocation: i32,
                StartInstanceLocation: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawInstanced: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                VertexCountPerInstance: u32,
                InstanceCount: u32,
                StartVertexLocation: u32,
                StartInstanceLocation: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                VertexCountPerInstance: u32,
                InstanceCount: u32,
                StartVertexLocation: u32,
                StartInstanceLocation: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GSSetConstantBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GSSetShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pShader: ?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pShader: ?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        IASetPrimitiveTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                Topology: D3D_PRIMITIVE_TOPOLOGY,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                Topology: D3D_PRIMITIVE_TOPOLOGY,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        VSSetShaderResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        VSSetSamplers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetPredication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pPredicate: ?*ID3D10Predicate,
                PredicateValue: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pPredicate: ?*ID3D10Predicate,
                PredicateValue: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GSSetShaderResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GSSetSamplers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OMSetRenderTargets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                NumViews: u32,
                ppRenderTargetViews: ?[*]?*ID3D10RenderTargetView,
                pDepthStencilView: ?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                NumViews: u32,
                ppRenderTargetViews: ?[*]?*ID3D10RenderTargetView,
                pDepthStencilView: ?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OMSetBlendState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pBlendState: ?*ID3D10BlendState,
                BlendFactor: ?*const f32,
                SampleMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pBlendState: ?*ID3D10BlendState,
                BlendFactor: ?*const f32,
                SampleMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OMSetDepthStencilState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDepthStencilState: ?*ID3D10DepthStencilState,
                StencilRef: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pDepthStencilState: ?*ID3D10DepthStencilState,
                StencilRef: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SOSetTargets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                NumBuffers: u32,
                ppSOTargets: ?[*]?*ID3D10Buffer,
                pOffsets: ?[*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                NumBuffers: u32,
                ppSOTargets: ?[*]?*ID3D10Buffer,
                pOffsets: ?[*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawAuto: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        RSSetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pRasterizerState: ?*ID3D10RasterizerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pRasterizerState: ?*ID3D10RasterizerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        RSSetViewports: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                NumViewports: u32,
                pViewports: ?[*]const D3D10_VIEWPORT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                NumViewports: u32,
                pViewports: ?[*]const D3D10_VIEWPORT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        RSSetScissorRects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                NumRects: u32,
                pRects: ?[*]const RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                NumRects: u32,
                pRects: ?[*]const RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CopySubresourceRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDstResource: ?*ID3D10Resource,
                DstSubresource: u32,
                DstX: u32,
                DstY: u32,
                DstZ: u32,
                pSrcResource: ?*ID3D10Resource,
                SrcSubresource: u32,
                pSrcBox: ?*const D3D10_BOX,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pDstResource: ?*ID3D10Resource,
                DstSubresource: u32,
                DstX: u32,
                DstY: u32,
                DstZ: u32,
                pSrcResource: ?*ID3D10Resource,
                SrcSubresource: u32,
                pSrcBox: ?*const D3D10_BOX,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CopyResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDstResource: ?*ID3D10Resource,
                pSrcResource: ?*ID3D10Resource,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pDstResource: ?*ID3D10Resource,
                pSrcResource: ?*ID3D10Resource,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        UpdateSubresource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDstResource: ?*ID3D10Resource,
                DstSubresource: u32,
                pDstBox: ?*const D3D10_BOX,
                pSrcData: ?*const anyopaque,
                SrcRowPitch: u32,
                SrcDepthPitch: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pDstResource: ?*ID3D10Resource,
                DstSubresource: u32,
                pDstBox: ?*const D3D10_BOX,
                pSrcData: ?*const anyopaque,
                SrcRowPitch: u32,
                SrcDepthPitch: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ClearRenderTargetView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pRenderTargetView: ?*ID3D10RenderTargetView,
                ColorRGBA: ?*const f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pRenderTargetView: ?*ID3D10RenderTargetView,
                ColorRGBA: ?*const f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ClearDepthStencilView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDepthStencilView: ?*ID3D10DepthStencilView,
                ClearFlags: u32,
                Depth: f32,
                Stencil: u8,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pDepthStencilView: ?*ID3D10DepthStencilView,
                ClearFlags: u32,
                Depth: f32,
                Stencil: u8,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GenerateMips: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pShaderResourceView: ?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pShaderResourceView: ?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ResolveSubresource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDstResource: ?*ID3D10Resource,
                DstSubresource: u32,
                pSrcResource: ?*ID3D10Resource,
                SrcSubresource: u32,
                Format: DXGI_FORMAT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pDstResource: ?*ID3D10Resource,
                DstSubresource: u32,
                pSrcResource: ?*ID3D10Resource,
                SrcSubresource: u32,
                Format: DXGI_FORMAT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        VSGetConstantBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PSGetShaderResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PSGetShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                ppPixelShader: ?*?*ID3D10PixelShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                ppPixelShader: ?*?*ID3D10PixelShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PSGetSamplers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        VSGetShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                ppVertexShader: ?*?*ID3D10VertexShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                ppVertexShader: ?*?*ID3D10VertexShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PSGetConstantBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        IAGetInputLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                ppInputLayout: ?*?*ID3D10InputLayout,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                ppInputLayout: ?*?*ID3D10InputLayout,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        IAGetVertexBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppVertexBuffers: ?[*]?*ID3D10Buffer,
                pStrides: ?[*]u32,
                pOffsets: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppVertexBuffers: ?[*]?*ID3D10Buffer,
                pStrides: ?[*]u32,
                pOffsets: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        IAGetIndexBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pIndexBuffer: ?*?*ID3D10Buffer,
                Format: ?*DXGI_FORMAT,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pIndexBuffer: ?*?*ID3D10Buffer,
                Format: ?*DXGI_FORMAT,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GSGetConstantBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumBuffers: u32,
                ppConstantBuffers: ?[*]?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GSGetShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                ppGeometryShader: ?*?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                ppGeometryShader: ?*?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        IAGetPrimitiveTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pTopology: ?*D3D_PRIMITIVE_TOPOLOGY,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pTopology: ?*D3D_PRIMITIVE_TOPOLOGY,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        VSGetShaderResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        VSGetSamplers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetPredication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                ppPredicate: ?*?*ID3D10Predicate,
                pPredicateValue: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                ppPredicate: ?*?*ID3D10Predicate,
                pPredicateValue: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GSGetShaderResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumViews: u32,
                ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GSGetSamplers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                StartSlot: u32,
                NumSamplers: u32,
                ppSamplers: ?[*]?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OMGetRenderTargets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                NumViews: u32,
                ppRenderTargetViews: ?[*]?*ID3D10RenderTargetView,
                ppDepthStencilView: ?*?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                NumViews: u32,
                ppRenderTargetViews: ?[*]?*ID3D10RenderTargetView,
                ppDepthStencilView: ?*?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OMGetBlendState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                ppBlendState: ?*?*ID3D10BlendState,
                BlendFactor: ?*f32,
                pSampleMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                ppBlendState: ?*?*ID3D10BlendState,
                BlendFactor: ?*f32,
                pSampleMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OMGetDepthStencilState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                ppDepthStencilState: ?*?*ID3D10DepthStencilState,
                pStencilRef: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                ppDepthStencilState: ?*?*ID3D10DepthStencilState,
                pStencilRef: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SOGetTargets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                NumBuffers: u32,
                ppSOTargets: ?[*]?*ID3D10Buffer,
                pOffsets: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                NumBuffers: u32,
                ppSOTargets: ?[*]?*ID3D10Buffer,
                pOffsets: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        RSGetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                ppRasterizerState: ?*?*ID3D10RasterizerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                ppRasterizerState: ?*?*ID3D10RasterizerState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        RSGetViewports: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                NumViewports: ?*u32,
                pViewports: ?[*]D3D10_VIEWPORT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                NumViewports: ?*u32,
                pViewports: ?[*]D3D10_VIEWPORT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        RSGetScissorRects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                NumRects: ?*u32,
                pRects: ?[*]RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                NumRects: ?*u32,
                pRects: ?[*]RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetDeviceRemovedReason: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                RaiseFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                RaiseFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetPrivateData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                guid: ?*const Guid,
                pDataSize: ?*u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                guid: ?*const Guid,
                pDataSize: ?*u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPrivateData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                guid: ?*const Guid,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                guid: ?*const Guid,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPrivateDataInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                guid: ?*const Guid,
                pData: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                guid: ?*const Guid,
                pData: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_BUFFER_DESC,
                pInitialData: ?*const D3D10_SUBRESOURCE_DATA,
                ppBuffer: ?*?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_BUFFER_DESC,
                pInitialData: ?*const D3D10_SUBRESOURCE_DATA,
                ppBuffer: ?*?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTexture1D: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_TEXTURE1D_DESC,
                pInitialData: ?*const D3D10_SUBRESOURCE_DATA,
                ppTexture1D: ?*?*ID3D10Texture1D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_TEXTURE1D_DESC,
                pInitialData: ?*const D3D10_SUBRESOURCE_DATA,
                ppTexture1D: ?*?*ID3D10Texture1D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTexture2D: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_TEXTURE2D_DESC,
                pInitialData: ?*const D3D10_SUBRESOURCE_DATA,
                ppTexture2D: ?*?*ID3D10Texture2D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_TEXTURE2D_DESC,
                pInitialData: ?*const D3D10_SUBRESOURCE_DATA,
                ppTexture2D: ?*?*ID3D10Texture2D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTexture3D: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_TEXTURE3D_DESC,
                pInitialData: ?*const D3D10_SUBRESOURCE_DATA,
                ppTexture3D: ?*?*ID3D10Texture3D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_TEXTURE3D_DESC,
                pInitialData: ?*const D3D10_SUBRESOURCE_DATA,
                ppTexture3D: ?*?*ID3D10Texture3D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateShaderResourceView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pResource: ?*ID3D10Resource,
                pDesc: ?*const D3D10_SHADER_RESOURCE_VIEW_DESC,
                ppSRView: ?*?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pResource: ?*ID3D10Resource,
                pDesc: ?*const D3D10_SHADER_RESOURCE_VIEW_DESC,
                ppSRView: ?*?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRenderTargetView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pResource: ?*ID3D10Resource,
                pDesc: ?*const D3D10_RENDER_TARGET_VIEW_DESC,
                ppRTView: ?*?*ID3D10RenderTargetView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pResource: ?*ID3D10Resource,
                pDesc: ?*const D3D10_RENDER_TARGET_VIEW_DESC,
                ppRTView: ?*?*ID3D10RenderTargetView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDepthStencilView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pResource: ?*ID3D10Resource,
                pDesc: ?*const D3D10_DEPTH_STENCIL_VIEW_DESC,
                ppDepthStencilView: ?*?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pResource: ?*ID3D10Resource,
                pDesc: ?*const D3D10_DEPTH_STENCIL_VIEW_DESC,
                ppDepthStencilView: ?*?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInputLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pInputElementDescs: [*]const D3D10_INPUT_ELEMENT_DESC,
                NumElements: u32,
                pShaderBytecodeWithInputSignature: [*]const u8,
                BytecodeLength: usize,
                ppInputLayout: ?*?*ID3D10InputLayout,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pInputElementDescs: [*]const D3D10_INPUT_ELEMENT_DESC,
                NumElements: u32,
                pShaderBytecodeWithInputSignature: [*]const u8,
                BytecodeLength: usize,
                ppInputLayout: ?*?*ID3D10InputLayout,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVertexShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pShaderBytecode: [*]const u8,
                BytecodeLength: usize,
                ppVertexShader: ?*?*ID3D10VertexShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pShaderBytecode: [*]const u8,
                BytecodeLength: usize,
                ppVertexShader: ?*?*ID3D10VertexShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateGeometryShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pShaderBytecode: [*]const u8,
                BytecodeLength: usize,
                ppGeometryShader: ?*?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pShaderBytecode: [*]const u8,
                BytecodeLength: usize,
                ppGeometryShader: ?*?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateGeometryShaderWithStreamOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pShaderBytecode: [*]const u8,
                BytecodeLength: usize,
                pSODeclaration: ?[*]const D3D10_SO_DECLARATION_ENTRY,
                NumEntries: u32,
                OutputStreamStride: u32,
                ppGeometryShader: ?*?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pShaderBytecode: [*]const u8,
                BytecodeLength: usize,
                pSODeclaration: ?[*]const D3D10_SO_DECLARATION_ENTRY,
                NumEntries: u32,
                OutputStreamStride: u32,
                ppGeometryShader: ?*?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePixelShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pShaderBytecode: [*]const u8,
                BytecodeLength: usize,
                ppPixelShader: ?*?*ID3D10PixelShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pShaderBytecode: [*]const u8,
                BytecodeLength: usize,
                ppPixelShader: ?*?*ID3D10PixelShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBlendState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pBlendStateDesc: ?*const D3D10_BLEND_DESC,
                ppBlendState: ?*?*ID3D10BlendState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pBlendStateDesc: ?*const D3D10_BLEND_DESC,
                ppBlendState: ?*?*ID3D10BlendState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDepthStencilState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDepthStencilDesc: ?*const D3D10_DEPTH_STENCIL_DESC,
                ppDepthStencilState: ?*?*ID3D10DepthStencilState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pDepthStencilDesc: ?*const D3D10_DEPTH_STENCIL_DESC,
                ppDepthStencilState: ?*?*ID3D10DepthStencilState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRasterizerState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pRasterizerDesc: ?*const D3D10_RASTERIZER_DESC,
                ppRasterizerState: ?*?*ID3D10RasterizerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pRasterizerDesc: ?*const D3D10_RASTERIZER_DESC,
                ppRasterizerState: ?*?*ID3D10RasterizerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSamplerState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pSamplerDesc: ?*const D3D10_SAMPLER_DESC,
                ppSamplerState: ?*?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pSamplerDesc: ?*const D3D10_SAMPLER_DESC,
                ppSamplerState: ?*?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pQueryDesc: ?*const D3D10_QUERY_DESC,
                ppQuery: ?*?*ID3D10Query,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pQueryDesc: ?*const D3D10_QUERY_DESC,
                ppQuery: ?*?*ID3D10Query,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePredicate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pPredicateDesc: ?*const D3D10_QUERY_DESC,
                ppPredicate: ?*?*ID3D10Predicate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pPredicateDesc: ?*const D3D10_QUERY_DESC,
                ppPredicate: ?*?*ID3D10Predicate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCounter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pCounterDesc: ?*const D3D10_COUNTER_DESC,
                ppCounter: ?*?*ID3D10Counter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pCounterDesc: ?*const D3D10_COUNTER_DESC,
                ppCounter: ?*?*ID3D10Counter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckFormatSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                Format: DXGI_FORMAT,
                pFormatSupport: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                Format: DXGI_FORMAT,
                pFormatSupport: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckMultisampleQualityLevels: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                Format: DXGI_FORMAT,
                SampleCount: u32,
                pNumQualityLevels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                Format: DXGI_FORMAT,
                SampleCount: u32,
                pNumQualityLevels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckCounterInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pCounterInfo: ?*D3D10_COUNTER_INFO,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pCounterInfo: ?*D3D10_COUNTER_INFO,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CheckCounter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_COUNTER_DESC,
                pType: ?*D3D10_COUNTER_TYPE,
                pActiveCounters: ?*u32,
                szName: ?[*:0]u8,
                pNameLength: ?*u32,
                szUnits: ?[*:0]u8,
                pUnitsLength: ?*u32,
                szDescription: ?[*:0]u8,
                pDescriptionLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                pDesc: ?*const D3D10_COUNTER_DESC,
                pType: ?*D3D10_COUNTER_TYPE,
                pActiveCounters: ?*u32,
                szName: ?[*:0]u8,
                pNameLength: ?*u32,
                szUnits: ?[*:0]u8,
                pUnitsLength: ?*u32,
                szDescription: ?[*:0]u8,
                pDescriptionLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCreationFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        OpenSharedResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                hResource: ?HANDLE,
                ReturnedInterface: ?*const Guid,
                ppResource: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device,
                hResource: ?HANDLE,
                ReturnedInterface: ?*const Guid,
                ppResource: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextFilterSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                Width: u32,
                Height: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                Width: u32,
                Height: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetTextFilterSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device,
                pWidth: ?*u32,
                pHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Device,
                pWidth: ?*u32,
                pHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_VSSetConstantBuffers(self: *const T, StartSlot: u32, NumBuffers: u32, ppConstantBuffers: ?[*]?*ID3D10Buffer) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).VSSetConstantBuffers(@ptrCast(*const ID3D10Device, self), StartSlot, NumBuffers, ppConstantBuffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_PSSetShaderResources(self: *const T, StartSlot: u32, NumViews: u32, ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).PSSetShaderResources(@ptrCast(*const ID3D10Device, self), StartSlot, NumViews, ppShaderResourceViews);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_PSSetShader(self: *const T, pPixelShader: ?*ID3D10PixelShader) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).PSSetShader(@ptrCast(*const ID3D10Device, self), pPixelShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_PSSetSamplers(self: *const T, StartSlot: u32, NumSamplers: u32, ppSamplers: ?[*]?*ID3D10SamplerState) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).PSSetSamplers(@ptrCast(*const ID3D10Device, self), StartSlot, NumSamplers, ppSamplers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_VSSetShader(self: *const T, pVertexShader: ?*ID3D10VertexShader) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).VSSetShader(@ptrCast(*const ID3D10Device, self), pVertexShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_DrawIndexed(self: *const T, IndexCount: u32, StartIndexLocation: u32, BaseVertexLocation: i32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).DrawIndexed(@ptrCast(*const ID3D10Device, self), IndexCount, StartIndexLocation, BaseVertexLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_Draw(self: *const T, VertexCount: u32, StartVertexLocation: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).Draw(@ptrCast(*const ID3D10Device, self), VertexCount, StartVertexLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_PSSetConstantBuffers(self: *const T, StartSlot: u32, NumBuffers: u32, ppConstantBuffers: ?[*]?*ID3D10Buffer) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).PSSetConstantBuffers(@ptrCast(*const ID3D10Device, self), StartSlot, NumBuffers, ppConstantBuffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_IASetInputLayout(self: *const T, pInputLayout: ?*ID3D10InputLayout) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).IASetInputLayout(@ptrCast(*const ID3D10Device, self), pInputLayout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_IASetVertexBuffers(self: *const T, StartSlot: u32, NumBuffers: u32, ppVertexBuffers: ?[*]?*ID3D10Buffer, pStrides: ?[*]const u32, pOffsets: ?[*]const u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).IASetVertexBuffers(@ptrCast(*const ID3D10Device, self), StartSlot, NumBuffers, ppVertexBuffers, pStrides, pOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_IASetIndexBuffer(self: *const T, pIndexBuffer: ?*ID3D10Buffer, Format: DXGI_FORMAT, Offset: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).IASetIndexBuffer(@ptrCast(*const ID3D10Device, self), pIndexBuffer, Format, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_DrawIndexedInstanced(self: *const T, IndexCountPerInstance: u32, InstanceCount: u32, StartIndexLocation: u32, BaseVertexLocation: i32, StartInstanceLocation: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).DrawIndexedInstanced(@ptrCast(*const ID3D10Device, self), IndexCountPerInstance, InstanceCount, StartIndexLocation, BaseVertexLocation, StartInstanceLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_DrawInstanced(self: *const T, VertexCountPerInstance: u32, InstanceCount: u32, StartVertexLocation: u32, StartInstanceLocation: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).DrawInstanced(@ptrCast(*const ID3D10Device, self), VertexCountPerInstance, InstanceCount, StartVertexLocation, StartInstanceLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GSSetConstantBuffers(self: *const T, StartSlot: u32, NumBuffers: u32, ppConstantBuffers: ?[*]?*ID3D10Buffer) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GSSetConstantBuffers(@ptrCast(*const ID3D10Device, self), StartSlot, NumBuffers, ppConstantBuffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GSSetShader(self: *const T, pShader: ?*ID3D10GeometryShader) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GSSetShader(@ptrCast(*const ID3D10Device, self), pShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_IASetPrimitiveTopology(self: *const T, Topology: D3D_PRIMITIVE_TOPOLOGY) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).IASetPrimitiveTopology(@ptrCast(*const ID3D10Device, self), Topology);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_VSSetShaderResources(self: *const T, StartSlot: u32, NumViews: u32, ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).VSSetShaderResources(@ptrCast(*const ID3D10Device, self), StartSlot, NumViews, ppShaderResourceViews);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_VSSetSamplers(self: *const T, StartSlot: u32, NumSamplers: u32, ppSamplers: ?[*]?*ID3D10SamplerState) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).VSSetSamplers(@ptrCast(*const ID3D10Device, self), StartSlot, NumSamplers, ppSamplers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_SetPredication(self: *const T, pPredicate: ?*ID3D10Predicate, PredicateValue: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).SetPredication(@ptrCast(*const ID3D10Device, self), pPredicate, PredicateValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GSSetShaderResources(self: *const T, StartSlot: u32, NumViews: u32, ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GSSetShaderResources(@ptrCast(*const ID3D10Device, self), StartSlot, NumViews, ppShaderResourceViews);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GSSetSamplers(self: *const T, StartSlot: u32, NumSamplers: u32, ppSamplers: ?[*]?*ID3D10SamplerState) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GSSetSamplers(@ptrCast(*const ID3D10Device, self), StartSlot, NumSamplers, ppSamplers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_OMSetRenderTargets(self: *const T, NumViews: u32, ppRenderTargetViews: ?[*]?*ID3D10RenderTargetView, pDepthStencilView: ?*ID3D10DepthStencilView) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).OMSetRenderTargets(@ptrCast(*const ID3D10Device, self), NumViews, ppRenderTargetViews, pDepthStencilView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_OMSetBlendState(self: *const T, pBlendState: ?*ID3D10BlendState, BlendFactor: ?*const f32, SampleMask: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).OMSetBlendState(@ptrCast(*const ID3D10Device, self), pBlendState, BlendFactor, SampleMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_OMSetDepthStencilState(self: *const T, pDepthStencilState: ?*ID3D10DepthStencilState, StencilRef: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).OMSetDepthStencilState(@ptrCast(*const ID3D10Device, self), pDepthStencilState, StencilRef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_SOSetTargets(self: *const T, NumBuffers: u32, ppSOTargets: ?[*]?*ID3D10Buffer, pOffsets: ?[*]const u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).SOSetTargets(@ptrCast(*const ID3D10Device, self), NumBuffers, ppSOTargets, pOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_DrawAuto(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).DrawAuto(@ptrCast(*const ID3D10Device, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_RSSetState(self: *const T, pRasterizerState: ?*ID3D10RasterizerState) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).RSSetState(@ptrCast(*const ID3D10Device, self), pRasterizerState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_RSSetViewports(self: *const T, NumViewports: u32, pViewports: ?[*]const D3D10_VIEWPORT) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).RSSetViewports(@ptrCast(*const ID3D10Device, self), NumViewports, pViewports);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_RSSetScissorRects(self: *const T, NumRects: u32, pRects: ?[*]const RECT) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).RSSetScissorRects(@ptrCast(*const ID3D10Device, self), NumRects, pRects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CopySubresourceRegion(self: *const T, pDstResource: ?*ID3D10Resource, DstSubresource: u32, DstX: u32, DstY: u32, DstZ: u32, pSrcResource: ?*ID3D10Resource, SrcSubresource: u32, pSrcBox: ?*const D3D10_BOX) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CopySubresourceRegion(@ptrCast(*const ID3D10Device, self), pDstResource, DstSubresource, DstX, DstY, DstZ, pSrcResource, SrcSubresource, pSrcBox);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CopyResource(self: *const T, pDstResource: ?*ID3D10Resource, pSrcResource: ?*ID3D10Resource) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CopyResource(@ptrCast(*const ID3D10Device, self), pDstResource, pSrcResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_UpdateSubresource(self: *const T, pDstResource: ?*ID3D10Resource, DstSubresource: u32, pDstBox: ?*const D3D10_BOX, pSrcData: ?*const anyopaque, SrcRowPitch: u32, SrcDepthPitch: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).UpdateSubresource(@ptrCast(*const ID3D10Device, self), pDstResource, DstSubresource, pDstBox, pSrcData, SrcRowPitch, SrcDepthPitch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_ClearRenderTargetView(self: *const T, pRenderTargetView: ?*ID3D10RenderTargetView, ColorRGBA: ?*const f32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).ClearRenderTargetView(@ptrCast(*const ID3D10Device, self), pRenderTargetView, ColorRGBA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_ClearDepthStencilView(self: *const T, pDepthStencilView: ?*ID3D10DepthStencilView, ClearFlags: u32, Depth: f32, Stencil: u8) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).ClearDepthStencilView(@ptrCast(*const ID3D10Device, self), pDepthStencilView, ClearFlags, Depth, Stencil);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GenerateMips(self: *const T, pShaderResourceView: ?*ID3D10ShaderResourceView) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GenerateMips(@ptrCast(*const ID3D10Device, self), pShaderResourceView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_ResolveSubresource(self: *const T, pDstResource: ?*ID3D10Resource, DstSubresource: u32, pSrcResource: ?*ID3D10Resource, SrcSubresource: u32, Format: DXGI_FORMAT) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).ResolveSubresource(@ptrCast(*const ID3D10Device, self), pDstResource, DstSubresource, pSrcResource, SrcSubresource, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_VSGetConstantBuffers(self: *const T, StartSlot: u32, NumBuffers: u32, ppConstantBuffers: ?[*]?*ID3D10Buffer) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).VSGetConstantBuffers(@ptrCast(*const ID3D10Device, self), StartSlot, NumBuffers, ppConstantBuffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_PSGetShaderResources(self: *const T, StartSlot: u32, NumViews: u32, ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).PSGetShaderResources(@ptrCast(*const ID3D10Device, self), StartSlot, NumViews, ppShaderResourceViews);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_PSGetShader(self: *const T, ppPixelShader: ?*?*ID3D10PixelShader) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).PSGetShader(@ptrCast(*const ID3D10Device, self), ppPixelShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_PSGetSamplers(self: *const T, StartSlot: u32, NumSamplers: u32, ppSamplers: ?[*]?*ID3D10SamplerState) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).PSGetSamplers(@ptrCast(*const ID3D10Device, self), StartSlot, NumSamplers, ppSamplers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_VSGetShader(self: *const T, ppVertexShader: ?*?*ID3D10VertexShader) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).VSGetShader(@ptrCast(*const ID3D10Device, self), ppVertexShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_PSGetConstantBuffers(self: *const T, StartSlot: u32, NumBuffers: u32, ppConstantBuffers: ?[*]?*ID3D10Buffer) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).PSGetConstantBuffers(@ptrCast(*const ID3D10Device, self), StartSlot, NumBuffers, ppConstantBuffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_IAGetInputLayout(self: *const T, ppInputLayout: ?*?*ID3D10InputLayout) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).IAGetInputLayout(@ptrCast(*const ID3D10Device, self), ppInputLayout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_IAGetVertexBuffers(self: *const T, StartSlot: u32, NumBuffers: u32, ppVertexBuffers: ?[*]?*ID3D10Buffer, pStrides: ?[*]u32, pOffsets: ?[*]u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).IAGetVertexBuffers(@ptrCast(*const ID3D10Device, self), StartSlot, NumBuffers, ppVertexBuffers, pStrides, pOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_IAGetIndexBuffer(self: *const T, pIndexBuffer: ?*?*ID3D10Buffer, Format: ?*DXGI_FORMAT, Offset: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).IAGetIndexBuffer(@ptrCast(*const ID3D10Device, self), pIndexBuffer, Format, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GSGetConstantBuffers(self: *const T, StartSlot: u32, NumBuffers: u32, ppConstantBuffers: ?[*]?*ID3D10Buffer) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GSGetConstantBuffers(@ptrCast(*const ID3D10Device, self), StartSlot, NumBuffers, ppConstantBuffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GSGetShader(self: *const T, ppGeometryShader: ?*?*ID3D10GeometryShader) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GSGetShader(@ptrCast(*const ID3D10Device, self), ppGeometryShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_IAGetPrimitiveTopology(self: *const T, pTopology: ?*D3D_PRIMITIVE_TOPOLOGY) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).IAGetPrimitiveTopology(@ptrCast(*const ID3D10Device, self), pTopology);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_VSGetShaderResources(self: *const T, StartSlot: u32, NumViews: u32, ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).VSGetShaderResources(@ptrCast(*const ID3D10Device, self), StartSlot, NumViews, ppShaderResourceViews);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_VSGetSamplers(self: *const T, StartSlot: u32, NumSamplers: u32, ppSamplers: ?[*]?*ID3D10SamplerState) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).VSGetSamplers(@ptrCast(*const ID3D10Device, self), StartSlot, NumSamplers, ppSamplers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GetPredication(self: *const T, ppPredicate: ?*?*ID3D10Predicate, pPredicateValue: ?*BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GetPredication(@ptrCast(*const ID3D10Device, self), ppPredicate, pPredicateValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GSGetShaderResources(self: *const T, StartSlot: u32, NumViews: u32, ppShaderResourceViews: ?[*]?*ID3D10ShaderResourceView) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GSGetShaderResources(@ptrCast(*const ID3D10Device, self), StartSlot, NumViews, ppShaderResourceViews);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GSGetSamplers(self: *const T, StartSlot: u32, NumSamplers: u32, ppSamplers: ?[*]?*ID3D10SamplerState) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GSGetSamplers(@ptrCast(*const ID3D10Device, self), StartSlot, NumSamplers, ppSamplers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_OMGetRenderTargets(self: *const T, NumViews: u32, ppRenderTargetViews: ?[*]?*ID3D10RenderTargetView, ppDepthStencilView: ?*?*ID3D10DepthStencilView) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).OMGetRenderTargets(@ptrCast(*const ID3D10Device, self), NumViews, ppRenderTargetViews, ppDepthStencilView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_OMGetBlendState(self: *const T, ppBlendState: ?*?*ID3D10BlendState, BlendFactor: ?*f32, pSampleMask: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).OMGetBlendState(@ptrCast(*const ID3D10Device, self), ppBlendState, BlendFactor, pSampleMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_OMGetDepthStencilState(self: *const T, ppDepthStencilState: ?*?*ID3D10DepthStencilState, pStencilRef: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).OMGetDepthStencilState(@ptrCast(*const ID3D10Device, self), ppDepthStencilState, pStencilRef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_SOGetTargets(self: *const T, NumBuffers: u32, ppSOTargets: ?[*]?*ID3D10Buffer, pOffsets: ?[*]u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).SOGetTargets(@ptrCast(*const ID3D10Device, self), NumBuffers, ppSOTargets, pOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_RSGetState(self: *const T, ppRasterizerState: ?*?*ID3D10RasterizerState) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).RSGetState(@ptrCast(*const ID3D10Device, self), ppRasterizerState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_RSGetViewports(self: *const T, NumViewports: ?*u32, pViewports: ?[*]D3D10_VIEWPORT) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).RSGetViewports(@ptrCast(*const ID3D10Device, self), NumViewports, pViewports);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_RSGetScissorRects(self: *const T, NumRects: ?*u32, pRects: ?[*]RECT) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).RSGetScissorRects(@ptrCast(*const ID3D10Device, self), NumRects, pRects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GetDeviceRemovedReason(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GetDeviceRemovedReason(@ptrCast(*const ID3D10Device, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_SetExceptionMode(self: *const T, RaiseFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).SetExceptionMode(@ptrCast(*const ID3D10Device, self), RaiseFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GetExceptionMode(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GetExceptionMode(@ptrCast(*const ID3D10Device, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GetPrivateData(self: *const T, guid: ?*const Guid, pDataSize: ?*u32, pData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GetPrivateData(@ptrCast(*const ID3D10Device, self), guid, pDataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_SetPrivateData(self: *const T, guid: ?*const Guid, DataSize: u32, pData: ?*const anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).SetPrivateData(@ptrCast(*const ID3D10Device, self), guid, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_SetPrivateDataInterface(self: *const T, guid: ?*const Guid, pData: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).SetPrivateDataInterface(@ptrCast(*const ID3D10Device, self), guid, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_ClearState(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).ClearState(@ptrCast(*const ID3D10Device, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_Flush(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).Flush(@ptrCast(*const ID3D10Device, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateBuffer(self: *const T, pDesc: ?*const D3D10_BUFFER_DESC, pInitialData: ?*const D3D10_SUBRESOURCE_DATA, ppBuffer: ?*?*ID3D10Buffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateBuffer(@ptrCast(*const ID3D10Device, self), pDesc, pInitialData, ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateTexture1D(self: *const T, pDesc: ?*const D3D10_TEXTURE1D_DESC, pInitialData: ?*const D3D10_SUBRESOURCE_DATA, ppTexture1D: ?*?*ID3D10Texture1D) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateTexture1D(@ptrCast(*const ID3D10Device, self), pDesc, pInitialData, ppTexture1D);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateTexture2D(self: *const T, pDesc: ?*const D3D10_TEXTURE2D_DESC, pInitialData: ?*const D3D10_SUBRESOURCE_DATA, ppTexture2D: ?*?*ID3D10Texture2D) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateTexture2D(@ptrCast(*const ID3D10Device, self), pDesc, pInitialData, ppTexture2D);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateTexture3D(self: *const T, pDesc: ?*const D3D10_TEXTURE3D_DESC, pInitialData: ?*const D3D10_SUBRESOURCE_DATA, ppTexture3D: ?*?*ID3D10Texture3D) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateTexture3D(@ptrCast(*const ID3D10Device, self), pDesc, pInitialData, ppTexture3D);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateShaderResourceView(self: *const T, pResource: ?*ID3D10Resource, pDesc: ?*const D3D10_SHADER_RESOURCE_VIEW_DESC, ppSRView: ?*?*ID3D10ShaderResourceView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateShaderResourceView(@ptrCast(*const ID3D10Device, self), pResource, pDesc, ppSRView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateRenderTargetView(self: *const T, pResource: ?*ID3D10Resource, pDesc: ?*const D3D10_RENDER_TARGET_VIEW_DESC, ppRTView: ?*?*ID3D10RenderTargetView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateRenderTargetView(@ptrCast(*const ID3D10Device, self), pResource, pDesc, ppRTView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateDepthStencilView(self: *const T, pResource: ?*ID3D10Resource, pDesc: ?*const D3D10_DEPTH_STENCIL_VIEW_DESC, ppDepthStencilView: ?*?*ID3D10DepthStencilView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateDepthStencilView(@ptrCast(*const ID3D10Device, self), pResource, pDesc, ppDepthStencilView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateInputLayout(self: *const T, pInputElementDescs: [*]const D3D10_INPUT_ELEMENT_DESC, NumElements: u32, pShaderBytecodeWithInputSignature: [*]const u8, BytecodeLength: usize, ppInputLayout: ?*?*ID3D10InputLayout) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateInputLayout(@ptrCast(*const ID3D10Device, self), pInputElementDescs, NumElements, pShaderBytecodeWithInputSignature, BytecodeLength, ppInputLayout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateVertexShader(self: *const T, pShaderBytecode: [*]const u8, BytecodeLength: usize, ppVertexShader: ?*?*ID3D10VertexShader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateVertexShader(@ptrCast(*const ID3D10Device, self), pShaderBytecode, BytecodeLength, ppVertexShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateGeometryShader(self: *const T, pShaderBytecode: [*]const u8, BytecodeLength: usize, ppGeometryShader: ?*?*ID3D10GeometryShader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateGeometryShader(@ptrCast(*const ID3D10Device, self), pShaderBytecode, BytecodeLength, ppGeometryShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateGeometryShaderWithStreamOutput(self: *const T, pShaderBytecode: [*]const u8, BytecodeLength: usize, pSODeclaration: ?[*]const D3D10_SO_DECLARATION_ENTRY, NumEntries: u32, OutputStreamStride: u32, ppGeometryShader: ?*?*ID3D10GeometryShader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateGeometryShaderWithStreamOutput(@ptrCast(*const ID3D10Device, self), pShaderBytecode, BytecodeLength, pSODeclaration, NumEntries, OutputStreamStride, ppGeometryShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreatePixelShader(self: *const T, pShaderBytecode: [*]const u8, BytecodeLength: usize, ppPixelShader: ?*?*ID3D10PixelShader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreatePixelShader(@ptrCast(*const ID3D10Device, self), pShaderBytecode, BytecodeLength, ppPixelShader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateBlendState(self: *const T, pBlendStateDesc: ?*const D3D10_BLEND_DESC, ppBlendState: ?*?*ID3D10BlendState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateBlendState(@ptrCast(*const ID3D10Device, self), pBlendStateDesc, ppBlendState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateDepthStencilState(self: *const T, pDepthStencilDesc: ?*const D3D10_DEPTH_STENCIL_DESC, ppDepthStencilState: ?*?*ID3D10DepthStencilState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateDepthStencilState(@ptrCast(*const ID3D10Device, self), pDepthStencilDesc, ppDepthStencilState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateRasterizerState(self: *const T, pRasterizerDesc: ?*const D3D10_RASTERIZER_DESC, ppRasterizerState: ?*?*ID3D10RasterizerState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateRasterizerState(@ptrCast(*const ID3D10Device, self), pRasterizerDesc, ppRasterizerState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateSamplerState(self: *const T, pSamplerDesc: ?*const D3D10_SAMPLER_DESC, ppSamplerState: ?*?*ID3D10SamplerState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateSamplerState(@ptrCast(*const ID3D10Device, self), pSamplerDesc, ppSamplerState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateQuery(self: *const T, pQueryDesc: ?*const D3D10_QUERY_DESC, ppQuery: ?*?*ID3D10Query) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateQuery(@ptrCast(*const ID3D10Device, self), pQueryDesc, ppQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreatePredicate(self: *const T, pPredicateDesc: ?*const D3D10_QUERY_DESC, ppPredicate: ?*?*ID3D10Predicate) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreatePredicate(@ptrCast(*const ID3D10Device, self), pPredicateDesc, ppPredicate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CreateCounter(self: *const T, pCounterDesc: ?*const D3D10_COUNTER_DESC, ppCounter: ?*?*ID3D10Counter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CreateCounter(@ptrCast(*const ID3D10Device, self), pCounterDesc, ppCounter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CheckFormatSupport(self: *const T, Format: DXGI_FORMAT, pFormatSupport: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CheckFormatSupport(@ptrCast(*const ID3D10Device, self), Format, pFormatSupport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CheckMultisampleQualityLevels(self: *const T, Format: DXGI_FORMAT, SampleCount: u32, pNumQualityLevels: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CheckMultisampleQualityLevels(@ptrCast(*const ID3D10Device, self), Format, SampleCount, pNumQualityLevels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CheckCounterInfo(self: *const T, pCounterInfo: ?*D3D10_COUNTER_INFO) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CheckCounterInfo(@ptrCast(*const ID3D10Device, self), pCounterInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_CheckCounter(self: *const T, pDesc: ?*const D3D10_COUNTER_DESC, pType: ?*D3D10_COUNTER_TYPE, pActiveCounters: ?*u32, szName: ?[*:0]u8, pNameLength: ?*u32, szUnits: ?[*:0]u8, pUnitsLength: ?*u32, szDescription: ?[*:0]u8, pDescriptionLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).CheckCounter(@ptrCast(*const ID3D10Device, self), pDesc, pType, pActiveCounters, szName, pNameLength, szUnits, pUnitsLength, szDescription, pDescriptionLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GetCreationFlags(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GetCreationFlags(@ptrCast(*const ID3D10Device, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_OpenSharedResource(self: *const T, hResource: ?HANDLE, ReturnedInterface: ?*const Guid, ppResource: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).OpenSharedResource(@ptrCast(*const ID3D10Device, self), hResource, ReturnedInterface, ppResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_SetTextFilterSize(self: *const T, Width: u32, Height: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).SetTextFilterSize(@ptrCast(*const ID3D10Device, self), Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device_GetTextFilterSize(self: *const T, pWidth: ?*u32, pHeight: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Device.VTable, self.vtable).GetTextFilterSize(@ptrCast(*const ID3D10Device, self), pWidth, pHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10Multithread_Value = Guid.initString("9b7e4e00-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Multithread = &IID_ID3D10Multithread_Value;
pub const ID3D10Multithread = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Enter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Multithread,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Multithread,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Leave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Multithread,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10Multithread,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetMultithreadProtected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Multithread,
                bMTProtect: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10Multithread,
                bMTProtect: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetMultithreadProtected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Multithread,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10Multithread,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Multithread_Enter(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Multithread.VTable, self.vtable).Enter(@ptrCast(*const ID3D10Multithread, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Multithread_Leave(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10Multithread.VTable, self.vtable).Leave(@ptrCast(*const ID3D10Multithread, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Multithread_SetMultithreadProtected(self: *const T, bMTProtect: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10Multithread.VTable, self.vtable).SetMultithreadProtected(@ptrCast(*const ID3D10Multithread, self), bMTProtect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Multithread_GetMultithreadProtected(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10Multithread.VTable, self.vtable).GetMultithreadProtected(@ptrCast(*const ID3D10Multithread, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_CREATE_DEVICE_FLAG = enum(i32) {
    SINGLETHREADED = 1,
    DEBUG = 2,
    SWITCH_TO_REF = 4,
    PREVENT_INTERNAL_THREADING_OPTIMIZATIONS = 8,
    ALLOW_NULL_FROM_MAP = 16,
    BGRA_SUPPORT = 32,
    PREVENT_ALTERING_LAYER_SETTINGS_FROM_REGISTRY = 128,
    STRICT_VALIDATION = 512,
    DEBUGGABLE = 1024,
};
pub const D3D10_CREATE_DEVICE_SINGLETHREADED = D3D10_CREATE_DEVICE_FLAG.SINGLETHREADED;
pub const D3D10_CREATE_DEVICE_DEBUG = D3D10_CREATE_DEVICE_FLAG.DEBUG;
pub const D3D10_CREATE_DEVICE_SWITCH_TO_REF = D3D10_CREATE_DEVICE_FLAG.SWITCH_TO_REF;
pub const D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS = D3D10_CREATE_DEVICE_FLAG.PREVENT_INTERNAL_THREADING_OPTIMIZATIONS;
pub const D3D10_CREATE_DEVICE_ALLOW_NULL_FROM_MAP = D3D10_CREATE_DEVICE_FLAG.ALLOW_NULL_FROM_MAP;
pub const D3D10_CREATE_DEVICE_BGRA_SUPPORT = D3D10_CREATE_DEVICE_FLAG.BGRA_SUPPORT;
pub const D3D10_CREATE_DEVICE_PREVENT_ALTERING_LAYER_SETTINGS_FROM_REGISTRY = D3D10_CREATE_DEVICE_FLAG.PREVENT_ALTERING_LAYER_SETTINGS_FROM_REGISTRY;
pub const D3D10_CREATE_DEVICE_STRICT_VALIDATION = D3D10_CREATE_DEVICE_FLAG.STRICT_VALIDATION;
pub const D3D10_CREATE_DEVICE_DEBUGGABLE = D3D10_CREATE_DEVICE_FLAG.DEBUGGABLE;

const IID_ID3D10Debug_Value = Guid.initString("9b7e4e01-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Debug = &IID_ID3D10Debug_Value;
pub const ID3D10Debug = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFeatureMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Debug,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Debug,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeatureMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Debug,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID3D10Debug,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        SetPresentPerRenderOpDelay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Debug,
                Milliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Debug,
                Milliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresentPerRenderOpDelay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Debug,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID3D10Debug,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        SetSwapChain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Debug,
                pSwapChain: ?*IDXGISwapChain,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Debug,
                pSwapChain: ?*IDXGISwapChain,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSwapChain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Debug,
                ppSwapChain: ?*?*IDXGISwapChain,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Debug,
                ppSwapChain: ?*?*IDXGISwapChain,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Validate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Debug,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Debug,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Debug_SetFeatureMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Debug.VTable, self.vtable).SetFeatureMask(@ptrCast(*const ID3D10Debug, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Debug_GetFeatureMask(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D10Debug.VTable, self.vtable).GetFeatureMask(@ptrCast(*const ID3D10Debug, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Debug_SetPresentPerRenderOpDelay(self: *const T, Milliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Debug.VTable, self.vtable).SetPresentPerRenderOpDelay(@ptrCast(*const ID3D10Debug, self), Milliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Debug_GetPresentPerRenderOpDelay(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D10Debug.VTable, self.vtable).GetPresentPerRenderOpDelay(@ptrCast(*const ID3D10Debug, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Debug_SetSwapChain(self: *const T, pSwapChain: ?*IDXGISwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Debug.VTable, self.vtable).SetSwapChain(@ptrCast(*const ID3D10Debug, self), pSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Debug_GetSwapChain(self: *const T, ppSwapChain: ?*?*IDXGISwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Debug.VTable, self.vtable).GetSwapChain(@ptrCast(*const ID3D10Debug, self), ppSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Debug_Validate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Debug.VTable, self.vtable).Validate(@ptrCast(*const ID3D10Debug, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10SwitchToRef_Value = Guid.initString("9b7e4e02-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10SwitchToRef = &IID_ID3D10SwitchToRef_Value;
pub const ID3D10SwitchToRef = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUseRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10SwitchToRef,
                UseRef: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10SwitchToRef,
                UseRef: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetUseRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10SwitchToRef,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10SwitchToRef,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10SwitchToRef_SetUseRef(self: *const T, UseRef: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10SwitchToRef.VTable, self.vtable).SetUseRef(@ptrCast(*const ID3D10SwitchToRef, self), UseRef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10SwitchToRef_GetUseRef(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10SwitchToRef.VTable, self.vtable).GetUseRef(@ptrCast(*const ID3D10SwitchToRef, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_MESSAGE_CATEGORY = enum(i32) {
    APPLICATION_DEFINED = 0,
    MISCELLANEOUS = 1,
    INITIALIZATION = 2,
    CLEANUP = 3,
    COMPILATION = 4,
    STATE_CREATION = 5,
    STATE_SETTING = 6,
    STATE_GETTING = 7,
    RESOURCE_MANIPULATION = 8,
    EXECUTION = 9,
    SHADER = 10,
};
pub const D3D10_MESSAGE_CATEGORY_APPLICATION_DEFINED = D3D10_MESSAGE_CATEGORY.APPLICATION_DEFINED;
pub const D3D10_MESSAGE_CATEGORY_MISCELLANEOUS = D3D10_MESSAGE_CATEGORY.MISCELLANEOUS;
pub const D3D10_MESSAGE_CATEGORY_INITIALIZATION = D3D10_MESSAGE_CATEGORY.INITIALIZATION;
pub const D3D10_MESSAGE_CATEGORY_CLEANUP = D3D10_MESSAGE_CATEGORY.CLEANUP;
pub const D3D10_MESSAGE_CATEGORY_COMPILATION = D3D10_MESSAGE_CATEGORY.COMPILATION;
pub const D3D10_MESSAGE_CATEGORY_STATE_CREATION = D3D10_MESSAGE_CATEGORY.STATE_CREATION;
pub const D3D10_MESSAGE_CATEGORY_STATE_SETTING = D3D10_MESSAGE_CATEGORY.STATE_SETTING;
pub const D3D10_MESSAGE_CATEGORY_STATE_GETTING = D3D10_MESSAGE_CATEGORY.STATE_GETTING;
pub const D3D10_MESSAGE_CATEGORY_RESOURCE_MANIPULATION = D3D10_MESSAGE_CATEGORY.RESOURCE_MANIPULATION;
pub const D3D10_MESSAGE_CATEGORY_EXECUTION = D3D10_MESSAGE_CATEGORY.EXECUTION;
pub const D3D10_MESSAGE_CATEGORY_SHADER = D3D10_MESSAGE_CATEGORY.SHADER;

pub const D3D10_MESSAGE_SEVERITY = enum(i32) {
    CORRUPTION = 0,
    ERROR = 1,
    WARNING = 2,
    INFO = 3,
    MESSAGE = 4,
};
pub const D3D10_MESSAGE_SEVERITY_CORRUPTION = D3D10_MESSAGE_SEVERITY.CORRUPTION;
pub const D3D10_MESSAGE_SEVERITY_ERROR = D3D10_MESSAGE_SEVERITY.ERROR;
pub const D3D10_MESSAGE_SEVERITY_WARNING = D3D10_MESSAGE_SEVERITY.WARNING;
pub const D3D10_MESSAGE_SEVERITY_INFO = D3D10_MESSAGE_SEVERITY.INFO;
pub const D3D10_MESSAGE_SEVERITY_MESSAGE = D3D10_MESSAGE_SEVERITY.MESSAGE;

pub const D3D10_MESSAGE_ID = enum(i32) {
    UNKNOWN = 0,
    DEVICE_IASETVERTEXBUFFERS_HAZARD = 1,
    DEVICE_IASETINDEXBUFFER_HAZARD = 2,
    DEVICE_VSSETSHADERRESOURCES_HAZARD = 3,
    DEVICE_VSSETCONSTANTBUFFERS_HAZARD = 4,
    DEVICE_GSSETSHADERRESOURCES_HAZARD = 5,
    DEVICE_GSSETCONSTANTBUFFERS_HAZARD = 6,
    DEVICE_PSSETSHADERRESOURCES_HAZARD = 7,
    DEVICE_PSSETCONSTANTBUFFERS_HAZARD = 8,
    DEVICE_OMSETRENDERTARGETS_HAZARD = 9,
    DEVICE_SOSETTARGETS_HAZARD = 10,
    STRING_FROM_APPLICATION = 11,
    CORRUPTED_THIS = 12,
    CORRUPTED_PARAMETER1 = 13,
    CORRUPTED_PARAMETER2 = 14,
    CORRUPTED_PARAMETER3 = 15,
    CORRUPTED_PARAMETER4 = 16,
    CORRUPTED_PARAMETER5 = 17,
    CORRUPTED_PARAMETER6 = 18,
    CORRUPTED_PARAMETER7 = 19,
    CORRUPTED_PARAMETER8 = 20,
    CORRUPTED_PARAMETER9 = 21,
    CORRUPTED_PARAMETER10 = 22,
    CORRUPTED_PARAMETER11 = 23,
    CORRUPTED_PARAMETER12 = 24,
    CORRUPTED_PARAMETER13 = 25,
    CORRUPTED_PARAMETER14 = 26,
    CORRUPTED_PARAMETER15 = 27,
    CORRUPTED_MULTITHREADING = 28,
    MESSAGE_REPORTING_OUTOFMEMORY = 29,
    IASETINPUTLAYOUT_UNBINDDELETINGOBJECT = 30,
    IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT = 31,
    IASETINDEXBUFFER_UNBINDDELETINGOBJECT = 32,
    VSSETSHADER_UNBINDDELETINGOBJECT = 33,
    VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = 34,
    VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = 35,
    VSSETSAMPLERS_UNBINDDELETINGOBJECT = 36,
    GSSETSHADER_UNBINDDELETINGOBJECT = 37,
    GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = 38,
    GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = 39,
    GSSETSAMPLERS_UNBINDDELETINGOBJECT = 40,
    SOSETTARGETS_UNBINDDELETINGOBJECT = 41,
    PSSETSHADER_UNBINDDELETINGOBJECT = 42,
    PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = 43,
    PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = 44,
    PSSETSAMPLERS_UNBINDDELETINGOBJECT = 45,
    RSSETSTATE_UNBINDDELETINGOBJECT = 46,
    OMSETBLENDSTATE_UNBINDDELETINGOBJECT = 47,
    OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT = 48,
    OMSETRENDERTARGETS_UNBINDDELETINGOBJECT = 49,
    SETPREDICATION_UNBINDDELETINGOBJECT = 50,
    GETPRIVATEDATA_MOREDATA = 51,
    SETPRIVATEDATA_INVALIDFREEDATA = 52,
    SETPRIVATEDATA_INVALIDIUNKNOWN = 53,
    SETPRIVATEDATA_INVALIDFLAGS = 54,
    SETPRIVATEDATA_CHANGINGPARAMS = 55,
    SETPRIVATEDATA_OUTOFMEMORY = 56,
    CREATEBUFFER_UNRECOGNIZEDFORMAT = 57,
    CREATEBUFFER_INVALIDSAMPLES = 58,
    CREATEBUFFER_UNRECOGNIZEDUSAGE = 59,
    CREATEBUFFER_UNRECOGNIZEDBINDFLAGS = 60,
    CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS = 61,
    CREATEBUFFER_UNRECOGNIZEDMISCFLAGS = 62,
    CREATEBUFFER_INVALIDCPUACCESSFLAGS = 63,
    CREATEBUFFER_INVALIDBINDFLAGS = 64,
    CREATEBUFFER_INVALIDINITIALDATA = 65,
    CREATEBUFFER_INVALIDDIMENSIONS = 66,
    CREATEBUFFER_INVALIDMIPLEVELS = 67,
    CREATEBUFFER_INVALIDMISCFLAGS = 68,
    CREATEBUFFER_INVALIDARG_RETURN = 69,
    CREATEBUFFER_OUTOFMEMORY_RETURN = 70,
    CREATEBUFFER_NULLDESC = 71,
    CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS = 72,
    CREATEBUFFER_LARGEALLOCATION = 73,
    CREATETEXTURE1D_UNRECOGNIZEDFORMAT = 74,
    CREATETEXTURE1D_UNSUPPORTEDFORMAT = 75,
    CREATETEXTURE1D_INVALIDSAMPLES = 76,
    CREATETEXTURE1D_UNRECOGNIZEDUSAGE = 77,
    CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS = 78,
    CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS = 79,
    CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS = 80,
    CREATETEXTURE1D_INVALIDCPUACCESSFLAGS = 81,
    CREATETEXTURE1D_INVALIDBINDFLAGS = 82,
    CREATETEXTURE1D_INVALIDINITIALDATA = 83,
    CREATETEXTURE1D_INVALIDDIMENSIONS = 84,
    CREATETEXTURE1D_INVALIDMIPLEVELS = 85,
    CREATETEXTURE1D_INVALIDMISCFLAGS = 86,
    CREATETEXTURE1D_INVALIDARG_RETURN = 87,
    CREATETEXTURE1D_OUTOFMEMORY_RETURN = 88,
    CREATETEXTURE1D_NULLDESC = 89,
    CREATETEXTURE1D_LARGEALLOCATION = 90,
    CREATETEXTURE2D_UNRECOGNIZEDFORMAT = 91,
    CREATETEXTURE2D_UNSUPPORTEDFORMAT = 92,
    CREATETEXTURE2D_INVALIDSAMPLES = 93,
    CREATETEXTURE2D_UNRECOGNIZEDUSAGE = 94,
    CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS = 95,
    CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS = 96,
    CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS = 97,
    CREATETEXTURE2D_INVALIDCPUACCESSFLAGS = 98,
    CREATETEXTURE2D_INVALIDBINDFLAGS = 99,
    CREATETEXTURE2D_INVALIDINITIALDATA = 100,
    CREATETEXTURE2D_INVALIDDIMENSIONS = 101,
    CREATETEXTURE2D_INVALIDMIPLEVELS = 102,
    CREATETEXTURE2D_INVALIDMISCFLAGS = 103,
    CREATETEXTURE2D_INVALIDARG_RETURN = 104,
    CREATETEXTURE2D_OUTOFMEMORY_RETURN = 105,
    CREATETEXTURE2D_NULLDESC = 106,
    CREATETEXTURE2D_LARGEALLOCATION = 107,
    CREATETEXTURE3D_UNRECOGNIZEDFORMAT = 108,
    CREATETEXTURE3D_UNSUPPORTEDFORMAT = 109,
    CREATETEXTURE3D_INVALIDSAMPLES = 110,
    CREATETEXTURE3D_UNRECOGNIZEDUSAGE = 111,
    CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS = 112,
    CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS = 113,
    CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS = 114,
    CREATETEXTURE3D_INVALIDCPUACCESSFLAGS = 115,
    CREATETEXTURE3D_INVALIDBINDFLAGS = 116,
    CREATETEXTURE3D_INVALIDINITIALDATA = 117,
    CREATETEXTURE3D_INVALIDDIMENSIONS = 118,
    CREATETEXTURE3D_INVALIDMIPLEVELS = 119,
    CREATETEXTURE3D_INVALIDMISCFLAGS = 120,
    CREATETEXTURE3D_INVALIDARG_RETURN = 121,
    CREATETEXTURE3D_OUTOFMEMORY_RETURN = 122,
    CREATETEXTURE3D_NULLDESC = 123,
    CREATETEXTURE3D_LARGEALLOCATION = 124,
    CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT = 125,
    CREATESHADERRESOURCEVIEW_INVALIDDESC = 126,
    CREATESHADERRESOURCEVIEW_INVALIDFORMAT = 127,
    CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS = 128,
    CREATESHADERRESOURCEVIEW_INVALIDRESOURCE = 129,
    CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS = 130,
    CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN = 131,
    CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN = 132,
    CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT = 133,
    CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT = 134,
    CREATERENDERTARGETVIEW_INVALIDDESC = 135,
    CREATERENDERTARGETVIEW_INVALIDFORMAT = 136,
    CREATERENDERTARGETVIEW_INVALIDDIMENSIONS = 137,
    CREATERENDERTARGETVIEW_INVALIDRESOURCE = 138,
    CREATERENDERTARGETVIEW_TOOMANYOBJECTS = 139,
    CREATERENDERTARGETVIEW_INVALIDARG_RETURN = 140,
    CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN = 141,
    CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT = 142,
    CREATEDEPTHSTENCILVIEW_INVALIDDESC = 143,
    CREATEDEPTHSTENCILVIEW_INVALIDFORMAT = 144,
    CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS = 145,
    CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE = 146,
    CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS = 147,
    CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN = 148,
    CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN = 149,
    CREATEINPUTLAYOUT_OUTOFMEMORY = 150,
    CREATEINPUTLAYOUT_TOOMANYELEMENTS = 151,
    CREATEINPUTLAYOUT_INVALIDFORMAT = 152,
    CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT = 153,
    CREATEINPUTLAYOUT_INVALIDSLOT = 154,
    CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS = 155,
    CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH = 156,
    CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE = 157,
    CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE = 158,
    CREATEINPUTLAYOUT_INVALIDALIGNMENT = 159,
    CREATEINPUTLAYOUT_DUPLICATESEMANTIC = 160,
    CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE = 161,
    CREATEINPUTLAYOUT_NULLSEMANTIC = 162,
    CREATEINPUTLAYOUT_MISSINGELEMENT = 163,
    CREATEINPUTLAYOUT_NULLDESC = 164,
    CREATEVERTEXSHADER_OUTOFMEMORY = 165,
    CREATEVERTEXSHADER_INVALIDSHADERBYTECODE = 166,
    CREATEVERTEXSHADER_INVALIDSHADERTYPE = 167,
    CREATEGEOMETRYSHADER_OUTOFMEMORY = 168,
    CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE = 169,
    CREATEGEOMETRYSHADER_INVALIDSHADERTYPE = 170,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY = 171,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE = 172,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE = 173,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES = 174,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED = 175,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL = 176,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL = 177,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED = 178,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT = 179,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT = 180,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT = 181,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT = 182,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION = 183,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT = 184,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE = 185,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC = 186,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH = 187,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS = 188,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX = 189,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE = 190,
    CREATEPIXELSHADER_OUTOFMEMORY = 191,
    CREATEPIXELSHADER_INVALIDSHADERBYTECODE = 192,
    CREATEPIXELSHADER_INVALIDSHADERTYPE = 193,
    CREATERASTERIZERSTATE_INVALIDFILLMODE = 194,
    CREATERASTERIZERSTATE_INVALIDCULLMODE = 195,
    CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP = 196,
    CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS = 197,
    CREATERASTERIZERSTATE_TOOMANYOBJECTS = 198,
    CREATERASTERIZERSTATE_NULLDESC = 199,
    CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK = 200,
    CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC = 201,
    CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP = 202,
    CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP = 203,
    CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP = 204,
    CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC = 205,
    CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP = 206,
    CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP = 207,
    CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP = 208,
    CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC = 209,
    CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS = 210,
    CREATEDEPTHSTENCILSTATE_NULLDESC = 211,
    CREATEBLENDSTATE_INVALIDSRCBLEND = 212,
    CREATEBLENDSTATE_INVALIDDESTBLEND = 213,
    CREATEBLENDSTATE_INVALIDBLENDOP = 214,
    CREATEBLENDSTATE_INVALIDSRCBLENDALPHA = 215,
    CREATEBLENDSTATE_INVALIDDESTBLENDALPHA = 216,
    CREATEBLENDSTATE_INVALIDBLENDOPALPHA = 217,
    CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK = 218,
    CREATEBLENDSTATE_TOOMANYOBJECTS = 219,
    CREATEBLENDSTATE_NULLDESC = 220,
    CREATESAMPLERSTATE_INVALIDFILTER = 221,
    CREATESAMPLERSTATE_INVALIDADDRESSU = 222,
    CREATESAMPLERSTATE_INVALIDADDRESSV = 223,
    CREATESAMPLERSTATE_INVALIDADDRESSW = 224,
    CREATESAMPLERSTATE_INVALIDMIPLODBIAS = 225,
    CREATESAMPLERSTATE_INVALIDMAXANISOTROPY = 226,
    CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC = 227,
    CREATESAMPLERSTATE_INVALIDMINLOD = 228,
    CREATESAMPLERSTATE_INVALIDMAXLOD = 229,
    CREATESAMPLERSTATE_TOOMANYOBJECTS = 230,
    CREATESAMPLERSTATE_NULLDESC = 231,
    CREATEQUERYORPREDICATE_INVALIDQUERY = 232,
    CREATEQUERYORPREDICATE_INVALIDMISCFLAGS = 233,
    CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG = 234,
    CREATEQUERYORPREDICATE_NULLDESC = 235,
    DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED = 236,
    DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED = 237,
    IASETVERTEXBUFFERS_INVALIDBUFFER = 238,
    DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE = 239,
    DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY = 240,
    IASETINDEXBUFFER_INVALIDBUFFER = 241,
    DEVICE_IASETINDEXBUFFER_FORMAT_INVALID = 242,
    DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE = 243,
    DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED = 244,
    DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY = 245,
    VSSETCONSTANTBUFFERS_INVALIDBUFFER = 246,
    DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY = 247,
    DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY = 248,
    DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY = 249,
    GSSETCONSTANTBUFFERS_INVALIDBUFFER = 250,
    DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY = 251,
    DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY = 252,
    SOSETTARGETS_INVALIDBUFFER = 253,
    DEVICE_SOSETTARGETS_OFFSET_UNALIGNED = 254,
    DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY = 255,
    PSSETCONSTANTBUFFERS_INVALIDBUFFER = 256,
    DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY = 257,
    DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY = 258,
    DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT = 259,
    DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR = 260,
    CLEARRENDERTARGETVIEW_DENORMFLUSH = 261,
    CLEARDEPTHSTENCILVIEW_DENORMFLUSH = 262,
    CLEARDEPTHSTENCILVIEW_INVALID = 263,
    DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY = 264,
    DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY = 265,
    DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY = 266,
    DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY = 267,
    DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY = 268,
    DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY = 269,
    DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY = 270,
    DEVICE_SOGETTARGETS_BUFFERS_EMPTY = 271,
    DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY = 272,
    DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY = 273,
    DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY = 274,
    DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY = 275,
    DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY = 276,
    DEVICE_GENERATEMIPS_RESOURCE_INVALID = 277,
    COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE = 278,
    COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE = 279,
    COPYSUBRESOURCEREGION_INVALIDSOURCEBOX = 280,
    COPYSUBRESOURCEREGION_INVALIDSOURCE = 281,
    COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE = 282,
    COPYSUBRESOURCEREGION_INVALIDSOURCESTATE = 283,
    COPYRESOURCE_INVALIDSOURCE = 284,
    COPYRESOURCE_INVALIDDESTINATIONSTATE = 285,
    COPYRESOURCE_INVALIDSOURCESTATE = 286,
    UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE = 287,
    UPDATESUBRESOURCE_INVALIDDESTINATIONBOX = 288,
    UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE = 289,
    DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID = 290,
    DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID = 291,
    DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID = 292,
    DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID = 293,
    DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID = 294,
    BUFFER_MAP_INVALIDMAPTYPE = 295,
    BUFFER_MAP_INVALIDFLAGS = 296,
    BUFFER_MAP_ALREADYMAPPED = 297,
    BUFFER_MAP_DEVICEREMOVED_RETURN = 298,
    BUFFER_UNMAP_NOTMAPPED = 299,
    TEXTURE1D_MAP_INVALIDMAPTYPE = 300,
    TEXTURE1D_MAP_INVALIDSUBRESOURCE = 301,
    TEXTURE1D_MAP_INVALIDFLAGS = 302,
    TEXTURE1D_MAP_ALREADYMAPPED = 303,
    TEXTURE1D_MAP_DEVICEREMOVED_RETURN = 304,
    TEXTURE1D_UNMAP_INVALIDSUBRESOURCE = 305,
    TEXTURE1D_UNMAP_NOTMAPPED = 306,
    TEXTURE2D_MAP_INVALIDMAPTYPE = 307,
    TEXTURE2D_MAP_INVALIDSUBRESOURCE = 308,
    TEXTURE2D_MAP_INVALIDFLAGS = 309,
    TEXTURE2D_MAP_ALREADYMAPPED = 310,
    TEXTURE2D_MAP_DEVICEREMOVED_RETURN = 311,
    TEXTURE2D_UNMAP_INVALIDSUBRESOURCE = 312,
    TEXTURE2D_UNMAP_NOTMAPPED = 313,
    TEXTURE3D_MAP_INVALIDMAPTYPE = 314,
    TEXTURE3D_MAP_INVALIDSUBRESOURCE = 315,
    TEXTURE3D_MAP_INVALIDFLAGS = 316,
    TEXTURE3D_MAP_ALREADYMAPPED = 317,
    TEXTURE3D_MAP_DEVICEREMOVED_RETURN = 318,
    TEXTURE3D_UNMAP_INVALIDSUBRESOURCE = 319,
    TEXTURE3D_UNMAP_NOTMAPPED = 320,
    CHECKFORMATSUPPORT_FORMAT_DEPRECATED = 321,
    CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED = 322,
    SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS = 323,
    SETEXCEPTIONMODE_INVALIDARG_RETURN = 324,
    SETEXCEPTIONMODE_DEVICEREMOVED_RETURN = 325,
    REF_SIMULATING_INFINITELY_FAST_HARDWARE = 326,
    REF_THREADING_MODE = 327,
    REF_UMDRIVER_EXCEPTION = 328,
    REF_KMDRIVER_EXCEPTION = 329,
    REF_HARDWARE_EXCEPTION = 330,
    REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE = 331,
    REF_PROBLEM_PARSING_SHADER = 332,
    REF_OUT_OF_MEMORY = 333,
    REF_INFO = 334,
    DEVICE_DRAW_VERTEXPOS_OVERFLOW = 335,
    DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW = 336,
    DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW = 337,
    DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW = 338,
    DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW = 339,
    DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW = 340,
    DEVICE_DRAW_VERTEX_SHADER_NOT_SET = 341,
    DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND = 342,
    DEVICE_SHADER_LINKAGE_REGISTERINDEX = 343,
    DEVICE_SHADER_LINKAGE_COMPONENTTYPE = 344,
    DEVICE_SHADER_LINKAGE_REGISTERMASK = 345,
    DEVICE_SHADER_LINKAGE_SYSTEMVALUE = 346,
    DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS = 347,
    DEVICE_DRAW_VERTEX_BUFFER_NOT_SET = 348,
    DEVICE_DRAW_INPUTLAYOUT_NOT_SET = 349,
    DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET = 350,
    DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL = 351,
    DEVICE_DRAW_SAMPLER_NOT_SET = 352,
    DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET = 353,
    DEVICE_DRAW_VIEW_DIMENSION_MISMATCH = 354,
    DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL = 355,
    DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL = 356,
    DEVICE_DRAW_INDEX_BUFFER_NOT_SET = 357,
    DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID = 358,
    DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL = 359,
    DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH = 360,
    DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH = 361,
    DEVICE_DRAW_POSITION_NOT_PRESENT = 362,
    DEVICE_DRAW_OUTPUT_STREAM_NOT_SET = 363,
    DEVICE_DRAW_BOUND_RESOURCE_MAPPED = 364,
    DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY = 365,
    DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED = 366,
    DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED = 367,
    DEVICE_DRAW_INDEX_OFFSET_UNALIGNED = 368,
    DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED = 369,
    DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED = 370,
    DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED = 371,
    DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED = 372,
    DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED = 373,
    DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE = 374,
    DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER = 375,
    DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING = 376,
    DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 = 377,
    DEVICE_REMOVAL_PROCESS_AT_FAULT = 378,
    DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT = 379,
    DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT = 380,
    DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN = 381,
    DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN = 382,
    DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN = 383,
    DEVICE_DRAW_VIEWPORT_NOT_SET = 384,
    CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC = 385,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC = 386,
    DEVICE_RSSETVIEWPORTS_DENORMFLUSH = 387,
    OMSETRENDERTARGETS_INVALIDVIEW = 388,
    DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS = 389,
    DEVICE_DRAW_SAMPLER_MISMATCH = 390,
    CREATEINPUTLAYOUT_TYPE_MISMATCH = 391,
    BLENDSTATE_GETDESC_LEGACY = 392,
    SHADERRESOURCEVIEW_GETDESC_LEGACY = 393,
    CREATEQUERY_OUTOFMEMORY_RETURN = 394,
    CREATEPREDICATE_OUTOFMEMORY_RETURN = 395,
    CREATECOUNTER_OUTOFRANGE_COUNTER = 396,
    CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED = 397,
    CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER = 398,
    CREATECOUNTER_OUTOFMEMORY_RETURN = 399,
    CREATECOUNTER_NONEXCLUSIVE_RETURN = 400,
    CREATECOUNTER_NULLDESC = 401,
    CHECKCOUNTER_OUTOFRANGE_COUNTER = 402,
    CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER = 403,
    SETPREDICATION_INVALID_PREDICATE_STATE = 404,
    QUERY_BEGIN_UNSUPPORTED = 405,
    PREDICATE_BEGIN_DURING_PREDICATION = 406,
    QUERY_BEGIN_DUPLICATE = 407,
    QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS = 408,
    PREDICATE_END_DURING_PREDICATION = 409,
    QUERY_END_ABANDONING_PREVIOUS_RESULTS = 410,
    QUERY_END_WITHOUT_BEGIN = 411,
    QUERY_GETDATA_INVALID_DATASIZE = 412,
    QUERY_GETDATA_INVALID_FLAGS = 413,
    QUERY_GETDATA_INVALID_CALL = 414,
    DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH = 415,
    DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED = 416,
    DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN = 417,
    DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE = 418,
    DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE = 419,
    CREATEINPUTLAYOUT_EMPTY_LAYOUT = 420,
    DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH = 421,
    LIVE_OBJECT_SUMMARY = 422,
    LIVE_BUFFER = 423,
    LIVE_TEXTURE1D = 424,
    LIVE_TEXTURE2D = 425,
    LIVE_TEXTURE3D = 426,
    LIVE_SHADERRESOURCEVIEW = 427,
    LIVE_RENDERTARGETVIEW = 428,
    LIVE_DEPTHSTENCILVIEW = 429,
    LIVE_VERTEXSHADER = 430,
    LIVE_GEOMETRYSHADER = 431,
    LIVE_PIXELSHADER = 432,
    LIVE_INPUTLAYOUT = 433,
    LIVE_SAMPLER = 434,
    LIVE_BLENDSTATE = 435,
    LIVE_DEPTHSTENCILSTATE = 436,
    LIVE_RASTERIZERSTATE = 437,
    LIVE_QUERY = 438,
    LIVE_PREDICATE = 439,
    LIVE_COUNTER = 440,
    LIVE_DEVICE = 441,
    LIVE_SWAPCHAIN = 442,
    D3D10_MESSAGES_END = 443,
    D3D10L9_MESSAGES_START = 1048576,
    CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED = 1048577,
    CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED = 1048578,
    CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT = 1048579,
    CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY = 1048580,
    CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE = 1048581,
    VSSETSAMPLERS_NOT_SUPPORTED = 1048582,
    VSSETSAMPLERS_TOO_MANY_SAMPLERS = 1048583,
    PSSETSAMPLERS_TOO_MANY_SAMPLERS = 1048584,
    CREATERESOURCE_NO_ARRAYS = 1048585,
    CREATERESOURCE_NO_VB_AND_IB_BIND = 1048586,
    CREATERESOURCE_NO_TEXTURE_1D = 1048587,
    CREATERESOURCE_DIMENSION_OUT_OF_RANGE = 1048588,
    CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE = 1048589,
    OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS = 1048590,
    OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS = 1048591,
    IASETVERTEXBUFFERS_BAD_BUFFER_INDEX = 1048592,
    DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS = 1048593,
    DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED = 1048594,
    DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS = 1048595,
    COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY = 1048596,
    COPYRESOURCE_NO_TEXTURE_3D_READBACK = 1048597,
    COPYRESOURCE_NO_TEXTURE_ONLY_READBACK = 1048598,
    CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT = 1048599,
    CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE = 1048600,
    CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE = 1048601,
    DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE = 1048602,
    CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD = 1048603,
    CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL = 1048604,
    CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX = 1048605,
    CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO = 1048606,
    CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES = 1048607,
    CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET = 1048608,
    CREATERESOURCE_NO_DWORD_INDEX_BUFFER = 1048609,
    CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE = 1048610,
    CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE = 1048611,
    CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE = 1048612,
    CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS = 1048613,
    CREATERESOURCE_NO_STREAM_OUT = 1048614,
    CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS = 1048615,
    CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES = 1048616,
    CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED = 1048617,
    VSSHADERRESOURCES_NOT_SUPPORTED = 1048618,
    GEOMETRY_SHADER_NOT_SUPPORTED = 1048619,
    STREAM_OUT_NOT_SUPPORTED = 1048620,
    TEXT_FILTER_NOT_SUPPORTED = 1048621,
    CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND = 1048622,
    CREATEBLENDSTATE_NO_MRT_BLEND = 1048623,
    CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED = 1048624,
    CREATESAMPLERSTATE_NO_MIRRORONCE = 1048625,
    DRAWINSTANCED_NOT_SUPPORTED = 1048626,
    DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3 = 1048627,
    DRAWINDEXED_POINTLIST_UNSUPPORTED = 1048628,
    SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO = 1048629,
    CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION = 1048630,
    CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED = 1048631,
    DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR = 1048632,
    SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA = 1048633,
    CREATERESOURCE_NON_POW_2_MIPMAP = 1048634,
    CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED = 1048635,
    OMSETRENDERTARGETS_NO_SRGB_MRT = 1048636,
    COPYRESOURCE_NO_3D_MISMATCHED_UPDATES = 1048637,
    D3D10L9_MESSAGES_END = 1048638,
};
pub const D3D10_MESSAGE_ID_UNKNOWN = D3D10_MESSAGE_ID.UNKNOWN;
pub const D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_HAZARD = D3D10_MESSAGE_ID.DEVICE_IASETVERTEXBUFFERS_HAZARD;
pub const D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_HAZARD = D3D10_MESSAGE_ID.DEVICE_IASETINDEXBUFFER_HAZARD;
pub const D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_HAZARD = D3D10_MESSAGE_ID.DEVICE_VSSETSHADERRESOURCES_HAZARD;
pub const D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_HAZARD = D3D10_MESSAGE_ID.DEVICE_VSSETCONSTANTBUFFERS_HAZARD;
pub const D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_HAZARD = D3D10_MESSAGE_ID.DEVICE_GSSETSHADERRESOURCES_HAZARD;
pub const D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_HAZARD = D3D10_MESSAGE_ID.DEVICE_GSSETCONSTANTBUFFERS_HAZARD;
pub const D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD = D3D10_MESSAGE_ID.DEVICE_PSSETSHADERRESOURCES_HAZARD;
pub const D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_HAZARD = D3D10_MESSAGE_ID.DEVICE_PSSETCONSTANTBUFFERS_HAZARD;
pub const D3D10_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD = D3D10_MESSAGE_ID.DEVICE_OMSETRENDERTARGETS_HAZARD;
pub const D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_HAZARD = D3D10_MESSAGE_ID.DEVICE_SOSETTARGETS_HAZARD;
pub const D3D10_MESSAGE_ID_STRING_FROM_APPLICATION = D3D10_MESSAGE_ID.STRING_FROM_APPLICATION;
pub const D3D10_MESSAGE_ID_CORRUPTED_THIS = D3D10_MESSAGE_ID.CORRUPTED_THIS;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER1 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER1;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER2 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER2;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER3 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER3;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER4 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER4;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER5 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER5;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER6 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER6;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER7 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER7;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER8 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER8;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER9 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER9;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER10 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER10;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER11 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER11;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER12 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER12;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER13 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER13;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER14 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER14;
pub const D3D10_MESSAGE_ID_CORRUPTED_PARAMETER15 = D3D10_MESSAGE_ID.CORRUPTED_PARAMETER15;
pub const D3D10_MESSAGE_ID_CORRUPTED_MULTITHREADING = D3D10_MESSAGE_ID.CORRUPTED_MULTITHREADING;
pub const D3D10_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY = D3D10_MESSAGE_ID.MESSAGE_REPORTING_OUTOFMEMORY;
pub const D3D10_MESSAGE_ID_IASETINPUTLAYOUT_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.IASETINPUTLAYOUT_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_IASETINDEXBUFFER_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.IASETINDEXBUFFER_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_VSSETSHADER_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.VSSETSHADER_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_VSSETSAMPLERS_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.VSSETSAMPLERS_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_GSSETSHADER_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.GSSETSHADER_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_GSSETSAMPLERS_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.GSSETSAMPLERS_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_SOSETTARGETS_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.SOSETTARGETS_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_PSSETSHADER_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.PSSETSHADER_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_PSSETSAMPLERS_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.PSSETSAMPLERS_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_RSSETSTATE_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.RSSETSTATE_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_OMSETBLENDSTATE_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.OMSETBLENDSTATE_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_OMSETRENDERTARGETS_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.OMSETRENDERTARGETS_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_SETPREDICATION_UNBINDDELETINGOBJECT = D3D10_MESSAGE_ID.SETPREDICATION_UNBINDDELETINGOBJECT;
pub const D3D10_MESSAGE_ID_GETPRIVATEDATA_MOREDATA = D3D10_MESSAGE_ID.GETPRIVATEDATA_MOREDATA;
pub const D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA = D3D10_MESSAGE_ID.SETPRIVATEDATA_INVALIDFREEDATA;
pub const D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN = D3D10_MESSAGE_ID.SETPRIVATEDATA_INVALIDIUNKNOWN;
pub const D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS = D3D10_MESSAGE_ID.SETPRIVATEDATA_INVALIDFLAGS;
pub const D3D10_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS = D3D10_MESSAGE_ID.SETPRIVATEDATA_CHANGINGPARAMS;
pub const D3D10_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY = D3D10_MESSAGE_ID.SETPRIVATEDATA_OUTOFMEMORY;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDFORMAT = D3D10_MESSAGE_ID.CREATEBUFFER_UNRECOGNIZEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDSAMPLES = D3D10_MESSAGE_ID.CREATEBUFFER_INVALIDSAMPLES;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDUSAGE = D3D10_MESSAGE_ID.CREATEBUFFER_UNRECOGNIZEDUSAGE;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDBINDFLAGS = D3D10_MESSAGE_ID.CREATEBUFFER_UNRECOGNIZEDBINDFLAGS;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS = D3D10_MESSAGE_ID.CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDMISCFLAGS = D3D10_MESSAGE_ID.CREATEBUFFER_UNRECOGNIZEDMISCFLAGS;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCPUACCESSFLAGS = D3D10_MESSAGE_ID.CREATEBUFFER_INVALIDCPUACCESSFLAGS;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDBINDFLAGS = D3D10_MESSAGE_ID.CREATEBUFFER_INVALIDBINDFLAGS;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDINITIALDATA = D3D10_MESSAGE_ID.CREATEBUFFER_INVALIDINITIALDATA;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDDIMENSIONS = D3D10_MESSAGE_ID.CREATEBUFFER_INVALIDDIMENSIONS;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMIPLEVELS = D3D10_MESSAGE_ID.CREATEBUFFER_INVALIDMIPLEVELS;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMISCFLAGS = D3D10_MESSAGE_ID.CREATEBUFFER_INVALIDMISCFLAGS;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDARG_RETURN = D3D10_MESSAGE_ID.CREATEBUFFER_INVALIDARG_RETURN;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATEBUFFER_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_NULLDESC = D3D10_MESSAGE_ID.CREATEBUFFER_NULLDESC;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS = D3D10_MESSAGE_ID.CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS;
pub const D3D10_MESSAGE_ID_CREATEBUFFER_LARGEALLOCATION = D3D10_MESSAGE_ID.CREATEBUFFER_LARGEALLOCATION;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDFORMAT = D3D10_MESSAGE_ID.CREATETEXTURE1D_UNRECOGNIZEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_UNSUPPORTEDFORMAT = D3D10_MESSAGE_ID.CREATETEXTURE1D_UNSUPPORTEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDSAMPLES = D3D10_MESSAGE_ID.CREATETEXTURE1D_INVALIDSAMPLES;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDUSAGE = D3D10_MESSAGE_ID.CREATETEXTURE1D_UNRECOGNIZEDUSAGE;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDCPUACCESSFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE1D_INVALIDCPUACCESSFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDBINDFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE1D_INVALIDBINDFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDINITIALDATA = D3D10_MESSAGE_ID.CREATETEXTURE1D_INVALIDINITIALDATA;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDDIMENSIONS = D3D10_MESSAGE_ID.CREATETEXTURE1D_INVALIDDIMENSIONS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMIPLEVELS = D3D10_MESSAGE_ID.CREATETEXTURE1D_INVALIDMIPLEVELS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMISCFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE1D_INVALIDMISCFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDARG_RETURN = D3D10_MESSAGE_ID.CREATETEXTURE1D_INVALIDARG_RETURN;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATETEXTURE1D_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_NULLDESC = D3D10_MESSAGE_ID.CREATETEXTURE1D_NULLDESC;
pub const D3D10_MESSAGE_ID_CREATETEXTURE1D_LARGEALLOCATION = D3D10_MESSAGE_ID.CREATETEXTURE1D_LARGEALLOCATION;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDFORMAT = D3D10_MESSAGE_ID.CREATETEXTURE2D_UNRECOGNIZEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_UNSUPPORTEDFORMAT = D3D10_MESSAGE_ID.CREATETEXTURE2D_UNSUPPORTEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDSAMPLES = D3D10_MESSAGE_ID.CREATETEXTURE2D_INVALIDSAMPLES;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDUSAGE = D3D10_MESSAGE_ID.CREATETEXTURE2D_UNRECOGNIZEDUSAGE;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDCPUACCESSFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE2D_INVALIDCPUACCESSFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDBINDFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE2D_INVALIDBINDFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDINITIALDATA = D3D10_MESSAGE_ID.CREATETEXTURE2D_INVALIDINITIALDATA;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDDIMENSIONS = D3D10_MESSAGE_ID.CREATETEXTURE2D_INVALIDDIMENSIONS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMIPLEVELS = D3D10_MESSAGE_ID.CREATETEXTURE2D_INVALIDMIPLEVELS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMISCFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE2D_INVALIDMISCFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDARG_RETURN = D3D10_MESSAGE_ID.CREATETEXTURE2D_INVALIDARG_RETURN;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATETEXTURE2D_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_NULLDESC = D3D10_MESSAGE_ID.CREATETEXTURE2D_NULLDESC;
pub const D3D10_MESSAGE_ID_CREATETEXTURE2D_LARGEALLOCATION = D3D10_MESSAGE_ID.CREATETEXTURE2D_LARGEALLOCATION;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDFORMAT = D3D10_MESSAGE_ID.CREATETEXTURE3D_UNRECOGNIZEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_UNSUPPORTEDFORMAT = D3D10_MESSAGE_ID.CREATETEXTURE3D_UNSUPPORTEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDSAMPLES = D3D10_MESSAGE_ID.CREATETEXTURE3D_INVALIDSAMPLES;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDUSAGE = D3D10_MESSAGE_ID.CREATETEXTURE3D_UNRECOGNIZEDUSAGE;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDCPUACCESSFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE3D_INVALIDCPUACCESSFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDBINDFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE3D_INVALIDBINDFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDINITIALDATA = D3D10_MESSAGE_ID.CREATETEXTURE3D_INVALIDINITIALDATA;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDDIMENSIONS = D3D10_MESSAGE_ID.CREATETEXTURE3D_INVALIDDIMENSIONS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMIPLEVELS = D3D10_MESSAGE_ID.CREATETEXTURE3D_INVALIDMIPLEVELS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMISCFLAGS = D3D10_MESSAGE_ID.CREATETEXTURE3D_INVALIDMISCFLAGS;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDARG_RETURN = D3D10_MESSAGE_ID.CREATETEXTURE3D_INVALIDARG_RETURN;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATETEXTURE3D_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_NULLDESC = D3D10_MESSAGE_ID.CREATETEXTURE3D_NULLDESC;
pub const D3D10_MESSAGE_ID_CREATETEXTURE3D_LARGEALLOCATION = D3D10_MESSAGE_ID.CREATETEXTURE3D_LARGEALLOCATION;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_INVALIDDESC;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_INVALIDFORMAT;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_INVALIDRESOURCE;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT = D3D10_MESSAGE_ID.CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT = D3D10_MESSAGE_ID.CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC = D3D10_MESSAGE_ID.CREATERENDERTARGETVIEW_INVALIDDESC;
pub const D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT = D3D10_MESSAGE_ID.CREATERENDERTARGETVIEW_INVALIDFORMAT;
pub const D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS = D3D10_MESSAGE_ID.CREATERENDERTARGETVIEW_INVALIDDIMENSIONS;
pub const D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE = D3D10_MESSAGE_ID.CREATERENDERTARGETVIEW_INVALIDRESOURCE;
pub const D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_TOOMANYOBJECTS = D3D10_MESSAGE_ID.CREATERENDERTARGETVIEW_TOOMANYOBJECTS;
pub const D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN = D3D10_MESSAGE_ID.CREATERENDERTARGETVIEW_INVALIDARG_RETURN;
pub const D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILVIEW_INVALIDDESC;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILVIEW_INVALIDFORMAT;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_OUTOFMEMORY;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_TOOMANYELEMENTS;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_INVALIDFORMAT;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_INVALIDSLOT;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_INVALIDALIGNMENT;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_DUPLICATESEMANTIC;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_NULLSEMANTIC;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_MISSINGELEMENT;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLDESC = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_NULLDESC;
pub const D3D10_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY = D3D10_MESSAGE_ID.CREATEVERTEXSHADER_OUTOFMEMORY;
pub const D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE = D3D10_MESSAGE_ID.CREATEVERTEXSHADER_INVALIDSHADERBYTECODE;
pub const D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE = D3D10_MESSAGE_ID.CREATEVERTEXSHADER_INVALIDSHADERTYPE;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADER_OUTOFMEMORY;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADER_INVALIDSHADERTYPE;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE;
pub const D3D10_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY = D3D10_MESSAGE_ID.CREATEPIXELSHADER_OUTOFMEMORY;
pub const D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE = D3D10_MESSAGE_ID.CREATEPIXELSHADER_INVALIDSHADERBYTECODE;
pub const D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE = D3D10_MESSAGE_ID.CREATEPIXELSHADER_INVALIDSHADERTYPE;
pub const D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE = D3D10_MESSAGE_ID.CREATERASTERIZERSTATE_INVALIDFILLMODE;
pub const D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE = D3D10_MESSAGE_ID.CREATERASTERIZERSTATE_INVALIDCULLMODE;
pub const D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP = D3D10_MESSAGE_ID.CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP;
pub const D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS = D3D10_MESSAGE_ID.CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS;
pub const D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_TOOMANYOBJECTS = D3D10_MESSAGE_ID.CREATERASTERIZERSTATE_TOOMANYOBJECTS;
pub const D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC = D3D10_MESSAGE_ID.CREATERASTERIZERSTATE_NULLDESC;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_NULLDESC;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND = D3D10_MESSAGE_ID.CREATEBLENDSTATE_INVALIDSRCBLEND;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND = D3D10_MESSAGE_ID.CREATEBLENDSTATE_INVALIDDESTBLEND;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP = D3D10_MESSAGE_ID.CREATEBLENDSTATE_INVALIDBLENDOP;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA = D3D10_MESSAGE_ID.CREATEBLENDSTATE_INVALIDSRCBLENDALPHA;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA = D3D10_MESSAGE_ID.CREATEBLENDSTATE_INVALIDDESTBLENDALPHA;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA = D3D10_MESSAGE_ID.CREATEBLENDSTATE_INVALIDBLENDOPALPHA;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK = D3D10_MESSAGE_ID.CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_TOOMANYOBJECTS = D3D10_MESSAGE_ID.CREATEBLENDSTATE_TOOMANYOBJECTS;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC = D3D10_MESSAGE_ID.CREATEBLENDSTATE_NULLDESC;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_INVALIDFILTER;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_INVALIDADDRESSU;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_INVALIDADDRESSV;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_INVALIDADDRESSW;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_INVALIDMIPLODBIAS;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_INVALIDMAXANISOTROPY;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_INVALIDMINLOD;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_INVALIDMAXLOD;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_TOOMANYOBJECTS = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_TOOMANYOBJECTS;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_NULLDESC;
pub const D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDQUERY = D3D10_MESSAGE_ID.CREATEQUERYORPREDICATE_INVALIDQUERY;
pub const D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDMISCFLAGS = D3D10_MESSAGE_ID.CREATEQUERYORPREDICATE_INVALIDMISCFLAGS;
pub const D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG = D3D10_MESSAGE_ID.CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG;
pub const D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_NULLDESC = D3D10_MESSAGE_ID.CREATEQUERYORPREDICATE_NULLDESC;
pub const D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED = D3D10_MESSAGE_ID.DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED;
pub const D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED = D3D10_MESSAGE_ID.DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED;
pub const D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_INVALIDBUFFER = D3D10_MESSAGE_ID.IASETVERTEXBUFFERS_INVALIDBUFFER;
pub const D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE = D3D10_MESSAGE_ID.DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE;
pub const D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY;
pub const D3D10_MESSAGE_ID_IASETINDEXBUFFER_INVALIDBUFFER = D3D10_MESSAGE_ID.IASETINDEXBUFFER_INVALIDBUFFER;
pub const D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_FORMAT_INVALID = D3D10_MESSAGE_ID.DEVICE_IASETINDEXBUFFER_FORMAT_INVALID;
pub const D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE = D3D10_MESSAGE_ID.DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE;
pub const D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED = D3D10_MESSAGE_ID.DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED;
pub const D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY = D3D10_MESSAGE_ID.DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY;
pub const D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFER = D3D10_MESSAGE_ID.VSSETCONSTANTBUFFERS_INVALIDBUFFER;
pub const D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY = D3D10_MESSAGE_ID.DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY;
pub const D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFER = D3D10_MESSAGE_ID.GSSETCONSTANTBUFFERS_INVALIDBUFFER;
pub const D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY;
pub const D3D10_MESSAGE_ID_SOSETTARGETS_INVALIDBUFFER = D3D10_MESSAGE_ID.SOSETTARGETS_INVALIDBUFFER;
pub const D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_OFFSET_UNALIGNED = D3D10_MESSAGE_ID.DEVICE_SOSETTARGETS_OFFSET_UNALIGNED;
pub const D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY = D3D10_MESSAGE_ID.DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY;
pub const D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFER = D3D10_MESSAGE_ID.PSSETCONSTANTBUFFERS_INVALIDBUFFER;
pub const D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT = D3D10_MESSAGE_ID.DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT;
pub const D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR = D3D10_MESSAGE_ID.DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR;
pub const D3D10_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH = D3D10_MESSAGE_ID.CLEARRENDERTARGETVIEW_DENORMFLUSH;
pub const D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH = D3D10_MESSAGE_ID.CLEARDEPTHSTENCILVIEW_DENORMFLUSH;
pub const D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID = D3D10_MESSAGE_ID.CLEARDEPTHSTENCILVIEW_INVALID;
pub const D3D10_MESSAGE_ID_DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY = D3D10_MESSAGE_ID.DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY = D3D10_MESSAGE_ID.DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_SOGETTARGETS_BUFFERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_SOGETTARGETS_BUFFERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY = D3D10_MESSAGE_ID.DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY = D3D10_MESSAGE_ID.DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY = D3D10_MESSAGE_ID.DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY = D3D10_MESSAGE_ID.DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY;
pub const D3D10_MESSAGE_ID_DEVICE_GENERATEMIPS_RESOURCE_INVALID = D3D10_MESSAGE_ID.DEVICE_GENERATEMIPS_RESOURCE_INVALID;
pub const D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE = D3D10_MESSAGE_ID.COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE;
pub const D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE = D3D10_MESSAGE_ID.COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE;
pub const D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCEBOX = D3D10_MESSAGE_ID.COPYSUBRESOURCEREGION_INVALIDSOURCEBOX;
pub const D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCE = D3D10_MESSAGE_ID.COPYSUBRESOURCEREGION_INVALIDSOURCE;
pub const D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE = D3D10_MESSAGE_ID.COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE;
pub const D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESTATE = D3D10_MESSAGE_ID.COPYSUBRESOURCEREGION_INVALIDSOURCESTATE;
pub const D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE = D3D10_MESSAGE_ID.COPYRESOURCE_INVALIDSOURCE;
pub const D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE = D3D10_MESSAGE_ID.COPYRESOURCE_INVALIDDESTINATIONSTATE;
pub const D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE = D3D10_MESSAGE_ID.COPYRESOURCE_INVALIDSOURCESTATE;
pub const D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE = D3D10_MESSAGE_ID.UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE;
pub const D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX = D3D10_MESSAGE_ID.UPDATESUBRESOURCE_INVALIDDESTINATIONBOX;
pub const D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE = D3D10_MESSAGE_ID.UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE;
pub const D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID = D3D10_MESSAGE_ID.DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID;
pub const D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID = D3D10_MESSAGE_ID.DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID;
pub const D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID = D3D10_MESSAGE_ID.DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID;
pub const D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID = D3D10_MESSAGE_ID.DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID;
pub const D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID = D3D10_MESSAGE_ID.DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID;
pub const D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE = D3D10_MESSAGE_ID.BUFFER_MAP_INVALIDMAPTYPE;
pub const D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS = D3D10_MESSAGE_ID.BUFFER_MAP_INVALIDFLAGS;
pub const D3D10_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED = D3D10_MESSAGE_ID.BUFFER_MAP_ALREADYMAPPED;
pub const D3D10_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN = D3D10_MESSAGE_ID.BUFFER_MAP_DEVICEREMOVED_RETURN;
pub const D3D10_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED = D3D10_MESSAGE_ID.BUFFER_UNMAP_NOTMAPPED;
pub const D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE = D3D10_MESSAGE_ID.TEXTURE1D_MAP_INVALIDMAPTYPE;
pub const D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE = D3D10_MESSAGE_ID.TEXTURE1D_MAP_INVALIDSUBRESOURCE;
pub const D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS = D3D10_MESSAGE_ID.TEXTURE1D_MAP_INVALIDFLAGS;
pub const D3D10_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED = D3D10_MESSAGE_ID.TEXTURE1D_MAP_ALREADYMAPPED;
pub const D3D10_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN = D3D10_MESSAGE_ID.TEXTURE1D_MAP_DEVICEREMOVED_RETURN;
pub const D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE = D3D10_MESSAGE_ID.TEXTURE1D_UNMAP_INVALIDSUBRESOURCE;
pub const D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED = D3D10_MESSAGE_ID.TEXTURE1D_UNMAP_NOTMAPPED;
pub const D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE = D3D10_MESSAGE_ID.TEXTURE2D_MAP_INVALIDMAPTYPE;
pub const D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE = D3D10_MESSAGE_ID.TEXTURE2D_MAP_INVALIDSUBRESOURCE;
pub const D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS = D3D10_MESSAGE_ID.TEXTURE2D_MAP_INVALIDFLAGS;
pub const D3D10_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED = D3D10_MESSAGE_ID.TEXTURE2D_MAP_ALREADYMAPPED;
pub const D3D10_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN = D3D10_MESSAGE_ID.TEXTURE2D_MAP_DEVICEREMOVED_RETURN;
pub const D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE = D3D10_MESSAGE_ID.TEXTURE2D_UNMAP_INVALIDSUBRESOURCE;
pub const D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED = D3D10_MESSAGE_ID.TEXTURE2D_UNMAP_NOTMAPPED;
pub const D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE = D3D10_MESSAGE_ID.TEXTURE3D_MAP_INVALIDMAPTYPE;
pub const D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE = D3D10_MESSAGE_ID.TEXTURE3D_MAP_INVALIDSUBRESOURCE;
pub const D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS = D3D10_MESSAGE_ID.TEXTURE3D_MAP_INVALIDFLAGS;
pub const D3D10_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED = D3D10_MESSAGE_ID.TEXTURE3D_MAP_ALREADYMAPPED;
pub const D3D10_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN = D3D10_MESSAGE_ID.TEXTURE3D_MAP_DEVICEREMOVED_RETURN;
pub const D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE = D3D10_MESSAGE_ID.TEXTURE3D_UNMAP_INVALIDSUBRESOURCE;
pub const D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED = D3D10_MESSAGE_ID.TEXTURE3D_UNMAP_NOTMAPPED;
pub const D3D10_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED = D3D10_MESSAGE_ID.CHECKFORMATSUPPORT_FORMAT_DEPRECATED;
pub const D3D10_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED = D3D10_MESSAGE_ID.CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED;
pub const D3D10_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS = D3D10_MESSAGE_ID.SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS;
pub const D3D10_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN = D3D10_MESSAGE_ID.SETEXCEPTIONMODE_INVALIDARG_RETURN;
pub const D3D10_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN = D3D10_MESSAGE_ID.SETEXCEPTIONMODE_DEVICEREMOVED_RETURN;
pub const D3D10_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE = D3D10_MESSAGE_ID.REF_SIMULATING_INFINITELY_FAST_HARDWARE;
pub const D3D10_MESSAGE_ID_REF_THREADING_MODE = D3D10_MESSAGE_ID.REF_THREADING_MODE;
pub const D3D10_MESSAGE_ID_REF_UMDRIVER_EXCEPTION = D3D10_MESSAGE_ID.REF_UMDRIVER_EXCEPTION;
pub const D3D10_MESSAGE_ID_REF_KMDRIVER_EXCEPTION = D3D10_MESSAGE_ID.REF_KMDRIVER_EXCEPTION;
pub const D3D10_MESSAGE_ID_REF_HARDWARE_EXCEPTION = D3D10_MESSAGE_ID.REF_HARDWARE_EXCEPTION;
pub const D3D10_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE = D3D10_MESSAGE_ID.REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE;
pub const D3D10_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER = D3D10_MESSAGE_ID.REF_PROBLEM_PARSING_SHADER;
pub const D3D10_MESSAGE_ID_REF_OUT_OF_MEMORY = D3D10_MESSAGE_ID.REF_OUT_OF_MEMORY;
pub const D3D10_MESSAGE_ID_REF_INFO = D3D10_MESSAGE_ID.REF_INFO;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW = D3D10_MESSAGE_ID.DEVICE_DRAW_VERTEXPOS_OVERFLOW;
pub const D3D10_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW = D3D10_MESSAGE_ID.DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW;
pub const D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW = D3D10_MESSAGE_ID.DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW;
pub const D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW = D3D10_MESSAGE_ID.DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW;
pub const D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW = D3D10_MESSAGE_ID.DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW;
pub const D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW = D3D10_MESSAGE_ID.DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET = D3D10_MESSAGE_ID.DEVICE_DRAW_VERTEX_SHADER_NOT_SET;
pub const D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND = D3D10_MESSAGE_ID.DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND;
pub const D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX = D3D10_MESSAGE_ID.DEVICE_SHADER_LINKAGE_REGISTERINDEX;
pub const D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE = D3D10_MESSAGE_ID.DEVICE_SHADER_LINKAGE_COMPONENTTYPE;
pub const D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK = D3D10_MESSAGE_ID.DEVICE_SHADER_LINKAGE_REGISTERMASK;
pub const D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE = D3D10_MESSAGE_ID.DEVICE_SHADER_LINKAGE_SYSTEMVALUE;
pub const D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS = D3D10_MESSAGE_ID.DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_NOT_SET = D3D10_MESSAGE_ID.DEVICE_DRAW_VERTEX_BUFFER_NOT_SET;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_INPUTLAYOUT_NOT_SET = D3D10_MESSAGE_ID.DEVICE_DRAW_INPUTLAYOUT_NOT_SET;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET = D3D10_MESSAGE_ID.DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL = D3D10_MESSAGE_ID.DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_NOT_SET = D3D10_MESSAGE_ID.DEVICE_DRAW_SAMPLER_NOT_SET;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET = D3D10_MESSAGE_ID.DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_VIEW_DIMENSION_MISMATCH = D3D10_MESSAGE_ID.DEVICE_DRAW_VIEW_DIMENSION_MISMATCH;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL = D3D10_MESSAGE_ID.DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL = D3D10_MESSAGE_ID.DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_NOT_SET = D3D10_MESSAGE_ID.DEVICE_DRAW_INDEX_BUFFER_NOT_SET;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID = D3D10_MESSAGE_ID.DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL = D3D10_MESSAGE_ID.DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH = D3D10_MESSAGE_ID.DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH = D3D10_MESSAGE_ID.DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_POSITION_NOT_PRESENT = D3D10_MESSAGE_ID.DEVICE_DRAW_POSITION_NOT_PRESENT;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_NOT_SET = D3D10_MESSAGE_ID.DEVICE_DRAW_OUTPUT_STREAM_NOT_SET;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_BOUND_RESOURCE_MAPPED = D3D10_MESSAGE_ID.DEVICE_DRAW_BOUND_RESOURCE_MAPPED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY = D3D10_MESSAGE_ID.DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED = D3D10_MESSAGE_ID.DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED = D3D10_MESSAGE_ID.DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_OFFSET_UNALIGNED = D3D10_MESSAGE_ID.DEVICE_DRAW_INDEX_OFFSET_UNALIGNED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED = D3D10_MESSAGE_ID.DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED = D3D10_MESSAGE_ID.DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED = D3D10_MESSAGE_ID.DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED = D3D10_MESSAGE_ID.DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED = D3D10_MESSAGE_ID.DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE = D3D10_MESSAGE_ID.DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER = D3D10_MESSAGE_ID.DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING = D3D10_MESSAGE_ID.DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 = D3D10_MESSAGE_ID.DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0;
pub const D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT = D3D10_MESSAGE_ID.DEVICE_REMOVAL_PROCESS_AT_FAULT;
pub const D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT = D3D10_MESSAGE_ID.DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT;
pub const D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT = D3D10_MESSAGE_ID.DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT;
pub const D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN = D3D10_MESSAGE_ID.DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN;
pub const D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN = D3D10_MESSAGE_ID.DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET = D3D10_MESSAGE_ID.DEVICE_DRAW_VIEWPORT_NOT_SET;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC;
pub const D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC = D3D10_MESSAGE_ID.CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC;
pub const D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH = D3D10_MESSAGE_ID.DEVICE_RSSETVIEWPORTS_DENORMFLUSH;
pub const D3D10_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW = D3D10_MESSAGE_ID.OMSETRENDERTARGETS_INVALIDVIEW;
pub const D3D10_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS = D3D10_MESSAGE_ID.DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH = D3D10_MESSAGE_ID.DEVICE_DRAW_SAMPLER_MISMATCH;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_TYPE_MISMATCH;
pub const D3D10_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY = D3D10_MESSAGE_ID.BLENDSTATE_GETDESC_LEGACY;
pub const D3D10_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY = D3D10_MESSAGE_ID.SHADERRESOURCEVIEW_GETDESC_LEGACY;
pub const D3D10_MESSAGE_ID_CREATEQUERY_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATEQUERY_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATEPREDICATE_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATEPREDICATE_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFRANGE_COUNTER = D3D10_MESSAGE_ID.CREATECOUNTER_OUTOFRANGE_COUNTER;
pub const D3D10_MESSAGE_ID_CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED = D3D10_MESSAGE_ID.CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED;
pub const D3D10_MESSAGE_ID_CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER = D3D10_MESSAGE_ID.CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER;
pub const D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFMEMORY_RETURN = D3D10_MESSAGE_ID.CREATECOUNTER_OUTOFMEMORY_RETURN;
pub const D3D10_MESSAGE_ID_CREATECOUNTER_NONEXCLUSIVE_RETURN = D3D10_MESSAGE_ID.CREATECOUNTER_NONEXCLUSIVE_RETURN;
pub const D3D10_MESSAGE_ID_CREATECOUNTER_NULLDESC = D3D10_MESSAGE_ID.CREATECOUNTER_NULLDESC;
pub const D3D10_MESSAGE_ID_CHECKCOUNTER_OUTOFRANGE_COUNTER = D3D10_MESSAGE_ID.CHECKCOUNTER_OUTOFRANGE_COUNTER;
pub const D3D10_MESSAGE_ID_CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER = D3D10_MESSAGE_ID.CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER;
pub const D3D10_MESSAGE_ID_SETPREDICATION_INVALID_PREDICATE_STATE = D3D10_MESSAGE_ID.SETPREDICATION_INVALID_PREDICATE_STATE;
pub const D3D10_MESSAGE_ID_QUERY_BEGIN_UNSUPPORTED = D3D10_MESSAGE_ID.QUERY_BEGIN_UNSUPPORTED;
pub const D3D10_MESSAGE_ID_PREDICATE_BEGIN_DURING_PREDICATION = D3D10_MESSAGE_ID.PREDICATE_BEGIN_DURING_PREDICATION;
pub const D3D10_MESSAGE_ID_QUERY_BEGIN_DUPLICATE = D3D10_MESSAGE_ID.QUERY_BEGIN_DUPLICATE;
pub const D3D10_MESSAGE_ID_QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS = D3D10_MESSAGE_ID.QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS;
pub const D3D10_MESSAGE_ID_PREDICATE_END_DURING_PREDICATION = D3D10_MESSAGE_ID.PREDICATE_END_DURING_PREDICATION;
pub const D3D10_MESSAGE_ID_QUERY_END_ABANDONING_PREVIOUS_RESULTS = D3D10_MESSAGE_ID.QUERY_END_ABANDONING_PREVIOUS_RESULTS;
pub const D3D10_MESSAGE_ID_QUERY_END_WITHOUT_BEGIN = D3D10_MESSAGE_ID.QUERY_END_WITHOUT_BEGIN;
pub const D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_DATASIZE = D3D10_MESSAGE_ID.QUERY_GETDATA_INVALID_DATASIZE;
pub const D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_FLAGS = D3D10_MESSAGE_ID.QUERY_GETDATA_INVALID_FLAGS;
pub const D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_CALL = D3D10_MESSAGE_ID.QUERY_GETDATA_INVALID_CALL;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH = D3D10_MESSAGE_ID.DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED = D3D10_MESSAGE_ID.DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN = D3D10_MESSAGE_ID.DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN;
pub const D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE = D3D10_MESSAGE_ID.DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE;
pub const D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE = D3D10_MESSAGE_ID.DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_EMPTY_LAYOUT;
pub const D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH = D3D10_MESSAGE_ID.DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH;
pub const D3D10_MESSAGE_ID_LIVE_OBJECT_SUMMARY = D3D10_MESSAGE_ID.LIVE_OBJECT_SUMMARY;
pub const D3D10_MESSAGE_ID_LIVE_BUFFER = D3D10_MESSAGE_ID.LIVE_BUFFER;
pub const D3D10_MESSAGE_ID_LIVE_TEXTURE1D = D3D10_MESSAGE_ID.LIVE_TEXTURE1D;
pub const D3D10_MESSAGE_ID_LIVE_TEXTURE2D = D3D10_MESSAGE_ID.LIVE_TEXTURE2D;
pub const D3D10_MESSAGE_ID_LIVE_TEXTURE3D = D3D10_MESSAGE_ID.LIVE_TEXTURE3D;
pub const D3D10_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW = D3D10_MESSAGE_ID.LIVE_SHADERRESOURCEVIEW;
pub const D3D10_MESSAGE_ID_LIVE_RENDERTARGETVIEW = D3D10_MESSAGE_ID.LIVE_RENDERTARGETVIEW;
pub const D3D10_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW = D3D10_MESSAGE_ID.LIVE_DEPTHSTENCILVIEW;
pub const D3D10_MESSAGE_ID_LIVE_VERTEXSHADER = D3D10_MESSAGE_ID.LIVE_VERTEXSHADER;
pub const D3D10_MESSAGE_ID_LIVE_GEOMETRYSHADER = D3D10_MESSAGE_ID.LIVE_GEOMETRYSHADER;
pub const D3D10_MESSAGE_ID_LIVE_PIXELSHADER = D3D10_MESSAGE_ID.LIVE_PIXELSHADER;
pub const D3D10_MESSAGE_ID_LIVE_INPUTLAYOUT = D3D10_MESSAGE_ID.LIVE_INPUTLAYOUT;
pub const D3D10_MESSAGE_ID_LIVE_SAMPLER = D3D10_MESSAGE_ID.LIVE_SAMPLER;
pub const D3D10_MESSAGE_ID_LIVE_BLENDSTATE = D3D10_MESSAGE_ID.LIVE_BLENDSTATE;
pub const D3D10_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE = D3D10_MESSAGE_ID.LIVE_DEPTHSTENCILSTATE;
pub const D3D10_MESSAGE_ID_LIVE_RASTERIZERSTATE = D3D10_MESSAGE_ID.LIVE_RASTERIZERSTATE;
pub const D3D10_MESSAGE_ID_LIVE_QUERY = D3D10_MESSAGE_ID.LIVE_QUERY;
pub const D3D10_MESSAGE_ID_LIVE_PREDICATE = D3D10_MESSAGE_ID.LIVE_PREDICATE;
pub const D3D10_MESSAGE_ID_LIVE_COUNTER = D3D10_MESSAGE_ID.LIVE_COUNTER;
pub const D3D10_MESSAGE_ID_LIVE_DEVICE = D3D10_MESSAGE_ID.LIVE_DEVICE;
pub const D3D10_MESSAGE_ID_LIVE_SWAPCHAIN = D3D10_MESSAGE_ID.LIVE_SWAPCHAIN;
pub const D3D10_MESSAGE_ID_D3D10_MESSAGES_END = D3D10_MESSAGE_ID.D3D10_MESSAGES_END;
pub const D3D10_MESSAGE_ID_D3D10L9_MESSAGES_START = D3D10_MESSAGE_ID.D3D10L9_MESSAGES_START;
pub const D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED = D3D10_MESSAGE_ID.CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED;
pub const D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED = D3D10_MESSAGE_ID.CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE;
pub const D3D10_MESSAGE_ID_VSSETSAMPLERS_NOT_SUPPORTED = D3D10_MESSAGE_ID.VSSETSAMPLERS_NOT_SUPPORTED;
pub const D3D10_MESSAGE_ID_VSSETSAMPLERS_TOO_MANY_SAMPLERS = D3D10_MESSAGE_ID.VSSETSAMPLERS_TOO_MANY_SAMPLERS;
pub const D3D10_MESSAGE_ID_PSSETSAMPLERS_TOO_MANY_SAMPLERS = D3D10_MESSAGE_ID.PSSETSAMPLERS_TOO_MANY_SAMPLERS;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_NO_ARRAYS = D3D10_MESSAGE_ID.CREATERESOURCE_NO_ARRAYS;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_NO_VB_AND_IB_BIND = D3D10_MESSAGE_ID.CREATERESOURCE_NO_VB_AND_IB_BIND;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_NO_TEXTURE_1D = D3D10_MESSAGE_ID.CREATERESOURCE_NO_TEXTURE_1D;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_OUT_OF_RANGE = D3D10_MESSAGE_ID.CREATERESOURCE_DIMENSION_OUT_OF_RANGE;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE = D3D10_MESSAGE_ID.CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE;
pub const D3D10_MESSAGE_ID_OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS = D3D10_MESSAGE_ID.OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS;
pub const D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS = D3D10_MESSAGE_ID.OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS;
pub const D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_BAD_BUFFER_INDEX = D3D10_MESSAGE_ID.IASETVERTEXBUFFERS_BAD_BUFFER_INDEX;
pub const D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS = D3D10_MESSAGE_ID.DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS;
pub const D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED = D3D10_MESSAGE_ID.DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED;
pub const D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS = D3D10_MESSAGE_ID.DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS;
pub const D3D10_MESSAGE_ID_COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY = D3D10_MESSAGE_ID.COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY;
pub const D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_3D_READBACK = D3D10_MESSAGE_ID.COPYRESOURCE_NO_TEXTURE_3D_READBACK;
pub const D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_ONLY_READBACK = D3D10_MESSAGE_ID.COPYRESOURCE_NO_TEXTURE_ONLY_READBACK;
pub const D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT = D3D10_MESSAGE_ID.CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE = D3D10_MESSAGE_ID.CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE;
pub const D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE = D3D10_MESSAGE_ID.CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE;
pub const D3D10_MESSAGE_ID_DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE = D3D10_MESSAGE_ID.DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO;
pub const D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES = D3D10_MESSAGE_ID.CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET = D3D10_MESSAGE_ID.CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_NO_DWORD_INDEX_BUFFER = D3D10_MESSAGE_ID.CREATERESOURCE_NO_DWORD_INDEX_BUFFER;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE = D3D10_MESSAGE_ID.CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE = D3D10_MESSAGE_ID.CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE = D3D10_MESSAGE_ID.CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS = D3D10_MESSAGE_ID.CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_NO_STREAM_OUT = D3D10_MESSAGE_ID.CREATERESOURCE_NO_STREAM_OUT;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS = D3D10_MESSAGE_ID.CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES = D3D10_MESSAGE_ID.CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED = D3D10_MESSAGE_ID.CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED;
pub const D3D10_MESSAGE_ID_VSSHADERRESOURCES_NOT_SUPPORTED = D3D10_MESSAGE_ID.VSSHADERRESOURCES_NOT_SUPPORTED;
pub const D3D10_MESSAGE_ID_GEOMETRY_SHADER_NOT_SUPPORTED = D3D10_MESSAGE_ID.GEOMETRY_SHADER_NOT_SUPPORTED;
pub const D3D10_MESSAGE_ID_STREAM_OUT_NOT_SUPPORTED = D3D10_MESSAGE_ID.STREAM_OUT_NOT_SUPPORTED;
pub const D3D10_MESSAGE_ID_TEXT_FILTER_NOT_SUPPORTED = D3D10_MESSAGE_ID.TEXT_FILTER_NOT_SUPPORTED;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND = D3D10_MESSAGE_ID.CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_MRT_BLEND = D3D10_MESSAGE_ID.CREATEBLENDSTATE_NO_MRT_BLEND;
pub const D3D10_MESSAGE_ID_CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED = D3D10_MESSAGE_ID.CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_MIRRORONCE = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_NO_MIRRORONCE;
pub const D3D10_MESSAGE_ID_DRAWINSTANCED_NOT_SUPPORTED = D3D10_MESSAGE_ID.DRAWINSTANCED_NOT_SUPPORTED;
pub const D3D10_MESSAGE_ID_DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3 = D3D10_MESSAGE_ID.DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3;
pub const D3D10_MESSAGE_ID_DRAWINDEXED_POINTLIST_UNSUPPORTED = D3D10_MESSAGE_ID.DRAWINDEXED_POINTLIST_UNSUPPORTED;
pub const D3D10_MESSAGE_ID_SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO = D3D10_MESSAGE_ID.SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION = D3D10_MESSAGE_ID.CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED = D3D10_MESSAGE_ID.CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED;
pub const D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR = D3D10_MESSAGE_ID.DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR;
pub const D3D10_MESSAGE_ID_SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA = D3D10_MESSAGE_ID.SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA;
pub const D3D10_MESSAGE_ID_CREATERESOURCE_NON_POW_2_MIPMAP = D3D10_MESSAGE_ID.CREATERESOURCE_NON_POW_2_MIPMAP;
pub const D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED = D3D10_MESSAGE_ID.CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED;
pub const D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_SRGB_MRT = D3D10_MESSAGE_ID.OMSETRENDERTARGETS_NO_SRGB_MRT;
pub const D3D10_MESSAGE_ID_COPYRESOURCE_NO_3D_MISMATCHED_UPDATES = D3D10_MESSAGE_ID.COPYRESOURCE_NO_3D_MISMATCHED_UPDATES;
pub const D3D10_MESSAGE_ID_D3D10L9_MESSAGES_END = D3D10_MESSAGE_ID.D3D10L9_MESSAGES_END;

pub const D3D10_MESSAGE = extern struct {
    Category: D3D10_MESSAGE_CATEGORY,
    Severity: D3D10_MESSAGE_SEVERITY,
    ID: D3D10_MESSAGE_ID,
    pDescription: ?*const u8,
    DescriptionByteLength: usize,
};

pub const D3D10_INFO_QUEUE_FILTER_DESC = extern struct {
    NumCategories: u32,
    pCategoryList: ?*D3D10_MESSAGE_CATEGORY,
    NumSeverities: u32,
    pSeverityList: ?*D3D10_MESSAGE_SEVERITY,
    NumIDs: u32,
    pIDList: ?*D3D10_MESSAGE_ID,
};

pub const D3D10_INFO_QUEUE_FILTER = extern struct {
    AllowList: D3D10_INFO_QUEUE_FILTER_DESC,
    DenyList: D3D10_INFO_QUEUE_FILTER_DESC,
};

const IID_ID3D10InfoQueue_Value = Guid.initString("1b940b17-2642-4d1f-ab1f-b99bad0c395f");
pub const IID_ID3D10InfoQueue = &IID_ID3D10InfoQueue_Value;
pub const ID3D10InfoQueue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMessageCountLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                MessageCountLimit: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                MessageCountLimit: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearStoredMessages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                MessageIndex: u64,
                // TODO: what to do with BytesParamIndex 2?
                pMessage: ?*D3D10_MESSAGE,
                pMessageByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                MessageIndex: u64,
                // TODO: what to do with BytesParamIndex 2?
                pMessage: ?*D3D10_MESSAGE,
                pMessageByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumMessagesAllowedByStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetNumMessagesDeniedByStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetNumStoredMessages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetNumStoredMessagesAllowedByRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetNumMessagesDiscardedByMessageCountLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetMessageCountLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        AddStorageFilterEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                // TODO: what to do with BytesParamIndex 1?
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
                pFilterByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                // TODO: what to do with BytesParamIndex 1?
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
                pFilterByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PushEmptyStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushCopyOfStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetStorageFilterStackSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        AddRetrievalFilterEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                // TODO: what to do with BytesParamIndex 1?
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
                pFilterByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                // TODO: what to do with BytesParamIndex 1?
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
                pFilterByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PushEmptyRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushCopyOfRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                pFilter: ?*D3D10_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetRetrievalFilterStackSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        AddMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                Category: D3D10_MESSAGE_CATEGORY,
                Severity: D3D10_MESSAGE_SEVERITY,
                ID: D3D10_MESSAGE_ID,
                pDescription: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                Category: D3D10_MESSAGE_CATEGORY,
                Severity: D3D10_MESSAGE_SEVERITY,
                ID: D3D10_MESSAGE_ID,
                pDescription: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddApplicationMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                Severity: D3D10_MESSAGE_SEVERITY,
                pDescription: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                Severity: D3D10_MESSAGE_SEVERITY,
                pDescription: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakOnCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                Category: D3D10_MESSAGE_CATEGORY,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                Category: D3D10_MESSAGE_CATEGORY,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakOnSeverity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                Severity: D3D10_MESSAGE_SEVERITY,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                Severity: D3D10_MESSAGE_SEVERITY,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakOnID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                ID: D3D10_MESSAGE_ID,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                ID: D3D10_MESSAGE_ID,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakOnCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                Category: D3D10_MESSAGE_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                Category: D3D10_MESSAGE_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetBreakOnSeverity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                Severity: D3D10_MESSAGE_SEVERITY,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                Severity: D3D10_MESSAGE_SEVERITY,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetBreakOnID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                ID: D3D10_MESSAGE_ID,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                ID: D3D10_MESSAGE_ID,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        SetMuteDebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
                bMute: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10InfoQueue,
                bMute: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetMuteDebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10InfoQueue,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_SetMessageCountLimit(self: *const T, MessageCountLimit: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).SetMessageCountLimit(@ptrCast(*const ID3D10InfoQueue, self), MessageCountLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_ClearStoredMessages(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).ClearStoredMessages(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetMessage(self: *const T, MessageIndex: u64, pMessage: ?*D3D10_MESSAGE, pMessageByteLength: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetMessage(@ptrCast(*const ID3D10InfoQueue, self), MessageIndex, pMessage, pMessageByteLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetNumMessagesAllowedByStorageFilter(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetNumMessagesAllowedByStorageFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetNumMessagesDeniedByStorageFilter(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetNumMessagesDeniedByStorageFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetNumStoredMessages(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetNumStoredMessages(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetNumStoredMessagesAllowedByRetrievalFilter(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetNumStoredMessagesAllowedByRetrievalFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetNumMessagesDiscardedByMessageCountLimit(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetNumMessagesDiscardedByMessageCountLimit(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetMessageCountLimit(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetMessageCountLimit(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_AddStorageFilterEntries(self: *const T, pFilter: ?*D3D10_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).AddStorageFilterEntries(@ptrCast(*const ID3D10InfoQueue, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetStorageFilter(self: *const T, pFilter: ?*D3D10_INFO_QUEUE_FILTER, pFilterByteLength: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetStorageFilter(@ptrCast(*const ID3D10InfoQueue, self), pFilter, pFilterByteLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_ClearStorageFilter(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).ClearStorageFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_PushEmptyStorageFilter(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).PushEmptyStorageFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_PushCopyOfStorageFilter(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).PushCopyOfStorageFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_PushStorageFilter(self: *const T, pFilter: ?*D3D10_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).PushStorageFilter(@ptrCast(*const ID3D10InfoQueue, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_PopStorageFilter(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).PopStorageFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetStorageFilterStackSize(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetStorageFilterStackSize(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_AddRetrievalFilterEntries(self: *const T, pFilter: ?*D3D10_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).AddRetrievalFilterEntries(@ptrCast(*const ID3D10InfoQueue, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetRetrievalFilter(self: *const T, pFilter: ?*D3D10_INFO_QUEUE_FILTER, pFilterByteLength: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetRetrievalFilter(@ptrCast(*const ID3D10InfoQueue, self), pFilter, pFilterByteLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_ClearRetrievalFilter(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).ClearRetrievalFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_PushEmptyRetrievalFilter(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).PushEmptyRetrievalFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_PushCopyOfRetrievalFilter(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).PushCopyOfRetrievalFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_PushRetrievalFilter(self: *const T, pFilter: ?*D3D10_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).PushRetrievalFilter(@ptrCast(*const ID3D10InfoQueue, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_PopRetrievalFilter(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).PopRetrievalFilter(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetRetrievalFilterStackSize(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetRetrievalFilterStackSize(@ptrCast(*const ID3D10InfoQueue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_AddMessage(self: *const T, Category: D3D10_MESSAGE_CATEGORY, Severity: D3D10_MESSAGE_SEVERITY, ID: D3D10_MESSAGE_ID, pDescription: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).AddMessage(@ptrCast(*const ID3D10InfoQueue, self), Category, Severity, ID, pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_AddApplicationMessage(self: *const T, Severity: D3D10_MESSAGE_SEVERITY, pDescription: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).AddApplicationMessage(@ptrCast(*const ID3D10InfoQueue, self), Severity, pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_SetBreakOnCategory(self: *const T, Category: D3D10_MESSAGE_CATEGORY, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).SetBreakOnCategory(@ptrCast(*const ID3D10InfoQueue, self), Category, bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_SetBreakOnSeverity(self: *const T, Severity: D3D10_MESSAGE_SEVERITY, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).SetBreakOnSeverity(@ptrCast(*const ID3D10InfoQueue, self), Severity, bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_SetBreakOnID(self: *const T, ID: D3D10_MESSAGE_ID, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).SetBreakOnID(@ptrCast(*const ID3D10InfoQueue, self), ID, bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetBreakOnCategory(self: *const T, Category: D3D10_MESSAGE_CATEGORY) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetBreakOnCategory(@ptrCast(*const ID3D10InfoQueue, self), Category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetBreakOnSeverity(self: *const T, Severity: D3D10_MESSAGE_SEVERITY) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetBreakOnSeverity(@ptrCast(*const ID3D10InfoQueue, self), Severity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetBreakOnID(self: *const T, ID: D3D10_MESSAGE_ID) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetBreakOnID(@ptrCast(*const ID3D10InfoQueue, self), ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_SetMuteDebugOutput(self: *const T, bMute: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).SetMuteDebugOutput(@ptrCast(*const ID3D10InfoQueue, self), bMute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10InfoQueue_GetMuteDebugOutput(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10InfoQueue.VTable, self.vtable).GetMuteDebugOutput(@ptrCast(*const ID3D10InfoQueue, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_DRIVER_TYPE = enum(i32) {
    HARDWARE = 0,
    REFERENCE = 1,
    NULL = 2,
    SOFTWARE = 3,
    WARP = 5,
};
pub const D3D10_DRIVER_TYPE_HARDWARE = D3D10_DRIVER_TYPE.HARDWARE;
pub const D3D10_DRIVER_TYPE_REFERENCE = D3D10_DRIVER_TYPE.REFERENCE;
pub const D3D10_DRIVER_TYPE_NULL = D3D10_DRIVER_TYPE.NULL;
pub const D3D10_DRIVER_TYPE_SOFTWARE = D3D10_DRIVER_TYPE.SOFTWARE;
pub const D3D10_DRIVER_TYPE_WARP = D3D10_DRIVER_TYPE.WARP;

pub const D3D10_SHADER_DESC = extern struct {
    Version: u32,
    Creator: ?[*:0]const u8,
    Flags: u32,
    ConstantBuffers: u32,
    BoundResources: u32,
    InputParameters: u32,
    OutputParameters: u32,
    InstructionCount: u32,
    TempRegisterCount: u32,
    TempArrayCount: u32,
    DefCount: u32,
    DclCount: u32,
    TextureNormalInstructions: u32,
    TextureLoadInstructions: u32,
    TextureCompInstructions: u32,
    TextureBiasInstructions: u32,
    TextureGradientInstructions: u32,
    FloatInstructionCount: u32,
    IntInstructionCount: u32,
    UintInstructionCount: u32,
    StaticFlowControlCount: u32,
    DynamicFlowControlCount: u32,
    MacroInstructionCount: u32,
    ArrayInstructionCount: u32,
    CutInstructionCount: u32,
    EmitInstructionCount: u32,
    GSOutputTopology: D3D_PRIMITIVE_TOPOLOGY,
    GSMaxOutputVertexCount: u32,
};

pub const D3D10_SHADER_BUFFER_DESC = extern struct {
    Name: ?[*:0]const u8,
    Type: D3D_CBUFFER_TYPE,
    Variables: u32,
    Size: u32,
    uFlags: u32,
};

pub const D3D10_SHADER_VARIABLE_DESC = extern struct {
    Name: ?[*:0]const u8,
    StartOffset: u32,
    Size: u32,
    uFlags: u32,
    DefaultValue: ?*anyopaque,
};

pub const D3D10_SHADER_TYPE_DESC = extern struct {
    Class: D3D_SHADER_VARIABLE_CLASS,
    Type: D3D_SHADER_VARIABLE_TYPE,
    Rows: u32,
    Columns: u32,
    Elements: u32,
    Members: u32,
    Offset: u32,
};

pub const D3D10_SHADER_INPUT_BIND_DESC = extern struct {
    Name: ?[*:0]const u8,
    Type: D3D_SHADER_INPUT_TYPE,
    BindPoint: u32,
    BindCount: u32,
    uFlags: u32,
    ReturnType: D3D_RESOURCE_RETURN_TYPE,
    Dimension: D3D_SRV_DIMENSION,
    NumSamples: u32,
};

pub const D3D10_SIGNATURE_PARAMETER_DESC = extern struct {
    SemanticName: ?[*:0]const u8,
    SemanticIndex: u32,
    Register: u32,
    SystemValueType: D3D_NAME,
    ComponentType: D3D_REGISTER_COMPONENT_TYPE,
    Mask: u8,
    ReadWriteMask: u8,
};

const IID_ID3D10ShaderReflectionType_Value = Guid.initString("c530ad7d-9b16-4395-a979-ba2ecff83add");
pub const IID_ID3D10ShaderReflectionType = &IID_ID3D10ShaderReflectionType_Value;
pub const ID3D10ShaderReflectionType = extern struct {
    pub const VTable = extern struct {
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflectionType,
                pDesc: ?*D3D10_SHADER_TYPE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflectionType,
                pDesc: ?*D3D10_SHADER_TYPE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemberTypeByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflectionType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionType,
            else => *const fn(
                self: *const ID3D10ShaderReflectionType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionType,
        },
        GetMemberTypeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflectionType,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionType,
            else => *const fn(
                self: *const ID3D10ShaderReflectionType,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionType,
        },
        GetMemberTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflectionType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?PSTR,
            else => *const fn(
                self: *const ID3D10ShaderReflectionType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?PSTR,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflectionType_GetDesc(self: *const T, pDesc: ?*D3D10_SHADER_TYPE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflectionType.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10ShaderReflectionType, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflectionType_GetMemberTypeByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10ShaderReflectionType {
            return @ptrCast(*const ID3D10ShaderReflectionType.VTable, self.vtable).GetMemberTypeByIndex(@ptrCast(*const ID3D10ShaderReflectionType, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflectionType_GetMemberTypeByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10ShaderReflectionType {
            return @ptrCast(*const ID3D10ShaderReflectionType.VTable, self.vtable).GetMemberTypeByName(@ptrCast(*const ID3D10ShaderReflectionType, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflectionType_GetMemberTypeName(self: *const T, Index: u32) callconv(.Inline) ?PSTR {
            return @ptrCast(*const ID3D10ShaderReflectionType.VTable, self.vtable).GetMemberTypeName(@ptrCast(*const ID3D10ShaderReflectionType, self), Index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10ShaderReflectionVariable_Value = Guid.initString("1bf63c95-2650-405d-99c1-3636bd1da0a1");
pub const IID_ID3D10ShaderReflectionVariable = &IID_ID3D10ShaderReflectionVariable_Value;
pub const ID3D10ShaderReflectionVariable = extern struct {
    pub const VTable = extern struct {
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflectionVariable,
                pDesc: ?*D3D10_SHADER_VARIABLE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflectionVariable,
                pDesc: ?*D3D10_SHADER_VARIABLE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflectionVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionType,
            else => *const fn(
                self: *const ID3D10ShaderReflectionVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionType,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflectionVariable_GetDesc(self: *const T, pDesc: ?*D3D10_SHADER_VARIABLE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflectionVariable.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10ShaderReflectionVariable, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflectionVariable_GetType(self: *const T) callconv(.Inline) ?*ID3D10ShaderReflectionType {
            return @ptrCast(*const ID3D10ShaderReflectionVariable.VTable, self.vtable).GetType(@ptrCast(*const ID3D10ShaderReflectionVariable, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10ShaderReflectionConstantBuffer_Value = Guid.initString("66c66a94-dddd-4b62-a66a-f0da33c2b4d0");
pub const IID_ID3D10ShaderReflectionConstantBuffer = &IID_ID3D10ShaderReflectionConstantBuffer_Value;
pub const ID3D10ShaderReflectionConstantBuffer = extern struct {
    pub const VTable = extern struct {
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflectionConstantBuffer,
                pDesc: ?*D3D10_SHADER_BUFFER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflectionConstantBuffer,
                pDesc: ?*D3D10_SHADER_BUFFER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVariableByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflectionConstantBuffer,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionVariable,
            else => *const fn(
                self: *const ID3D10ShaderReflectionConstantBuffer,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionVariable,
        },
        GetVariableByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflectionConstantBuffer,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionVariable,
            else => *const fn(
                self: *const ID3D10ShaderReflectionConstantBuffer,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionVariable,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflectionConstantBuffer_GetDesc(self: *const T, pDesc: ?*D3D10_SHADER_BUFFER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflectionConstantBuffer.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10ShaderReflectionConstantBuffer, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflectionConstantBuffer_GetVariableByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10ShaderReflectionVariable {
            return @ptrCast(*const ID3D10ShaderReflectionConstantBuffer.VTable, self.vtable).GetVariableByIndex(@ptrCast(*const ID3D10ShaderReflectionConstantBuffer, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflectionConstantBuffer_GetVariableByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10ShaderReflectionVariable {
            return @ptrCast(*const ID3D10ShaderReflectionConstantBuffer.VTable, self.vtable).GetVariableByName(@ptrCast(*const ID3D10ShaderReflectionConstantBuffer, self), Name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10ShaderReflection_Value = Guid.initString("d40e20b6-f8f7-42ad-ab20-4baf8f15dfaa");
pub const IID_ID3D10ShaderReflection = &IID_ID3D10ShaderReflection_Value;
pub const ID3D10ShaderReflection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection,
                pDesc: ?*D3D10_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection,
                pDesc: ?*D3D10_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantBufferByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionConstantBuffer,
            else => *const fn(
                self: *const ID3D10ShaderReflection,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionConstantBuffer,
        },
        GetConstantBufferByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionConstantBuffer,
            else => *const fn(
                self: *const ID3D10ShaderReflection,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionConstantBuffer,
        },
        GetResourceBindingDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection,
                ResourceIndex: u32,
                pDesc: ?*D3D10_SHADER_INPUT_BIND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection,
                ResourceIndex: u32,
                pDesc: ?*D3D10_SHADER_INPUT_BIND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputParameterDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection,
                ParameterIndex: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection,
                ParameterIndex: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputParameterDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection,
                ParameterIndex: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection,
                ParameterIndex: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection_GetDesc(self: *const T, pDesc: ?*D3D10_SHADER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10ShaderReflection, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection_GetConstantBufferByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10ShaderReflectionConstantBuffer {
            return @ptrCast(*const ID3D10ShaderReflection.VTable, self.vtable).GetConstantBufferByIndex(@ptrCast(*const ID3D10ShaderReflection, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection_GetConstantBufferByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10ShaderReflectionConstantBuffer {
            return @ptrCast(*const ID3D10ShaderReflection.VTable, self.vtable).GetConstantBufferByName(@ptrCast(*const ID3D10ShaderReflection, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection_GetResourceBindingDesc(self: *const T, ResourceIndex: u32, pDesc: ?*D3D10_SHADER_INPUT_BIND_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection.VTable, self.vtable).GetResourceBindingDesc(@ptrCast(*const ID3D10ShaderReflection, self), ResourceIndex, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection_GetInputParameterDesc(self: *const T, ParameterIndex: u32, pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection.VTable, self.vtable).GetInputParameterDesc(@ptrCast(*const ID3D10ShaderReflection, self), ParameterIndex, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection_GetOutputParameterDesc(self: *const T, ParameterIndex: u32, pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection.VTable, self.vtable).GetOutputParameterDesc(@ptrCast(*const ID3D10ShaderReflection, self), ParameterIndex, pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_DEVICE_STATE_TYPES = enum(i32) {
    SO_BUFFERS = 1,
    OM_RENDER_TARGETS = 2,
    OM_DEPTH_STENCIL_STATE = 3,
    OM_BLEND_STATE = 4,
    VS = 5,
    VS_SAMPLERS = 6,
    VS_SHADER_RESOURCES = 7,
    VS_CONSTANT_BUFFERS = 8,
    GS = 9,
    GS_SAMPLERS = 10,
    GS_SHADER_RESOURCES = 11,
    GS_CONSTANT_BUFFERS = 12,
    PS = 13,
    PS_SAMPLERS = 14,
    PS_SHADER_RESOURCES = 15,
    PS_CONSTANT_BUFFERS = 16,
    IA_VERTEX_BUFFERS = 17,
    IA_INDEX_BUFFER = 18,
    IA_INPUT_LAYOUT = 19,
    IA_PRIMITIVE_TOPOLOGY = 20,
    RS_VIEWPORTS = 21,
    RS_SCISSOR_RECTS = 22,
    RS_RASTERIZER_STATE = 23,
    PREDICATION = 24,
};
pub const D3D10_DST_SO_BUFFERS = D3D10_DEVICE_STATE_TYPES.SO_BUFFERS;
pub const D3D10_DST_OM_RENDER_TARGETS = D3D10_DEVICE_STATE_TYPES.OM_RENDER_TARGETS;
pub const D3D10_DST_OM_DEPTH_STENCIL_STATE = D3D10_DEVICE_STATE_TYPES.OM_DEPTH_STENCIL_STATE;
pub const D3D10_DST_OM_BLEND_STATE = D3D10_DEVICE_STATE_TYPES.OM_BLEND_STATE;
pub const D3D10_DST_VS = D3D10_DEVICE_STATE_TYPES.VS;
pub const D3D10_DST_VS_SAMPLERS = D3D10_DEVICE_STATE_TYPES.VS_SAMPLERS;
pub const D3D10_DST_VS_SHADER_RESOURCES = D3D10_DEVICE_STATE_TYPES.VS_SHADER_RESOURCES;
pub const D3D10_DST_VS_CONSTANT_BUFFERS = D3D10_DEVICE_STATE_TYPES.VS_CONSTANT_BUFFERS;
pub const D3D10_DST_GS = D3D10_DEVICE_STATE_TYPES.GS;
pub const D3D10_DST_GS_SAMPLERS = D3D10_DEVICE_STATE_TYPES.GS_SAMPLERS;
pub const D3D10_DST_GS_SHADER_RESOURCES = D3D10_DEVICE_STATE_TYPES.GS_SHADER_RESOURCES;
pub const D3D10_DST_GS_CONSTANT_BUFFERS = D3D10_DEVICE_STATE_TYPES.GS_CONSTANT_BUFFERS;
pub const D3D10_DST_PS = D3D10_DEVICE_STATE_TYPES.PS;
pub const D3D10_DST_PS_SAMPLERS = D3D10_DEVICE_STATE_TYPES.PS_SAMPLERS;
pub const D3D10_DST_PS_SHADER_RESOURCES = D3D10_DEVICE_STATE_TYPES.PS_SHADER_RESOURCES;
pub const D3D10_DST_PS_CONSTANT_BUFFERS = D3D10_DEVICE_STATE_TYPES.PS_CONSTANT_BUFFERS;
pub const D3D10_DST_IA_VERTEX_BUFFERS = D3D10_DEVICE_STATE_TYPES.IA_VERTEX_BUFFERS;
pub const D3D10_DST_IA_INDEX_BUFFER = D3D10_DEVICE_STATE_TYPES.IA_INDEX_BUFFER;
pub const D3D10_DST_IA_INPUT_LAYOUT = D3D10_DEVICE_STATE_TYPES.IA_INPUT_LAYOUT;
pub const D3D10_DST_IA_PRIMITIVE_TOPOLOGY = D3D10_DEVICE_STATE_TYPES.IA_PRIMITIVE_TOPOLOGY;
pub const D3D10_DST_RS_VIEWPORTS = D3D10_DEVICE_STATE_TYPES.RS_VIEWPORTS;
pub const D3D10_DST_RS_SCISSOR_RECTS = D3D10_DEVICE_STATE_TYPES.RS_SCISSOR_RECTS;
pub const D3D10_DST_RS_RASTERIZER_STATE = D3D10_DEVICE_STATE_TYPES.RS_RASTERIZER_STATE;
pub const D3D10_DST_PREDICATION = D3D10_DEVICE_STATE_TYPES.PREDICATION;

pub const D3D10_STATE_BLOCK_MASK = extern struct {
    VS: u8,
    VSSamplers: [2]u8,
    VSShaderResources: [16]u8,
    VSConstantBuffers: [2]u8,
    GS: u8,
    GSSamplers: [2]u8,
    GSShaderResources: [16]u8,
    GSConstantBuffers: [2]u8,
    PS: u8,
    PSSamplers: [2]u8,
    PSShaderResources: [16]u8,
    PSConstantBuffers: [2]u8,
    IAVertexBuffers: [2]u8,
    IAIndexBuffer: u8,
    IAInputLayout: u8,
    IAPrimitiveTopology: u8,
    OMRenderTargets: u8,
    OMDepthStencilState: u8,
    OMBlendState: u8,
    RSViewports: u8,
    RSScissorRects: u8,
    RSRasterizerState: u8,
    SOBuffers: u8,
    Predication: u8,
};

const IID_ID3D10StateBlock_Value = Guid.initString("0803425a-57f5-4dd6-9465-a87570834a08");
pub const IID_ID3D10StateBlock = &IID_ID3D10StateBlock_Value;
pub const ID3D10StateBlock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Capture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10StateBlock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10StateBlock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Apply: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10StateBlock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10StateBlock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseAllDeviceObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10StateBlock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10StateBlock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10StateBlock,
                ppDevice: ?*?*ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10StateBlock,
                ppDevice: ?*?*ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10StateBlock_Capture(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10StateBlock.VTable, self.vtable).Capture(@ptrCast(*const ID3D10StateBlock, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10StateBlock_Apply(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10StateBlock.VTable, self.vtable).Apply(@ptrCast(*const ID3D10StateBlock, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10StateBlock_ReleaseAllDeviceObjects(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10StateBlock.VTable, self.vtable).ReleaseAllDeviceObjects(@ptrCast(*const ID3D10StateBlock, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10StateBlock_GetDevice(self: *const T, ppDevice: ?*?*ID3D10Device) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10StateBlock.VTable, self.vtable).GetDevice(@ptrCast(*const ID3D10StateBlock, self), ppDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_EFFECT_TYPE_DESC = extern struct {
    TypeName: ?[*:0]const u8,
    Class: D3D_SHADER_VARIABLE_CLASS,
    Type: D3D_SHADER_VARIABLE_TYPE,
    Elements: u32,
    Members: u32,
    Rows: u32,
    Columns: u32,
    PackedSize: u32,
    UnpackedSize: u32,
    Stride: u32,
};

const IID_ID3D10EffectType_Value = Guid.initString("4e9e1ddc-cd9d-4772-a837-00180b9b88fd");
pub const IID_ID3D10EffectType = &IID_ID3D10EffectType_Value;
pub const ID3D10EffectType = extern struct {
    pub const VTable = extern struct {
        IsValid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectType,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10EffectType,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectType,
                pDesc: ?*D3D10_EFFECT_TYPE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectType,
                pDesc: ?*D3D10_EFFECT_TYPE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemberTypeByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectType,
            else => *const fn(
                self: *const ID3D10EffectType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectType,
        },
        GetMemberTypeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectType,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectType,
            else => *const fn(
                self: *const ID3D10EffectType,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectType,
        },
        GetMemberTypeBySemantic: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectType,
                Semantic: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectType,
            else => *const fn(
                self: *const ID3D10EffectType,
                Semantic: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectType,
        },
        GetMemberName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?PSTR,
            else => *const fn(
                self: *const ID3D10EffectType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?PSTR,
        },
        GetMemberSemantic: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?PSTR,
            else => *const fn(
                self: *const ID3D10EffectType,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?PSTR,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectType_IsValid(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10EffectType.VTable, self.vtable).IsValid(@ptrCast(*const ID3D10EffectType, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectType_GetDesc(self: *const T, pDesc: ?*D3D10_EFFECT_TYPE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectType.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10EffectType, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectType_GetMemberTypeByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectType {
            return @ptrCast(*const ID3D10EffectType.VTable, self.vtable).GetMemberTypeByIndex(@ptrCast(*const ID3D10EffectType, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectType_GetMemberTypeByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectType {
            return @ptrCast(*const ID3D10EffectType.VTable, self.vtable).GetMemberTypeByName(@ptrCast(*const ID3D10EffectType, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectType_GetMemberTypeBySemantic(self: *const T, Semantic: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectType {
            return @ptrCast(*const ID3D10EffectType.VTable, self.vtable).GetMemberTypeBySemantic(@ptrCast(*const ID3D10EffectType, self), Semantic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectType_GetMemberName(self: *const T, Index: u32) callconv(.Inline) ?PSTR {
            return @ptrCast(*const ID3D10EffectType.VTable, self.vtable).GetMemberName(@ptrCast(*const ID3D10EffectType, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectType_GetMemberSemantic(self: *const T, Index: u32) callconv(.Inline) ?PSTR {
            return @ptrCast(*const ID3D10EffectType.VTable, self.vtable).GetMemberSemantic(@ptrCast(*const ID3D10EffectType, self), Index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_EFFECT_VARIABLE_DESC = extern struct {
    Name: ?[*:0]const u8,
    Semantic: ?[*:0]const u8,
    Flags: u32,
    Annotations: u32,
    BufferOffset: u32,
    ExplicitBindPoint: u32,
};

const IID_ID3D10EffectVariable_Value = Guid.initString("ae897105-00e6-45bf-bb8e-281dd6db8e1b");
pub const IID_ID3D10EffectVariable = &IID_ID3D10EffectVariable_Value;
pub const ID3D10EffectVariable = extern struct {
    pub const VTable = extern struct {
        IsValid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectType,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectType,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
                pDesc: ?*D3D10_EFFECT_VARIABLE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVariable,
                pDesc: ?*D3D10_EFFECT_VARIABLE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnnotationByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetAnnotationByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetMemberByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetMemberByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetMemberBySemantic: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
                Semantic: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
                Semantic: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetParentConstantBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectConstantBuffer,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectConstantBuffer,
        },
        AsScalar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectScalarVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectScalarVariable,
        },
        AsVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVectorVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVectorVariable,
        },
        AsMatrix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectMatrixVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectMatrixVariable,
        },
        AsString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectStringVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectStringVariable,
        },
        AsShaderResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectShaderResourceVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectShaderResourceVariable,
        },
        AsRenderTargetView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectRenderTargetViewVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectRenderTargetViewVariable,
        },
        AsDepthStencilView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectDepthStencilViewVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectDepthStencilViewVariable,
        },
        AsConstantBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectConstantBuffer,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectConstantBuffer,
        },
        AsShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectShaderVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectShaderVariable,
        },
        AsBlend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectBlendVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectBlendVariable,
        },
        AsDepthStencil: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectDepthStencilVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectDepthStencilVariable,
        },
        AsRasterizer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectRasterizerVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectRasterizerVariable,
        },
        AsSampler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectSamplerVariable,
            else => *const fn(
                self: *const ID3D10EffectVariable,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectSamplerVariable,
        },
        SetRawValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*anyopaque,
                Offset: u32,
                ByteCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVariable,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*anyopaque,
                Offset: u32,
                ByteCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVariable,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*anyopaque,
                Offset: u32,
                ByteCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVariable,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*anyopaque,
                Offset: u32,
                ByteCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_IsValid(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).IsValid(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetType(self: *const T) callconv(.Inline) ?*ID3D10EffectType {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetType(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetDesc(self: *const T, pDesc: ?*D3D10_EFFECT_VARIABLE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10EffectVariable, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetAnnotationByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetAnnotationByIndex(@ptrCast(*const ID3D10EffectVariable, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetAnnotationByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetAnnotationByName(@ptrCast(*const ID3D10EffectVariable, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetMemberByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetMemberByIndex(@ptrCast(*const ID3D10EffectVariable, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetMemberByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetMemberByName(@ptrCast(*const ID3D10EffectVariable, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetMemberBySemantic(self: *const T, Semantic: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetMemberBySemantic(@ptrCast(*const ID3D10EffectVariable, self), Semantic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetElement(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetElement(@ptrCast(*const ID3D10EffectVariable, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetParentConstantBuffer(self: *const T) callconv(.Inline) ?*ID3D10EffectConstantBuffer {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetParentConstantBuffer(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsScalar(self: *const T) callconv(.Inline) ?*ID3D10EffectScalarVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsScalar(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsVector(self: *const T) callconv(.Inline) ?*ID3D10EffectVectorVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsVector(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsMatrix(self: *const T) callconv(.Inline) ?*ID3D10EffectMatrixVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsMatrix(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsString(self: *const T) callconv(.Inline) ?*ID3D10EffectStringVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsString(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsShaderResource(self: *const T) callconv(.Inline) ?*ID3D10EffectShaderResourceVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsShaderResource(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsRenderTargetView(self: *const T) callconv(.Inline) ?*ID3D10EffectRenderTargetViewVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsRenderTargetView(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsDepthStencilView(self: *const T) callconv(.Inline) ?*ID3D10EffectDepthStencilViewVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsDepthStencilView(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsConstantBuffer(self: *const T) callconv(.Inline) ?*ID3D10EffectConstantBuffer {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsConstantBuffer(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsShader(self: *const T) callconv(.Inline) ?*ID3D10EffectShaderVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsShader(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsBlend(self: *const T) callconv(.Inline) ?*ID3D10EffectBlendVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsBlend(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsDepthStencil(self: *const T) callconv(.Inline) ?*ID3D10EffectDepthStencilVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsDepthStencil(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsRasterizer(self: *const T) callconv(.Inline) ?*ID3D10EffectRasterizerVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsRasterizer(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_AsSampler(self: *const T) callconv(.Inline) ?*ID3D10EffectSamplerVariable {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).AsSampler(@ptrCast(*const ID3D10EffectVariable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_SetRawValue(self: *const T, pData: ?*anyopaque, Offset: u32, ByteCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).SetRawValue(@ptrCast(*const ID3D10EffectVariable, self), pData, Offset, ByteCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVariable_GetRawValue(self: *const T, pData: ?*anyopaque, Offset: u32, ByteCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVariable.VTable, self.vtable).GetRawValue(@ptrCast(*const ID3D10EffectVariable, self), pData, Offset, ByteCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectScalarVariable_Value = Guid.initString("00e48f7b-d2c8-49e8-a86c-022dee53431f");
pub const IID_ID3D10EffectScalarVariable = &IID_ID3D10EffectScalarVariable_Value;
pub const ID3D10EffectScalarVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        SetFloat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFloat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFloatArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFloatArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIntArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]i32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]i32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]i32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]i32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBool: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                Value: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                Value: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBool: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                pValue: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                pValue: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBoolArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]BOOL,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]BOOL,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoolArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]BOOL,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectScalarVariable,
                pData: [*]BOOL,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_SetFloat(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).SetFloat(@ptrCast(*const ID3D10EffectScalarVariable, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_GetFloat(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).GetFloat(@ptrCast(*const ID3D10EffectScalarVariable, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_SetFloatArray(self: *const T, pData: [*]f32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).SetFloatArray(@ptrCast(*const ID3D10EffectScalarVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_GetFloatArray(self: *const T, pData: [*]f32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).GetFloatArray(@ptrCast(*const ID3D10EffectScalarVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_SetInt(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).SetInt(@ptrCast(*const ID3D10EffectScalarVariable, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_GetInt(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).GetInt(@ptrCast(*const ID3D10EffectScalarVariable, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_SetIntArray(self: *const T, pData: [*]i32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).SetIntArray(@ptrCast(*const ID3D10EffectScalarVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_GetIntArray(self: *const T, pData: [*]i32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).GetIntArray(@ptrCast(*const ID3D10EffectScalarVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_SetBool(self: *const T, Value: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).SetBool(@ptrCast(*const ID3D10EffectScalarVariable, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_GetBool(self: *const T, pValue: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).GetBool(@ptrCast(*const ID3D10EffectScalarVariable, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_SetBoolArray(self: *const T, pData: [*]BOOL, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).SetBoolArray(@ptrCast(*const ID3D10EffectScalarVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectScalarVariable_GetBoolArray(self: *const T, pData: [*]BOOL, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectScalarVariable.VTable, self.vtable).GetBoolArray(@ptrCast(*const ID3D10EffectScalarVariable, self), pData, Offset, Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectVectorVariable_Value = Guid.initString("62b98c44-1f82-4c67-bcd0-72cf8f217e81");
pub const IID_ID3D10EffectVectorVariable = &IID_ID3D10EffectVectorVariable_Value;
pub const ID3D10EffectVectorVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        SetBoolVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIntVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFloatVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoolVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFloatVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBoolVectorArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*BOOL,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*BOOL,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIntVectorArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*i32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*i32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFloatVectorArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoolVectorArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*BOOL,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*BOOL,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntVectorArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*i32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*i32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFloatVectorArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectVectorVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_SetBoolVector(self: *const T, pData: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).SetBoolVector(@ptrCast(*const ID3D10EffectVectorVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_SetIntVector(self: *const T, pData: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).SetIntVector(@ptrCast(*const ID3D10EffectVectorVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_SetFloatVector(self: *const T, pData: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).SetFloatVector(@ptrCast(*const ID3D10EffectVectorVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_GetBoolVector(self: *const T, pData: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).GetBoolVector(@ptrCast(*const ID3D10EffectVectorVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_GetIntVector(self: *const T, pData: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).GetIntVector(@ptrCast(*const ID3D10EffectVectorVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_GetFloatVector(self: *const T, pData: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).GetFloatVector(@ptrCast(*const ID3D10EffectVectorVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_SetBoolVectorArray(self: *const T, pData: ?*BOOL, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).SetBoolVectorArray(@ptrCast(*const ID3D10EffectVectorVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_SetIntVectorArray(self: *const T, pData: ?*i32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).SetIntVectorArray(@ptrCast(*const ID3D10EffectVectorVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_SetFloatVectorArray(self: *const T, pData: ?*f32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).SetFloatVectorArray(@ptrCast(*const ID3D10EffectVectorVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_GetBoolVectorArray(self: *const T, pData: ?*BOOL, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).GetBoolVectorArray(@ptrCast(*const ID3D10EffectVectorVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_GetIntVectorArray(self: *const T, pData: ?*i32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).GetIntVectorArray(@ptrCast(*const ID3D10EffectVectorVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectVectorVariable_GetFloatVectorArray(self: *const T, pData: ?*f32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectVectorVariable.VTable, self.vtable).GetFloatVectorArray(@ptrCast(*const ID3D10EffectVectorVariable, self), pData, Offset, Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectMatrixVariable_Value = Guid.initString("50666c24-b82f-4eed-a172-5b6e7e8522e0");
pub const IID_ID3D10EffectMatrixVariable = &IID_ID3D10EffectMatrixVariable_Value;
pub const ID3D10EffectMatrixVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        SetMatrix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatrix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMatrixArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatrixArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMatrixTranspose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatrixTranspose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMatrixTransposeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatrixTransposeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectMatrixVariable,
                pData: ?*f32,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectMatrixVariable_SetMatrix(self: *const T, pData: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectMatrixVariable.VTable, self.vtable).SetMatrix(@ptrCast(*const ID3D10EffectMatrixVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectMatrixVariable_GetMatrix(self: *const T, pData: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectMatrixVariable.VTable, self.vtable).GetMatrix(@ptrCast(*const ID3D10EffectMatrixVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectMatrixVariable_SetMatrixArray(self: *const T, pData: ?*f32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectMatrixVariable.VTable, self.vtable).SetMatrixArray(@ptrCast(*const ID3D10EffectMatrixVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectMatrixVariable_GetMatrixArray(self: *const T, pData: ?*f32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectMatrixVariable.VTable, self.vtable).GetMatrixArray(@ptrCast(*const ID3D10EffectMatrixVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectMatrixVariable_SetMatrixTranspose(self: *const T, pData: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectMatrixVariable.VTable, self.vtable).SetMatrixTranspose(@ptrCast(*const ID3D10EffectMatrixVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectMatrixVariable_GetMatrixTranspose(self: *const T, pData: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectMatrixVariable.VTable, self.vtable).GetMatrixTranspose(@ptrCast(*const ID3D10EffectMatrixVariable, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectMatrixVariable_SetMatrixTransposeArray(self: *const T, pData: ?*f32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectMatrixVariable.VTable, self.vtable).SetMatrixTransposeArray(@ptrCast(*const ID3D10EffectMatrixVariable, self), pData, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectMatrixVariable_GetMatrixTransposeArray(self: *const T, pData: ?*f32, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectMatrixVariable.VTable, self.vtable).GetMatrixTransposeArray(@ptrCast(*const ID3D10EffectMatrixVariable, self), pData, Offset, Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectStringVariable_Value = Guid.initString("71417501-8df9-4e0a-a78a-255f9756baff");
pub const IID_ID3D10EffectStringVariable = &IID_ID3D10EffectStringVariable_Value;
pub const ID3D10EffectStringVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectStringVariable,
                ppString: ?*?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectStringVariable,
                ppString: ?*?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectStringVariable,
                ppStrings: [*]?PSTR,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectStringVariable,
                ppStrings: [*]?PSTR,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectStringVariable_GetString(self: *const T, ppString: ?*?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectStringVariable.VTable, self.vtable).GetString(@ptrCast(*const ID3D10EffectStringVariable, self), ppString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectStringVariable_GetStringArray(self: *const T, ppStrings: [*]?PSTR, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectStringVariable.VTable, self.vtable).GetStringArray(@ptrCast(*const ID3D10EffectStringVariable, self), ppStrings, Offset, Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectShaderResourceVariable_Value = Guid.initString("c0a7157b-d872-4b1d-8073-efc2acd4b1fc");
pub const IID_ID3D10EffectShaderResourceVariable = &IID_ID3D10EffectShaderResourceVariable_Value;
pub const ID3D10EffectShaderResourceVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        SetResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderResourceVariable,
                pResource: ?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderResourceVariable,
                pResource: ?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderResourceVariable,
                ppResource: ?*?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderResourceVariable,
                ppResource: ?*?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetResourceArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderResourceVariable,
                ppResources: [*]?*ID3D10ShaderResourceView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderResourceVariable,
                ppResources: [*]?*ID3D10ShaderResourceView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResourceArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderResourceVariable,
                ppResources: [*]?*ID3D10ShaderResourceView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderResourceVariable,
                ppResources: [*]?*ID3D10ShaderResourceView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderResourceVariable_SetResource(self: *const T, pResource: ?*ID3D10ShaderResourceView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderResourceVariable.VTable, self.vtable).SetResource(@ptrCast(*const ID3D10EffectShaderResourceVariable, self), pResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderResourceVariable_GetResource(self: *const T, ppResource: ?*?*ID3D10ShaderResourceView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderResourceVariable.VTable, self.vtable).GetResource(@ptrCast(*const ID3D10EffectShaderResourceVariable, self), ppResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderResourceVariable_SetResourceArray(self: *const T, ppResources: [*]?*ID3D10ShaderResourceView, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderResourceVariable.VTable, self.vtable).SetResourceArray(@ptrCast(*const ID3D10EffectShaderResourceVariable, self), ppResources, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderResourceVariable_GetResourceArray(self: *const T, ppResources: [*]?*ID3D10ShaderResourceView, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderResourceVariable.VTable, self.vtable).GetResourceArray(@ptrCast(*const ID3D10EffectShaderResourceVariable, self), ppResources, Offset, Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectRenderTargetViewVariable_Value = Guid.initString("28ca0cc3-c2c9-40bb-b57f-67b737122b17");
pub const IID_ID3D10EffectRenderTargetViewVariable = &IID_ID3D10EffectRenderTargetViewVariable_Value;
pub const ID3D10EffectRenderTargetViewVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        SetRenderTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectRenderTargetViewVariable,
                pResource: ?*ID3D10RenderTargetView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectRenderTargetViewVariable,
                pResource: ?*ID3D10RenderTargetView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenderTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectRenderTargetViewVariable,
                ppResource: ?*?*ID3D10RenderTargetView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectRenderTargetViewVariable,
                ppResource: ?*?*ID3D10RenderTargetView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRenderTargetArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectRenderTargetViewVariable,
                ppResources: [*]?*ID3D10RenderTargetView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectRenderTargetViewVariable,
                ppResources: [*]?*ID3D10RenderTargetView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenderTargetArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectRenderTargetViewVariable,
                ppResources: [*]?*ID3D10RenderTargetView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectRenderTargetViewVariable,
                ppResources: [*]?*ID3D10RenderTargetView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectRenderTargetViewVariable_SetRenderTarget(self: *const T, pResource: ?*ID3D10RenderTargetView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectRenderTargetViewVariable.VTable, self.vtable).SetRenderTarget(@ptrCast(*const ID3D10EffectRenderTargetViewVariable, self), pResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectRenderTargetViewVariable_GetRenderTarget(self: *const T, ppResource: ?*?*ID3D10RenderTargetView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectRenderTargetViewVariable.VTable, self.vtable).GetRenderTarget(@ptrCast(*const ID3D10EffectRenderTargetViewVariable, self), ppResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectRenderTargetViewVariable_SetRenderTargetArray(self: *const T, ppResources: [*]?*ID3D10RenderTargetView, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectRenderTargetViewVariable.VTable, self.vtable).SetRenderTargetArray(@ptrCast(*const ID3D10EffectRenderTargetViewVariable, self), ppResources, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectRenderTargetViewVariable_GetRenderTargetArray(self: *const T, ppResources: [*]?*ID3D10RenderTargetView, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectRenderTargetViewVariable.VTable, self.vtable).GetRenderTargetArray(@ptrCast(*const ID3D10EffectRenderTargetViewVariable, self), ppResources, Offset, Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectDepthStencilViewVariable_Value = Guid.initString("3e02c918-cc79-4985-b622-2d92ad701623");
pub const IID_ID3D10EffectDepthStencilViewVariable = &IID_ID3D10EffectDepthStencilViewVariable_Value;
pub const ID3D10EffectDepthStencilViewVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        SetDepthStencil: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectDepthStencilViewVariable,
                pResource: ?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectDepthStencilViewVariable,
                pResource: ?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDepthStencil: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectDepthStencilViewVariable,
                ppResource: ?*?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectDepthStencilViewVariable,
                ppResource: ?*?*ID3D10DepthStencilView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDepthStencilArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectDepthStencilViewVariable,
                ppResources: [*]?*ID3D10DepthStencilView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectDepthStencilViewVariable,
                ppResources: [*]?*ID3D10DepthStencilView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDepthStencilArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectDepthStencilViewVariable,
                ppResources: [*]?*ID3D10DepthStencilView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectDepthStencilViewVariable,
                ppResources: [*]?*ID3D10DepthStencilView,
                Offset: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectDepthStencilViewVariable_SetDepthStencil(self: *const T, pResource: ?*ID3D10DepthStencilView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectDepthStencilViewVariable.VTable, self.vtable).SetDepthStencil(@ptrCast(*const ID3D10EffectDepthStencilViewVariable, self), pResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectDepthStencilViewVariable_GetDepthStencil(self: *const T, ppResource: ?*?*ID3D10DepthStencilView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectDepthStencilViewVariable.VTable, self.vtable).GetDepthStencil(@ptrCast(*const ID3D10EffectDepthStencilViewVariable, self), ppResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectDepthStencilViewVariable_SetDepthStencilArray(self: *const T, ppResources: [*]?*ID3D10DepthStencilView, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectDepthStencilViewVariable.VTable, self.vtable).SetDepthStencilArray(@ptrCast(*const ID3D10EffectDepthStencilViewVariable, self), ppResources, Offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectDepthStencilViewVariable_GetDepthStencilArray(self: *const T, ppResources: [*]?*ID3D10DepthStencilView, Offset: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectDepthStencilViewVariable.VTable, self.vtable).GetDepthStencilArray(@ptrCast(*const ID3D10EffectDepthStencilViewVariable, self), ppResources, Offset, Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectConstantBuffer_Value = Guid.initString("56648f4d-cc8b-4444-a5ad-b5a3d76e91b3");
pub const IID_ID3D10EffectConstantBuffer = &IID_ID3D10EffectConstantBuffer_Value;
pub const ID3D10EffectConstantBuffer = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        SetConstantBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectConstantBuffer,
                pConstantBuffer: ?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectConstantBuffer,
                pConstantBuffer: ?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectConstantBuffer,
                ppConstantBuffer: ?*?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectConstantBuffer,
                ppConstantBuffer: ?*?*ID3D10Buffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextureBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectConstantBuffer,
                pTextureBuffer: ?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectConstantBuffer,
                pTextureBuffer: ?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextureBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectConstantBuffer,
                ppTextureBuffer: ?*?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectConstantBuffer,
                ppTextureBuffer: ?*?*ID3D10ShaderResourceView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectConstantBuffer_SetConstantBuffer(self: *const T, pConstantBuffer: ?*ID3D10Buffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectConstantBuffer.VTable, self.vtable).SetConstantBuffer(@ptrCast(*const ID3D10EffectConstantBuffer, self), pConstantBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectConstantBuffer_GetConstantBuffer(self: *const T, ppConstantBuffer: ?*?*ID3D10Buffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectConstantBuffer.VTable, self.vtable).GetConstantBuffer(@ptrCast(*const ID3D10EffectConstantBuffer, self), ppConstantBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectConstantBuffer_SetTextureBuffer(self: *const T, pTextureBuffer: ?*ID3D10ShaderResourceView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectConstantBuffer.VTable, self.vtable).SetTextureBuffer(@ptrCast(*const ID3D10EffectConstantBuffer, self), pTextureBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectConstantBuffer_GetTextureBuffer(self: *const T, ppTextureBuffer: ?*?*ID3D10ShaderResourceView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectConstantBuffer.VTable, self.vtable).GetTextureBuffer(@ptrCast(*const ID3D10EffectConstantBuffer, self), ppTextureBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_EFFECT_SHADER_DESC = extern struct {
    pInputSignature: ?*const u8,
    IsInline: BOOL,
    pBytecode: ?*const u8,
    BytecodeLength: u32,
    SODecl: ?[*:0]const u8,
    NumInputSignatureEntries: u32,
    NumOutputSignatureEntries: u32,
};

const IID_ID3D10EffectShaderVariable_Value = Guid.initString("80849279-c799-4797-8c33-0407a07d9e06");
pub const IID_ID3D10EffectShaderVariable = &IID_ID3D10EffectShaderVariable_Value;
pub const ID3D10EffectShaderVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        GetShaderDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                pDesc: ?*D3D10_EFFECT_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                pDesc: ?*D3D10_EFFECT_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVertexShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                ppVS: ?*?*ID3D10VertexShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                ppVS: ?*?*ID3D10VertexShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGeometryShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                ppGS: ?*?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                ppGS: ?*?*ID3D10GeometryShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPixelShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                ppPS: ?*?*ID3D10PixelShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                ppPS: ?*?*ID3D10PixelShader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputSignatureElementDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                Element: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                Element: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputSignatureElementDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                Element: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectShaderVariable,
                ShaderIndex: u32,
                Element: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderVariable_GetShaderDesc(self: *const T, ShaderIndex: u32, pDesc: ?*D3D10_EFFECT_SHADER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderVariable.VTable, self.vtable).GetShaderDesc(@ptrCast(*const ID3D10EffectShaderVariable, self), ShaderIndex, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderVariable_GetVertexShader(self: *const T, ShaderIndex: u32, ppVS: ?*?*ID3D10VertexShader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderVariable.VTable, self.vtable).GetVertexShader(@ptrCast(*const ID3D10EffectShaderVariable, self), ShaderIndex, ppVS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderVariable_GetGeometryShader(self: *const T, ShaderIndex: u32, ppGS: ?*?*ID3D10GeometryShader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderVariable.VTable, self.vtable).GetGeometryShader(@ptrCast(*const ID3D10EffectShaderVariable, self), ShaderIndex, ppGS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderVariable_GetPixelShader(self: *const T, ShaderIndex: u32, ppPS: ?*?*ID3D10PixelShader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderVariable.VTable, self.vtable).GetPixelShader(@ptrCast(*const ID3D10EffectShaderVariable, self), ShaderIndex, ppPS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderVariable_GetInputSignatureElementDesc(self: *const T, ShaderIndex: u32, Element: u32, pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderVariable.VTable, self.vtable).GetInputSignatureElementDesc(@ptrCast(*const ID3D10EffectShaderVariable, self), ShaderIndex, Element, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectShaderVariable_GetOutputSignatureElementDesc(self: *const T, ShaderIndex: u32, Element: u32, pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectShaderVariable.VTable, self.vtable).GetOutputSignatureElementDesc(@ptrCast(*const ID3D10EffectShaderVariable, self), ShaderIndex, Element, pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectBlendVariable_Value = Guid.initString("1fcd2294-df6d-4eae-86b3-0e9160cfb07b");
pub const IID_ID3D10EffectBlendVariable = &IID_ID3D10EffectBlendVariable_Value;
pub const ID3D10EffectBlendVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        GetBlendState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectBlendVariable,
                Index: u32,
                ppBlendState: ?*?*ID3D10BlendState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectBlendVariable,
                Index: u32,
                ppBlendState: ?*?*ID3D10BlendState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackingStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectBlendVariable,
                Index: u32,
                pBlendDesc: ?*D3D10_BLEND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectBlendVariable,
                Index: u32,
                pBlendDesc: ?*D3D10_BLEND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectBlendVariable_GetBlendState(self: *const T, Index: u32, ppBlendState: ?*?*ID3D10BlendState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectBlendVariable.VTable, self.vtable).GetBlendState(@ptrCast(*const ID3D10EffectBlendVariable, self), Index, ppBlendState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectBlendVariable_GetBackingStore(self: *const T, Index: u32, pBlendDesc: ?*D3D10_BLEND_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectBlendVariable.VTable, self.vtable).GetBackingStore(@ptrCast(*const ID3D10EffectBlendVariable, self), Index, pBlendDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectDepthStencilVariable_Value = Guid.initString("af482368-330a-46a5-9a5c-01c71af24c8d");
pub const IID_ID3D10EffectDepthStencilVariable = &IID_ID3D10EffectDepthStencilVariable_Value;
pub const ID3D10EffectDepthStencilVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        GetDepthStencilState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectDepthStencilVariable,
                Index: u32,
                ppDepthStencilState: ?*?*ID3D10DepthStencilState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectDepthStencilVariable,
                Index: u32,
                ppDepthStencilState: ?*?*ID3D10DepthStencilState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackingStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectDepthStencilVariable,
                Index: u32,
                pDepthStencilDesc: ?*D3D10_DEPTH_STENCIL_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectDepthStencilVariable,
                Index: u32,
                pDepthStencilDesc: ?*D3D10_DEPTH_STENCIL_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectDepthStencilVariable_GetDepthStencilState(self: *const T, Index: u32, ppDepthStencilState: ?*?*ID3D10DepthStencilState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectDepthStencilVariable.VTable, self.vtable).GetDepthStencilState(@ptrCast(*const ID3D10EffectDepthStencilVariable, self), Index, ppDepthStencilState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectDepthStencilVariable_GetBackingStore(self: *const T, Index: u32, pDepthStencilDesc: ?*D3D10_DEPTH_STENCIL_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectDepthStencilVariable.VTable, self.vtable).GetBackingStore(@ptrCast(*const ID3D10EffectDepthStencilVariable, self), Index, pDepthStencilDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectRasterizerVariable_Value = Guid.initString("21af9f0e-4d94-4ea9-9785-2cb76b8c0b34");
pub const IID_ID3D10EffectRasterizerVariable = &IID_ID3D10EffectRasterizerVariable_Value;
pub const ID3D10EffectRasterizerVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        GetRasterizerState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectRasterizerVariable,
                Index: u32,
                ppRasterizerState: ?*?*ID3D10RasterizerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectRasterizerVariable,
                Index: u32,
                ppRasterizerState: ?*?*ID3D10RasterizerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackingStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectRasterizerVariable,
                Index: u32,
                pRasterizerDesc: ?*D3D10_RASTERIZER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectRasterizerVariable,
                Index: u32,
                pRasterizerDesc: ?*D3D10_RASTERIZER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectRasterizerVariable_GetRasterizerState(self: *const T, Index: u32, ppRasterizerState: ?*?*ID3D10RasterizerState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectRasterizerVariable.VTable, self.vtable).GetRasterizerState(@ptrCast(*const ID3D10EffectRasterizerVariable, self), Index, ppRasterizerState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectRasterizerVariable_GetBackingStore(self: *const T, Index: u32, pRasterizerDesc: ?*D3D10_RASTERIZER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectRasterizerVariable.VTable, self.vtable).GetBackingStore(@ptrCast(*const ID3D10EffectRasterizerVariable, self), Index, pRasterizerDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectSamplerVariable_Value = Guid.initString("6530d5c7-07e9-4271-a418-e7ce4bd1e480");
pub const IID_ID3D10EffectSamplerVariable = &IID_ID3D10EffectSamplerVariable_Value;
pub const ID3D10EffectSamplerVariable = extern struct {
    pub const VTable = extern struct {
        base: ID3D10EffectVariable.VTable,
        GetSampler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectSamplerVariable,
                Index: u32,
                ppSampler: ?*?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectSamplerVariable,
                Index: u32,
                ppSampler: ?*?*ID3D10SamplerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackingStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectSamplerVariable,
                Index: u32,
                pSamplerDesc: ?*D3D10_SAMPLER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectSamplerVariable,
                Index: u32,
                pSamplerDesc: ?*D3D10_SAMPLER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10EffectVariable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectSamplerVariable_GetSampler(self: *const T, Index: u32, ppSampler: ?*?*ID3D10SamplerState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectSamplerVariable.VTable, self.vtable).GetSampler(@ptrCast(*const ID3D10EffectSamplerVariable, self), Index, ppSampler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectSamplerVariable_GetBackingStore(self: *const T, Index: u32, pSamplerDesc: ?*D3D10_SAMPLER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectSamplerVariable.VTable, self.vtable).GetBackingStore(@ptrCast(*const ID3D10EffectSamplerVariable, self), Index, pSamplerDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_PASS_DESC = extern struct {
    Name: ?[*:0]const u8,
    Annotations: u32,
    pIAInputSignature: ?*u8,
    IAInputSignatureSize: usize,
    StencilRef: u32,
    SampleMask: u32,
    BlendFactor: [4]f32,
};

pub const D3D10_PASS_SHADER_DESC = extern struct {
    pShaderVariable: ?*ID3D10EffectShaderVariable,
    ShaderIndex: u32,
};

const IID_ID3D10EffectPass_Value = Guid.initString("5cfbeb89-1a06-46e0-b282-e3f9bfa36a54");
pub const IID_ID3D10EffectPass = &IID_ID3D10EffectPass_Value;
pub const ID3D10EffectPass = extern struct {
    pub const VTable = extern struct {
        IsValid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPass,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10EffectPass,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPass,
                pDesc: ?*D3D10_PASS_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectPass,
                pDesc: ?*D3D10_PASS_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVertexShaderDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPass,
                pDesc: ?*D3D10_PASS_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectPass,
                pDesc: ?*D3D10_PASS_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGeometryShaderDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPass,
                pDesc: ?*D3D10_PASS_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectPass,
                pDesc: ?*D3D10_PASS_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPixelShaderDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPass,
                pDesc: ?*D3D10_PASS_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectPass,
                pDesc: ?*D3D10_PASS_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnnotationByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPass,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectPass,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetAnnotationByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPass,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectPass,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        Apply: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPass,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectPass,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComputeStateBlockMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPass,
                pStateBlockMask: ?*D3D10_STATE_BLOCK_MASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectPass,
                pStateBlockMask: ?*D3D10_STATE_BLOCK_MASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPass_IsValid(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10EffectPass.VTable, self.vtable).IsValid(@ptrCast(*const ID3D10EffectPass, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPass_GetDesc(self: *const T, pDesc: ?*D3D10_PASS_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectPass.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10EffectPass, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPass_GetVertexShaderDesc(self: *const T, pDesc: ?*D3D10_PASS_SHADER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectPass.VTable, self.vtable).GetVertexShaderDesc(@ptrCast(*const ID3D10EffectPass, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPass_GetGeometryShaderDesc(self: *const T, pDesc: ?*D3D10_PASS_SHADER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectPass.VTable, self.vtable).GetGeometryShaderDesc(@ptrCast(*const ID3D10EffectPass, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPass_GetPixelShaderDesc(self: *const T, pDesc: ?*D3D10_PASS_SHADER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectPass.VTable, self.vtable).GetPixelShaderDesc(@ptrCast(*const ID3D10EffectPass, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPass_GetAnnotationByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectPass.VTable, self.vtable).GetAnnotationByIndex(@ptrCast(*const ID3D10EffectPass, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPass_GetAnnotationByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectPass.VTable, self.vtable).GetAnnotationByName(@ptrCast(*const ID3D10EffectPass, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPass_Apply(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectPass.VTable, self.vtable).Apply(@ptrCast(*const ID3D10EffectPass, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPass_ComputeStateBlockMask(self: *const T, pStateBlockMask: ?*D3D10_STATE_BLOCK_MASK) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectPass.VTable, self.vtable).ComputeStateBlockMask(@ptrCast(*const ID3D10EffectPass, self), pStateBlockMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_TECHNIQUE_DESC = extern struct {
    Name: ?[*:0]const u8,
    Passes: u32,
    Annotations: u32,
};

const IID_ID3D10EffectTechnique_Value = Guid.initString("db122ce8-d1c9-4292-b237-24ed3de8b175");
pub const IID_ID3D10EffectTechnique = &IID_ID3D10EffectTechnique_Value;
pub const ID3D10EffectTechnique = extern struct {
    pub const VTable = extern struct {
        IsValid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectTechnique,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10EffectTechnique,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectTechnique,
                pDesc: ?*D3D10_TECHNIQUE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectTechnique,
                pDesc: ?*D3D10_TECHNIQUE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnnotationByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectTechnique,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectTechnique,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetAnnotationByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectTechnique,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10EffectTechnique,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetPassByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectTechnique,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectPass,
            else => *const fn(
                self: *const ID3D10EffectTechnique,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectPass,
        },
        GetPassByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectTechnique,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectPass,
            else => *const fn(
                self: *const ID3D10EffectTechnique,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectPass,
        },
        ComputeStateBlockMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectTechnique,
                pStateBlockMask: ?*D3D10_STATE_BLOCK_MASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10EffectTechnique,
                pStateBlockMask: ?*D3D10_STATE_BLOCK_MASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectTechnique_IsValid(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10EffectTechnique.VTable, self.vtable).IsValid(@ptrCast(*const ID3D10EffectTechnique, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectTechnique_GetDesc(self: *const T, pDesc: ?*D3D10_TECHNIQUE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectTechnique.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10EffectTechnique, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectTechnique_GetAnnotationByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectTechnique.VTable, self.vtable).GetAnnotationByIndex(@ptrCast(*const ID3D10EffectTechnique, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectTechnique_GetAnnotationByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10EffectTechnique.VTable, self.vtable).GetAnnotationByName(@ptrCast(*const ID3D10EffectTechnique, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectTechnique_GetPassByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectPass {
            return @ptrCast(*const ID3D10EffectTechnique.VTable, self.vtable).GetPassByIndex(@ptrCast(*const ID3D10EffectTechnique, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectTechnique_GetPassByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectPass {
            return @ptrCast(*const ID3D10EffectTechnique.VTable, self.vtable).GetPassByName(@ptrCast(*const ID3D10EffectTechnique, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectTechnique_ComputeStateBlockMask(self: *const T, pStateBlockMask: ?*D3D10_STATE_BLOCK_MASK) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10EffectTechnique.VTable, self.vtable).ComputeStateBlockMask(@ptrCast(*const ID3D10EffectTechnique, self), pStateBlockMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_EFFECT_DESC = extern struct {
    IsChildEffect: BOOL,
    ConstantBuffers: u32,
    SharedConstantBuffers: u32,
    GlobalVariables: u32,
    SharedGlobalVariables: u32,
    Techniques: u32,
};

const IID_ID3D10Effect_Value = Guid.initString("51b0ca8b-ec0b-4519-870d-8ee1cb5017c7");
pub const IID_ID3D10Effect = &IID_ID3D10Effect_Value;
pub const ID3D10Effect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsValid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10Effect,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        IsPool: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10Effect,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
                ppDevice: ?*?*ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Effect,
                ppDevice: ?*?*ID3D10Device,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
                pDesc: ?*D3D10_EFFECT_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Effect,
                pDesc: ?*D3D10_EFFECT_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantBufferByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectConstantBuffer,
            else => *const fn(
                self: *const ID3D10Effect,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectConstantBuffer,
        },
        GetConstantBufferByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectConstantBuffer,
            else => *const fn(
                self: *const ID3D10Effect,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectConstantBuffer,
        },
        GetVariableByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10Effect,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetVariableByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10Effect,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetVariableBySemantic: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
                Semantic: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
            else => *const fn(
                self: *const ID3D10Effect,
                Semantic: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectVariable,
        },
        GetTechniqueByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectTechnique,
            else => *const fn(
                self: *const ID3D10Effect,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectTechnique,
        },
        GetTechniqueByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectTechnique,
            else => *const fn(
                self: *const ID3D10Effect,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10EffectTechnique,
        },
        Optimize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Effect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsOptimized: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Effect,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID3D10Effect,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_IsValid(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).IsValid(@ptrCast(*const ID3D10Effect, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_IsPool(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).IsPool(@ptrCast(*const ID3D10Effect, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_GetDevice(self: *const T, ppDevice: ?*?*ID3D10Device) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).GetDevice(@ptrCast(*const ID3D10Effect, self), ppDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_GetDesc(self: *const T, pDesc: ?*D3D10_EFFECT_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10Effect, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_GetConstantBufferByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectConstantBuffer {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).GetConstantBufferByIndex(@ptrCast(*const ID3D10Effect, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_GetConstantBufferByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectConstantBuffer {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).GetConstantBufferByName(@ptrCast(*const ID3D10Effect, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_GetVariableByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).GetVariableByIndex(@ptrCast(*const ID3D10Effect, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_GetVariableByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).GetVariableByName(@ptrCast(*const ID3D10Effect, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_GetVariableBySemantic(self: *const T, Semantic: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectVariable {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).GetVariableBySemantic(@ptrCast(*const ID3D10Effect, self), Semantic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_GetTechniqueByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10EffectTechnique {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).GetTechniqueByIndex(@ptrCast(*const ID3D10Effect, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_GetTechniqueByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10EffectTechnique {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).GetTechniqueByName(@ptrCast(*const ID3D10Effect, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_Optimize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).Optimize(@ptrCast(*const ID3D10Effect, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Effect_IsOptimized(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ID3D10Effect.VTable, self.vtable).IsOptimized(@ptrCast(*const ID3D10Effect, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D10EffectPool_Value = Guid.initString("9537ab04-3250-412e-8213-fcd2f8677933");
pub const IID_ID3D10EffectPool = &IID_ID3D10EffectPool_Value;
pub const ID3D10EffectPool = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AsEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10EffectPool,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10Effect,
            else => *const fn(
                self: *const ID3D10EffectPool,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10Effect,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10EffectPool_AsEffect(self: *const T) callconv(.Inline) ?*ID3D10Effect {
            return @ptrCast(*const ID3D10EffectPool.VTable, self.vtable).AsEffect(@ptrCast(*const ID3D10EffectPool, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_FEATURE_LEVEL1 = enum(i32) {
    @"10_0" = 40960,
    @"10_1" = 41216,
    @"9_1" = 37120,
    @"9_2" = 37376,
    @"9_3" = 37632,
};
pub const D3D10_FEATURE_LEVEL_10_0 = D3D10_FEATURE_LEVEL1.@"10_0";
pub const D3D10_FEATURE_LEVEL_10_1 = D3D10_FEATURE_LEVEL1.@"10_1";
pub const D3D10_FEATURE_LEVEL_9_1 = D3D10_FEATURE_LEVEL1.@"9_1";
pub const D3D10_FEATURE_LEVEL_9_2 = D3D10_FEATURE_LEVEL1.@"9_2";
pub const D3D10_FEATURE_LEVEL_9_3 = D3D10_FEATURE_LEVEL1.@"9_3";

pub const D3D10_RENDER_TARGET_BLEND_DESC1 = extern struct {
    BlendEnable: BOOL,
    SrcBlend: D3D10_BLEND,
    DestBlend: D3D10_BLEND,
    BlendOp: D3D10_BLEND_OP,
    SrcBlendAlpha: D3D10_BLEND,
    DestBlendAlpha: D3D10_BLEND,
    BlendOpAlpha: D3D10_BLEND_OP,
    RenderTargetWriteMask: u8,
};

pub const D3D10_BLEND_DESC1 = extern struct {
    AlphaToCoverageEnable: BOOL,
    IndependentBlendEnable: BOOL,
    RenderTarget: [8]D3D10_RENDER_TARGET_BLEND_DESC1,
};

const IID_ID3D10BlendState1_Value = Guid.initString("edad8d99-8a35-4d6d-8566-2ea276cde161");
pub const IID_ID3D10BlendState1 = &IID_ID3D10BlendState1_Value;
pub const ID3D10BlendState1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D10BlendState.VTable,
        GetDesc1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10BlendState1,
                pDesc: ?*D3D10_BLEND_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10BlendState1,
                pDesc: ?*D3D10_BLEND_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10BlendState.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10BlendState1_GetDesc1(self: *const T, pDesc: ?*D3D10_BLEND_DESC1) callconv(.Inline) void {
            return @ptrCast(*const ID3D10BlendState1.VTable, self.vtable).GetDesc1(@ptrCast(*const ID3D10BlendState1, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_TEXCUBE_ARRAY_SRV1 = extern struct {
    MostDetailedMip: u32,
    MipLevels: u32,
    First2DArrayFace: u32,
    NumCubes: u32,
};

pub const D3D10_SHADER_RESOURCE_VIEW_DESC1 = extern struct {
    Format: DXGI_FORMAT,
    ViewDimension: D3D_SRV_DIMENSION,
    Anonymous: extern union {
        Buffer: D3D10_BUFFER_SRV,
        Texture1D: D3D10_TEX1D_SRV,
        Texture1DArray: D3D10_TEX1D_ARRAY_SRV,
        Texture2D: D3D10_TEX2D_SRV,
        Texture2DArray: D3D10_TEX2D_ARRAY_SRV,
        Texture2DMS: D3D10_TEX2DMS_SRV,
        Texture2DMSArray: D3D10_TEX2DMS_ARRAY_SRV,
        Texture3D: D3D10_TEX3D_SRV,
        TextureCube: D3D10_TEXCUBE_SRV,
        TextureCubeArray: D3D10_TEXCUBE_ARRAY_SRV1,
    },
};

const IID_ID3D10ShaderResourceView1_Value = Guid.initString("9b7e4c87-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10ShaderResourceView1 = &IID_ID3D10ShaderResourceView1_Value;
pub const ID3D10ShaderResourceView1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D10ShaderResourceView.VTable,
        GetDesc1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderResourceView1,
                pDesc: ?*D3D10_SHADER_RESOURCE_VIEW_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID3D10ShaderResourceView1,
                pDesc: ?*D3D10_SHADER_RESOURCE_VIEW_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10ShaderResourceView.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderResourceView1_GetDesc1(self: *const T, pDesc: ?*D3D10_SHADER_RESOURCE_VIEW_DESC1) callconv(.Inline) void {
            return @ptrCast(*const ID3D10ShaderResourceView1.VTable, self.vtable).GetDesc1(@ptrCast(*const ID3D10ShaderResourceView1, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_STANDARD_MULTISAMPLE_QUALITY_LEVELS = enum(i32) {
    STANDARD_MULTISAMPLE_PATTERN = -1,
    CENTER_MULTISAMPLE_PATTERN = -2,
};
pub const D3D10_STANDARD_MULTISAMPLE_PATTERN = D3D10_STANDARD_MULTISAMPLE_QUALITY_LEVELS.STANDARD_MULTISAMPLE_PATTERN;
pub const D3D10_CENTER_MULTISAMPLE_PATTERN = D3D10_STANDARD_MULTISAMPLE_QUALITY_LEVELS.CENTER_MULTISAMPLE_PATTERN;

const IID_ID3D10Device1_Value = Guid.initString("9b7e4c8f-342c-4106-a19f-4f2704f689f0");
pub const IID_ID3D10Device1 = &IID_ID3D10Device1_Value;
pub const ID3D10Device1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D10Device.VTable,
        CreateShaderResourceView1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device1,
                pResource: ?*ID3D10Resource,
                pDesc: ?*const D3D10_SHADER_RESOURCE_VIEW_DESC1,
                ppSRView: ?*?*ID3D10ShaderResourceView1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device1,
                pResource: ?*ID3D10Resource,
                pDesc: ?*const D3D10_SHADER_RESOURCE_VIEW_DESC1,
                ppSRView: ?*?*ID3D10ShaderResourceView1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBlendState1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device1,
                pBlendStateDesc: ?*const D3D10_BLEND_DESC1,
                ppBlendState: ?*?*ID3D10BlendState1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10Device1,
                pBlendStateDesc: ?*const D3D10_BLEND_DESC1,
                ppBlendState: ?*?*ID3D10BlendState1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeatureLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10Device1,
            ) callconv(@import("std").os.windows.WINAPI) D3D10_FEATURE_LEVEL1,
            else => *const fn(
                self: *const ID3D10Device1,
            ) callconv(@import("std").os.windows.WINAPI) D3D10_FEATURE_LEVEL1,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D10Device.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device1_CreateShaderResourceView1(self: *const T, pResource: ?*ID3D10Resource, pDesc: ?*const D3D10_SHADER_RESOURCE_VIEW_DESC1, ppSRView: ?*?*ID3D10ShaderResourceView1) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device1.VTable, self.vtable).CreateShaderResourceView1(@ptrCast(*const ID3D10Device1, self), pResource, pDesc, ppSRView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device1_CreateBlendState1(self: *const T, pBlendStateDesc: ?*const D3D10_BLEND_DESC1, ppBlendState: ?*?*ID3D10BlendState1) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10Device1.VTable, self.vtable).CreateBlendState1(@ptrCast(*const ID3D10Device1, self), pBlendStateDesc, ppBlendState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10Device1_GetFeatureLevel(self: *const T) callconv(.Inline) D3D10_FEATURE_LEVEL1 {
            return @ptrCast(*const ID3D10Device1.VTable, self.vtable).GetFeatureLevel(@ptrCast(*const ID3D10Device1, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D10_SHADER_DEBUG_REGTYPE = enum(i32) {
    @"0_SHADER_DEBUG_REG_INPUT" = 0,
    @"0_SHADER_DEBUG_REG_OUTPUT" = 1,
    @"0_SHADER_DEBUG_REG_CBUFFER" = 2,
    @"0_SHADER_DEBUG_REG_TBUFFER" = 3,
    @"0_SHADER_DEBUG_REG_TEMP" = 4,
    @"0_SHADER_DEBUG_REG_TEMPARRAY" = 5,
    @"0_SHADER_DEBUG_REG_TEXTURE" = 6,
    @"0_SHADER_DEBUG_REG_SAMPLER" = 7,
    @"0_SHADER_DEBUG_REG_IMMEDIATECBUFFER" = 8,
    @"0_SHADER_DEBUG_REG_LITERAL" = 9,
    @"0_SHADER_DEBUG_REG_UNUSED" = 10,
    @"1_SHADER_DEBUG_REG_INTERFACE_POINTERS" = 11,
    @"1_SHADER_DEBUG_REG_UAV" = 12,
    @"0_SHADER_DEBUG_REG_FORCE_DWORD" = 2147483647,
};
pub const D3D10_SHADER_DEBUG_REG_INPUT = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_INPUT";
pub const D3D10_SHADER_DEBUG_REG_OUTPUT = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_OUTPUT";
pub const D3D10_SHADER_DEBUG_REG_CBUFFER = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_CBUFFER";
pub const D3D10_SHADER_DEBUG_REG_TBUFFER = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_TBUFFER";
pub const D3D10_SHADER_DEBUG_REG_TEMP = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_TEMP";
pub const D3D10_SHADER_DEBUG_REG_TEMPARRAY = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_TEMPARRAY";
pub const D3D10_SHADER_DEBUG_REG_TEXTURE = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_TEXTURE";
pub const D3D10_SHADER_DEBUG_REG_SAMPLER = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_SAMPLER";
pub const D3D10_SHADER_DEBUG_REG_IMMEDIATECBUFFER = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_IMMEDIATECBUFFER";
pub const D3D10_SHADER_DEBUG_REG_LITERAL = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_LITERAL";
pub const D3D10_SHADER_DEBUG_REG_UNUSED = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_UNUSED";
pub const D3D11_SHADER_DEBUG_REG_INTERFACE_POINTERS = D3D10_SHADER_DEBUG_REGTYPE.@"1_SHADER_DEBUG_REG_INTERFACE_POINTERS";
pub const D3D11_SHADER_DEBUG_REG_UAV = D3D10_SHADER_DEBUG_REGTYPE.@"1_SHADER_DEBUG_REG_UAV";
pub const D3D10_SHADER_DEBUG_REG_FORCE_DWORD = D3D10_SHADER_DEBUG_REGTYPE.@"0_SHADER_DEBUG_REG_FORCE_DWORD";

pub const D3D10_SHADER_DEBUG_SCOPETYPE = enum(i32) {
    GLOBAL = 0,
    BLOCK = 1,
    FORLOOP = 2,
    STRUCT = 3,
    FUNC_PARAMS = 4,
    STATEBLOCK = 5,
    NAMESPACE = 6,
    ANNOTATION = 7,
    FORCE_DWORD = 2147483647,
};
pub const D3D10_SHADER_DEBUG_SCOPE_GLOBAL = D3D10_SHADER_DEBUG_SCOPETYPE.GLOBAL;
pub const D3D10_SHADER_DEBUG_SCOPE_BLOCK = D3D10_SHADER_DEBUG_SCOPETYPE.BLOCK;
pub const D3D10_SHADER_DEBUG_SCOPE_FORLOOP = D3D10_SHADER_DEBUG_SCOPETYPE.FORLOOP;
pub const D3D10_SHADER_DEBUG_SCOPE_STRUCT = D3D10_SHADER_DEBUG_SCOPETYPE.STRUCT;
pub const D3D10_SHADER_DEBUG_SCOPE_FUNC_PARAMS = D3D10_SHADER_DEBUG_SCOPETYPE.FUNC_PARAMS;
pub const D3D10_SHADER_DEBUG_SCOPE_STATEBLOCK = D3D10_SHADER_DEBUG_SCOPETYPE.STATEBLOCK;
pub const D3D10_SHADER_DEBUG_SCOPE_NAMESPACE = D3D10_SHADER_DEBUG_SCOPETYPE.NAMESPACE;
pub const D3D10_SHADER_DEBUG_SCOPE_ANNOTATION = D3D10_SHADER_DEBUG_SCOPETYPE.ANNOTATION;
pub const D3D10_SHADER_DEBUG_SCOPE_FORCE_DWORD = D3D10_SHADER_DEBUG_SCOPETYPE.FORCE_DWORD;

pub const D3D10_SHADER_DEBUG_VARTYPE = enum(i32) {
    VARIABLE = 0,
    FUNCTION = 1,
    FORCE_DWORD = 2147483647,
};
pub const D3D10_SHADER_DEBUG_VAR_VARIABLE = D3D10_SHADER_DEBUG_VARTYPE.VARIABLE;
pub const D3D10_SHADER_DEBUG_VAR_FUNCTION = D3D10_SHADER_DEBUG_VARTYPE.FUNCTION;
pub const D3D10_SHADER_DEBUG_VAR_FORCE_DWORD = D3D10_SHADER_DEBUG_VARTYPE.FORCE_DWORD;

pub const D3D10_SHADER_DEBUG_TOKEN_INFO = extern struct {
    File: u32,
    Line: u32,
    Column: u32,
    TokenLength: u32,
    TokenId: u32,
};

pub const D3D10_SHADER_DEBUG_VAR_INFO = extern struct {
    TokenId: u32,
    Type: D3D_SHADER_VARIABLE_TYPE,
    Register: u32,
    Component: u32,
    ScopeVar: u32,
    ScopeVarOffset: u32,
};

pub const D3D10_SHADER_DEBUG_INPUT_INFO = extern struct {
    Var: u32,
    InitialRegisterSet: D3D10_SHADER_DEBUG_REGTYPE,
    InitialBank: u32,
    InitialRegister: u32,
    InitialComponent: u32,
    InitialValue: u32,
};

pub const D3D10_SHADER_DEBUG_SCOPEVAR_INFO = extern struct {
    TokenId: u32,
    VarType: D3D10_SHADER_DEBUG_VARTYPE,
    Class: D3D_SHADER_VARIABLE_CLASS,
    Rows: u32,
    Columns: u32,
    StructMemberScope: u32,
    uArrayIndices: u32,
    ArrayElements: u32,
    ArrayStrides: u32,
    uVariables: u32,
    uFirstVariable: u32,
};

pub const D3D10_SHADER_DEBUG_SCOPE_INFO = extern struct {
    ScopeType: D3D10_SHADER_DEBUG_SCOPETYPE,
    Name: u32,
    uNameLen: u32,
    uVariables: u32,
    VariableData: u32,
};

pub const D3D10_SHADER_DEBUG_OUTPUTVAR = extern struct {
    Var: u32,
    uValueMin: u32,
    uValueMax: u32,
    iValueMin: i32,
    iValueMax: i32,
    fValueMin: f32,
    fValueMax: f32,
    bNaNPossible: BOOL,
    bInfPossible: BOOL,
};

pub const D3D10_SHADER_DEBUG_OUTPUTREG_INFO = extern struct {
    OutputRegisterSet: D3D10_SHADER_DEBUG_REGTYPE,
    OutputReg: u32,
    TempArrayReg: u32,
    OutputComponents: [4]u32,
    OutputVars: [4]D3D10_SHADER_DEBUG_OUTPUTVAR,
    IndexReg: u32,
    IndexComp: u32,
};

pub const D3D10_SHADER_DEBUG_INST_INFO = extern struct {
    Id: u32,
    Opcode: u32,
    uOutputs: u32,
    pOutputs: [2]D3D10_SHADER_DEBUG_OUTPUTREG_INFO,
    TokenId: u32,
    NestingLevel: u32,
    Scopes: u32,
    ScopeInfo: u32,
    AccessedVars: u32,
    AccessedVarsInfo: u32,
};

pub const D3D10_SHADER_DEBUG_FILE_INFO = extern struct {
    FileName: u32,
    FileNameLen: u32,
    FileData: u32,
    FileLen: u32,
};

pub const D3D10_SHADER_DEBUG_INFO = extern struct {
    Size: u32,
    Creator: u32,
    EntrypointName: u32,
    ShaderTarget: u32,
    CompileFlags: u32,
    Files: u32,
    FileInfo: u32,
    Instructions: u32,
    InstructionInfo: u32,
    Variables: u32,
    VariableInfo: u32,
    InputVariables: u32,
    InputVariableInfo: u32,
    Tokens: u32,
    TokenInfo: u32,
    Scopes: u32,
    ScopeInfo: u32,
    ScopeVariables: u32,
    ScopeVariableInfo: u32,
    UintOffset: u32,
    StringOffset: u32,
};

const IID_ID3D10ShaderReflection1_Value = Guid.initString("c3457783-a846-47ce-9520-cea6f66e7447");
pub const IID_ID3D10ShaderReflection1 = &IID_ID3D10ShaderReflection1_Value;
pub const ID3D10ShaderReflection1 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                pDesc: ?*D3D10_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                pDesc: ?*D3D10_SHADER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantBufferByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionConstantBuffer,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionConstantBuffer,
        },
        GetConstantBufferByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionConstantBuffer,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionConstantBuffer,
        },
        GetResourceBindingDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                ResourceIndex: u32,
                pDesc: ?*D3D10_SHADER_INPUT_BIND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                ResourceIndex: u32,
                pDesc: ?*D3D10_SHADER_INPUT_BIND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputParameterDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                ParameterIndex: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                ParameterIndex: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputParameterDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                ParameterIndex: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                ParameterIndex: u32,
                pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVariableByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionVariable,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*ID3D10ShaderReflectionVariable,
        },
        GetResourceBindingDescByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                Name: ?[*:0]const u8,
                pDesc: ?*D3D10_SHADER_INPUT_BIND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                Name: ?[*:0]const u8,
                pDesc: ?*D3D10_SHADER_INPUT_BIND_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMovInstructionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMovcInstructionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionInstructionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBitwiseInstructionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGSInputPrimitive: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                pPrim: ?*D3D_PRIMITIVE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                pPrim: ?*D3D_PRIMITIVE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsLevel9Shader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                pbLevel9Shader: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                pbLevel9Shader: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSampleFrequencyShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID3D10ShaderReflection1,
                pbSampleFrequency: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID3D10ShaderReflection1,
                pbSampleFrequency: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetDesc(self: *const T, pDesc: ?*D3D10_SHADER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D10ShaderReflection1, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetConstantBufferByIndex(self: *const T, Index: u32) callconv(.Inline) ?*ID3D10ShaderReflectionConstantBuffer {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetConstantBufferByIndex(@ptrCast(*const ID3D10ShaderReflection1, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetConstantBufferByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10ShaderReflectionConstantBuffer {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetConstantBufferByName(@ptrCast(*const ID3D10ShaderReflection1, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetResourceBindingDesc(self: *const T, ResourceIndex: u32, pDesc: ?*D3D10_SHADER_INPUT_BIND_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetResourceBindingDesc(@ptrCast(*const ID3D10ShaderReflection1, self), ResourceIndex, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetInputParameterDesc(self: *const T, ParameterIndex: u32, pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetInputParameterDesc(@ptrCast(*const ID3D10ShaderReflection1, self), ParameterIndex, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetOutputParameterDesc(self: *const T, ParameterIndex: u32, pDesc: ?*D3D10_SIGNATURE_PARAMETER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetOutputParameterDesc(@ptrCast(*const ID3D10ShaderReflection1, self), ParameterIndex, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetVariableByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) ?*ID3D10ShaderReflectionVariable {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetVariableByName(@ptrCast(*const ID3D10ShaderReflection1, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetResourceBindingDescByName(self: *const T, Name: ?[*:0]const u8, pDesc: ?*D3D10_SHADER_INPUT_BIND_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetResourceBindingDescByName(@ptrCast(*const ID3D10ShaderReflection1, self), Name, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetMovInstructionCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetMovInstructionCount(@ptrCast(*const ID3D10ShaderReflection1, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetMovcInstructionCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetMovcInstructionCount(@ptrCast(*const ID3D10ShaderReflection1, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetConversionInstructionCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetConversionInstructionCount(@ptrCast(*const ID3D10ShaderReflection1, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetBitwiseInstructionCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetBitwiseInstructionCount(@ptrCast(*const ID3D10ShaderReflection1, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_GetGSInputPrimitive(self: *const T, pPrim: ?*D3D_PRIMITIVE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).GetGSInputPrimitive(@ptrCast(*const ID3D10ShaderReflection1, self), pPrim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_IsLevel9Shader(self: *const T, pbLevel9Shader: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).IsLevel9Shader(@ptrCast(*const ID3D10ShaderReflection1, self), pbLevel9Shader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D10ShaderReflection1_IsSampleFrequencyShader(self: *const T, pbSampleFrequency: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D10ShaderReflection1.VTable, self.vtable).IsSampleFrequencyShader(@ptrCast(*const ID3D10ShaderReflection1, self), pbSampleFrequency);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PFN_D3D10_CREATE_DEVICE1 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?*IDXGIAdapter,
        param1: D3D10_DRIVER_TYPE,
        param2: ?HINSTANCE,
        param3: u32,
        param4: D3D10_FEATURE_LEVEL1,
        param5: u32,
        param6: ?*?*ID3D10Device1,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        param0: ?*IDXGIAdapter,
        param1: D3D10_DRIVER_TYPE,
        param2: ?HINSTANCE,
        param3: u32,
        param4: D3D10_FEATURE_LEVEL1,
        param5: u32,
        param6: ?*?*ID3D10Device1,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PFN_D3D10_CREATE_DEVICE_AND_SWAP_CHAIN1 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?*IDXGIAdapter,
        param1: D3D10_DRIVER_TYPE,
        param2: ?HINSTANCE,
        param3: u32,
        param4: D3D10_FEATURE_LEVEL1,
        param5: u32,
        param6: ?*DXGI_SWAP_CHAIN_DESC,
        param7: ?*?*IDXGISwapChain,
        param8: ?*?*ID3D10Device1,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        param0: ?*IDXGIAdapter,
        param1: D3D10_DRIVER_TYPE,
        param2: ?HINSTANCE,
        param3: u32,
        param4: D3D10_FEATURE_LEVEL1,
        param5: u32,
        param6: ?*DXGI_SWAP_CHAIN_DESC,
        param7: ?*?*IDXGISwapChain,
        param8: ?*?*ID3D10Device1,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;


//--------------------------------------------------------------------------------
// Section: Functions (29)
//--------------------------------------------------------------------------------
pub extern "d3d10" fn D3D10CreateDevice(
    pAdapter: ?*IDXGIAdapter,
    DriverType: D3D10_DRIVER_TYPE,
    Software: ?HINSTANCE,
    Flags: u32,
    SDKVersion: u32,
    ppDevice: ?*?*ID3D10Device,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10CreateDeviceAndSwapChain(
    pAdapter: ?*IDXGIAdapter,
    DriverType: D3D10_DRIVER_TYPE,
    Software: ?HINSTANCE,
    Flags: u32,
    SDKVersion: u32,
    pSwapChainDesc: ?*DXGI_SWAP_CHAIN_DESC,
    ppSwapChain: ?*?*IDXGISwapChain,
    ppDevice: ?*?*ID3D10Device,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10CreateBlob(
    NumBytes: usize,
    ppBuffer: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10CompileShader(
    // TODO: what to do with BytesParamIndex 1?
    pSrcData: ?[*:0]const u8,
    SrcDataSize: usize,
    pFileName: ?[*:0]const u8,
    pDefines: ?*const D3D_SHADER_MACRO,
    pInclude: ?*ID3DInclude,
    pFunctionName: ?[*:0]const u8,
    pProfile: ?[*:0]const u8,
    Flags: u32,
    ppShader: ?*?*ID3DBlob,
    ppErrorMsgs: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10DisassembleShader(
    // TODO: what to do with BytesParamIndex 1?
    pShader: ?*const anyopaque,
    BytecodeLength: usize,
    EnableColorCode: BOOL,
    pComments: ?[*:0]const u8,
    ppDisassembly: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10GetPixelShaderProfile(
    pDevice: ?*ID3D10Device,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "d3d10" fn D3D10GetVertexShaderProfile(
    pDevice: ?*ID3D10Device,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "d3d10" fn D3D10GetGeometryShaderProfile(
    pDevice: ?*ID3D10Device,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "d3d10" fn D3D10ReflectShader(
    // TODO: what to do with BytesParamIndex 1?
    pShaderBytecode: ?*const anyopaque,
    BytecodeLength: usize,
    ppReflector: ?*?*ID3D10ShaderReflection,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10PreprocessShader(
    // TODO: what to do with BytesParamIndex 1?
    pSrcData: ?[*:0]const u8,
    SrcDataSize: usize,
    pFileName: ?[*:0]const u8,
    pDefines: ?*const D3D_SHADER_MACRO,
    pInclude: ?*ID3DInclude,
    ppShaderText: ?*?*ID3DBlob,
    ppErrorMsgs: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10GetInputSignatureBlob(
    // TODO: what to do with BytesParamIndex 1?
    pShaderBytecode: ?*const anyopaque,
    BytecodeLength: usize,
    ppSignatureBlob: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10GetOutputSignatureBlob(
    // TODO: what to do with BytesParamIndex 1?
    pShaderBytecode: ?*const anyopaque,
    BytecodeLength: usize,
    ppSignatureBlob: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10GetInputAndOutputSignatureBlob(
    // TODO: what to do with BytesParamIndex 1?
    pShaderBytecode: ?*const anyopaque,
    BytecodeLength: usize,
    ppSignatureBlob: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10GetShaderDebugInfo(
    // TODO: what to do with BytesParamIndex 1?
    pShaderBytecode: ?*const anyopaque,
    BytecodeLength: usize,
    ppDebugInfo: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10StateBlockMaskUnion(
    pA: ?*D3D10_STATE_BLOCK_MASK,
    pB: ?*D3D10_STATE_BLOCK_MASK,
    pResult: ?*D3D10_STATE_BLOCK_MASK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10StateBlockMaskIntersect(
    pA: ?*D3D10_STATE_BLOCK_MASK,
    pB: ?*D3D10_STATE_BLOCK_MASK,
    pResult: ?*D3D10_STATE_BLOCK_MASK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10StateBlockMaskDifference(
    pA: ?*D3D10_STATE_BLOCK_MASK,
    pB: ?*D3D10_STATE_BLOCK_MASK,
    pResult: ?*D3D10_STATE_BLOCK_MASK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10StateBlockMaskEnableCapture(
    pMask: ?*D3D10_STATE_BLOCK_MASK,
    StateType: D3D10_DEVICE_STATE_TYPES,
    RangeStart: u32,
    RangeLength: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10StateBlockMaskDisableCapture(
    pMask: ?*D3D10_STATE_BLOCK_MASK,
    StateType: D3D10_DEVICE_STATE_TYPES,
    RangeStart: u32,
    RangeLength: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10StateBlockMaskEnableAll(
    pMask: ?*D3D10_STATE_BLOCK_MASK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10StateBlockMaskDisableAll(
    pMask: ?*D3D10_STATE_BLOCK_MASK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10StateBlockMaskGetSetting(
    pMask: ?*D3D10_STATE_BLOCK_MASK,
    StateType: D3D10_DEVICE_STATE_TYPES,
    Entry: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "d3d10" fn D3D10CreateStateBlock(
    pDevice: ?*ID3D10Device,
    pStateBlockMask: ?*D3D10_STATE_BLOCK_MASK,
    ppStateBlock: ?*?*ID3D10StateBlock,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10CompileEffectFromMemory(
    // TODO: what to do with BytesParamIndex 1?
    pData: ?*anyopaque,
    DataLength: usize,
    pSrcFileName: ?[*:0]const u8,
    pDefines: ?*const D3D_SHADER_MACRO,
    pInclude: ?*ID3DInclude,
    HLSLFlags: u32,
    FXFlags: u32,
    ppCompiledEffect: ?*?*ID3DBlob,
    ppErrors: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10CreateEffectFromMemory(
    // TODO: what to do with BytesParamIndex 1?
    pData: ?*anyopaque,
    DataLength: usize,
    FXFlags: u32,
    pDevice: ?*ID3D10Device,
    pEffectPool: ?*ID3D10EffectPool,
    ppEffect: ?*?*ID3D10Effect,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10CreateEffectPoolFromMemory(
    // TODO: what to do with BytesParamIndex 1?
    pData: ?*anyopaque,
    DataLength: usize,
    FXFlags: u32,
    pDevice: ?*ID3D10Device,
    ppEffectPool: ?*?*ID3D10EffectPool,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10" fn D3D10DisassembleEffect(
    pEffect: ?*ID3D10Effect,
    EnableColorCode: BOOL,
    ppDisassembly: ?*?*ID3DBlob,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10_1" fn D3D10CreateDevice1(
    pAdapter: ?*IDXGIAdapter,
    DriverType: D3D10_DRIVER_TYPE,
    Software: ?HINSTANCE,
    Flags: u32,
    HardwareLevel: D3D10_FEATURE_LEVEL1,
    SDKVersion: u32,
    ppDevice: ?*?*ID3D10Device1,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d10_1" fn D3D10CreateDeviceAndSwapChain1(
    pAdapter: ?*IDXGIAdapter,
    DriverType: D3D10_DRIVER_TYPE,
    Software: ?HINSTANCE,
    Flags: u32,
    HardwareLevel: D3D10_FEATURE_LEVEL1,
    SDKVersion: u32,
    pSwapChainDesc: ?*DXGI_SWAP_CHAIN_DESC,
    ppSwapChain: ?*?*IDXGISwapChain,
    ppDevice: ?*?*ID3D10Device1,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (26)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const D3D_CBUFFER_TYPE = @import("../graphics/direct3d.zig").D3D_CBUFFER_TYPE;
const D3D_NAME = @import("../graphics/direct3d.zig").D3D_NAME;
const D3D_PRIMITIVE = @import("../graphics/direct3d.zig").D3D_PRIMITIVE;
const D3D_PRIMITIVE_TOPOLOGY = @import("../graphics/direct3d.zig").D3D_PRIMITIVE_TOPOLOGY;
const D3D_REGISTER_COMPONENT_TYPE = @import("../graphics/direct3d.zig").D3D_REGISTER_COMPONENT_TYPE;
const D3D_RESOURCE_RETURN_TYPE = @import("../graphics/direct3d.zig").D3D_RESOURCE_RETURN_TYPE;
const D3D_SHADER_INPUT_TYPE = @import("../graphics/direct3d.zig").D3D_SHADER_INPUT_TYPE;
const D3D_SHADER_MACRO = @import("../graphics/direct3d.zig").D3D_SHADER_MACRO;
const D3D_SHADER_VARIABLE_CLASS = @import("../graphics/direct3d.zig").D3D_SHADER_VARIABLE_CLASS;
const D3D_SHADER_VARIABLE_TYPE = @import("../graphics/direct3d.zig").D3D_SHADER_VARIABLE_TYPE;
const D3D_SRV_DIMENSION = @import("../graphics/direct3d.zig").D3D_SRV_DIMENSION;
const DXGI_FORMAT = @import("../graphics/dxgi/common.zig").DXGI_FORMAT;
const DXGI_SAMPLE_DESC = @import("../graphics/dxgi/common.zig").DXGI_SAMPLE_DESC;
const DXGI_SWAP_CHAIN_DESC = @import("../graphics/dxgi.zig").DXGI_SWAP_CHAIN_DESC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const ID3DBlob = @import("../graphics/direct3d.zig").ID3DBlob;
const ID3DInclude = @import("../graphics/direct3d.zig").ID3DInclude;
const IDXGIAdapter = @import("../graphics/dxgi.zig").IDXGIAdapter;
const IDXGISwapChain = @import("../graphics/dxgi.zig").IDXGISwapChain;
const IUnknown = @import("../system/com.zig").IUnknown;
const PSTR = @import("../foundation.zig").PSTR;
const RECT = @import("../foundation.zig").RECT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFN_D3D10_CREATE_DEVICE1")) { _ = PFN_D3D10_CREATE_DEVICE1; }
    if (@hasDecl(@This(), "PFN_D3D10_CREATE_DEVICE_AND_SWAP_CHAIN1")) { _ = PFN_D3D10_CREATE_DEVICE_AND_SWAP_CHAIN1; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
