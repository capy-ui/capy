//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (70)
//--------------------------------------------------------------------------------
pub const DXGI_USAGE_SHADER_INPUT = @as(u32, 16);
pub const DXGI_USAGE_RENDER_TARGET_OUTPUT = @as(u32, 32);
pub const DXGI_USAGE_BACK_BUFFER = @as(u32, 64);
pub const DXGI_USAGE_SHARED = @as(u32, 128);
pub const DXGI_USAGE_READ_ONLY = @as(u32, 256);
pub const DXGI_USAGE_DISCARD_ON_PRESENT = @as(u32, 512);
pub const DXGI_USAGE_UNORDERED_ACCESS = @as(u32, 1024);
pub const DXGI_MAP_READ = @as(u32, 1);
pub const DXGI_MAP_WRITE = @as(u32, 2);
pub const DXGI_MAP_DISCARD = @as(u32, 4);
pub const DXGI_ENUM_MODES_INTERLACED = @as(u32, 1);
pub const DXGI_ENUM_MODES_SCALING = @as(u32, 2);
pub const DXGI_MAX_SWAP_CHAIN_BUFFERS = @as(u32, 16);
pub const DXGI_PRESENT_TEST = @as(u32, 1);
pub const DXGI_PRESENT_DO_NOT_SEQUENCE = @as(u32, 2);
pub const DXGI_PRESENT_RESTART = @as(u32, 4);
pub const DXGI_PRESENT_DO_NOT_WAIT = @as(u32, 8);
pub const DXGI_PRESENT_STEREO_PREFER_RIGHT = @as(u32, 16);
pub const DXGI_PRESENT_STEREO_TEMPORARY_MONO = @as(u32, 32);
pub const DXGI_PRESENT_RESTRICT_TO_OUTPUT = @as(u32, 64);
pub const DXGI_PRESENT_USE_DURATION = @as(u32, 256);
pub const DXGI_PRESENT_ALLOW_TEARING = @as(u32, 512);
pub const DXGI_MWA_NO_WINDOW_CHANGES = @as(u32, 1);
pub const DXGI_MWA_NO_ALT_ENTER = @as(u32, 2);
pub const DXGI_MWA_NO_PRINT_SCREEN = @as(u32, 4);
pub const DXGI_MWA_VALID = @as(u32, 7);
pub const DXGI_ENUM_MODES_STEREO = @as(u32, 4);
pub const DXGI_ENUM_MODES_DISABLED_STEREO = @as(u32, 8);
pub const DXGI_SHARED_RESOURCE_READ = @as(u32, 2147483648);
pub const DXGI_SHARED_RESOURCE_WRITE = @as(u32, 1);
pub const DXGI_DEBUG_BINARY_VERSION = @as(u32, 1);
pub const DXGI_DEBUG_ALL = Guid.initString("e48ae283-da80-490b-87e6-43e9a9cfda08");
pub const DXGI_DEBUG_DX = Guid.initString("35cdd7fc-13b2-421d-a5d7-7e4451287d64");
pub const DXGI_DEBUG_DXGI = Guid.initString("25cddaa4-b1c6-47e1-ac3e-98875b5a2e2a");
pub const DXGI_DEBUG_APP = Guid.initString("06cd6e01-4219-4ebd-8709-27ed23360c62");
pub const DXGI_INFO_QUEUE_MESSAGE_ID_STRING_FROM_APPLICATION = @as(u32, 0);
pub const DXGI_INFO_QUEUE_DEFAULT_MESSAGE_COUNT_LIMIT = @as(u32, 1024);
pub const DXGI_CREATE_FACTORY_DEBUG = @as(u32, 1);
pub const DXGI_ERROR_INVALID_CALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270527));
pub const DXGI_ERROR_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270526));
pub const DXGI_ERROR_MORE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270525));
pub const DXGI_ERROR_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270524));
pub const DXGI_ERROR_DEVICE_REMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270523));
pub const DXGI_ERROR_DEVICE_HUNG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270522));
pub const DXGI_ERROR_DEVICE_RESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270521));
pub const DXGI_ERROR_WAS_STILL_DRAWING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270518));
pub const DXGI_ERROR_FRAME_STATISTICS_DISJOINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270517));
pub const DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270516));
pub const DXGI_ERROR_DRIVER_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270496));
pub const DXGI_ERROR_NONEXCLUSIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270495));
pub const DXGI_ERROR_NOT_CURRENTLY_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270494));
pub const DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270493));
pub const DXGI_ERROR_REMOTE_OUTOFMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270492));
pub const DXGI_ERROR_ACCESS_LOST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270490));
pub const DXGI_ERROR_WAIT_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270489));
pub const DXGI_ERROR_SESSION_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270488));
pub const DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270487));
pub const DXGI_ERROR_CANNOT_PROTECT_CONTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270486));
pub const DXGI_ERROR_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270485));
pub const DXGI_ERROR_NAME_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270484));
pub const DXGI_ERROR_SDK_COMPONENT_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270483));
pub const DXGI_ERROR_NOT_CURRENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270482));
pub const DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270480));
pub const DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270479));
pub const DXGI_ERROR_NON_COMPOSITED_UI = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270478));
pub const DXGI_ERROR_MODE_CHANGE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270491));
pub const DXGI_ERROR_CACHE_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270477));
pub const DXGI_ERROR_CACHE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270476));
pub const DXGI_ERROR_CACHE_HASH_COLLISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270475));
pub const DXGI_ERROR_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270474));

//--------------------------------------------------------------------------------
// Section: Types (106)
//--------------------------------------------------------------------------------
pub const DXGI_RGBA = extern struct {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
};

pub const DXGI_RESOURCE_PRIORITY = enum(u32) {
    MINIMUM = 671088640,
    LOW = 1342177280,
    NORMAL = 2013265920,
    HIGH = 2684354560,
    MAXIMUM = 3355443200,
};
pub const DXGI_RESOURCE_PRIORITY_MINIMUM = DXGI_RESOURCE_PRIORITY.MINIMUM;
pub const DXGI_RESOURCE_PRIORITY_LOW = DXGI_RESOURCE_PRIORITY.LOW;
pub const DXGI_RESOURCE_PRIORITY_NORMAL = DXGI_RESOURCE_PRIORITY.NORMAL;
pub const DXGI_RESOURCE_PRIORITY_HIGH = DXGI_RESOURCE_PRIORITY.HIGH;
pub const DXGI_RESOURCE_PRIORITY_MAXIMUM = DXGI_RESOURCE_PRIORITY.MAXIMUM;

pub const DXGI_FRAME_STATISTICS = extern struct {
    PresentCount: u32,
    PresentRefreshCount: u32,
    SyncRefreshCount: u32,
    SyncQPCTime: LARGE_INTEGER,
    SyncGPUTime: LARGE_INTEGER,
};

pub const DXGI_MAPPED_RECT = extern struct {
    Pitch: i32,
    pBits: ?*u8,
};

pub const DXGI_ADAPTER_DESC = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
};

pub const DXGI_OUTPUT_DESC = extern struct {
    DeviceName: [32]u16,
    DesktopCoordinates: RECT,
    AttachedToDesktop: BOOL,
    Rotation: DXGI_MODE_ROTATION,
    Monitor: ?HMONITOR,
};

pub const DXGI_SHARED_RESOURCE = extern struct {
    Handle: ?HANDLE,
};

pub const DXGI_RESIDENCY = enum(i32) {
    FULLY_RESIDENT = 1,
    RESIDENT_IN_SHARED_MEMORY = 2,
    EVICTED_TO_DISK = 3,
};
pub const DXGI_RESIDENCY_FULLY_RESIDENT = DXGI_RESIDENCY.FULLY_RESIDENT;
pub const DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY = DXGI_RESIDENCY.RESIDENT_IN_SHARED_MEMORY;
pub const DXGI_RESIDENCY_EVICTED_TO_DISK = DXGI_RESIDENCY.EVICTED_TO_DISK;

pub const DXGI_SURFACE_DESC = extern struct {
    Width: u32,
    Height: u32,
    Format: DXGI_FORMAT,
    SampleDesc: DXGI_SAMPLE_DESC,
};

pub const DXGI_SWAP_EFFECT = enum(i32) {
    DISCARD = 0,
    SEQUENTIAL = 1,
    FLIP_SEQUENTIAL = 3,
    FLIP_DISCARD = 4,
};
pub const DXGI_SWAP_EFFECT_DISCARD = DXGI_SWAP_EFFECT.DISCARD;
pub const DXGI_SWAP_EFFECT_SEQUENTIAL = DXGI_SWAP_EFFECT.SEQUENTIAL;
pub const DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL = DXGI_SWAP_EFFECT.FLIP_SEQUENTIAL;
pub const DXGI_SWAP_EFFECT_FLIP_DISCARD = DXGI_SWAP_EFFECT.FLIP_DISCARD;

pub const DXGI_SWAP_CHAIN_FLAG = enum(i32) {
    NONPREROTATED = 1,
    ALLOW_MODE_SWITCH = 2,
    GDI_COMPATIBLE = 4,
    RESTRICTED_CONTENT = 8,
    RESTRICT_SHARED_RESOURCE_DRIVER = 16,
    DISPLAY_ONLY = 32,
    FRAME_LATENCY_WAITABLE_OBJECT = 64,
    FOREGROUND_LAYER = 128,
    FULLSCREEN_VIDEO = 256,
    YUV_VIDEO = 512,
    HW_PROTECTED = 1024,
    ALLOW_TEARING = 2048,
    RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS = 4096,
};
pub const DXGI_SWAP_CHAIN_FLAG_NONPREROTATED = DXGI_SWAP_CHAIN_FLAG.NONPREROTATED;
pub const DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH = DXGI_SWAP_CHAIN_FLAG.ALLOW_MODE_SWITCH;
pub const DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE = DXGI_SWAP_CHAIN_FLAG.GDI_COMPATIBLE;
pub const DXGI_SWAP_CHAIN_FLAG_RESTRICTED_CONTENT = DXGI_SWAP_CHAIN_FLAG.RESTRICTED_CONTENT;
pub const DXGI_SWAP_CHAIN_FLAG_RESTRICT_SHARED_RESOURCE_DRIVER = DXGI_SWAP_CHAIN_FLAG.RESTRICT_SHARED_RESOURCE_DRIVER;
pub const DXGI_SWAP_CHAIN_FLAG_DISPLAY_ONLY = DXGI_SWAP_CHAIN_FLAG.DISPLAY_ONLY;
pub const DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT = DXGI_SWAP_CHAIN_FLAG.FRAME_LATENCY_WAITABLE_OBJECT;
pub const DXGI_SWAP_CHAIN_FLAG_FOREGROUND_LAYER = DXGI_SWAP_CHAIN_FLAG.FOREGROUND_LAYER;
pub const DXGI_SWAP_CHAIN_FLAG_FULLSCREEN_VIDEO = DXGI_SWAP_CHAIN_FLAG.FULLSCREEN_VIDEO;
pub const DXGI_SWAP_CHAIN_FLAG_YUV_VIDEO = DXGI_SWAP_CHAIN_FLAG.YUV_VIDEO;
pub const DXGI_SWAP_CHAIN_FLAG_HW_PROTECTED = DXGI_SWAP_CHAIN_FLAG.HW_PROTECTED;
pub const DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING = DXGI_SWAP_CHAIN_FLAG.ALLOW_TEARING;
pub const DXGI_SWAP_CHAIN_FLAG_RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS = DXGI_SWAP_CHAIN_FLAG.RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS;

pub const DXGI_SWAP_CHAIN_DESC = extern struct {
    BufferDesc: DXGI_MODE_DESC,
    SampleDesc: DXGI_SAMPLE_DESC,
    BufferUsage: u32,
    BufferCount: u32,
    OutputWindow: ?HWND,
    Windowed: BOOL,
    SwapEffect: DXGI_SWAP_EFFECT,
    Flags: u32,
};

const IID_IDXGIObject_Value = Guid.initString("aec22fb8-76f3-4639-9be0-28eb43a67a2e");
pub const IID_IDXGIObject = &IID_IDXGIObject_Value;
pub const IDXGIObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPrivateData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIObject,
                Name: ?*const Guid,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIObject,
                Name: ?*const Guid,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPrivateDataInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIObject,
                Name: ?*const Guid,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIObject,
                Name: ?*const Guid,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrivateData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIObject,
                Name: ?*const Guid,
                pDataSize: ?*u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIObject,
                Name: ?*const Guid,
                pDataSize: ?*u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIObject,
                riid: ?*const Guid,
                ppParent: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIObject,
                riid: ?*const Guid,
                ppParent: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIObject_SetPrivateData(self: *const T, Name: ?*const Guid, DataSize: u32, pData: ?*const anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIObject.VTable, self.vtable).SetPrivateData(@ptrCast(*const IDXGIObject, self), Name, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIObject_SetPrivateDataInterface(self: *const T, Name: ?*const Guid, pUnknown: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIObject.VTable, self.vtable).SetPrivateDataInterface(@ptrCast(*const IDXGIObject, self), Name, pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIObject_GetPrivateData(self: *const T, Name: ?*const Guid, pDataSize: ?*u32, pData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIObject.VTable, self.vtable).GetPrivateData(@ptrCast(*const IDXGIObject, self), Name, pDataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIObject_GetParent(self: *const T, riid: ?*const Guid, ppParent: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIObject.VTable, self.vtable).GetParent(@ptrCast(*const IDXGIObject, self), riid, ppParent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIDeviceSubObject_Value = Guid.initString("3d3e0379-f9de-4d58-bb6c-18d62992f1a6");
pub const IID_IDXGIDeviceSubObject = &IID_IDXGIDeviceSubObject_Value;
pub const IDXGIDeviceSubObject = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDeviceSubObject,
                riid: ?*const Guid,
                ppDevice: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDeviceSubObject,
                riid: ?*const Guid,
                ppDevice: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDeviceSubObject_GetDevice(self: *const T, riid: ?*const Guid, ppDevice: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDeviceSubObject.VTable, self.vtable).GetDevice(@ptrCast(*const IDXGIDeviceSubObject, self), riid, ppDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIResource_Value = Guid.initString("035f3ab4-482e-4e50-b41f-8a7f8bd8960b");
pub const IID_IDXGIResource = &IID_IDXGIResource_Value;
pub const IDXGIResource = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        GetSharedHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIResource,
                pSharedHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIResource,
                pSharedHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUsage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIResource,
                pUsage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIResource,
                pUsage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEvictionPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIResource,
                EvictionPriority: DXGI_RESOURCE_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIResource,
                EvictionPriority: DXGI_RESOURCE_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEvictionPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIResource,
                pEvictionPriority: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIResource,
                pEvictionPriority: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource_GetSharedHandle(self: *const T, pSharedHandle: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource.VTable, self.vtable).GetSharedHandle(@ptrCast(*const IDXGIResource, self), pSharedHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource_GetUsage(self: *const T, pUsage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource.VTable, self.vtable).GetUsage(@ptrCast(*const IDXGIResource, self), pUsage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource_SetEvictionPriority(self: *const T, EvictionPriority: DXGI_RESOURCE_PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource.VTable, self.vtable).SetEvictionPriority(@ptrCast(*const IDXGIResource, self), EvictionPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource_GetEvictionPriority(self: *const T, pEvictionPriority: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource.VTable, self.vtable).GetEvictionPriority(@ptrCast(*const IDXGIResource, self), pEvictionPriority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIKeyedMutex_Value = Guid.initString("9d8e1289-d7b3-465f-8126-250e349af85d");
pub const IID_IDXGIKeyedMutex = &IID_IDXGIKeyedMutex_Value;
pub const IDXGIKeyedMutex = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        AcquireSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIKeyedMutex,
                Key: u64,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIKeyedMutex,
                Key: u64,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIKeyedMutex,
                Key: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIKeyedMutex,
                Key: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIKeyedMutex_AcquireSync(self: *const T, Key: u64, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIKeyedMutex.VTable, self.vtable).AcquireSync(@ptrCast(*const IDXGIKeyedMutex, self), Key, dwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIKeyedMutex_ReleaseSync(self: *const T, Key: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIKeyedMutex.VTable, self.vtable).ReleaseSync(@ptrCast(*const IDXGIKeyedMutex, self), Key);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGISurface_Value = Guid.initString("cafcb56c-6ac3-4889-bf47-9e23bbd260ec");
pub const IID_IDXGISurface = &IID_IDXGISurface_Value;
pub const IDXGISurface = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISurface,
                pDesc: ?*DXGI_SURFACE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISurface,
                pDesc: ?*DXGI_SURFACE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Map: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISurface,
                pLockedRect: ?*DXGI_MAPPED_RECT,
                MapFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISurface,
                pLockedRect: ?*DXGI_MAPPED_RECT,
                MapFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface_GetDesc(self: *const T, pDesc: ?*DXGI_SURFACE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGISurface, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface_Map(self: *const T, pLockedRect: ?*DXGI_MAPPED_RECT, MapFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface.VTable, self.vtable).Map(@ptrCast(*const IDXGISurface, self), pLockedRect, MapFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface_Unmap(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface.VTable, self.vtable).Unmap(@ptrCast(*const IDXGISurface, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGISurface1_Value = Guid.initString("4ae63092-6327-4c1b-80ae-bfe12ea32b86");
pub const IID_IDXGISurface1 = &IID_IDXGISurface1_Value;
pub const IDXGISurface1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISurface.VTable,
        GetDC: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISurface1,
                Discard: BOOL,
                phdc: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISurface1,
                Discard: BOOL,
                phdc: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseDC: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISurface1,
                pDirtyRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISurface1,
                pDirtyRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISurface.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface1_GetDC(self: *const T, Discard: BOOL, phdc: ?*?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface1.VTable, self.vtable).GetDC(@ptrCast(*const IDXGISurface1, self), Discard, phdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface1_ReleaseDC(self: *const T, pDirtyRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface1.VTable, self.vtable).ReleaseDC(@ptrCast(*const IDXGISurface1, self), pDirtyRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIAdapter_Value = Guid.initString("2411e7e1-12ac-4ccf-bd14-9798e8534dc0");
pub const IID_IDXGIAdapter = &IID_IDXGIAdapter_Value;
pub const IDXGIAdapter = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        EnumOutputs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter,
                Output: u32,
                ppOutput: ?*?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter,
                Output: u32,
                ppOutput: ?*?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter,
                pDesc: ?*DXGI_ADAPTER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter,
                pDesc: ?*DXGI_ADAPTER_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckInterfaceSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter,
                InterfaceName: ?*const Guid,
                pUMDVersion: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter,
                InterfaceName: ?*const Guid,
                pUMDVersion: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter_EnumOutputs(self: *const T, Output: u32, ppOutput: ?*?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter.VTable, self.vtable).EnumOutputs(@ptrCast(*const IDXGIAdapter, self), Output, ppOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter_GetDesc(self: *const T, pDesc: ?*DXGI_ADAPTER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGIAdapter, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter_CheckInterfaceSupport(self: *const T, InterfaceName: ?*const Guid, pUMDVersion: ?*LARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter.VTable, self.vtable).CheckInterfaceSupport(@ptrCast(*const IDXGIAdapter, self), InterfaceName, pUMDVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIOutput_Value = Guid.initString("ae02eedb-c735-4690-8d52-5a8dc20213aa");
pub const IID_IDXGIOutput = &IID_IDXGIOutput_Value;
pub const IDXGIOutput = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                pDesc: ?*DXGI_OUTPUT_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                pDesc: ?*DXGI_OUTPUT_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayModeList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                EnumFormat: DXGI_FORMAT,
                Flags: u32,
                pNumModes: ?*u32,
                pDesc: ?[*]DXGI_MODE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                EnumFormat: DXGI_FORMAT,
                Flags: u32,
                pNumModes: ?*u32,
                pDesc: ?[*]DXGI_MODE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindClosestMatchingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                pModeToMatch: ?*const DXGI_MODE_DESC,
                pClosestMatch: ?*DXGI_MODE_DESC,
                pConcernedDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                pModeToMatch: ?*const DXGI_MODE_DESC,
                pClosestMatch: ?*DXGI_MODE_DESC,
                pConcernedDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForVBlank: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TakeOwnership: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                pDevice: ?*IUnknown,
                Exclusive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                pDevice: ?*IUnknown,
                Exclusive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseOwnership: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetGammaControlCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                pGammaCaps: ?*DXGI_GAMMA_CONTROL_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                pGammaCaps: ?*DXGI_GAMMA_CONTROL_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGammaControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                pArray: ?*const DXGI_GAMMA_CONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                pArray: ?*const DXGI_GAMMA_CONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGammaControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                pArray: ?*DXGI_GAMMA_CONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                pArray: ?*DXGI_GAMMA_CONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDisplaySurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                pScanoutSurface: ?*IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                pScanoutSurface: ?*IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplaySurfaceData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                pDestination: ?*IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                pDestination: ?*IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput,
                pStats: ?*DXGI_FRAME_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput,
                pStats: ?*DXGI_FRAME_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetDesc(self: *const T, pDesc: ?*DXGI_OUTPUT_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGIOutput, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetDisplayModeList(self: *const T, EnumFormat: DXGI_FORMAT, Flags: u32, pNumModes: ?*u32, pDesc: ?[*]DXGI_MODE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetDisplayModeList(@ptrCast(*const IDXGIOutput, self), EnumFormat, Flags, pNumModes, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_FindClosestMatchingMode(self: *const T, pModeToMatch: ?*const DXGI_MODE_DESC, pClosestMatch: ?*DXGI_MODE_DESC, pConcernedDevice: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).FindClosestMatchingMode(@ptrCast(*const IDXGIOutput, self), pModeToMatch, pClosestMatch, pConcernedDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_WaitForVBlank(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).WaitForVBlank(@ptrCast(*const IDXGIOutput, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_TakeOwnership(self: *const T, pDevice: ?*IUnknown, Exclusive: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).TakeOwnership(@ptrCast(*const IDXGIOutput, self), pDevice, Exclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_ReleaseOwnership(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).ReleaseOwnership(@ptrCast(*const IDXGIOutput, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetGammaControlCapabilities(self: *const T, pGammaCaps: ?*DXGI_GAMMA_CONTROL_CAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetGammaControlCapabilities(@ptrCast(*const IDXGIOutput, self), pGammaCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_SetGammaControl(self: *const T, pArray: ?*const DXGI_GAMMA_CONTROL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).SetGammaControl(@ptrCast(*const IDXGIOutput, self), pArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetGammaControl(self: *const T, pArray: ?*DXGI_GAMMA_CONTROL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetGammaControl(@ptrCast(*const IDXGIOutput, self), pArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_SetDisplaySurface(self: *const T, pScanoutSurface: ?*IDXGISurface) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).SetDisplaySurface(@ptrCast(*const IDXGIOutput, self), pScanoutSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetDisplaySurfaceData(self: *const T, pDestination: ?*IDXGISurface) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetDisplaySurfaceData(@ptrCast(*const IDXGIOutput, self), pDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetFrameStatistics(self: *const T, pStats: ?*DXGI_FRAME_STATISTICS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetFrameStatistics(@ptrCast(*const IDXGIOutput, self), pStats);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGISwapChain_Value = Guid.initString("310d36a0-d2e7-4c0a-aa04-6a9d23b8886a");
pub const IID_IDXGISwapChain = &IID_IDXGISwapChain_Value;
pub const IDXGISwapChain = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        Present: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                SyncInterval: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                SyncInterval: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                Buffer: u32,
                riid: ?*const Guid,
                ppSurface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                Buffer: u32,
                riid: ?*const Guid,
                ppSurface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFullscreenState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                Fullscreen: BOOL,
                pTarget: ?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                Fullscreen: BOOL,
                pTarget: ?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFullscreenState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                pFullscreen: ?*BOOL,
                ppTarget: ?*?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                pFullscreen: ?*BOOL,
                ppTarget: ?*?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                pDesc: ?*DXGI_SWAP_CHAIN_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                pDesc: ?*DXGI_SWAP_CHAIN_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResizeBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                BufferCount: u32,
                Width: u32,
                Height: u32,
                NewFormat: DXGI_FORMAT,
                SwapChainFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                BufferCount: u32,
                Width: u32,
                Height: u32,
                NewFormat: DXGI_FORMAT,
                SwapChainFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResizeTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                pNewTargetParameters: ?*const DXGI_MODE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                pNewTargetParameters: ?*const DXGI_MODE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContainingOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                ppOutput: ?*?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                ppOutput: ?*?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                pStats: ?*DXGI_FRAME_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                pStats: ?*DXGI_FRAME_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastPresentCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain,
                pLastPresentCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain,
                pLastPresentCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_Present(self: *const T, SyncInterval: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).Present(@ptrCast(*const IDXGISwapChain, self), SyncInterval, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetBuffer(self: *const T, Buffer: u32, riid: ?*const Guid, ppSurface: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetBuffer(@ptrCast(*const IDXGISwapChain, self), Buffer, riid, ppSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_SetFullscreenState(self: *const T, Fullscreen: BOOL, pTarget: ?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).SetFullscreenState(@ptrCast(*const IDXGISwapChain, self), Fullscreen, pTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetFullscreenState(self: *const T, pFullscreen: ?*BOOL, ppTarget: ?*?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetFullscreenState(@ptrCast(*const IDXGISwapChain, self), pFullscreen, ppTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetDesc(self: *const T, pDesc: ?*DXGI_SWAP_CHAIN_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGISwapChain, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_ResizeBuffers(self: *const T, BufferCount: u32, Width: u32, Height: u32, NewFormat: DXGI_FORMAT, SwapChainFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).ResizeBuffers(@ptrCast(*const IDXGISwapChain, self), BufferCount, Width, Height, NewFormat, SwapChainFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_ResizeTarget(self: *const T, pNewTargetParameters: ?*const DXGI_MODE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).ResizeTarget(@ptrCast(*const IDXGISwapChain, self), pNewTargetParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetContainingOutput(self: *const T, ppOutput: ?*?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetContainingOutput(@ptrCast(*const IDXGISwapChain, self), ppOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetFrameStatistics(self: *const T, pStats: ?*DXGI_FRAME_STATISTICS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetFrameStatistics(@ptrCast(*const IDXGISwapChain, self), pStats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetLastPresentCount(self: *const T, pLastPresentCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetLastPresentCount(@ptrCast(*const IDXGISwapChain, self), pLastPresentCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIFactory_Value = Guid.initString("7b7166ec-21c7-44ae-b21a-c9ae321ae369");
pub const IID_IDXGIFactory = &IID_IDXGIFactory_Value;
pub const IDXGIFactory = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        EnumAdapters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory,
                Adapter: u32,
                ppAdapter: ?*?*IDXGIAdapter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory,
                Adapter: u32,
                ppAdapter: ?*?*IDXGIAdapter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MakeWindowAssociation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory,
                WindowHandle: ?HWND,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory,
                WindowHandle: ?HWND,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowAssociation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory,
                pWindowHandle: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory,
                pWindowHandle: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSwapChain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory,
                pDevice: ?*IUnknown,
                pDesc: ?*DXGI_SWAP_CHAIN_DESC,
                ppSwapChain: ?*?*IDXGISwapChain,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory,
                pDevice: ?*IUnknown,
                pDesc: ?*DXGI_SWAP_CHAIN_DESC,
                ppSwapChain: ?*?*IDXGISwapChain,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSoftwareAdapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory,
                Module: ?HINSTANCE,
                ppAdapter: ?*?*IDXGIAdapter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory,
                Module: ?HINSTANCE,
                ppAdapter: ?*?*IDXGIAdapter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_EnumAdapters(self: *const T, Adapter: u32, ppAdapter: ?*?*IDXGIAdapter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).EnumAdapters(@ptrCast(*const IDXGIFactory, self), Adapter, ppAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_MakeWindowAssociation(self: *const T, WindowHandle: ?HWND, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).MakeWindowAssociation(@ptrCast(*const IDXGIFactory, self), WindowHandle, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_GetWindowAssociation(self: *const T, pWindowHandle: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).GetWindowAssociation(@ptrCast(*const IDXGIFactory, self), pWindowHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_CreateSwapChain(self: *const T, pDevice: ?*IUnknown, pDesc: ?*DXGI_SWAP_CHAIN_DESC, ppSwapChain: ?*?*IDXGISwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).CreateSwapChain(@ptrCast(*const IDXGIFactory, self), pDevice, pDesc, ppSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_CreateSoftwareAdapter(self: *const T, Module: ?HINSTANCE, ppAdapter: ?*?*IDXGIAdapter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).CreateSoftwareAdapter(@ptrCast(*const IDXGIFactory, self), Module, ppAdapter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIDevice_Value = Guid.initString("54ec77fa-1377-44e6-8c32-88fd5f44c84c");
pub const IID_IDXGIDevice = &IID_IDXGIDevice_Value;
pub const IDXGIDevice = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetAdapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice,
                pAdapter: ?*?*IDXGIAdapter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice,
                pAdapter: ?*?*IDXGIAdapter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice,
                pDesc: ?*const DXGI_SURFACE_DESC,
                NumSurfaces: u32,
                Usage: u32,
                pSharedResource: ?*const DXGI_SHARED_RESOURCE,
                ppSurface: [*]?*IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice,
                pDesc: ?*const DXGI_SURFACE_DESC,
                NumSurfaces: u32,
                Usage: u32,
                pSharedResource: ?*const DXGI_SHARED_RESOURCE,
                ppSurface: [*]?*IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryResourceResidency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice,
                ppResources: [*]?*IUnknown,
                pResidencyStatus: [*]DXGI_RESIDENCY,
                NumResources: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice,
                ppResources: [*]?*IUnknown,
                pResidencyStatus: [*]DXGI_RESIDENCY,
                NumResources: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGPUThreadPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice,
                Priority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice,
                Priority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGPUThreadPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice,
                pPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice,
                pPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_GetAdapter(self: *const T, pAdapter: ?*?*IDXGIAdapter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).GetAdapter(@ptrCast(*const IDXGIDevice, self), pAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_CreateSurface(self: *const T, pDesc: ?*const DXGI_SURFACE_DESC, NumSurfaces: u32, Usage: u32, pSharedResource: ?*const DXGI_SHARED_RESOURCE, ppSurface: [*]?*IDXGISurface) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).CreateSurface(@ptrCast(*const IDXGIDevice, self), pDesc, NumSurfaces, Usage, pSharedResource, ppSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_QueryResourceResidency(self: *const T, ppResources: [*]?*IUnknown, pResidencyStatus: [*]DXGI_RESIDENCY, NumResources: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).QueryResourceResidency(@ptrCast(*const IDXGIDevice, self), ppResources, pResidencyStatus, NumResources);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_SetGPUThreadPriority(self: *const T, Priority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).SetGPUThreadPriority(@ptrCast(*const IDXGIDevice, self), Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_GetGPUThreadPriority(self: *const T, pPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).GetGPUThreadPriority(@ptrCast(*const IDXGIDevice, self), pPriority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_ADAPTER_FLAG = enum(u32) {
    NONE = 0,
    REMOTE = 1,
    SOFTWARE = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        REMOTE: u1 = 0,
        SOFTWARE: u1 = 0,
    }) DXGI_ADAPTER_FLAG {
        return @intToEnum(DXGI_ADAPTER_FLAG,
              (if (o.NONE == 1) @enumToInt(DXGI_ADAPTER_FLAG.NONE) else 0)
            | (if (o.REMOTE == 1) @enumToInt(DXGI_ADAPTER_FLAG.REMOTE) else 0)
            | (if (o.SOFTWARE == 1) @enumToInt(DXGI_ADAPTER_FLAG.SOFTWARE) else 0)
        );
    }
};
pub const DXGI_ADAPTER_FLAG_NONE = DXGI_ADAPTER_FLAG.NONE;
pub const DXGI_ADAPTER_FLAG_REMOTE = DXGI_ADAPTER_FLAG.REMOTE;
pub const DXGI_ADAPTER_FLAG_SOFTWARE = DXGI_ADAPTER_FLAG.SOFTWARE;

pub const DXGI_ADAPTER_DESC1 = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
    Flags: u32,
};

pub const DXGI_DISPLAY_COLOR_SPACE = extern struct {
    PrimaryCoordinates: [16]f32,
    WhitePoints: [32]f32,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGIFactory1_Value = Guid.initString("770aae78-f26f-4dba-a829-253c83d1b387");
pub const IID_IDXGIFactory1 = &IID_IDXGIFactory1_Value;
pub const IDXGIFactory1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory.VTable,
        EnumAdapters1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory1,
                Adapter: u32,
                ppAdapter: ?*?*IDXGIAdapter1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory1,
                Adapter: u32,
                ppAdapter: ?*?*IDXGIAdapter1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory1,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGIFactory1,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory1_EnumAdapters1(self: *const T, Adapter: u32, ppAdapter: ?*?*IDXGIAdapter1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory1.VTable, self.vtable).EnumAdapters1(@ptrCast(*const IDXGIFactory1, self), Adapter, ppAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory1_IsCurrent(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIFactory1.VTable, self.vtable).IsCurrent(@ptrCast(*const IDXGIFactory1, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGIAdapter1_Value = Guid.initString("29038f61-3839-4626-91fd-086879011a05");
pub const IID_IDXGIAdapter1 = &IID_IDXGIAdapter1_Value;
pub const IDXGIAdapter1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter.VTable,
        GetDesc1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter1,
                pDesc: ?*DXGI_ADAPTER_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter1,
                pDesc: ?*DXGI_ADAPTER_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIAdapter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter1_GetDesc1(self: *const T, pDesc: ?*DXGI_ADAPTER_DESC1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter1.VTable, self.vtable).GetDesc1(@ptrCast(*const IDXGIAdapter1, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGIDevice1_Value = Guid.initString("77db970f-6276-48ba-ba28-070143b4392c");
pub const IID_IDXGIDevice1 = &IID_IDXGIDevice1_Value;
pub const IDXGIDevice1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice.VTable,
        SetMaximumFrameLatency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice1,
                MaxLatency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice1,
                MaxLatency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaximumFrameLatency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice1,
                pMaxLatency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice1,
                pMaxLatency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice1_SetMaximumFrameLatency(self: *const T, MaxLatency: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice1.VTable, self.vtable).SetMaximumFrameLatency(@ptrCast(*const IDXGIDevice1, self), MaxLatency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice1_GetMaximumFrameLatency(self: *const T, pMaxLatency: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice1.VTable, self.vtable).GetMaximumFrameLatency(@ptrCast(*const IDXGIDevice1, self), pMaxLatency);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIDisplayControl_Value = Guid.initString("ea9dbf1a-c88e-4486-854a-98aa0138f30c");
pub const IID_IDXGIDisplayControl = &IID_IDXGIDisplayControl_Value;
pub const IDXGIDisplayControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsStereoEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDisplayControl,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGIDisplayControl,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        SetStereoEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDisplayControl,
                enabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIDisplayControl,
                enabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDisplayControl_IsStereoEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIDisplayControl.VTable, self.vtable).IsStereoEnabled(@ptrCast(*const IDXGIDisplayControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDisplayControl_SetStereoEnabled(self: *const T, enabled: BOOL) callconv(.Inline) void {
            return @ptrCast(*const IDXGIDisplayControl.VTable, self.vtable).SetStereoEnabled(@ptrCast(*const IDXGIDisplayControl, self), enabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OUTDUPL_MOVE_RECT = extern struct {
    SourcePoint: POINT,
    DestinationRect: RECT,
};

pub const DXGI_OUTDUPL_DESC = extern struct {
    ModeDesc: DXGI_MODE_DESC,
    Rotation: DXGI_MODE_ROTATION,
    DesktopImageInSystemMemory: BOOL,
};

pub const DXGI_OUTDUPL_POINTER_POSITION = extern struct {
    Position: POINT,
    Visible: BOOL,
};

pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE = enum(i32) {
    MONOCHROME = 1,
    COLOR = 2,
    MASKED_COLOR = 4,
};
pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROME = DXGI_OUTDUPL_POINTER_SHAPE_TYPE.MONOCHROME;
pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR = DXGI_OUTDUPL_POINTER_SHAPE_TYPE.COLOR;
pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR = DXGI_OUTDUPL_POINTER_SHAPE_TYPE.MASKED_COLOR;

pub const DXGI_OUTDUPL_POINTER_SHAPE_INFO = extern struct {
    Type: u32,
    Width: u32,
    Height: u32,
    Pitch: u32,
    HotSpot: POINT,
};

pub const DXGI_OUTDUPL_FRAME_INFO = extern struct {
    LastPresentTime: LARGE_INTEGER,
    LastMouseUpdateTime: LARGE_INTEGER,
    AccumulatedFrames: u32,
    RectsCoalesced: BOOL,
    ProtectedContentMaskedOut: BOOL,
    PointerPosition: DXGI_OUTDUPL_POINTER_POSITION,
    TotalMetadataBufferSize: u32,
    PointerShapeBufferSize: u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIOutputDuplication_Value = Guid.initString("191cfac3-a341-470d-b26e-a864f428319c");
pub const IID_IDXGIOutputDuplication = &IID_IDXGIOutputDuplication_Value;
pub const IDXGIOutputDuplication = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutputDuplication,
                pDesc: ?*DXGI_OUTDUPL_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIOutputDuplication,
                pDesc: ?*DXGI_OUTDUPL_DESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        AcquireNextFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutputDuplication,
                TimeoutInMilliseconds: u32,
                pFrameInfo: ?*DXGI_OUTDUPL_FRAME_INFO,
                ppDesktopResource: ?*?*IDXGIResource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutputDuplication,
                TimeoutInMilliseconds: u32,
                pFrameInfo: ?*DXGI_OUTDUPL_FRAME_INFO,
                ppDesktopResource: ?*?*IDXGIResource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameDirtyRects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutputDuplication,
                DirtyRectsBufferSize: u32,
                // TODO: what to do with BytesParamIndex 0?
                pDirtyRectsBuffer: ?*RECT,
                pDirtyRectsBufferSizeRequired: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutputDuplication,
                DirtyRectsBufferSize: u32,
                // TODO: what to do with BytesParamIndex 0?
                pDirtyRectsBuffer: ?*RECT,
                pDirtyRectsBufferSizeRequired: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameMoveRects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutputDuplication,
                MoveRectsBufferSize: u32,
                // TODO: what to do with BytesParamIndex 0?
                pMoveRectBuffer: ?*DXGI_OUTDUPL_MOVE_RECT,
                pMoveRectsBufferSizeRequired: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutputDuplication,
                MoveRectsBufferSize: u32,
                // TODO: what to do with BytesParamIndex 0?
                pMoveRectBuffer: ?*DXGI_OUTDUPL_MOVE_RECT,
                pMoveRectsBufferSizeRequired: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFramePointerShape: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutputDuplication,
                PointerShapeBufferSize: u32,
                // TODO: what to do with BytesParamIndex 0?
                pPointerShapeBuffer: ?*anyopaque,
                pPointerShapeBufferSizeRequired: ?*u32,
                pPointerShapeInfo: ?*DXGI_OUTDUPL_POINTER_SHAPE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutputDuplication,
                PointerShapeBufferSize: u32,
                // TODO: what to do with BytesParamIndex 0?
                pPointerShapeBuffer: ?*anyopaque,
                pPointerShapeBufferSizeRequired: ?*u32,
                pPointerShapeInfo: ?*DXGI_OUTDUPL_POINTER_SHAPE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapDesktopSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutputDuplication,
                pLockedRect: ?*DXGI_MAPPED_RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutputDuplication,
                pLockedRect: ?*DXGI_MAPPED_RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnMapDesktopSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutputDuplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutputDuplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutputDuplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutputDuplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_GetDesc(self: *const T, pDesc: ?*DXGI_OUTDUPL_DESC) callconv(.Inline) void {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGIOutputDuplication, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_AcquireNextFrame(self: *const T, TimeoutInMilliseconds: u32, pFrameInfo: ?*DXGI_OUTDUPL_FRAME_INFO, ppDesktopResource: ?*?*IDXGIResource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).AcquireNextFrame(@ptrCast(*const IDXGIOutputDuplication, self), TimeoutInMilliseconds, pFrameInfo, ppDesktopResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_GetFrameDirtyRects(self: *const T, DirtyRectsBufferSize: u32, pDirtyRectsBuffer: ?*RECT, pDirtyRectsBufferSizeRequired: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).GetFrameDirtyRects(@ptrCast(*const IDXGIOutputDuplication, self), DirtyRectsBufferSize, pDirtyRectsBuffer, pDirtyRectsBufferSizeRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_GetFrameMoveRects(self: *const T, MoveRectsBufferSize: u32, pMoveRectBuffer: ?*DXGI_OUTDUPL_MOVE_RECT, pMoveRectsBufferSizeRequired: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).GetFrameMoveRects(@ptrCast(*const IDXGIOutputDuplication, self), MoveRectsBufferSize, pMoveRectBuffer, pMoveRectsBufferSizeRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_GetFramePointerShape(self: *const T, PointerShapeBufferSize: u32, pPointerShapeBuffer: ?*anyopaque, pPointerShapeBufferSizeRequired: ?*u32, pPointerShapeInfo: ?*DXGI_OUTDUPL_POINTER_SHAPE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).GetFramePointerShape(@ptrCast(*const IDXGIOutputDuplication, self), PointerShapeBufferSize, pPointerShapeBuffer, pPointerShapeBufferSizeRequired, pPointerShapeInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_MapDesktopSurface(self: *const T, pLockedRect: ?*DXGI_MAPPED_RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).MapDesktopSurface(@ptrCast(*const IDXGIOutputDuplication, self), pLockedRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_UnMapDesktopSurface(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).UnMapDesktopSurface(@ptrCast(*const IDXGIOutputDuplication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_ReleaseFrame(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).ReleaseFrame(@ptrCast(*const IDXGIOutputDuplication, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGISurface2_Value = Guid.initString("aba496dd-b617-4cb8-a866-bc44d7eb1fa2");
pub const IID_IDXGISurface2 = &IID_IDXGISurface2_Value;
pub const IDXGISurface2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISurface1.VTable,
        GetResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISurface2,
                riid: ?*const Guid,
                ppParentResource: ?*?*anyopaque,
                pSubresourceIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISurface2,
                riid: ?*const Guid,
                ppParentResource: ?*?*anyopaque,
                pSubresourceIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISurface1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface2_GetResource(self: *const T, riid: ?*const Guid, ppParentResource: ?*?*anyopaque, pSubresourceIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface2.VTable, self.vtable).GetResource(@ptrCast(*const IDXGISurface2, self), riid, ppParentResource, pSubresourceIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIResource1_Value = Guid.initString("30961379-4609-4a41-998e-54fe567ee0c1");
pub const IID_IDXGIResource1 = &IID_IDXGIResource1_Value;
pub const IDXGIResource1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIResource.VTable,
        CreateSubresourceSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIResource1,
                index: u32,
                ppSurface: ?*?*IDXGISurface2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIResource1,
                index: u32,
                ppSurface: ?*?*IDXGISurface2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSharedHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIResource1,
                pAttributes: ?*const SECURITY_ATTRIBUTES,
                dwAccess: u32,
                lpName: ?[*:0]const u16,
                pHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIResource1,
                pAttributes: ?*const SECURITY_ATTRIBUTES,
                dwAccess: u32,
                lpName: ?[*:0]const u16,
                pHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIResource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource1_CreateSubresourceSurface(self: *const T, index: u32, ppSurface: ?*?*IDXGISurface2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource1.VTable, self.vtable).CreateSubresourceSurface(@ptrCast(*const IDXGIResource1, self), index, ppSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource1_CreateSharedHandle(self: *const T, pAttributes: ?*const SECURITY_ATTRIBUTES, dwAccess: u32, lpName: ?[*:0]const u16, pHandle: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource1.VTable, self.vtable).CreateSharedHandle(@ptrCast(*const IDXGIResource1, self), pAttributes, dwAccess, lpName, pHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OFFER_RESOURCE_PRIORITY = enum(i32) {
    LOW = 1,
    NORMAL = 2,
    HIGH = 3,
};
pub const DXGI_OFFER_RESOURCE_PRIORITY_LOW = DXGI_OFFER_RESOURCE_PRIORITY.LOW;
pub const DXGI_OFFER_RESOURCE_PRIORITY_NORMAL = DXGI_OFFER_RESOURCE_PRIORITY.NORMAL;
pub const DXGI_OFFER_RESOURCE_PRIORITY_HIGH = DXGI_OFFER_RESOURCE_PRIORITY.HIGH;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIDevice2_Value = Guid.initString("05008617-fbfd-4051-a790-144884b4f6a9");
pub const IID_IDXGIDevice2 = &IID_IDXGIDevice2_Value;
pub const IDXGIDevice2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice1.VTable,
        OfferResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice2,
                NumResources: u32,
                ppResources: [*]?*IDXGIResource,
                Priority: DXGI_OFFER_RESOURCE_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice2,
                NumResources: u32,
                ppResources: [*]?*IDXGIResource,
                Priority: DXGI_OFFER_RESOURCE_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReclaimResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice2,
                NumResources: u32,
                ppResources: [*]?*IDXGIResource,
                pDiscarded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice2,
                NumResources: u32,
                ppResources: [*]?*IDXGIResource,
                pDiscarded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnqueueSetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice2,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice2,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDevice1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice2_OfferResources(self: *const T, NumResources: u32, ppResources: [*]?*IDXGIResource, Priority: DXGI_OFFER_RESOURCE_PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice2.VTable, self.vtable).OfferResources(@ptrCast(*const IDXGIDevice2, self), NumResources, ppResources, Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice2_ReclaimResources(self: *const T, NumResources: u32, ppResources: [*]?*IDXGIResource, pDiscarded: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice2.VTable, self.vtable).ReclaimResources(@ptrCast(*const IDXGIDevice2, self), NumResources, ppResources, pDiscarded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice2_EnqueueSetEvent(self: *const T, hEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice2.VTable, self.vtable).EnqueueSetEvent(@ptrCast(*const IDXGIDevice2, self), hEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_MODE_DESC1 = extern struct {
    Width: u32,
    Height: u32,
    RefreshRate: DXGI_RATIONAL,
    Format: DXGI_FORMAT,
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER,
    Scaling: DXGI_MODE_SCALING,
    Stereo: BOOL,
};

pub const DXGI_SCALING = enum(i32) {
    STRETCH = 0,
    NONE = 1,
    ASPECT_RATIO_STRETCH = 2,
};
pub const DXGI_SCALING_STRETCH = DXGI_SCALING.STRETCH;
pub const DXGI_SCALING_NONE = DXGI_SCALING.NONE;
pub const DXGI_SCALING_ASPECT_RATIO_STRETCH = DXGI_SCALING.ASPECT_RATIO_STRETCH;

pub const DXGI_SWAP_CHAIN_DESC1 = extern struct {
    Width: u32,
    Height: u32,
    Format: DXGI_FORMAT,
    Stereo: BOOL,
    SampleDesc: DXGI_SAMPLE_DESC,
    BufferUsage: u32,
    BufferCount: u32,
    Scaling: DXGI_SCALING,
    SwapEffect: DXGI_SWAP_EFFECT,
    AlphaMode: DXGI_ALPHA_MODE,
    Flags: u32,
};

pub const DXGI_SWAP_CHAIN_FULLSCREEN_DESC = extern struct {
    RefreshRate: DXGI_RATIONAL,
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER,
    Scaling: DXGI_MODE_SCALING,
    Windowed: BOOL,
};

pub const DXGI_PRESENT_PARAMETERS = extern struct {
    DirtyRectsCount: u32,
    pDirtyRects: ?*RECT,
    pScrollRect: ?*RECT,
    pScrollOffset: ?*POINT,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGISwapChain1_Value = Guid.initString("790a45f7-0d42-4876-983a-0a55cfe6f4aa");
pub const IID_IDXGISwapChain1 = &IID_IDXGISwapChain1_Value;
pub const IDXGISwapChain1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain.VTable,
        GetDesc1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                pDesc: ?*DXGI_SWAP_CHAIN_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                pDesc: ?*DXGI_SWAP_CHAIN_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFullscreenDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                pDesc: ?*DXGI_SWAP_CHAIN_FULLSCREEN_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                pDesc: ?*DXGI_SWAP_CHAIN_FULLSCREEN_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHwnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                pHwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                pHwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCoreWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                refiid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                refiid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Present1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                SyncInterval: u32,
                PresentFlags: u32,
                pPresentParameters: ?*const DXGI_PRESENT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                SyncInterval: u32,
                PresentFlags: u32,
                pPresentParameters: ?*const DXGI_PRESENT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTemporaryMonoSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetRestrictToOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                ppRestrictToOutput: ?*?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                ppRestrictToOutput: ?*?*IDXGIOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                pColor: ?*const DXGI_RGBA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                pColor: ?*const DXGI_RGBA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                pColor: ?*DXGI_RGBA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                pColor: ?*DXGI_RGBA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                Rotation: DXGI_MODE_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                Rotation: DXGI_MODE_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain1,
                pRotation: ?*DXGI_MODE_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain1,
                pRotation: ?*DXGI_MODE_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISwapChain.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetDesc1(self: *const T, pDesc: ?*DXGI_SWAP_CHAIN_DESC1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetDesc1(@ptrCast(*const IDXGISwapChain1, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetFullscreenDesc(self: *const T, pDesc: ?*DXGI_SWAP_CHAIN_FULLSCREEN_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetFullscreenDesc(@ptrCast(*const IDXGISwapChain1, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetHwnd(self: *const T, pHwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetHwnd(@ptrCast(*const IDXGISwapChain1, self), pHwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetCoreWindow(self: *const T, refiid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetCoreWindow(@ptrCast(*const IDXGISwapChain1, self), refiid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_Present1(self: *const T, SyncInterval: u32, PresentFlags: u32, pPresentParameters: ?*const DXGI_PRESENT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).Present1(@ptrCast(*const IDXGISwapChain1, self), SyncInterval, PresentFlags, pPresentParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_IsTemporaryMonoSupported(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).IsTemporaryMonoSupported(@ptrCast(*const IDXGISwapChain1, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetRestrictToOutput(self: *const T, ppRestrictToOutput: ?*?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetRestrictToOutput(@ptrCast(*const IDXGISwapChain1, self), ppRestrictToOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_SetBackgroundColor(self: *const T, pColor: ?*const DXGI_RGBA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).SetBackgroundColor(@ptrCast(*const IDXGISwapChain1, self), pColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetBackgroundColor(self: *const T, pColor: ?*DXGI_RGBA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetBackgroundColor(@ptrCast(*const IDXGISwapChain1, self), pColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_SetRotation(self: *const T, Rotation: DXGI_MODE_ROTATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).SetRotation(@ptrCast(*const IDXGISwapChain1, self), Rotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetRotation(self: *const T, pRotation: ?*DXGI_MODE_ROTATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetRotation(@ptrCast(*const IDXGISwapChain1, self), pRotation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIFactory2_Value = Guid.initString("50c83a1c-e072-4c48-87b0-3630fa36a6d0");
pub const IID_IDXGIFactory2 = &IID_IDXGIFactory2_Value;
pub const IDXGIFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory1.VTable,
        IsWindowedStereoEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGIFactory2,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        CreateSwapChainForHwnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                pDevice: ?*IUnknown,
                hWnd: ?HWND,
                pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
                pFullscreenDesc: ?*const DXGI_SWAP_CHAIN_FULLSCREEN_DESC,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory2,
                pDevice: ?*IUnknown,
                hWnd: ?HWND,
                pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
                pFullscreenDesc: ?*const DXGI_SWAP_CHAIN_FULLSCREEN_DESC,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSwapChainForCoreWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                pDevice: ?*IUnknown,
                pWindow: ?*IUnknown,
                pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory2,
                pDevice: ?*IUnknown,
                pWindow: ?*IUnknown,
                pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSharedResourceAdapterLuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                hResource: ?HANDLE,
                pLuid: ?*LUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory2,
                hResource: ?HANDLE,
                pLuid: ?*LUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterStereoStatusWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                WindowHandle: ?HWND,
                wMsg: u32,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory2,
                WindowHandle: ?HWND,
                wMsg: u32,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterStereoStatusEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory2,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterStereoStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIFactory2,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        RegisterOcclusionStatusWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                WindowHandle: ?HWND,
                wMsg: u32,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory2,
                WindowHandle: ?HWND,
                wMsg: u32,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterOcclusionStatusEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory2,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterOcclusionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIFactory2,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateSwapChainForComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory2,
                pDevice: ?*IUnknown,
                pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory2,
                pDevice: ?*IUnknown,
                pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_IsWindowedStereoEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).IsWindowedStereoEnabled(@ptrCast(*const IDXGIFactory2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_CreateSwapChainForHwnd(self: *const T, pDevice: ?*IUnknown, hWnd: ?HWND, pDesc: ?*const DXGI_SWAP_CHAIN_DESC1, pFullscreenDesc: ?*const DXGI_SWAP_CHAIN_FULLSCREEN_DESC, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGISwapChain1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).CreateSwapChainForHwnd(@ptrCast(*const IDXGIFactory2, self), pDevice, hWnd, pDesc, pFullscreenDesc, pRestrictToOutput, ppSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_CreateSwapChainForCoreWindow(self: *const T, pDevice: ?*IUnknown, pWindow: ?*IUnknown, pDesc: ?*const DXGI_SWAP_CHAIN_DESC1, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGISwapChain1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).CreateSwapChainForCoreWindow(@ptrCast(*const IDXGIFactory2, self), pDevice, pWindow, pDesc, pRestrictToOutput, ppSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_GetSharedResourceAdapterLuid(self: *const T, hResource: ?HANDLE, pLuid: ?*LUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).GetSharedResourceAdapterLuid(@ptrCast(*const IDXGIFactory2, self), hResource, pLuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_RegisterStereoStatusWindow(self: *const T, WindowHandle: ?HWND, wMsg: u32, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).RegisterStereoStatusWindow(@ptrCast(*const IDXGIFactory2, self), WindowHandle, wMsg, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_RegisterStereoStatusEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).RegisterStereoStatusEvent(@ptrCast(*const IDXGIFactory2, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_UnregisterStereoStatus(self: *const T, dwCookie: u32) callconv(.Inline) void {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).UnregisterStereoStatus(@ptrCast(*const IDXGIFactory2, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_RegisterOcclusionStatusWindow(self: *const T, WindowHandle: ?HWND, wMsg: u32, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).RegisterOcclusionStatusWindow(@ptrCast(*const IDXGIFactory2, self), WindowHandle, wMsg, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_RegisterOcclusionStatusEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).RegisterOcclusionStatusEvent(@ptrCast(*const IDXGIFactory2, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_UnregisterOcclusionStatus(self: *const T, dwCookie: u32) callconv(.Inline) void {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).UnregisterOcclusionStatus(@ptrCast(*const IDXGIFactory2, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_CreateSwapChainForComposition(self: *const T, pDevice: ?*IUnknown, pDesc: ?*const DXGI_SWAP_CHAIN_DESC1, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGISwapChain1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).CreateSwapChainForComposition(@ptrCast(*const IDXGIFactory2, self), pDevice, pDesc, pRestrictToOutput, ppSwapChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_GRAPHICS_PREEMPTION_GRANULARITY = enum(i32) {
    DMA_BUFFER_BOUNDARY = 0,
    PRIMITIVE_BOUNDARY = 1,
    TRIANGLE_BOUNDARY = 2,
    PIXEL_BOUNDARY = 3,
    INSTRUCTION_BOUNDARY = 4,
};
pub const DXGI_GRAPHICS_PREEMPTION_DMA_BUFFER_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.DMA_BUFFER_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_PRIMITIVE_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.PRIMITIVE_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_TRIANGLE_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.TRIANGLE_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_PIXEL_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.PIXEL_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_INSTRUCTION_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.INSTRUCTION_BOUNDARY;

pub const DXGI_COMPUTE_PREEMPTION_GRANULARITY = enum(i32) {
    DMA_BUFFER_BOUNDARY = 0,
    DISPATCH_BOUNDARY = 1,
    THREAD_GROUP_BOUNDARY = 2,
    THREAD_BOUNDARY = 3,
    INSTRUCTION_BOUNDARY = 4,
};
pub const DXGI_COMPUTE_PREEMPTION_DMA_BUFFER_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.DMA_BUFFER_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_DISPATCH_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.DISPATCH_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_THREAD_GROUP_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.THREAD_GROUP_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_THREAD_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.THREAD_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_INSTRUCTION_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.INSTRUCTION_BOUNDARY;

pub const DXGI_ADAPTER_DESC2 = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
    Flags: u32,
    GraphicsPreemptionGranularity: DXGI_GRAPHICS_PREEMPTION_GRANULARITY,
    ComputePreemptionGranularity: DXGI_COMPUTE_PREEMPTION_GRANULARITY,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIAdapter2_Value = Guid.initString("0aa1ae0a-fa0e-4b84-8644-e05ff8e5acb5");
pub const IID_IDXGIAdapter2 = &IID_IDXGIAdapter2_Value;
pub const IDXGIAdapter2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter1.VTable,
        GetDesc2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter2,
                pDesc: ?*DXGI_ADAPTER_DESC2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter2,
                pDesc: ?*DXGI_ADAPTER_DESC2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIAdapter1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter2_GetDesc2(self: *const T, pDesc: ?*DXGI_ADAPTER_DESC2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter2.VTable, self.vtable).GetDesc2(@ptrCast(*const IDXGIAdapter2, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIOutput1_Value = Guid.initString("00cddea8-939b-4b83-a340-a685226666cc");
pub const IID_IDXGIOutput1 = &IID_IDXGIOutput1_Value;
pub const IDXGIOutput1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput.VTable,
        GetDisplayModeList1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput1,
                EnumFormat: DXGI_FORMAT,
                Flags: u32,
                pNumModes: ?*u32,
                pDesc: ?[*]DXGI_MODE_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput1,
                EnumFormat: DXGI_FORMAT,
                Flags: u32,
                pNumModes: ?*u32,
                pDesc: ?[*]DXGI_MODE_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindClosestMatchingMode1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput1,
                pModeToMatch: ?*const DXGI_MODE_DESC1,
                pClosestMatch: ?*DXGI_MODE_DESC1,
                pConcernedDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput1,
                pModeToMatch: ?*const DXGI_MODE_DESC1,
                pClosestMatch: ?*DXGI_MODE_DESC1,
                pConcernedDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplaySurfaceData1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput1,
                pDestination: ?*IDXGIResource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput1,
                pDestination: ?*IDXGIResource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DuplicateOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput1,
                pDevice: ?*IUnknown,
                ppOutputDuplication: ?*?*IDXGIOutputDuplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput1,
                pDevice: ?*IUnknown,
                ppOutputDuplication: ?*?*IDXGIOutputDuplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput1_GetDisplayModeList1(self: *const T, EnumFormat: DXGI_FORMAT, Flags: u32, pNumModes: ?*u32, pDesc: ?[*]DXGI_MODE_DESC1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput1.VTable, self.vtable).GetDisplayModeList1(@ptrCast(*const IDXGIOutput1, self), EnumFormat, Flags, pNumModes, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput1_FindClosestMatchingMode1(self: *const T, pModeToMatch: ?*const DXGI_MODE_DESC1, pClosestMatch: ?*DXGI_MODE_DESC1, pConcernedDevice: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput1.VTable, self.vtable).FindClosestMatchingMode1(@ptrCast(*const IDXGIOutput1, self), pModeToMatch, pClosestMatch, pConcernedDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput1_GetDisplaySurfaceData1(self: *const T, pDestination: ?*IDXGIResource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput1.VTable, self.vtable).GetDisplaySurfaceData1(@ptrCast(*const IDXGIOutput1, self), pDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput1_DuplicateOutput(self: *const T, pDevice: ?*IUnknown, ppOutputDuplication: ?*?*IDXGIOutputDuplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput1.VTable, self.vtable).DuplicateOutput(@ptrCast(*const IDXGIOutput1, self), pDevice, ppOutputDuplication);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIDevice3_Value = Guid.initString("6007896c-3244-4afd-bf18-a6d3beda5023");
pub const IID_IDXGIDevice3 = &IID_IDXGIDevice3_Value;
pub const IDXGIDevice3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice2.VTable,
        Trim: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice3,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIDevice3,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDevice2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice3_Trim(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGIDevice3.VTable, self.vtable).Trim(@ptrCast(*const IDXGIDevice3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_MATRIX_3X2_F = extern struct {
    _11: f32,
    _12: f32,
    _21: f32,
    _22: f32,
    _31: f32,
    _32: f32,
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGISwapChain2_Value = Guid.initString("a8be2ac4-199f-4946-b331-79599fb98de7");
pub const IID_IDXGISwapChain2 = &IID_IDXGISwapChain2_Value;
pub const IDXGISwapChain2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain1.VTable,
        SetSourceSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain2,
                Width: u32,
                Height: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain2,
                Width: u32,
                Height: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain2,
                pWidth: ?*u32,
                pHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain2,
                pWidth: ?*u32,
                pHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaximumFrameLatency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain2,
                MaxLatency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain2,
                MaxLatency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaximumFrameLatency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain2,
                pMaxLatency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain2,
                pMaxLatency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameLatencyWaitableObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain2,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
            else => *const fn(
                self: *const IDXGISwapChain2,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
        },
        SetMatrixTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain2,
                pMatrix: ?*const DXGI_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain2,
                pMatrix: ?*const DXGI_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatrixTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain2,
                pMatrix: ?*DXGI_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain2,
                pMatrix: ?*DXGI_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISwapChain1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_SetSourceSize(self: *const T, Width: u32, Height: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).SetSourceSize(@ptrCast(*const IDXGISwapChain2, self), Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_GetSourceSize(self: *const T, pWidth: ?*u32, pHeight: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).GetSourceSize(@ptrCast(*const IDXGISwapChain2, self), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_SetMaximumFrameLatency(self: *const T, MaxLatency: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).SetMaximumFrameLatency(@ptrCast(*const IDXGISwapChain2, self), MaxLatency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_GetMaximumFrameLatency(self: *const T, pMaxLatency: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).GetMaximumFrameLatency(@ptrCast(*const IDXGISwapChain2, self), pMaxLatency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_GetFrameLatencyWaitableObject(self: *const T) callconv(.Inline) ?HANDLE {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).GetFrameLatencyWaitableObject(@ptrCast(*const IDXGISwapChain2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_SetMatrixTransform(self: *const T, pMatrix: ?*const DXGI_MATRIX_3X2_F) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).SetMatrixTransform(@ptrCast(*const IDXGISwapChain2, self), pMatrix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_GetMatrixTransform(self: *const T, pMatrix: ?*DXGI_MATRIX_3X2_F) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).GetMatrixTransform(@ptrCast(*const IDXGISwapChain2, self), pMatrix);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIOutput2_Value = Guid.initString("595e39d1-2724-4663-99b1-da969de28364");
pub const IID_IDXGIOutput2 = &IID_IDXGIOutput2_Value;
pub const IDXGIOutput2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput1.VTable,
        SupportsOverlays: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput2,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGIOutput2,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput2_SupportsOverlays(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIOutput2.VTable, self.vtable).SupportsOverlays(@ptrCast(*const IDXGIOutput2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIFactory3_Value = Guid.initString("25483823-cd46-4c7d-86ca-47aa95b837bd");
pub const IID_IDXGIFactory3 = &IID_IDXGIFactory3_Value;
pub const IDXGIFactory3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory2.VTable,
        GetCreationFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory3,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDXGIFactory3,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory3_GetCreationFlags(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IDXGIFactory3.VTable, self.vtable).GetCreationFlags(@ptrCast(*const IDXGIFactory3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_DECODE_SWAP_CHAIN_DESC = extern struct {
    Flags: u32,
};

pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS = enum(i32) {
    NOMINAL_RANGE = 1,
    BT709 = 2,
    xvYCC = 4,
};
pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_NOMINAL_RANGE = DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS.NOMINAL_RANGE;
pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_BT709 = DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS.BT709;
pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_xvYCC = DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS.xvYCC;

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIDecodeSwapChain_Value = Guid.initString("2633066b-4514-4c7a-8fd8-12ea98059d18");
pub const IID_IDXGIDecodeSwapChain = &IID_IDXGIDecodeSwapChain_Value;
pub const IDXGIDecodeSwapChain = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PresentBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDecodeSwapChain,
                BufferToPresent: u32,
                SyncInterval: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDecodeSwapChain,
                BufferToPresent: u32,
                SyncInterval: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourceRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDecodeSwapChain,
                pRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDecodeSwapChain,
                pRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTargetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDecodeSwapChain,
                pRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDecodeSwapChain,
                pRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDestSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDecodeSwapChain,
                Width: u32,
                Height: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDecodeSwapChain,
                Width: u32,
                Height: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDecodeSwapChain,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDecodeSwapChain,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTargetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDecodeSwapChain,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDecodeSwapChain,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDestSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDecodeSwapChain,
                pWidth: ?*u32,
                pHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDecodeSwapChain,
                pWidth: ?*u32,
                pHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColorSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDecodeSwapChain,
                ColorSpace: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDecodeSwapChain,
                ColorSpace: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColorSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDecodeSwapChain,
            ) callconv(@import("std").os.windows.WINAPI) DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS,
            else => *const fn(
                self: *const IDXGIDecodeSwapChain,
            ) callconv(@import("std").os.windows.WINAPI) DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_PresentBuffer(self: *const T, BufferToPresent: u32, SyncInterval: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).PresentBuffer(@ptrCast(*const IDXGIDecodeSwapChain, self), BufferToPresent, SyncInterval, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_SetSourceRect(self: *const T, pRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).SetSourceRect(@ptrCast(*const IDXGIDecodeSwapChain, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_SetTargetRect(self: *const T, pRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).SetTargetRect(@ptrCast(*const IDXGIDecodeSwapChain, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_SetDestSize(self: *const T, Width: u32, Height: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).SetDestSize(@ptrCast(*const IDXGIDecodeSwapChain, self), Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_GetSourceRect(self: *const T, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).GetSourceRect(@ptrCast(*const IDXGIDecodeSwapChain, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_GetTargetRect(self: *const T, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).GetTargetRect(@ptrCast(*const IDXGIDecodeSwapChain, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_GetDestSize(self: *const T, pWidth: ?*u32, pHeight: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).GetDestSize(@ptrCast(*const IDXGIDecodeSwapChain, self), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_SetColorSpace(self: *const T, ColorSpace: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).SetColorSpace(@ptrCast(*const IDXGIDecodeSwapChain, self), ColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_GetColorSpace(self: *const T) callconv(.Inline) DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).GetColorSpace(@ptrCast(*const IDXGIDecodeSwapChain, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIFactoryMedia_Value = Guid.initString("41e7d1f2-a591-4f7b-a2e5-fa9c843e1c12");
pub const IID_IDXGIFactoryMedia = &IID_IDXGIFactoryMedia_Value;
pub const IDXGIFactoryMedia = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSwapChainForCompositionSurfaceHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactoryMedia,
                pDevice: ?*IUnknown,
                hSurface: ?HANDLE,
                pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactoryMedia,
                pDevice: ?*IUnknown,
                hSurface: ?HANDLE,
                pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGISwapChain1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDecodeSwapChainForCompositionSurfaceHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactoryMedia,
                pDevice: ?*IUnknown,
                hSurface: ?HANDLE,
                pDesc: ?*DXGI_DECODE_SWAP_CHAIN_DESC,
                pYuvDecodeBuffers: ?*IDXGIResource,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGIDecodeSwapChain,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactoryMedia,
                pDevice: ?*IUnknown,
                hSurface: ?HANDLE,
                pDesc: ?*DXGI_DECODE_SWAP_CHAIN_DESC,
                pYuvDecodeBuffers: ?*IDXGIResource,
                pRestrictToOutput: ?*IDXGIOutput,
                ppSwapChain: ?*?*IDXGIDecodeSwapChain,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactoryMedia_CreateSwapChainForCompositionSurfaceHandle(self: *const T, pDevice: ?*IUnknown, hSurface: ?HANDLE, pDesc: ?*const DXGI_SWAP_CHAIN_DESC1, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGISwapChain1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactoryMedia.VTable, self.vtable).CreateSwapChainForCompositionSurfaceHandle(@ptrCast(*const IDXGIFactoryMedia, self), pDevice, hSurface, pDesc, pRestrictToOutput, ppSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactoryMedia_CreateDecodeSwapChainForCompositionSurfaceHandle(self: *const T, pDevice: ?*IUnknown, hSurface: ?HANDLE, pDesc: ?*DXGI_DECODE_SWAP_CHAIN_DESC, pYuvDecodeBuffers: ?*IDXGIResource, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGIDecodeSwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactoryMedia.VTable, self.vtable).CreateDecodeSwapChainForCompositionSurfaceHandle(@ptrCast(*const IDXGIFactoryMedia, self), pDevice, hSurface, pDesc, pYuvDecodeBuffers, pRestrictToOutput, ppSwapChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_FRAME_PRESENTATION_MODE = enum(i32) {
    COMPOSED = 0,
    OVERLAY = 1,
    NONE = 2,
    COMPOSITION_FAILURE = 3,
};
pub const DXGI_FRAME_PRESENTATION_MODE_COMPOSED = DXGI_FRAME_PRESENTATION_MODE.COMPOSED;
pub const DXGI_FRAME_PRESENTATION_MODE_OVERLAY = DXGI_FRAME_PRESENTATION_MODE.OVERLAY;
pub const DXGI_FRAME_PRESENTATION_MODE_NONE = DXGI_FRAME_PRESENTATION_MODE.NONE;
pub const DXGI_FRAME_PRESENTATION_MODE_COMPOSITION_FAILURE = DXGI_FRAME_PRESENTATION_MODE.COMPOSITION_FAILURE;

pub const DXGI_FRAME_STATISTICS_MEDIA = extern struct {
    PresentCount: u32,
    PresentRefreshCount: u32,
    SyncRefreshCount: u32,
    SyncQPCTime: LARGE_INTEGER,
    SyncGPUTime: LARGE_INTEGER,
    CompositionMode: DXGI_FRAME_PRESENTATION_MODE,
    ApprovedPresentDuration: u32,
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGISwapChainMedia_Value = Guid.initString("dd95b90b-f05f-4f6a-bd65-25bfb264bd84");
pub const IID_IDXGISwapChainMedia = &IID_IDXGISwapChainMedia_Value;
pub const IDXGISwapChainMedia = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameStatisticsMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChainMedia,
                pStats: ?*DXGI_FRAME_STATISTICS_MEDIA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChainMedia,
                pStats: ?*DXGI_FRAME_STATISTICS_MEDIA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPresentDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChainMedia,
                Duration: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChainMedia,
                Duration: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckPresentDurationSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChainMedia,
                DesiredPresentDuration: u32,
                pClosestSmallerPresentDuration: ?*u32,
                pClosestLargerPresentDuration: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChainMedia,
                DesiredPresentDuration: u32,
                pClosestSmallerPresentDuration: ?*u32,
                pClosestLargerPresentDuration: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChainMedia_GetFrameStatisticsMedia(self: *const T, pStats: ?*DXGI_FRAME_STATISTICS_MEDIA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChainMedia.VTable, self.vtable).GetFrameStatisticsMedia(@ptrCast(*const IDXGISwapChainMedia, self), pStats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChainMedia_SetPresentDuration(self: *const T, Duration: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChainMedia.VTable, self.vtable).SetPresentDuration(@ptrCast(*const IDXGISwapChainMedia, self), Duration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChainMedia_CheckPresentDurationSupport(self: *const T, DesiredPresentDuration: u32, pClosestSmallerPresentDuration: ?*u32, pClosestLargerPresentDuration: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChainMedia.VTable, self.vtable).CheckPresentDurationSupport(@ptrCast(*const IDXGISwapChainMedia, self), DesiredPresentDuration, pClosestSmallerPresentDuration, pClosestLargerPresentDuration);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OVERLAY_SUPPORT_FLAG = enum(i32) {
    DIRECT = 1,
    SCALING = 2,
};
pub const DXGI_OVERLAY_SUPPORT_FLAG_DIRECT = DXGI_OVERLAY_SUPPORT_FLAG.DIRECT;
pub const DXGI_OVERLAY_SUPPORT_FLAG_SCALING = DXGI_OVERLAY_SUPPORT_FLAG.SCALING;

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIOutput3_Value = Guid.initString("8a6bb301-7e7e-41f4-a8e0-5b32f7f99b18");
pub const IID_IDXGIOutput3 = &IID_IDXGIOutput3_Value;
pub const IDXGIOutput3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput2.VTable,
        CheckOverlaySupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput3,
                EnumFormat: DXGI_FORMAT,
                pConcernedDevice: ?*IUnknown,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput3,
                EnumFormat: DXGI_FORMAT,
                pConcernedDevice: ?*IUnknown,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput3_CheckOverlaySupport(self: *const T, EnumFormat: DXGI_FORMAT, pConcernedDevice: ?*IUnknown, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput3.VTable, self.vtable).CheckOverlaySupport(@ptrCast(*const IDXGIOutput3, self), EnumFormat, pConcernedDevice, pFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG = enum(i32) {
    PRESENT = 1,
    OVERLAY_PRESENT = 2,
};
pub const DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT = DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG.PRESENT;
pub const DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_OVERLAY_PRESENT = DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG.OVERLAY_PRESENT;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGISwapChain3_Value = Guid.initString("94d99bdb-f1f8-4ab0-b236-7da0170edab1");
pub const IID_IDXGISwapChain3 = &IID_IDXGISwapChain3_Value;
pub const IDXGISwapChain3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain2.VTable,
        GetCurrentBackBufferIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain3,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDXGISwapChain3,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        CheckColorSpaceSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain3,
                ColorSpace: DXGI_COLOR_SPACE_TYPE,
                pColorSpaceSupport: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain3,
                ColorSpace: DXGI_COLOR_SPACE_TYPE,
                pColorSpaceSupport: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColorSpace1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain3,
                ColorSpace: DXGI_COLOR_SPACE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain3,
                ColorSpace: DXGI_COLOR_SPACE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResizeBuffers1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain3,
                BufferCount: u32,
                Width: u32,
                Height: u32,
                Format: DXGI_FORMAT,
                SwapChainFlags: u32,
                pCreationNodeMask: [*]const u32,
                ppPresentQueue: [*]?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain3,
                BufferCount: u32,
                Width: u32,
                Height: u32,
                Format: DXGI_FORMAT,
                SwapChainFlags: u32,
                pCreationNodeMask: [*]const u32,
                ppPresentQueue: [*]?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISwapChain2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain3_GetCurrentBackBufferIndex(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IDXGISwapChain3.VTable, self.vtable).GetCurrentBackBufferIndex(@ptrCast(*const IDXGISwapChain3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain3_CheckColorSpaceSupport(self: *const T, ColorSpace: DXGI_COLOR_SPACE_TYPE, pColorSpaceSupport: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain3.VTable, self.vtable).CheckColorSpaceSupport(@ptrCast(*const IDXGISwapChain3, self), ColorSpace, pColorSpaceSupport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain3_SetColorSpace1(self: *const T, ColorSpace: DXGI_COLOR_SPACE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain3.VTable, self.vtable).SetColorSpace1(@ptrCast(*const IDXGISwapChain3, self), ColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain3_ResizeBuffers1(self: *const T, BufferCount: u32, Width: u32, Height: u32, Format: DXGI_FORMAT, SwapChainFlags: u32, pCreationNodeMask: [*]const u32, ppPresentQueue: [*]?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain3.VTable, self.vtable).ResizeBuffers1(@ptrCast(*const IDXGISwapChain3, self), BufferCount, Width, Height, Format, SwapChainFlags, pCreationNodeMask, ppPresentQueue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG = enum(i32) {
    T = 1,
};
pub const DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG_PRESENT = DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG.T;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGIOutput4_Value = Guid.initString("dc7dca35-2196-414d-9f53-617884032a60");
pub const IID_IDXGIOutput4 = &IID_IDXGIOutput4_Value;
pub const IDXGIOutput4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput3.VTable,
        CheckOverlayColorSpaceSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput4,
                Format: DXGI_FORMAT,
                ColorSpace: DXGI_COLOR_SPACE_TYPE,
                pConcernedDevice: ?*IUnknown,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput4,
                Format: DXGI_FORMAT,
                ColorSpace: DXGI_COLOR_SPACE_TYPE,
                pConcernedDevice: ?*IUnknown,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput4_CheckOverlayColorSpaceSupport(self: *const T, Format: DXGI_FORMAT, ColorSpace: DXGI_COLOR_SPACE_TYPE, pConcernedDevice: ?*IUnknown, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput4.VTable, self.vtable).CheckOverlayColorSpaceSupport(@ptrCast(*const IDXGIOutput4, self), Format, ColorSpace, pConcernedDevice, pFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIFactory4_Value = Guid.initString("1bc6ea02-ef36-464f-bf0c-21ca39e5168a");
pub const IID_IDXGIFactory4 = &IID_IDXGIFactory4_Value;
pub const IDXGIFactory4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory3.VTable,
        EnumAdapterByLuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory4,
                AdapterLuid: LUID,
                riid: ?*const Guid,
                ppvAdapter: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory4,
                AdapterLuid: LUID,
                riid: ?*const Guid,
                ppvAdapter: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumWarpAdapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory4,
                riid: ?*const Guid,
                ppvAdapter: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory4,
                riid: ?*const Guid,
                ppvAdapter: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory4_EnumAdapterByLuid(self: *const T, AdapterLuid: LUID, riid: ?*const Guid, ppvAdapter: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory4.VTable, self.vtable).EnumAdapterByLuid(@ptrCast(*const IDXGIFactory4, self), AdapterLuid, riid, ppvAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory4_EnumWarpAdapter(self: *const T, riid: ?*const Guid, ppvAdapter: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory4.VTable, self.vtable).EnumWarpAdapter(@ptrCast(*const IDXGIFactory4, self), riid, ppvAdapter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_MEMORY_SEGMENT_GROUP = enum(i32) {
    LOCAL = 0,
    NON_LOCAL = 1,
};
pub const DXGI_MEMORY_SEGMENT_GROUP_LOCAL = DXGI_MEMORY_SEGMENT_GROUP.LOCAL;
pub const DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL = DXGI_MEMORY_SEGMENT_GROUP.NON_LOCAL;

pub const DXGI_QUERY_VIDEO_MEMORY_INFO = extern struct {
    Budget: u64,
    CurrentUsage: u64,
    AvailableForReservation: u64,
    CurrentReservation: u64,
};

const IID_IDXGIAdapter3_Value = Guid.initString("645967a4-1392-4310-a798-8053ce3e93fd");
pub const IID_IDXGIAdapter3 = &IID_IDXGIAdapter3_Value;
pub const IDXGIAdapter3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter2.VTable,
        RegisterHardwareContentProtectionTeardownStatusEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter3,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter3,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterHardwareContentProtectionTeardownStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter3,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIAdapter3,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        QueryVideoMemoryInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter3,
                NodeIndex: u32,
                MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP,
                pVideoMemoryInfo: ?*DXGI_QUERY_VIDEO_MEMORY_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter3,
                NodeIndex: u32,
                MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP,
                pVideoMemoryInfo: ?*DXGI_QUERY_VIDEO_MEMORY_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoMemoryReservation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter3,
                NodeIndex: u32,
                MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP,
                Reservation: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter3,
                NodeIndex: u32,
                MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP,
                Reservation: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterVideoMemoryBudgetChangeNotificationEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter3,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter3,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterVideoMemoryBudgetChangeNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter3,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIAdapter3,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIAdapter2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_RegisterHardwareContentProtectionTeardownStatusEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).RegisterHardwareContentProtectionTeardownStatusEvent(@ptrCast(*const IDXGIAdapter3, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_UnregisterHardwareContentProtectionTeardownStatus(self: *const T, dwCookie: u32) callconv(.Inline) void {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).UnregisterHardwareContentProtectionTeardownStatus(@ptrCast(*const IDXGIAdapter3, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_QueryVideoMemoryInfo(self: *const T, NodeIndex: u32, MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP, pVideoMemoryInfo: ?*DXGI_QUERY_VIDEO_MEMORY_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).QueryVideoMemoryInfo(@ptrCast(*const IDXGIAdapter3, self), NodeIndex, MemorySegmentGroup, pVideoMemoryInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_SetVideoMemoryReservation(self: *const T, NodeIndex: u32, MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP, Reservation: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).SetVideoMemoryReservation(@ptrCast(*const IDXGIAdapter3, self), NodeIndex, MemorySegmentGroup, Reservation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_RegisterVideoMemoryBudgetChangeNotificationEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).RegisterVideoMemoryBudgetChangeNotificationEvent(@ptrCast(*const IDXGIAdapter3, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_UnregisterVideoMemoryBudgetChangeNotification(self: *const T, dwCookie: u32) callconv(.Inline) void {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).UnregisterVideoMemoryBudgetChangeNotification(@ptrCast(*const IDXGIAdapter3, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OUTDUPL_FLAG = enum(i32) {
    Y = 1,
};
pub const DXGI_OUTDUPL_COMPOSITED_UI_CAPTURE_ONLY = DXGI_OUTDUPL_FLAG.Y;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGIOutput5_Value = Guid.initString("80a07424-ab52-42eb-833c-0c42fd282d98");
pub const IID_IDXGIOutput5 = &IID_IDXGIOutput5_Value;
pub const IDXGIOutput5 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput4.VTable,
        DuplicateOutput1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput5,
                pDevice: ?*IUnknown,
                Flags: u32,
                SupportedFormatsCount: u32,
                pSupportedFormats: [*]const DXGI_FORMAT,
                ppOutputDuplication: ?*?*IDXGIOutputDuplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput5,
                pDevice: ?*IUnknown,
                Flags: u32,
                SupportedFormatsCount: u32,
                pSupportedFormats: [*]const DXGI_FORMAT,
                ppOutputDuplication: ?*?*IDXGIOutputDuplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput5_DuplicateOutput1(self: *const T, pDevice: ?*IUnknown, Flags: u32, SupportedFormatsCount: u32, pSupportedFormats: [*]const DXGI_FORMAT, ppOutputDuplication: ?*?*IDXGIOutputDuplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput5.VTable, self.vtable).DuplicateOutput1(@ptrCast(*const IDXGIOutput5, self), pDevice, Flags, SupportedFormatsCount, pSupportedFormats, ppOutputDuplication);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_HDR_METADATA_TYPE = enum(i32) {
    NONE = 0,
    HDR10 = 1,
    HDR10PLUS = 2,
};
pub const DXGI_HDR_METADATA_TYPE_NONE = DXGI_HDR_METADATA_TYPE.NONE;
pub const DXGI_HDR_METADATA_TYPE_HDR10 = DXGI_HDR_METADATA_TYPE.HDR10;
pub const DXGI_HDR_METADATA_TYPE_HDR10PLUS = DXGI_HDR_METADATA_TYPE.HDR10PLUS;

pub const DXGI_HDR_METADATA_HDR10 = extern struct {
    RedPrimary: [2]u16,
    GreenPrimary: [2]u16,
    BluePrimary: [2]u16,
    WhitePoint: [2]u16,
    MaxMasteringLuminance: u32,
    MinMasteringLuminance: u32,
    MaxContentLightLevel: u16,
    MaxFrameAverageLightLevel: u16,
};

pub const DXGI_HDR_METADATA_HDR10PLUS = extern struct {
    Data: [72]u8,
};

const IID_IDXGISwapChain4_Value = Guid.initString("3d585d5a-bd4a-489e-b1f4-3dbcb6452ffb");
pub const IID_IDXGISwapChain4 = &IID_IDXGISwapChain4_Value;
pub const IDXGISwapChain4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain3.VTable,
        SetHDRMetaData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGISwapChain4,
                Type: DXGI_HDR_METADATA_TYPE,
                Size: u32,
                pMetaData: ?[*]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGISwapChain4,
                Type: DXGI_HDR_METADATA_TYPE,
                Size: u32,
                pMetaData: ?[*]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISwapChain3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain4_SetHDRMetaData(self: *const T, Type: DXGI_HDR_METADATA_TYPE, Size: u32, pMetaData: ?[*]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain4.VTable, self.vtable).SetHDRMetaData(@ptrCast(*const IDXGISwapChain4, self), Type, Size, pMetaData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OFFER_RESOURCE_FLAGS = enum(i32) {
    T = 1,
};
pub const DXGI_OFFER_RESOURCE_FLAG_ALLOW_DECOMMIT = DXGI_OFFER_RESOURCE_FLAGS.T;

pub const DXGI_RECLAIM_RESOURCE_RESULTS = enum(i32) {
    OK = 0,
    DISCARDED = 1,
    NOT_COMMITTED = 2,
};
pub const DXGI_RECLAIM_RESOURCE_RESULT_OK = DXGI_RECLAIM_RESOURCE_RESULTS.OK;
pub const DXGI_RECLAIM_RESOURCE_RESULT_DISCARDED = DXGI_RECLAIM_RESOURCE_RESULTS.DISCARDED;
pub const DXGI_RECLAIM_RESOURCE_RESULT_NOT_COMMITTED = DXGI_RECLAIM_RESOURCE_RESULTS.NOT_COMMITTED;

const IID_IDXGIDevice4_Value = Guid.initString("95b4f95f-d8da-4ca4-9ee6-3b76d5968a10");
pub const IID_IDXGIDevice4 = &IID_IDXGIDevice4_Value;
pub const IDXGIDevice4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice3.VTable,
        OfferResources1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice4,
                NumResources: u32,
                ppResources: [*]?*IDXGIResource,
                Priority: DXGI_OFFER_RESOURCE_PRIORITY,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice4,
                NumResources: u32,
                ppResources: [*]?*IDXGIResource,
                Priority: DXGI_OFFER_RESOURCE_PRIORITY,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReclaimResources1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDevice4,
                NumResources: u32,
                ppResources: [*]?*IDXGIResource,
                pResults: ?*DXGI_RECLAIM_RESOURCE_RESULTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDevice4,
                NumResources: u32,
                ppResources: [*]?*IDXGIResource,
                pResults: ?*DXGI_RECLAIM_RESOURCE_RESULTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDevice3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice4_OfferResources1(self: *const T, NumResources: u32, ppResources: [*]?*IDXGIResource, Priority: DXGI_OFFER_RESOURCE_PRIORITY, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice4.VTable, self.vtable).OfferResources1(@ptrCast(*const IDXGIDevice4, self), NumResources, ppResources, Priority, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice4_ReclaimResources1(self: *const T, NumResources: u32, ppResources: [*]?*IDXGIResource, pResults: ?*DXGI_RECLAIM_RESOURCE_RESULTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice4.VTable, self.vtable).ReclaimResources1(@ptrCast(*const IDXGIDevice4, self), NumResources, ppResources, pResults);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_FEATURE = enum(i32) {
    G = 0,
};
pub const DXGI_FEATURE_PRESENT_ALLOW_TEARING = DXGI_FEATURE.G;

const IID_IDXGIFactory5_Value = Guid.initString("7632e1f5-ee65-4dca-87fd-84cd75f8838d");
pub const IID_IDXGIFactory5 = &IID_IDXGIFactory5_Value;
pub const IDXGIFactory5 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory4.VTable,
        CheckFeatureSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory5,
                Feature: DXGI_FEATURE,
                // TODO: what to do with BytesParamIndex 2?
                pFeatureSupportData: ?*anyopaque,
                FeatureSupportDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory5,
                Feature: DXGI_FEATURE,
                // TODO: what to do with BytesParamIndex 2?
                pFeatureSupportData: ?*anyopaque,
                FeatureSupportDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory5_CheckFeatureSupport(self: *const T, Feature: DXGI_FEATURE, pFeatureSupportData: ?*anyopaque, FeatureSupportDataSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory5.VTable, self.vtable).CheckFeatureSupport(@ptrCast(*const IDXGIFactory5, self), Feature, pFeatureSupportData, FeatureSupportDataSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_ADAPTER_FLAG3 = enum(u32) {
    NONE = 0,
    REMOTE = 1,
    SOFTWARE = 2,
    ACG_COMPATIBLE = 4,
    SUPPORT_MONITORED_FENCES = 8,
    SUPPORT_NON_MONITORED_FENCES = 16,
    KEYED_MUTEX_CONFORMANCE = 32,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        REMOTE: u1 = 0,
        SOFTWARE: u1 = 0,
        ACG_COMPATIBLE: u1 = 0,
        SUPPORT_MONITORED_FENCES: u1 = 0,
        SUPPORT_NON_MONITORED_FENCES: u1 = 0,
        KEYED_MUTEX_CONFORMANCE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) DXGI_ADAPTER_FLAG3 {
        return @intToEnum(DXGI_ADAPTER_FLAG3,
              (if (o.NONE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.NONE) else 0)
            | (if (o.REMOTE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.REMOTE) else 0)
            | (if (o.SOFTWARE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.SOFTWARE) else 0)
            | (if (o.ACG_COMPATIBLE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.ACG_COMPATIBLE) else 0)
            | (if (o.SUPPORT_MONITORED_FENCES == 1) @enumToInt(DXGI_ADAPTER_FLAG3.SUPPORT_MONITORED_FENCES) else 0)
            | (if (o.SUPPORT_NON_MONITORED_FENCES == 1) @enumToInt(DXGI_ADAPTER_FLAG3.SUPPORT_NON_MONITORED_FENCES) else 0)
            | (if (o.KEYED_MUTEX_CONFORMANCE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.KEYED_MUTEX_CONFORMANCE) else 0)
            | (if (o.FORCE_DWORD == 1) @enumToInt(DXGI_ADAPTER_FLAG3.FORCE_DWORD) else 0)
        );
    }
};
pub const DXGI_ADAPTER_FLAG3_NONE = DXGI_ADAPTER_FLAG3.NONE;
pub const DXGI_ADAPTER_FLAG3_REMOTE = DXGI_ADAPTER_FLAG3.REMOTE;
pub const DXGI_ADAPTER_FLAG3_SOFTWARE = DXGI_ADAPTER_FLAG3.SOFTWARE;
pub const DXGI_ADAPTER_FLAG3_ACG_COMPATIBLE = DXGI_ADAPTER_FLAG3.ACG_COMPATIBLE;
pub const DXGI_ADAPTER_FLAG3_SUPPORT_MONITORED_FENCES = DXGI_ADAPTER_FLAG3.SUPPORT_MONITORED_FENCES;
pub const DXGI_ADAPTER_FLAG3_SUPPORT_NON_MONITORED_FENCES = DXGI_ADAPTER_FLAG3.SUPPORT_NON_MONITORED_FENCES;
pub const DXGI_ADAPTER_FLAG3_KEYED_MUTEX_CONFORMANCE = DXGI_ADAPTER_FLAG3.KEYED_MUTEX_CONFORMANCE;
pub const DXGI_ADAPTER_FLAG3_FORCE_DWORD = DXGI_ADAPTER_FLAG3.FORCE_DWORD;

pub const DXGI_ADAPTER_DESC3 = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
    Flags: DXGI_ADAPTER_FLAG3,
    GraphicsPreemptionGranularity: DXGI_GRAPHICS_PREEMPTION_GRANULARITY,
    ComputePreemptionGranularity: DXGI_COMPUTE_PREEMPTION_GRANULARITY,
};

const IID_IDXGIAdapter4_Value = Guid.initString("3c8d99d1-4fbf-4181-a82c-af66bf7bd24e");
pub const IID_IDXGIAdapter4 = &IID_IDXGIAdapter4_Value;
pub const IDXGIAdapter4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter3.VTable,
        GetDesc3: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIAdapter4,
                pDesc: ?*DXGI_ADAPTER_DESC3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIAdapter4,
                pDesc: ?*DXGI_ADAPTER_DESC3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIAdapter3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter4_GetDesc3(self: *const T, pDesc: ?*DXGI_ADAPTER_DESC3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter4.VTable, self.vtable).GetDesc3(@ptrCast(*const IDXGIAdapter4, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OUTPUT_DESC1 = extern struct {
    DeviceName: [32]u16,
    DesktopCoordinates: RECT,
    AttachedToDesktop: BOOL,
    Rotation: DXGI_MODE_ROTATION,
    Monitor: ?HMONITOR,
    BitsPerColor: u32,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
    RedPrimary: [2]f32,
    GreenPrimary: [2]f32,
    BluePrimary: [2]f32,
    WhitePoint: [2]f32,
    MinLuminance: f32,
    MaxLuminance: f32,
    MaxFullFrameLuminance: f32,
};

pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS = enum(u32) {
    FULLSCREEN = 1,
    WINDOWED = 2,
    CURSOR_STRETCHED = 4,
    _,
    pub fn initFlags(o: struct {
        FULLSCREEN: u1 = 0,
        WINDOWED: u1 = 0,
        CURSOR_STRETCHED: u1 = 0,
    }) DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS {
        return @intToEnum(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS,
              (if (o.FULLSCREEN == 1) @enumToInt(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.FULLSCREEN) else 0)
            | (if (o.WINDOWED == 1) @enumToInt(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.WINDOWED) else 0)
            | (if (o.CURSOR_STRETCHED == 1) @enumToInt(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.CURSOR_STRETCHED) else 0)
        );
    }
};
pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_FULLSCREEN = DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.FULLSCREEN;
pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_WINDOWED = DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.WINDOWED;
pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_CURSOR_STRETCHED = DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.CURSOR_STRETCHED;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGIOutput6_Value = Guid.initString("068346e8-aaec-4b84-add7-137f513f77a1");
pub const IID_IDXGIOutput6 = &IID_IDXGIOutput6_Value;
pub const IDXGIOutput6 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput5.VTable,
        GetDesc1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput6,
                pDesc: ?*DXGI_OUTPUT_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput6,
                pDesc: ?*DXGI_OUTPUT_DESC1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckHardwareCompositionSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIOutput6,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIOutput6,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput6_GetDesc1(self: *const T, pDesc: ?*DXGI_OUTPUT_DESC1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput6.VTable, self.vtable).GetDesc1(@ptrCast(*const IDXGIOutput6, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput6_CheckHardwareCompositionSupport(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput6.VTable, self.vtable).CheckHardwareCompositionSupport(@ptrCast(*const IDXGIOutput6, self), pFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_GPU_PREFERENCE = enum(i32) {
    UNSPECIFIED = 0,
    MINIMUM_POWER = 1,
    HIGH_PERFORMANCE = 2,
};
pub const DXGI_GPU_PREFERENCE_UNSPECIFIED = DXGI_GPU_PREFERENCE.UNSPECIFIED;
pub const DXGI_GPU_PREFERENCE_MINIMUM_POWER = DXGI_GPU_PREFERENCE.MINIMUM_POWER;
pub const DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE = DXGI_GPU_PREFERENCE.HIGH_PERFORMANCE;

// TODO: this type is limited to platform 'windows10.0.17134'
const IID_IDXGIFactory6_Value = Guid.initString("c1b6694f-ff09-44a9-b03c-77900a0a1d17");
pub const IID_IDXGIFactory6 = &IID_IDXGIFactory6_Value;
pub const IDXGIFactory6 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory5.VTable,
        EnumAdapterByGpuPreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory6,
                Adapter: u32,
                GpuPreference: DXGI_GPU_PREFERENCE,
                riid: ?*const Guid,
                ppvAdapter: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory6,
                Adapter: u32,
                GpuPreference: DXGI_GPU_PREFERENCE,
                riid: ?*const Guid,
                ppvAdapter: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory6_EnumAdapterByGpuPreference(self: *const T, Adapter: u32, GpuPreference: DXGI_GPU_PREFERENCE, riid: ?*const Guid, ppvAdapter: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory6.VTable, self.vtable).EnumAdapterByGpuPreference(@ptrCast(*const IDXGIFactory6, self), Adapter, GpuPreference, riid, ppvAdapter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17763'
const IID_IDXGIFactory7_Value = Guid.initString("a4966eed-76db-44da-84c1-ee9a7afb20a8");
pub const IID_IDXGIFactory7 = &IID_IDXGIFactory7_Value;
pub const IDXGIFactory7 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory6.VTable,
        RegisterAdaptersChangedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory7,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory7,
                hEvent: ?HANDLE,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterAdaptersChangedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIFactory7,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIFactory7,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory7_RegisterAdaptersChangedEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory7.VTable, self.vtable).RegisterAdaptersChangedEvent(@ptrCast(*const IDXGIFactory7, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory7_UnregisterAdaptersChangedEvent(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory7.VTable, self.vtable).UnregisterAdaptersChangedEvent(@ptrCast(*const IDXGIFactory7, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_DEBUG_RLO_FLAGS = enum(u32) {
    SUMMARY = 1,
    DETAIL = 2,
    IGNORE_INTERNAL = 4,
    ALL = 7,
    _,
    pub fn initFlags(o: struct {
        SUMMARY: u1 = 0,
        DETAIL: u1 = 0,
        IGNORE_INTERNAL: u1 = 0,
        ALL: u1 = 0,
    }) DXGI_DEBUG_RLO_FLAGS {
        return @intToEnum(DXGI_DEBUG_RLO_FLAGS,
              (if (o.SUMMARY == 1) @enumToInt(DXGI_DEBUG_RLO_FLAGS.SUMMARY) else 0)
            | (if (o.DETAIL == 1) @enumToInt(DXGI_DEBUG_RLO_FLAGS.DETAIL) else 0)
            | (if (o.IGNORE_INTERNAL == 1) @enumToInt(DXGI_DEBUG_RLO_FLAGS.IGNORE_INTERNAL) else 0)
            | (if (o.ALL == 1) @enumToInt(DXGI_DEBUG_RLO_FLAGS.ALL) else 0)
        );
    }
};
pub const DXGI_DEBUG_RLO_SUMMARY = DXGI_DEBUG_RLO_FLAGS.SUMMARY;
pub const DXGI_DEBUG_RLO_DETAIL = DXGI_DEBUG_RLO_FLAGS.DETAIL;
pub const DXGI_DEBUG_RLO_IGNORE_INTERNAL = DXGI_DEBUG_RLO_FLAGS.IGNORE_INTERNAL;
pub const DXGI_DEBUG_RLO_ALL = DXGI_DEBUG_RLO_FLAGS.ALL;

pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY = enum(i32) {
    UNKNOWN = 0,
    MISCELLANEOUS = 1,
    INITIALIZATION = 2,
    CLEANUP = 3,
    COMPILATION = 4,
    STATE_CREATION = 5,
    STATE_SETTING = 6,
    STATE_GETTING = 7,
    RESOURCE_MANIPULATION = 8,
    EXECUTION = 9,
    SHADER = 10,
};
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_UNKNOWN = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.UNKNOWN;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_MISCELLANEOUS = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.MISCELLANEOUS;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_INITIALIZATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.INITIALIZATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_CLEANUP = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.CLEANUP;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_COMPILATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.COMPILATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_CREATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.STATE_CREATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_SETTING = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.STATE_SETTING;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_GETTING = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.STATE_GETTING;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_RESOURCE_MANIPULATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.RESOURCE_MANIPULATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_EXECUTION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.EXECUTION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_SHADER = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.SHADER;

pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY = enum(i32) {
    CORRUPTION = 0,
    ERROR = 1,
    WARNING = 2,
    INFO = 3,
    MESSAGE = 4,
};
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_CORRUPTION = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.CORRUPTION;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_ERROR = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.ERROR;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_WARNING = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.WARNING;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_INFO = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.INFO;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_MESSAGE = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.MESSAGE;

pub const DXGI_INFO_QUEUE_MESSAGE = extern struct {
    Producer: Guid,
    Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
    Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
    ID: i32,
    pDescription: ?*const u8,
    DescriptionByteLength: usize,
};

pub const DXGI_INFO_QUEUE_FILTER_DESC = extern struct {
    NumCategories: u32,
    pCategoryList: ?*DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
    NumSeverities: u32,
    pSeverityList: ?*DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
    NumIDs: u32,
    pIDList: ?*i32,
};

pub const DXGI_INFO_QUEUE_FILTER = extern struct {
    AllowList: DXGI_INFO_QUEUE_FILTER_DESC,
    DenyList: DXGI_INFO_QUEUE_FILTER_DESC,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIInfoQueue_Value = Guid.initString("d67441c7-672a-476f-9e82-cd55b44949ce");
pub const IID_IDXGIInfoQueue = &IID_IDXGIInfoQueue_Value;
pub const IDXGIInfoQueue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMessageCountLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                MessageCountLimit: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                MessageCountLimit: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearStoredMessages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                MessageIndex: u64,
                // TODO: what to do with BytesParamIndex 3?
                pMessage: ?*DXGI_INFO_QUEUE_MESSAGE,
                pMessageByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                MessageIndex: u64,
                // TODO: what to do with BytesParamIndex 3?
                pMessage: ?*DXGI_INFO_QUEUE_MESSAGE,
                pMessageByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumStoredMessagesAllowedByRetrievalFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetNumStoredMessages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetNumMessagesDiscardedByMessageCountLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetMessageCountLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetNumMessagesAllowedByStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetNumMessagesDeniedByStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        AddStorageFilterEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                // TODO: what to do with BytesParamIndex 2?
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
                pFilterByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                // TODO: what to do with BytesParamIndex 2?
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
                pFilterByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PushEmptyStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushDenyAllStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushCopyOfStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopStorageFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetStorageFilterStackSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        AddRetrievalFilterEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                // TODO: what to do with BytesParamIndex 2?
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
                pFilterByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                // TODO: what to do with BytesParamIndex 2?
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
                pFilterByteLength: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PushEmptyRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushDenyAllRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushCopyOfRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopRetrievalFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetRetrievalFilterStackSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        AddMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
                Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
                ID: i32,
                pDescription: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
                Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
                ID: i32,
                pDescription: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddApplicationMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
                pDescription: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
                pDescription: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakOnCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakOnSeverity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakOnID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                ID: i32,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                ID: i32,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakOnCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetBreakOnSeverity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetBreakOnID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                ID: i32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                ID: i32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        SetMuteDebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                bMute: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
                bMute: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetMuteDebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGIInfoQueue,
                Producer: Guid,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetMessageCountLimit(self: *const T, Producer: Guid, MessageCountLimit: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetMessageCountLimit(@ptrCast(*const IDXGIInfoQueue, self), Producer, MessageCountLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_ClearStoredMessages(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).ClearStoredMessages(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetMessage(self: *const T, Producer: Guid, MessageIndex: u64, pMessage: ?*DXGI_INFO_QUEUE_MESSAGE, pMessageByteLength: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetMessage(@ptrCast(*const IDXGIInfoQueue, self), Producer, MessageIndex, pMessage, pMessageByteLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumStoredMessagesAllowedByRetrievalFilters(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumStoredMessagesAllowedByRetrievalFilters(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumStoredMessages(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumStoredMessages(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumMessagesDiscardedByMessageCountLimit(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumMessagesDiscardedByMessageCountLimit(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetMessageCountLimit(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetMessageCountLimit(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumMessagesAllowedByStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumMessagesAllowedByStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumMessagesDeniedByStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumMessagesDeniedByStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_AddStorageFilterEntries(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).AddStorageFilterEntries(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetStorageFilter(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER, pFilterByteLength: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter, pFilterByteLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_ClearStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).ClearStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushEmptyStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushEmptyStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushDenyAllStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushDenyAllStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushCopyOfStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushCopyOfStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushStorageFilter(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PopStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PopStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetStorageFilterStackSize(self: *const T, Producer: Guid) callconv(.Inline) u32 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetStorageFilterStackSize(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_AddRetrievalFilterEntries(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).AddRetrievalFilterEntries(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetRetrievalFilter(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER, pFilterByteLength: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter, pFilterByteLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_ClearRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).ClearRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushEmptyRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushEmptyRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushDenyAllRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushDenyAllRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushCopyOfRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushCopyOfRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushRetrievalFilter(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PopRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PopRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetRetrievalFilterStackSize(self: *const T, Producer: Guid) callconv(.Inline) u32 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetRetrievalFilterStackSize(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_AddMessage(self: *const T, Producer: Guid, Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, ID: i32, pDescription: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).AddMessage(@ptrCast(*const IDXGIInfoQueue, self), Producer, Category, Severity, ID, pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_AddApplicationMessage(self: *const T, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, pDescription: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).AddApplicationMessage(@ptrCast(*const IDXGIInfoQueue, self), Severity, pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetBreakOnCategory(self: *const T, Producer: Guid, Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetBreakOnCategory(@ptrCast(*const IDXGIInfoQueue, self), Producer, Category, bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetBreakOnSeverity(self: *const T, Producer: Guid, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetBreakOnSeverity(@ptrCast(*const IDXGIInfoQueue, self), Producer, Severity, bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetBreakOnID(self: *const T, Producer: Guid, ID: i32, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetBreakOnID(@ptrCast(*const IDXGIInfoQueue, self), Producer, ID, bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetBreakOnCategory(self: *const T, Producer: Guid, Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetBreakOnCategory(@ptrCast(*const IDXGIInfoQueue, self), Producer, Category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetBreakOnSeverity(self: *const T, Producer: Guid, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetBreakOnSeverity(@ptrCast(*const IDXGIInfoQueue, self), Producer, Severity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetBreakOnID(self: *const T, Producer: Guid, ID: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetBreakOnID(@ptrCast(*const IDXGIInfoQueue, self), Producer, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetMuteDebugOutput(self: *const T, Producer: Guid, bMute: BOOL) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetMuteDebugOutput(@ptrCast(*const IDXGIInfoQueue, self), Producer, bMute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetMuteDebugOutput(self: *const T, Producer: Guid) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetMuteDebugOutput(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIDebug_Value = Guid.initString("119e7452-de9e-40fe-8806-88f90c12b441");
pub const IID_IDXGIDebug = &IID_IDXGIDebug_Value;
pub const IDXGIDebug = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportLiveObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDebug,
                apiid: Guid,
                flags: DXGI_DEBUG_RLO_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDXGIDebug,
                apiid: Guid,
                flags: DXGI_DEBUG_RLO_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDebug_ReportLiveObjects(self: *const T, apiid: Guid, flags: DXGI_DEBUG_RLO_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDebug.VTable, self.vtable).ReportLiveObjects(@ptrCast(*const IDXGIDebug, self), apiid, flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIDebug1_Value = Guid.initString("c5a05f0c-16f2-4adf-9f4d-a8c4d58ac550");
pub const IID_IDXGIDebug1 = &IID_IDXGIDebug1_Value;
pub const IDXGIDebug1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDebug.VTable,
        EnableLeakTrackingForThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDebug1,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIDebug1,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DisableLeakTrackingForThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDebug1,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGIDebug1,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        IsLeakTrackingEnabledForThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGIDebug1,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDXGIDebug1,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDebug.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDebug1_EnableLeakTrackingForThread(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGIDebug1.VTable, self.vtable).EnableLeakTrackingForThread(@ptrCast(*const IDXGIDebug1, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDebug1_DisableLeakTrackingForThread(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGIDebug1.VTable, self.vtable).DisableLeakTrackingForThread(@ptrCast(*const IDXGIDebug1, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDebug1_IsLeakTrackingEnabledForThread(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIDebug1.VTable, self.vtable).IsLeakTrackingEnabledForThread(@ptrCast(*const IDXGIDebug1, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_Message_Id = enum(i32) {
    IDXGISwapChain_CreationOrResizeBuffers_InvalidOutputWindow = 0,
    IDXGISwapChain_CreationOrResizeBuffers_BufferWidthInferred = 1,
    IDXGISwapChain_CreationOrResizeBuffers_BufferHeightInferred = 2,
    IDXGISwapChain_CreationOrResizeBuffers_NoScanoutFlagChanged = 3,
    IDXGISwapChain_Creation_MaxBufferCountExceeded = 4,
    IDXGISwapChain_Creation_TooFewBuffers = 5,
    IDXGISwapChain_Creation_NoOutputWindow = 6,
    IDXGISwapChain_Destruction_OtherMethodsCalled = 7,
    IDXGISwapChain_GetDesc_pDescIsNULL = 8,
    IDXGISwapChain_GetBuffer_ppSurfaceIsNULL = 9,
    IDXGISwapChain_GetBuffer_NoAllocatedBuffers = 10,
    IDXGISwapChain_GetBuffer_iBufferMustBeZero = 11,
    IDXGISwapChain_GetBuffer_iBufferOOB = 12,
    IDXGISwapChain_GetContainingOutput_ppOutputIsNULL = 13,
    IDXGISwapChain_Present_SyncIntervalOOB = 14,
    IDXGISwapChain_Present_InvalidNonPreRotatedFlag = 15,
    IDXGISwapChain_Present_NoAllocatedBuffers = 16,
    IDXGISwapChain_Present_GetDXGIAdapterFailed = 17,
    IDXGISwapChain_ResizeBuffers_BufferCountOOB = 18,
    IDXGISwapChain_ResizeBuffers_UnreleasedReferences = 19,
    IDXGISwapChain_ResizeBuffers_InvalidSwapChainFlag = 20,
    IDXGISwapChain_ResizeBuffers_InvalidNonPreRotatedFlag = 21,
    IDXGISwapChain_ResizeTarget_RefreshRateDivideByZero = 22,
    IDXGISwapChain_SetFullscreenState_InvalidTarget = 23,
    IDXGISwapChain_GetFrameStatistics_pStatsIsNULL = 24,
    IDXGISwapChain_GetLastPresentCount_pLastPresentCountIsNULL = 25,
    IDXGISwapChain_SetFullscreenState_RemoteNotSupported = 26,
    IDXGIOutput_TakeOwnership_FailedToAcquireFullscreenMutex = 27,
    IDXGIFactory_CreateSoftwareAdapter_ppAdapterInterfaceIsNULL = 28,
    IDXGIFactory_EnumAdapters_ppAdapterInterfaceIsNULL = 29,
    IDXGIFactory_CreateSwapChain_ppSwapChainIsNULL = 30,
    IDXGIFactory_CreateSwapChain_pDescIsNULL = 31,
    IDXGIFactory_CreateSwapChain_UnknownSwapEffect = 32,
    IDXGIFactory_CreateSwapChain_InvalidFlags = 33,
    IDXGIFactory_CreateSwapChain_NonPreRotatedFlagAndWindowed = 34,
    IDXGIFactory_CreateSwapChain_NullDeviceInterface = 35,
    IDXGIFactory_GetWindowAssociation_phWndIsNULL = 36,
    IDXGIFactory_MakeWindowAssociation_InvalidFlags = 37,
    IDXGISurface_Map_InvalidSurface = 38,
    IDXGISurface_Map_FlagsSetToZero = 39,
    IDXGISurface_Map_DiscardAndReadFlagSet = 40,
    IDXGISurface_Map_DiscardButNotWriteFlagSet = 41,
    IDXGISurface_Map_NoCPUAccess = 42,
    IDXGISurface_Map_ReadFlagSetButCPUAccessIsDynamic = 43,
    IDXGISurface_Map_DiscardFlagSetButCPUAccessIsNotDynamic = 44,
    IDXGIOutput_GetDisplayModeList_pNumModesIsNULL = 45,
    IDXGIOutput_FindClosestMatchingMode_ModeHasInvalidWidthOrHeight = 46,
    IDXGIOutput_GetCammaControlCapabilities_NoOwnerDevice = 47,
    IDXGIOutput_TakeOwnership_pDeviceIsNULL = 48,
    IDXGIOutput_GetDisplaySurfaceData_NoOwnerDevice = 49,
    IDXGIOutput_GetDisplaySurfaceData_pDestinationIsNULL = 50,
    IDXGIOutput_GetDisplaySurfaceData_MapOfDestinationFailed = 51,
    IDXGIOutput_GetFrameStatistics_NoOwnerDevice = 52,
    IDXGIOutput_GetFrameStatistics_pStatsIsNULL = 53,
    IDXGIOutput_SetGammaControl_NoOwnerDevice = 54,
    IDXGIOutput_GetGammaControl_NoOwnerDevice = 55,
    IDXGIOutput_GetGammaControl_NoGammaControls = 56,
    IDXGIOutput_SetDisplaySurface_IDXGIResourceNotSupportedBypPrimary = 57,
    IDXGIOutput_SetDisplaySurface_pPrimaryIsInvalid = 58,
    IDXGIOutput_SetDisplaySurface_NoOwnerDevice = 59,
    IDXGIOutput_TakeOwnership_RemoteDeviceNotSupported = 60,
    IDXGIOutput_GetDisplayModeList_RemoteDeviceNotSupported = 61,
    IDXGIOutput_FindClosestMatchingMode_RemoteDeviceNotSupported = 62,
    IDXGIDevice_CreateSurface_InvalidParametersWithpSharedResource = 63,
    IDXGIObject_GetPrivateData_puiDataSizeIsNULL = 64,
    IDXGISwapChain_Creation_InvalidOutputWindow = 65,
    IDXGISwapChain_Release_SwapChainIsFullscreen = 66,
    IDXGIOutput_GetDisplaySurfaceData_InvalidTargetSurfaceFormat = 67,
    IDXGIFactory_CreateSoftwareAdapter_ModuleIsNULL = 68,
    IDXGIOutput_FindClosestMatchingMode_IDXGIDeviceNotSupportedBypConcernedDevice = 69,
    IDXGIOutput_FindClosestMatchingMode_pModeToMatchOrpClosestMatchIsNULL = 70,
    IDXGIOutput_FindClosestMatchingMode_ModeHasRefreshRateDenominatorZero = 71,
    IDXGIOutput_FindClosestMatchingMode_UnknownFormatIsInvalidForConfiguration = 72,
    IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScanlineOrdering = 73,
    IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScaling = 74,
    IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeFormatAndDeviceCombination = 75,
    IDXGIFactory_Creation_CalledFromDllMain = 76,
    IDXGISwapChain_SetFullscreenState_OutputNotOwnedBySwapChainDevice = 77,
    IDXGISwapChain_Creation_InvalidWindowStyle = 78,
    IDXGISwapChain_GetFrameStatistics_UnsupportedStatistics = 79,
    IDXGISwapChain_GetContainingOutput_SwapchainAdapterDoesNotControlOutput = 80,
    IDXGIOutput_SetOrGetGammaControl_pArrayIsNULL = 81,
    IDXGISwapChain_SetFullscreenState_FullscreenInvalidForChildWindows = 82,
    IDXGIFactory_Release_CalledFromDllMain = 83,
    IDXGISwapChain_Present_UnreleasedHDC = 84,
    IDXGISwapChain_ResizeBuffers_NonPreRotatedAndGDICompatibleFlags = 85,
    IDXGIFactory_CreateSwapChain_NonPreRotatedAndGDICompatibleFlags = 86,
    IDXGISurface1_GetDC_pHdcIsNULL = 87,
    IDXGISurface1_GetDC_SurfaceNotTexture2D = 88,
    IDXGISurface1_GetDC_GDICompatibleFlagNotSet = 89,
    IDXGISurface1_GetDC_UnreleasedHDC = 90,
    IDXGISurface_Map_NoCPUAccess2 = 91,
    IDXGISurface1_ReleaseDC_GetDCNotCalled = 92,
    IDXGISurface1_ReleaseDC_InvalidRectangleDimensions = 93,
    IDXGIOutput_TakeOwnership_RemoteOutputNotSupported = 94,
    IDXGIOutput_FindClosestMatchingMode_RemoteOutputNotSupported = 95,
    IDXGIOutput_GetDisplayModeList_RemoteOutputNotSupported = 96,
    IDXGIFactory_CreateSwapChain_pDeviceHasMismatchedDXGIFactory = 97,
    IDXGISwapChain_Present_NonOptimalFSConfiguration = 98,
    IDXGIFactory_CreateSwapChain_FlipSequentialNotSupportedOnD3D10 = 99,
    IDXGIFactory_CreateSwapChain_BufferCountOOBForFlipSequential = 100,
    IDXGIFactory_CreateSwapChain_InvalidFormatForFlipSequential = 101,
    IDXGIFactory_CreateSwapChain_MultiSamplingNotSupportedForFlipSequential = 102,
    IDXGISwapChain_ResizeBuffers_BufferCountOOBForFlipSequential = 103,
    IDXGISwapChain_ResizeBuffers_InvalidFormatForFlipSequential = 104,
    IDXGISwapChain_Present_PartialPresentationBeforeStandardPresentation = 105,
    IDXGISwapChain_Present_FullscreenPartialPresentIsInvalid = 106,
    IDXGISwapChain_Present_InvalidPresentTestOrDoNotSequenceFlag = 107,
    IDXGISwapChain_Present_ScrollInfoWithNoDirtyRectsSpecified = 108,
    IDXGISwapChain_Present_EmptyScrollRect = 109,
    IDXGISwapChain_Present_ScrollRectOutOfBackbufferBounds = 110,
    IDXGISwapChain_Present_ScrollRectOutOfBackbufferBoundsWithOffset = 111,
    IDXGISwapChain_Present_EmptyDirtyRect = 112,
    IDXGISwapChain_Present_DirtyRectOutOfBackbufferBounds = 113,
    IDXGIFactory_CreateSwapChain_UnsupportedBufferUsageFlags = 114,
    IDXGISwapChain_Present_DoNotSequenceFlagSetButPreviousBufferIsUndefined = 115,
    IDXGISwapChain_Present_UnsupportedFlags = 116,
    IDXGISwapChain_Present_FlipModelChainMustResizeOrCreateOnFSTransition = 117,
    IDXGIFactory_CreateSwapChain_pRestrictToOutputFromOtherIDXGIFactory = 118,
    IDXGIFactory_CreateSwapChain_RestrictOutputNotSupportedOnAdapter = 119,
    IDXGISwapChain_Present_RestrictToOutputFlagSetButInvalidpRestrictToOutput = 120,
    IDXGISwapChain_Present_RestrictToOutputFlagdWithFullscreen = 121,
    IDXGISwapChain_Present_RestrictOutputFlagWithStaleSwapChain = 122,
    IDXGISwapChain_Present_OtherFlagsCausingInvalidPresentTestFlag = 123,
    IDXGIFactory_CreateSwapChain_UnavailableInSession0 = 124,
    IDXGIFactory_MakeWindowAssociation_UnavailableInSession0 = 125,
    IDXGIFactory_GetWindowAssociation_UnavailableInSession0 = 126,
    IDXGIAdapter_EnumOutputs_UnavailableInSession0 = 127,
    IDXGISwapChain_CreationOrSetFullscreenState_StereoDisabled = 128,
    IDXGIFactory2_UnregisterStatus_CookieNotFound = 129,
    IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFSOrOverlay = 130,
    IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFlipSequential = 131,
    IDXGISwapChain_Present_ProtectedContentWithRDPDriver = 132,
    IDXGISwapChain_Present_ProtectedContentInWindowedModeWithDWMOffOrInvalidDisplayAffinity = 133,
    IDXGIFactory_CreateSwapChainForComposition_WidthOrHeightIsZero = 134,
    IDXGIFactory_CreateSwapChainForComposition_OnlyFlipSequentialSupported = 135,
    IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnAdapter = 136,
    IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnWindows7 = 137,
    IDXGISwapChain_SetFullscreenState_FSTransitionWithCompositionSwapChain = 138,
    IDXGISwapChain_ResizeTarget_InvalidWithCompositionSwapChain = 139,
    IDXGISwapChain_ResizeBuffers_WidthOrHeightIsZero = 140,
    IDXGIFactory_CreateSwapChain_ScalingNoneIsFlipModelOnly = 141,
    IDXGIFactory_CreateSwapChain_ScalingUnrecognized = 142,
    IDXGIFactory_CreateSwapChain_DisplayOnlyFullscreenUnsupported = 143,
    IDXGIFactory_CreateSwapChain_DisplayOnlyUnsupported = 144,
    IDXGISwapChain_Present_RestartIsFullscreenOnly = 145,
    IDXGISwapChain_Present_ProtectedWindowlessPresentationRequiresDisplayOnly = 146,
    IDXGISwapChain_SetFullscreenState_DisplayOnlyUnsupported = 147,
    IDXGISwapChain1_SetBackgroundColor_OutOfRange = 148,
    IDXGISwapChain_ResizeBuffers_DisplayOnlyFullscreenUnsupported = 149,
    IDXGISwapChain_ResizeBuffers_DisplayOnlyUnsupported = 150,
    IDXGISwapchain_Present_ScrollUnsupported = 151,
    IDXGISwapChain1_SetRotation_UnsupportedOS = 152,
    IDXGISwapChain1_GetRotation_UnsupportedOS = 153,
    IDXGISwapchain_Present_FullscreenRotation = 154,
    IDXGISwapChain_Present_PartialPresentationWithMSAABuffers = 155,
    IDXGISwapChain1_SetRotation_FlipSequentialRequired = 156,
    IDXGISwapChain1_SetRotation_InvalidRotation = 157,
    IDXGISwapChain1_GetRotation_FlipSequentialRequired = 158,
    IDXGISwapChain_GetHwnd_WrongType = 159,
    IDXGISwapChain_GetCompositionSurface_WrongType = 160,
    IDXGISwapChain_GetCoreWindow_WrongType = 161,
    IDXGISwapChain_GetFullscreenDesc_NonHwnd = 162,
    IDXGISwapChain_SetFullscreenState_CoreWindow = 163,
    IDXGIFactory2_CreateSwapChainForCoreWindow_UnsupportedOnWindows7 = 164,
    IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsNULL = 165,
    IDXGIFactory_CreateSwapChain_FSUnsupportedForModernApps = 166,
    IDXGIFactory_MakeWindowAssociation_ModernApp = 167,
    IDXGISwapChain_ResizeTarget_ModernApp = 168,
    IDXGISwapChain_ResizeTarget_pNewTargetParametersIsNULL = 169,
    IDXGIOutput_SetDisplaySurface_ModernApp = 170,
    IDXGIOutput_TakeOwnership_ModernApp = 171,
    IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsInvalid = 172,
    IDXGIFactory2_CreateSwapChainForCompositionSurface_InvalidHandle = 173,
    IDXGISurface1_GetDC_ModernApp = 174,
    IDXGIFactory_CreateSwapChain_ScalingNoneRequiresWindows8OrNewer = 175,
    IDXGISwapChain_Present_TemporaryMonoAndPreferRight = 176,
    IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithDoNotSequence = 177,
    IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithoutStereo = 178,
    IDXGISwapChain_Present_TemporaryMonoUnsupported = 179,
    IDXGIOutput_GetDisplaySurfaceData_ArraySizeMismatch = 180,
    IDXGISwapChain_Present_PartialPresentationWithSwapEffectDiscard = 181,
    IDXGIFactory_CreateSwapChain_AlphaUnrecognized = 182,
    IDXGIFactory_CreateSwapChain_AlphaIsWindowlessOnly = 183,
    IDXGIFactory_CreateSwapChain_AlphaIsFlipModelOnly = 184,
    IDXGIFactory_CreateSwapChain_RestrictToOutputAdapterMismatch = 185,
    IDXGIFactory_CreateSwapChain_DisplayOnlyOnLegacy = 186,
    IDXGISwapChain_ResizeBuffers_DisplayOnlyOnLegacy = 187,
    IDXGIResource1_CreateSubresourceSurface_InvalidIndex = 188,
    IDXGIFactory_CreateSwapChainForComposition_InvalidScaling = 189,
    IDXGIFactory_CreateSwapChainForCoreWindow_InvalidSwapEffect = 190,
    IDXGIResource1_CreateSharedHandle_UnsupportedOS = 191,
    IDXGIFactory2_RegisterOcclusionStatusWindow_UnsupportedOS = 192,
    IDXGIFactory2_RegisterOcclusionStatusEvent_UnsupportedOS = 193,
    IDXGIOutput1_DuplicateOutput_UnsupportedOS = 194,
    IDXGIDisplayControl_IsStereoEnabled_UnsupportedOS = 195,
    IDXGIFactory_CreateSwapChainForComposition_InvalidAlphaMode = 196,
    IDXGIFactory_GetSharedResourceAdapterLuid_InvalidResource = 197,
    IDXGIFactory_GetSharedResourceAdapterLuid_InvalidLUID = 198,
    IDXGIFactory_GetSharedResourceAdapterLuid_UnsupportedOS = 199,
    IDXGIOutput1_GetDisplaySurfaceData1_2DOnly = 200,
    IDXGIOutput1_GetDisplaySurfaceData1_StagingOnly = 201,
    IDXGIOutput1_GetDisplaySurfaceData1_NeedCPUAccessWrite = 202,
    IDXGIOutput1_GetDisplaySurfaceData1_NoShared = 203,
    IDXGIOutput1_GetDisplaySurfaceData1_OnlyMipLevels1 = 204,
    IDXGIOutput1_GetDisplaySurfaceData1_MappedOrOfferedResource = 205,
    IDXGISwapChain_SetFullscreenState_FSUnsupportedForModernApps = 206,
    IDXGIFactory_CreateSwapChain_FailedToGoFSButNonPreRotated = 207,
    IDXGIFactory_CreateSwapChainOrRegisterOcclusionStatus_BlitModelUsedWhileRegisteredForOcclusionStatusEvents = 208,
    IDXGISwapChain_Present_BlitModelUsedWhileRegisteredForOcclusionStatusEvents = 209,
    IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreFlipModelOnly = 210,
    IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreNotFullscreen = 211,
    IDXGISwapChain_SetFullscreenState_Waitable = 212,
    IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveWaitableFlag = 213,
    IDXGISwapChain_GetFrameLatencyWaitableObject_OnlyWaitable = 214,
    IDXGISwapChain_GetMaximumFrameLatency_OnlyWaitable = 215,
    IDXGISwapChain_GetMaximumFrameLatency_pMaxLatencyIsNULL = 216,
    IDXGISwapChain_SetMaximumFrameLatency_OnlyWaitable = 217,
    IDXGISwapChain_SetMaximumFrameLatency_MaxLatencyIsOutOfBounds = 218,
    IDXGIFactory_CreateSwapChain_ForegroundIsCoreWindowOnly = 219,
    IDXGIFactory2_CreateSwapChainForCoreWindow_ForegroundUnsupportedOnAdapter = 220,
    IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidScaling = 221,
    IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidAlphaMode = 222,
    IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveForegroundFlag = 223,
    IDXGISwapChain_SetMatrixTransform_MatrixPointerCannotBeNull = 224,
    IDXGISwapChain_SetMatrixTransform_RequiresCompositionSwapChain = 225,
    IDXGISwapChain_SetMatrixTransform_MatrixMustBeFinite = 226,
    IDXGISwapChain_SetMatrixTransform_MatrixMustBeTranslateAndOrScale = 227,
    IDXGISwapChain_GetMatrixTransform_MatrixPointerCannotBeNull = 228,
    IDXGISwapChain_GetMatrixTransform_RequiresCompositionSwapChain = 229,
    DXGIGetDebugInterface1_NULL_ppDebug = 230,
    DXGIGetDebugInterface1_InvalidFlags = 231,
    IDXGISwapChain_Present_Decode = 232,
    IDXGISwapChain_ResizeBuffers_Decode = 233,
    IDXGISwapChain_SetSourceSize_FlipModel = 234,
    IDXGISwapChain_SetSourceSize_Decode = 235,
    IDXGISwapChain_SetSourceSize_WidthHeight = 236,
    IDXGISwapChain_GetSourceSize_NullPointers = 237,
    IDXGISwapChain_GetSourceSize_Decode = 238,
    IDXGIDecodeSwapChain_SetColorSpace_InvalidFlags = 239,
    IDXGIDecodeSwapChain_SetSourceRect_InvalidRect = 240,
    IDXGIDecodeSwapChain_SetTargetRect_InvalidRect = 241,
    IDXGIDecodeSwapChain_SetDestSize_InvalidSize = 242,
    IDXGIDecodeSwapChain_GetSourceRect_InvalidPointer = 243,
    IDXGIDecodeSwapChain_GetTargetRect_InvalidPointer = 244,
    IDXGIDecodeSwapChain_GetDestSize_InvalidPointer = 245,
    IDXGISwapChain_PresentBuffer_YUV = 246,
    IDXGISwapChain_SetSourceSize_YUV = 247,
    IDXGISwapChain_GetSourceSize_YUV = 248,
    IDXGISwapChain_SetMatrixTransform_YUV = 249,
    IDXGISwapChain_GetMatrixTransform_YUV = 250,
    IDXGISwapChain_Present_PartialPresentation_YUV = 251,
    IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveFlag_YUV = 252,
    IDXGISwapChain_ResizeBuffers_Alignment_YUV = 253,
    IDXGIFactory_CreateSwapChain_ShaderInputUnsupported_YUV = 254,
    IDXGIOutput3_CheckOverlaySupport_NullPointers = 255,
    IDXGIOutput3_CheckOverlaySupport_IDXGIDeviceNotSupportedBypConcernedDevice = 256,
    IDXGIAdapter_EnumOutputs2_InvalidEnumOutputs2Flag = 257,
    IDXGISwapChain_CreationOrSetFullscreenState_FSUnsupportedForFlipDiscard = 258,
    IDXGIOutput4_CheckOverlayColorSpaceSupport_NullPointers = 259,
    IDXGIOutput4_CheckOverlayColorSpaceSupport_IDXGIDeviceNotSupportedBypConcernedDevice = 260,
    IDXGISwapChain3_CheckColorSpaceSupport_NullPointers = 261,
    IDXGISwapChain3_SetColorSpace1_InvalidColorSpace = 262,
    IDXGIFactory_CreateSwapChain_InvalidHwProtect = 263,
    IDXGIFactory_CreateSwapChain_HwProtectUnsupported = 264,
    IDXGISwapChain_ResizeBuffers_InvalidHwProtect = 265,
    IDXGISwapChain_ResizeBuffers_HwProtectUnsupported = 266,
    IDXGISwapChain_ResizeBuffers1_D3D12Only = 267,
    IDXGISwapChain_ResizeBuffers1_FlipModel = 268,
    IDXGISwapChain_ResizeBuffers1_NodeMaskAndQueueRequired = 269,
    IDXGISwapChain_CreateSwapChain_InvalidHwProtectGdiFlag = 270,
    IDXGISwapChain_ResizeBuffers_InvalidHwProtectGdiFlag = 271,
    IDXGIFactory_CreateSwapChain_10BitFormatNotSupported = 272,
    IDXGIFactory_CreateSwapChain_FlipSwapEffectRequired = 273,
    IDXGIFactory_CreateSwapChain_InvalidDevice = 274,
    IDXGIOutput_TakeOwnership_Unsupported = 275,
    IDXGIFactory_CreateSwapChain_InvalidQueue = 276,
    IDXGISwapChain3_ResizeBuffers1_InvalidQueue = 277,
    IDXGIFactory_CreateSwapChainForHwnd_InvalidScaling = 278,
    IDXGISwapChain3_SetHDRMetaData_InvalidSize = 279,
    IDXGISwapChain3_SetHDRMetaData_InvalidPointer = 280,
    IDXGISwapChain3_SetHDRMetaData_InvalidType = 281,
    IDXGISwapChain_Present_FullscreenAllowTearingIsInvalid = 282,
    IDXGISwapChain_Present_AllowTearingRequiresPresentIntervalZero = 283,
    IDXGISwapChain_Present_AllowTearingRequiresCreationFlag = 284,
    IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveAllowTearingFlag = 285,
    IDXGIFactory_CreateSwapChain_AllowTearingFlagIsFlipModelOnly = 286,
    IDXGIFactory_CheckFeatureSupport_InvalidFeature = 287,
    IDXGIFactory_CheckFeatureSupport_InvalidSize = 288,
    IDXGIOutput6_CheckHardwareCompositionSupport_NullPointer = 289,
    IDXGISwapChain_SetFullscreenState_PerMonitorDpiShimApplied = 290,
    IDXGIOutput_DuplicateOutput_PerMonitorDpiShimApplied = 291,
    IDXGIOutput_DuplicateOutput1_PerMonitorDpiRequired = 292,
    IDXGIFactory7_UnregisterAdaptersChangedEvent_CookieNotFound = 293,
    IDXGIFactory_CreateSwapChain_LegacyBltModelSwapEffect = 294,
    IDXGISwapChain4_SetHDRMetaData_MetadataUnchanged = 295,
    IDXGISwapChain_Present_11On12_Released_Resource = 296,
    IDXGIFactory_CreateSwapChain_MultipleSwapchainRefToSurface_DeferredDtr = 297,
    IDXGIFactory_MakeWindowAssociation_NoOpBehavior = 298,
    Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow = 1000,
    Phone_IDXGIFactory_CreateSwapChain_DISCARD_BufferCount = 1001,
    Phone_IDXGISwapChain_SetFullscreenState_NotAvailable = 1002,
    Phone_IDXGISwapChain_ResizeBuffers_NotAvailable = 1003,
    Phone_IDXGISwapChain_ResizeTarget_NotAvailable = 1004,
    Phone_IDXGISwapChain_Present_InvalidLayerIndex = 1005,
    Phone_IDXGISwapChain_Present_MultipleLayerIndex = 1006,
    Phone_IDXGISwapChain_Present_InvalidLayerFlag = 1007,
    Phone_IDXGISwapChain_Present_InvalidRotation = 1008,
    Phone_IDXGISwapChain_Present_InvalidBlend = 1009,
    Phone_IDXGISwapChain_Present_InvalidResource = 1010,
    Phone_IDXGISwapChain_Present_InvalidMultiPlaneOverlayResource = 1011,
    Phone_IDXGISwapChain_Present_InvalidIndexForPrimary = 1012,
    Phone_IDXGISwapChain_Present_InvalidIndexForOverlay = 1013,
    Phone_IDXGISwapChain_Present_InvalidSubResourceIndex = 1014,
    Phone_IDXGISwapChain_Present_InvalidSourceRect = 1015,
    Phone_IDXGISwapChain_Present_InvalidDestinationRect = 1016,
    Phone_IDXGISwapChain_Present_MultipleResource = 1017,
    Phone_IDXGISwapChain_Present_NotSharedResource = 1018,
    Phone_IDXGISwapChain_Present_InvalidFlag = 1019,
    Phone_IDXGISwapChain_Present_InvalidInterval = 1020,
    Phone_IDXGIFactory_CreateSwapChain_MSAA_NotSupported = 1021,
    Phone_IDXGIFactory_CreateSwapChain_ScalingAspectRatioStretch_Supported_ModernApp = 1022,
    Phone_IDXGISwapChain_GetFrameStatistics_NotAvailable_ModernApp = 1023,
    Phone_IDXGISwapChain_Present_ReplaceInterval0With1 = 1024,
    Phone_IDXGIFactory_CreateSwapChain_FailedRegisterWithCompositor = 1025,
    Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow_AtRendering = 1026,
    Phone_IDXGIFactory_CreateSwapChain_FLIP_SEQUENTIAL_BufferCount = 1027,
    Phone_IDXGIFactory_CreateSwapChain_FLIP_Modern_CoreWindow_Only = 1028,
    Phone_IDXGISwapChain_Present1_RequiresOverlays = 1029,
    Phone_IDXGISwapChain_SetBackgroundColor_FlipSequentialRequired = 1030,
    Phone_IDXGISwapChain_GetBackgroundColor_FlipSequentialRequired = 1031,
};
pub const DXGI_MSG_IDXGISwapChain_CreationOrResizeBuffers_InvalidOutputWindow = DXGI_Message_Id.IDXGISwapChain_CreationOrResizeBuffers_InvalidOutputWindow;
pub const DXGI_MSG_IDXGISwapChain_CreationOrResizeBuffers_BufferWidthInferred = DXGI_Message_Id.IDXGISwapChain_CreationOrResizeBuffers_BufferWidthInferred;
pub const DXGI_MSG_IDXGISwapChain_CreationOrResizeBuffers_BufferHeightInferred = DXGI_Message_Id.IDXGISwapChain_CreationOrResizeBuffers_BufferHeightInferred;
pub const DXGI_MSG_IDXGISwapChain_CreationOrResizeBuffers_NoScanoutFlagChanged = DXGI_Message_Id.IDXGISwapChain_CreationOrResizeBuffers_NoScanoutFlagChanged;
pub const DXGI_MSG_IDXGISwapChain_Creation_MaxBufferCountExceeded = DXGI_Message_Id.IDXGISwapChain_Creation_MaxBufferCountExceeded;
pub const DXGI_MSG_IDXGISwapChain_Creation_TooFewBuffers = DXGI_Message_Id.IDXGISwapChain_Creation_TooFewBuffers;
pub const DXGI_MSG_IDXGISwapChain_Creation_NoOutputWindow = DXGI_Message_Id.IDXGISwapChain_Creation_NoOutputWindow;
pub const DXGI_MSG_IDXGISwapChain_Destruction_OtherMethodsCalled = DXGI_Message_Id.IDXGISwapChain_Destruction_OtherMethodsCalled;
pub const DXGI_MSG_IDXGISwapChain_GetDesc_pDescIsNULL = DXGI_Message_Id.IDXGISwapChain_GetDesc_pDescIsNULL;
pub const DXGI_MSG_IDXGISwapChain_GetBuffer_ppSurfaceIsNULL = DXGI_Message_Id.IDXGISwapChain_GetBuffer_ppSurfaceIsNULL;
pub const DXGI_MSG_IDXGISwapChain_GetBuffer_NoAllocatedBuffers = DXGI_Message_Id.IDXGISwapChain_GetBuffer_NoAllocatedBuffers;
pub const DXGI_MSG_IDXGISwapChain_GetBuffer_iBufferMustBeZero = DXGI_Message_Id.IDXGISwapChain_GetBuffer_iBufferMustBeZero;
pub const DXGI_MSG_IDXGISwapChain_GetBuffer_iBufferOOB = DXGI_Message_Id.IDXGISwapChain_GetBuffer_iBufferOOB;
pub const DXGI_MSG_IDXGISwapChain_GetContainingOutput_ppOutputIsNULL = DXGI_Message_Id.IDXGISwapChain_GetContainingOutput_ppOutputIsNULL;
pub const DXGI_MSG_IDXGISwapChain_Present_SyncIntervalOOB = DXGI_Message_Id.IDXGISwapChain_Present_SyncIntervalOOB;
pub const DXGI_MSG_IDXGISwapChain_Present_InvalidNonPreRotatedFlag = DXGI_Message_Id.IDXGISwapChain_Present_InvalidNonPreRotatedFlag;
pub const DXGI_MSG_IDXGISwapChain_Present_NoAllocatedBuffers = DXGI_Message_Id.IDXGISwapChain_Present_NoAllocatedBuffers;
pub const DXGI_MSG_IDXGISwapChain_Present_GetDXGIAdapterFailed = DXGI_Message_Id.IDXGISwapChain_Present_GetDXGIAdapterFailed;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_BufferCountOOB = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_BufferCountOOB;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_UnreleasedReferences = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_UnreleasedReferences;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidSwapChainFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidSwapChainFlag;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidNonPreRotatedFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidNonPreRotatedFlag;
pub const DXGI_MSG_IDXGISwapChain_ResizeTarget_RefreshRateDivideByZero = DXGI_Message_Id.IDXGISwapChain_ResizeTarget_RefreshRateDivideByZero;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_InvalidTarget = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_InvalidTarget;
pub const DXGI_MSG_IDXGISwapChain_GetFrameStatistics_pStatsIsNULL = DXGI_Message_Id.IDXGISwapChain_GetFrameStatistics_pStatsIsNULL;
pub const DXGI_MSG_IDXGISwapChain_GetLastPresentCount_pLastPresentCountIsNULL = DXGI_Message_Id.IDXGISwapChain_GetLastPresentCount_pLastPresentCountIsNULL;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_RemoteNotSupported = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_RemoteNotSupported;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_FailedToAcquireFullscreenMutex = DXGI_Message_Id.IDXGIOutput_TakeOwnership_FailedToAcquireFullscreenMutex;
pub const DXGI_MSG_IDXGIFactory_CreateSoftwareAdapter_ppAdapterInterfaceIsNULL = DXGI_Message_Id.IDXGIFactory_CreateSoftwareAdapter_ppAdapterInterfaceIsNULL;
pub const DXGI_MSG_IDXGIFactory_EnumAdapters_ppAdapterInterfaceIsNULL = DXGI_Message_Id.IDXGIFactory_EnumAdapters_ppAdapterInterfaceIsNULL;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ppSwapChainIsNULL = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ppSwapChainIsNULL;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_pDescIsNULL = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_pDescIsNULL;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_UnknownSwapEffect = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_UnknownSwapEffect;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidFlags = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidFlags;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_NonPreRotatedFlagAndWindowed = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_NonPreRotatedFlagAndWindowed;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_NullDeviceInterface = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_NullDeviceInterface;
pub const DXGI_MSG_IDXGIFactory_GetWindowAssociation_phWndIsNULL = DXGI_Message_Id.IDXGIFactory_GetWindowAssociation_phWndIsNULL;
pub const DXGI_MSG_IDXGIFactory_MakeWindowAssociation_InvalidFlags = DXGI_Message_Id.IDXGIFactory_MakeWindowAssociation_InvalidFlags;
pub const DXGI_MSG_IDXGISurface_Map_InvalidSurface = DXGI_Message_Id.IDXGISurface_Map_InvalidSurface;
pub const DXGI_MSG_IDXGISurface_Map_FlagsSetToZero = DXGI_Message_Id.IDXGISurface_Map_FlagsSetToZero;
pub const DXGI_MSG_IDXGISurface_Map_DiscardAndReadFlagSet = DXGI_Message_Id.IDXGISurface_Map_DiscardAndReadFlagSet;
pub const DXGI_MSG_IDXGISurface_Map_DiscardButNotWriteFlagSet = DXGI_Message_Id.IDXGISurface_Map_DiscardButNotWriteFlagSet;
pub const DXGI_MSG_IDXGISurface_Map_NoCPUAccess = DXGI_Message_Id.IDXGISurface_Map_NoCPUAccess;
pub const DXGI_MSG_IDXGISurface_Map_ReadFlagSetButCPUAccessIsDynamic = DXGI_Message_Id.IDXGISurface_Map_ReadFlagSetButCPUAccessIsDynamic;
pub const DXGI_MSG_IDXGISurface_Map_DiscardFlagSetButCPUAccessIsNotDynamic = DXGI_Message_Id.IDXGISurface_Map_DiscardFlagSetButCPUAccessIsNotDynamic;
pub const DXGI_MSG_IDXGIOutput_GetDisplayModeList_pNumModesIsNULL = DXGI_Message_Id.IDXGIOutput_GetDisplayModeList_pNumModesIsNULL;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_ModeHasInvalidWidthOrHeight = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_ModeHasInvalidWidthOrHeight;
pub const DXGI_MSG_IDXGIOutput_GetCammaControlCapabilities_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_GetCammaControlCapabilities_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_pDeviceIsNULL = DXGI_Message_Id.IDXGIOutput_TakeOwnership_pDeviceIsNULL;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_pDestinationIsNULL = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_pDestinationIsNULL;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_MapOfDestinationFailed = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_MapOfDestinationFailed;
pub const DXGI_MSG_IDXGIOutput_GetFrameStatistics_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_GetFrameStatistics_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_GetFrameStatistics_pStatsIsNULL = DXGI_Message_Id.IDXGIOutput_GetFrameStatistics_pStatsIsNULL;
pub const DXGI_MSG_IDXGIOutput_SetGammaControl_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_SetGammaControl_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_GetGammaControl_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_GetGammaControl_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_GetGammaControl_NoGammaControls = DXGI_Message_Id.IDXGIOutput_GetGammaControl_NoGammaControls;
pub const DXGI_MSG_IDXGIOutput_SetDisplaySurface_IDXGIResourceNotSupportedBypPrimary = DXGI_Message_Id.IDXGIOutput_SetDisplaySurface_IDXGIResourceNotSupportedBypPrimary;
pub const DXGI_MSG_IDXGIOutput_SetDisplaySurface_pPrimaryIsInvalid = DXGI_Message_Id.IDXGIOutput_SetDisplaySurface_pPrimaryIsInvalid;
pub const DXGI_MSG_IDXGIOutput_SetDisplaySurface_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_SetDisplaySurface_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_RemoteDeviceNotSupported = DXGI_Message_Id.IDXGIOutput_TakeOwnership_RemoteDeviceNotSupported;
pub const DXGI_MSG_IDXGIOutput_GetDisplayModeList_RemoteDeviceNotSupported = DXGI_Message_Id.IDXGIOutput_GetDisplayModeList_RemoteDeviceNotSupported;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_RemoteDeviceNotSupported = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_RemoteDeviceNotSupported;
pub const DXGI_MSG_IDXGIDevice_CreateSurface_InvalidParametersWithpSharedResource = DXGI_Message_Id.IDXGIDevice_CreateSurface_InvalidParametersWithpSharedResource;
pub const DXGI_MSG_IDXGIObject_GetPrivateData_puiDataSizeIsNULL = DXGI_Message_Id.IDXGIObject_GetPrivateData_puiDataSizeIsNULL;
pub const DXGI_MSG_IDXGISwapChain_Creation_InvalidOutputWindow = DXGI_Message_Id.IDXGISwapChain_Creation_InvalidOutputWindow;
pub const DXGI_MSG_IDXGISwapChain_Release_SwapChainIsFullscreen = DXGI_Message_Id.IDXGISwapChain_Release_SwapChainIsFullscreen;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_InvalidTargetSurfaceFormat = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_InvalidTargetSurfaceFormat;
pub const DXGI_MSG_IDXGIFactory_CreateSoftwareAdapter_ModuleIsNULL = DXGI_Message_Id.IDXGIFactory_CreateSoftwareAdapter_ModuleIsNULL;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_IDXGIDeviceNotSupportedBypConcernedDevice = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_IDXGIDeviceNotSupportedBypConcernedDevice;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_pModeToMatchOrpClosestMatchIsNULL = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_pModeToMatchOrpClosestMatchIsNULL;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_ModeHasRefreshRateDenominatorZero = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_ModeHasRefreshRateDenominatorZero;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_UnknownFormatIsInvalidForConfiguration = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_UnknownFormatIsInvalidForConfiguration;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScanlineOrdering = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScanlineOrdering;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScaling = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScaling;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeFormatAndDeviceCombination = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeFormatAndDeviceCombination;
pub const DXGI_MSG_IDXGIFactory_Creation_CalledFromDllMain = DXGI_Message_Id.IDXGIFactory_Creation_CalledFromDllMain;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_OutputNotOwnedBySwapChainDevice = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_OutputNotOwnedBySwapChainDevice;
pub const DXGI_MSG_IDXGISwapChain_Creation_InvalidWindowStyle = DXGI_Message_Id.IDXGISwapChain_Creation_InvalidWindowStyle;
pub const DXGI_MSG_IDXGISwapChain_GetFrameStatistics_UnsupportedStatistics = DXGI_Message_Id.IDXGISwapChain_GetFrameStatistics_UnsupportedStatistics;
pub const DXGI_MSG_IDXGISwapChain_GetContainingOutput_SwapchainAdapterDoesNotControlOutput = DXGI_Message_Id.IDXGISwapChain_GetContainingOutput_SwapchainAdapterDoesNotControlOutput;
pub const DXGI_MSG_IDXGIOutput_SetOrGetGammaControl_pArrayIsNULL = DXGI_Message_Id.IDXGIOutput_SetOrGetGammaControl_pArrayIsNULL;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_FullscreenInvalidForChildWindows = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_FullscreenInvalidForChildWindows;
pub const DXGI_MSG_IDXGIFactory_Release_CalledFromDllMain = DXGI_Message_Id.IDXGIFactory_Release_CalledFromDllMain;
pub const DXGI_MSG_IDXGISwapChain_Present_UnreleasedHDC = DXGI_Message_Id.IDXGISwapChain_Present_UnreleasedHDC;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_NonPreRotatedAndGDICompatibleFlags = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_NonPreRotatedAndGDICompatibleFlags;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_NonPreRotatedAndGDICompatibleFlags = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_NonPreRotatedAndGDICompatibleFlags;
pub const DXGI_MSG_IDXGISurface1_GetDC_pHdcIsNULL = DXGI_Message_Id.IDXGISurface1_GetDC_pHdcIsNULL;
pub const DXGI_MSG_IDXGISurface1_GetDC_SurfaceNotTexture2D = DXGI_Message_Id.IDXGISurface1_GetDC_SurfaceNotTexture2D;
pub const DXGI_MSG_IDXGISurface1_GetDC_GDICompatibleFlagNotSet = DXGI_Message_Id.IDXGISurface1_GetDC_GDICompatibleFlagNotSet;
pub const DXGI_MSG_IDXGISurface1_GetDC_UnreleasedHDC = DXGI_Message_Id.IDXGISurface1_GetDC_UnreleasedHDC;
pub const DXGI_MSG_IDXGISurface_Map_NoCPUAccess2 = DXGI_Message_Id.IDXGISurface_Map_NoCPUAccess2;
pub const DXGI_MSG_IDXGISurface1_ReleaseDC_GetDCNotCalled = DXGI_Message_Id.IDXGISurface1_ReleaseDC_GetDCNotCalled;
pub const DXGI_MSG_IDXGISurface1_ReleaseDC_InvalidRectangleDimensions = DXGI_Message_Id.IDXGISurface1_ReleaseDC_InvalidRectangleDimensions;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_RemoteOutputNotSupported = DXGI_Message_Id.IDXGIOutput_TakeOwnership_RemoteOutputNotSupported;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_RemoteOutputNotSupported = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_RemoteOutputNotSupported;
pub const DXGI_MSG_IDXGIOutput_GetDisplayModeList_RemoteOutputNotSupported = DXGI_Message_Id.IDXGIOutput_GetDisplayModeList_RemoteOutputNotSupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_pDeviceHasMismatchedDXGIFactory = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_pDeviceHasMismatchedDXGIFactory;
pub const DXGI_MSG_IDXGISwapChain_Present_NonOptimalFSConfiguration = DXGI_Message_Id.IDXGISwapChain_Present_NonOptimalFSConfiguration;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_FlipSequentialNotSupportedOnD3D10 = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_FlipSequentialNotSupportedOnD3D10;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_BufferCountOOBForFlipSequential = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_BufferCountOOBForFlipSequential;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidFormatForFlipSequential = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidFormatForFlipSequential;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_MultiSamplingNotSupportedForFlipSequential = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_MultiSamplingNotSupportedForFlipSequential;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_BufferCountOOBForFlipSequential = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_BufferCountOOBForFlipSequential;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidFormatForFlipSequential = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidFormatForFlipSequential;
pub const DXGI_MSG_IDXGISwapChain_Present_PartialPresentationBeforeStandardPresentation = DXGI_Message_Id.IDXGISwapChain_Present_PartialPresentationBeforeStandardPresentation;
pub const DXGI_MSG_IDXGISwapChain_Present_FullscreenPartialPresentIsInvalid = DXGI_Message_Id.IDXGISwapChain_Present_FullscreenPartialPresentIsInvalid;
pub const DXGI_MSG_IDXGISwapChain_Present_InvalidPresentTestOrDoNotSequenceFlag = DXGI_Message_Id.IDXGISwapChain_Present_InvalidPresentTestOrDoNotSequenceFlag;
pub const DXGI_MSG_IDXGISwapChain_Present_ScrollInfoWithNoDirtyRectsSpecified = DXGI_Message_Id.IDXGISwapChain_Present_ScrollInfoWithNoDirtyRectsSpecified;
pub const DXGI_MSG_IDXGISwapChain_Present_EmptyScrollRect = DXGI_Message_Id.IDXGISwapChain_Present_EmptyScrollRect;
pub const DXGI_MSG_IDXGISwapChain_Present_ScrollRectOutOfBackbufferBounds = DXGI_Message_Id.IDXGISwapChain_Present_ScrollRectOutOfBackbufferBounds;
pub const DXGI_MSG_IDXGISwapChain_Present_ScrollRectOutOfBackbufferBoundsWithOffset = DXGI_Message_Id.IDXGISwapChain_Present_ScrollRectOutOfBackbufferBoundsWithOffset;
pub const DXGI_MSG_IDXGISwapChain_Present_EmptyDirtyRect = DXGI_Message_Id.IDXGISwapChain_Present_EmptyDirtyRect;
pub const DXGI_MSG_IDXGISwapChain_Present_DirtyRectOutOfBackbufferBounds = DXGI_Message_Id.IDXGISwapChain_Present_DirtyRectOutOfBackbufferBounds;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_UnsupportedBufferUsageFlags = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_UnsupportedBufferUsageFlags;
pub const DXGI_MSG_IDXGISwapChain_Present_DoNotSequenceFlagSetButPreviousBufferIsUndefined = DXGI_Message_Id.IDXGISwapChain_Present_DoNotSequenceFlagSetButPreviousBufferIsUndefined;
pub const DXGI_MSG_IDXGISwapChain_Present_UnsupportedFlags = DXGI_Message_Id.IDXGISwapChain_Present_UnsupportedFlags;
pub const DXGI_MSG_IDXGISwapChain_Present_FlipModelChainMustResizeOrCreateOnFSTransition = DXGI_Message_Id.IDXGISwapChain_Present_FlipModelChainMustResizeOrCreateOnFSTransition;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_pRestrictToOutputFromOtherIDXGIFactory = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_pRestrictToOutputFromOtherIDXGIFactory;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_RestrictOutputNotSupportedOnAdapter = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_RestrictOutputNotSupportedOnAdapter;
pub const DXGI_MSG_IDXGISwapChain_Present_RestrictToOutputFlagSetButInvalidpRestrictToOutput = DXGI_Message_Id.IDXGISwapChain_Present_RestrictToOutputFlagSetButInvalidpRestrictToOutput;
pub const DXGI_MSG_IDXGISwapChain_Present_RestrictToOutputFlagdWithFullscreen = DXGI_Message_Id.IDXGISwapChain_Present_RestrictToOutputFlagdWithFullscreen;
pub const DXGI_MSG_IDXGISwapChain_Present_RestrictOutputFlagWithStaleSwapChain = DXGI_Message_Id.IDXGISwapChain_Present_RestrictOutputFlagWithStaleSwapChain;
pub const DXGI_MSG_IDXGISwapChain_Present_OtherFlagsCausingInvalidPresentTestFlag = DXGI_Message_Id.IDXGISwapChain_Present_OtherFlagsCausingInvalidPresentTestFlag;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_UnavailableInSession0 = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_UnavailableInSession0;
pub const DXGI_MSG_IDXGIFactory_MakeWindowAssociation_UnavailableInSession0 = DXGI_Message_Id.IDXGIFactory_MakeWindowAssociation_UnavailableInSession0;
pub const DXGI_MSG_IDXGIFactory_GetWindowAssociation_UnavailableInSession0 = DXGI_Message_Id.IDXGIFactory_GetWindowAssociation_UnavailableInSession0;
pub const DXGI_MSG_IDXGIAdapter_EnumOutputs_UnavailableInSession0 = DXGI_Message_Id.IDXGIAdapter_EnumOutputs_UnavailableInSession0;
pub const DXGI_MSG_IDXGISwapChain_CreationOrSetFullscreenState_StereoDisabled = DXGI_Message_Id.IDXGISwapChain_CreationOrSetFullscreenState_StereoDisabled;
pub const DXGI_MSG_IDXGIFactory2_UnregisterStatus_CookieNotFound = DXGI_Message_Id.IDXGIFactory2_UnregisterStatus_CookieNotFound;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFSOrOverlay = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFSOrOverlay;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFlipSequential = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFlipSequential;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedContentWithRDPDriver = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedContentWithRDPDriver;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedContentInWindowedModeWithDWMOffOrInvalidDisplayAffinity = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedContentInWindowedModeWithDWMOffOrInvalidDisplayAffinity;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_WidthOrHeightIsZero = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_WidthOrHeightIsZero;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_OnlyFlipSequentialSupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_OnlyFlipSequentialSupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnAdapter = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnAdapter;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnWindows7 = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnWindows7;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_FSTransitionWithCompositionSwapChain = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_FSTransitionWithCompositionSwapChain;
pub const DXGI_MSG_IDXGISwapChain_ResizeTarget_InvalidWithCompositionSwapChain = DXGI_Message_Id.IDXGISwapChain_ResizeTarget_InvalidWithCompositionSwapChain;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_WidthOrHeightIsZero = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_WidthOrHeightIsZero;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ScalingNoneIsFlipModelOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ScalingNoneIsFlipModelOnly;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ScalingUnrecognized = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ScalingUnrecognized;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_DisplayOnlyFullscreenUnsupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_DisplayOnlyFullscreenUnsupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_DisplayOnlyUnsupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_DisplayOnlyUnsupported;
pub const DXGI_MSG_IDXGISwapChain_Present_RestartIsFullscreenOnly = DXGI_Message_Id.IDXGISwapChain_Present_RestartIsFullscreenOnly;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedWindowlessPresentationRequiresDisplayOnly = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedWindowlessPresentationRequiresDisplayOnly;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_DisplayOnlyUnsupported = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_DisplayOnlyUnsupported;
pub const DXGI_MSG_IDXGISwapChain1_SetBackgroundColor_OutOfRange = DXGI_Message_Id.IDXGISwapChain1_SetBackgroundColor_OutOfRange;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_DisplayOnlyFullscreenUnsupported = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_DisplayOnlyFullscreenUnsupported;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_DisplayOnlyUnsupported = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_DisplayOnlyUnsupported;
pub const DXGI_MSG_IDXGISwapchain_Present_ScrollUnsupported = DXGI_Message_Id.IDXGISwapchain_Present_ScrollUnsupported;
pub const DXGI_MSG_IDXGISwapChain1_SetRotation_UnsupportedOS = DXGI_Message_Id.IDXGISwapChain1_SetRotation_UnsupportedOS;
pub const DXGI_MSG_IDXGISwapChain1_GetRotation_UnsupportedOS = DXGI_Message_Id.IDXGISwapChain1_GetRotation_UnsupportedOS;
pub const DXGI_MSG_IDXGISwapchain_Present_FullscreenRotation = DXGI_Message_Id.IDXGISwapchain_Present_FullscreenRotation;
pub const DXGI_MSG_IDXGISwapChain_Present_PartialPresentationWithMSAABuffers = DXGI_Message_Id.IDXGISwapChain_Present_PartialPresentationWithMSAABuffers;
pub const DXGI_MSG_IDXGISwapChain1_SetRotation_FlipSequentialRequired = DXGI_Message_Id.IDXGISwapChain1_SetRotation_FlipSequentialRequired;
pub const DXGI_MSG_IDXGISwapChain1_SetRotation_InvalidRotation = DXGI_Message_Id.IDXGISwapChain1_SetRotation_InvalidRotation;
pub const DXGI_MSG_IDXGISwapChain1_GetRotation_FlipSequentialRequired = DXGI_Message_Id.IDXGISwapChain1_GetRotation_FlipSequentialRequired;
pub const DXGI_MSG_IDXGISwapChain_GetHwnd_WrongType = DXGI_Message_Id.IDXGISwapChain_GetHwnd_WrongType;
pub const DXGI_MSG_IDXGISwapChain_GetCompositionSurface_WrongType = DXGI_Message_Id.IDXGISwapChain_GetCompositionSurface_WrongType;
pub const DXGI_MSG_IDXGISwapChain_GetCoreWindow_WrongType = DXGI_Message_Id.IDXGISwapChain_GetCoreWindow_WrongType;
pub const DXGI_MSG_IDXGISwapChain_GetFullscreenDesc_NonHwnd = DXGI_Message_Id.IDXGISwapChain_GetFullscreenDesc_NonHwnd;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_CoreWindow = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_CoreWindow;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_UnsupportedOnWindows7 = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_UnsupportedOnWindows7;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsNULL = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsNULL;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_FSUnsupportedForModernApps = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_FSUnsupportedForModernApps;
pub const DXGI_MSG_IDXGIFactory_MakeWindowAssociation_ModernApp = DXGI_Message_Id.IDXGIFactory_MakeWindowAssociation_ModernApp;
pub const DXGI_MSG_IDXGISwapChain_ResizeTarget_ModernApp = DXGI_Message_Id.IDXGISwapChain_ResizeTarget_ModernApp;
pub const DXGI_MSG_IDXGISwapChain_ResizeTarget_pNewTargetParametersIsNULL = DXGI_Message_Id.IDXGISwapChain_ResizeTarget_pNewTargetParametersIsNULL;
pub const DXGI_MSG_IDXGIOutput_SetDisplaySurface_ModernApp = DXGI_Message_Id.IDXGIOutput_SetDisplaySurface_ModernApp;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_ModernApp = DXGI_Message_Id.IDXGIOutput_TakeOwnership_ModernApp;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsInvalid = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsInvalid;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCompositionSurface_InvalidHandle = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCompositionSurface_InvalidHandle;
pub const DXGI_MSG_IDXGISurface1_GetDC_ModernApp = DXGI_Message_Id.IDXGISurface1_GetDC_ModernApp;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ScalingNoneRequiresWindows8OrNewer = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ScalingNoneRequiresWindows8OrNewer;
pub const DXGI_MSG_IDXGISwapChain_Present_TemporaryMonoAndPreferRight = DXGI_Message_Id.IDXGISwapChain_Present_TemporaryMonoAndPreferRight;
pub const DXGI_MSG_IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithDoNotSequence = DXGI_Message_Id.IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithDoNotSequence;
pub const DXGI_MSG_IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithoutStereo = DXGI_Message_Id.IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithoutStereo;
pub const DXGI_MSG_IDXGISwapChain_Present_TemporaryMonoUnsupported = DXGI_Message_Id.IDXGISwapChain_Present_TemporaryMonoUnsupported;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_ArraySizeMismatch = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_ArraySizeMismatch;
pub const DXGI_MSG_IDXGISwapChain_Present_PartialPresentationWithSwapEffectDiscard = DXGI_Message_Id.IDXGISwapChain_Present_PartialPresentationWithSwapEffectDiscard;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_AlphaUnrecognized = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_AlphaUnrecognized;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_AlphaIsWindowlessOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_AlphaIsWindowlessOnly;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_AlphaIsFlipModelOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_AlphaIsFlipModelOnly;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_RestrictToOutputAdapterMismatch = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_RestrictToOutputAdapterMismatch;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_DisplayOnlyOnLegacy = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_DisplayOnlyOnLegacy;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_DisplayOnlyOnLegacy = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_DisplayOnlyOnLegacy;
pub const DXGI_MSG_IDXGIResource1_CreateSubresourceSurface_InvalidIndex = DXGI_Message_Id.IDXGIResource1_CreateSubresourceSurface_InvalidIndex;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_InvalidScaling = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_InvalidScaling;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForCoreWindow_InvalidSwapEffect = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForCoreWindow_InvalidSwapEffect;
pub const DXGI_MSG_IDXGIResource1_CreateSharedHandle_UnsupportedOS = DXGI_Message_Id.IDXGIResource1_CreateSharedHandle_UnsupportedOS;
pub const DXGI_MSG_IDXGIFactory2_RegisterOcclusionStatusWindow_UnsupportedOS = DXGI_Message_Id.IDXGIFactory2_RegisterOcclusionStatusWindow_UnsupportedOS;
pub const DXGI_MSG_IDXGIFactory2_RegisterOcclusionStatusEvent_UnsupportedOS = DXGI_Message_Id.IDXGIFactory2_RegisterOcclusionStatusEvent_UnsupportedOS;
pub const DXGI_MSG_IDXGIOutput1_DuplicateOutput_UnsupportedOS = DXGI_Message_Id.IDXGIOutput1_DuplicateOutput_UnsupportedOS;
pub const DXGI_MSG_IDXGIDisplayControl_IsStereoEnabled_UnsupportedOS = DXGI_Message_Id.IDXGIDisplayControl_IsStereoEnabled_UnsupportedOS;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_InvalidAlphaMode = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_InvalidAlphaMode;
pub const DXGI_MSG_IDXGIFactory_GetSharedResourceAdapterLuid_InvalidResource = DXGI_Message_Id.IDXGIFactory_GetSharedResourceAdapterLuid_InvalidResource;
pub const DXGI_MSG_IDXGIFactory_GetSharedResourceAdapterLuid_InvalidLUID = DXGI_Message_Id.IDXGIFactory_GetSharedResourceAdapterLuid_InvalidLUID;
pub const DXGI_MSG_IDXGIFactory_GetSharedResourceAdapterLuid_UnsupportedOS = DXGI_Message_Id.IDXGIFactory_GetSharedResourceAdapterLuid_UnsupportedOS;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_2DOnly = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_2DOnly;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_StagingOnly = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_StagingOnly;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_NeedCPUAccessWrite = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_NeedCPUAccessWrite;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_NoShared = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_NoShared;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_OnlyMipLevels1 = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_OnlyMipLevels1;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_MappedOrOfferedResource = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_MappedOrOfferedResource;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_FSUnsupportedForModernApps = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_FSUnsupportedForModernApps;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_FailedToGoFSButNonPreRotated = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_FailedToGoFSButNonPreRotated;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainOrRegisterOcclusionStatus_BlitModelUsedWhileRegisteredForOcclusionStatusEvents = DXGI_Message_Id.IDXGIFactory_CreateSwapChainOrRegisterOcclusionStatus_BlitModelUsedWhileRegisteredForOcclusionStatusEvents;
pub const DXGI_MSG_IDXGISwapChain_Present_BlitModelUsedWhileRegisteredForOcclusionStatusEvents = DXGI_Message_Id.IDXGISwapChain_Present_BlitModelUsedWhileRegisteredForOcclusionStatusEvents;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreFlipModelOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreFlipModelOnly;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreNotFullscreen = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreNotFullscreen;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_Waitable = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_Waitable;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveWaitableFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveWaitableFlag;
pub const DXGI_MSG_IDXGISwapChain_GetFrameLatencyWaitableObject_OnlyWaitable = DXGI_Message_Id.IDXGISwapChain_GetFrameLatencyWaitableObject_OnlyWaitable;
pub const DXGI_MSG_IDXGISwapChain_GetMaximumFrameLatency_OnlyWaitable = DXGI_Message_Id.IDXGISwapChain_GetMaximumFrameLatency_OnlyWaitable;
pub const DXGI_MSG_IDXGISwapChain_GetMaximumFrameLatency_pMaxLatencyIsNULL = DXGI_Message_Id.IDXGISwapChain_GetMaximumFrameLatency_pMaxLatencyIsNULL;
pub const DXGI_MSG_IDXGISwapChain_SetMaximumFrameLatency_OnlyWaitable = DXGI_Message_Id.IDXGISwapChain_SetMaximumFrameLatency_OnlyWaitable;
pub const DXGI_MSG_IDXGISwapChain_SetMaximumFrameLatency_MaxLatencyIsOutOfBounds = DXGI_Message_Id.IDXGISwapChain_SetMaximumFrameLatency_MaxLatencyIsOutOfBounds;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ForegroundIsCoreWindowOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ForegroundIsCoreWindowOnly;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_ForegroundUnsupportedOnAdapter = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_ForegroundUnsupportedOnAdapter;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidScaling = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidScaling;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidAlphaMode = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidAlphaMode;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveForegroundFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveForegroundFlag;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_MatrixPointerCannotBeNull = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_MatrixPointerCannotBeNull;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_RequiresCompositionSwapChain = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_RequiresCompositionSwapChain;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_MatrixMustBeFinite = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_MatrixMustBeFinite;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_MatrixMustBeTranslateAndOrScale = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_MatrixMustBeTranslateAndOrScale;
pub const DXGI_MSG_IDXGISwapChain_GetMatrixTransform_MatrixPointerCannotBeNull = DXGI_Message_Id.IDXGISwapChain_GetMatrixTransform_MatrixPointerCannotBeNull;
pub const DXGI_MSG_IDXGISwapChain_GetMatrixTransform_RequiresCompositionSwapChain = DXGI_Message_Id.IDXGISwapChain_GetMatrixTransform_RequiresCompositionSwapChain;
pub const DXGI_MSG_DXGIGetDebugInterface1_NULL_ppDebug = DXGI_Message_Id.DXGIGetDebugInterface1_NULL_ppDebug;
pub const DXGI_MSG_DXGIGetDebugInterface1_InvalidFlags = DXGI_Message_Id.DXGIGetDebugInterface1_InvalidFlags;
pub const DXGI_MSG_IDXGISwapChain_Present_Decode = DXGI_Message_Id.IDXGISwapChain_Present_Decode;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_Decode = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_Decode;
pub const DXGI_MSG_IDXGISwapChain_SetSourceSize_FlipModel = DXGI_Message_Id.IDXGISwapChain_SetSourceSize_FlipModel;
pub const DXGI_MSG_IDXGISwapChain_SetSourceSize_Decode = DXGI_Message_Id.IDXGISwapChain_SetSourceSize_Decode;
pub const DXGI_MSG_IDXGISwapChain_SetSourceSize_WidthHeight = DXGI_Message_Id.IDXGISwapChain_SetSourceSize_WidthHeight;
pub const DXGI_MSG_IDXGISwapChain_GetSourceSize_NullPointers = DXGI_Message_Id.IDXGISwapChain_GetSourceSize_NullPointers;
pub const DXGI_MSG_IDXGISwapChain_GetSourceSize_Decode = DXGI_Message_Id.IDXGISwapChain_GetSourceSize_Decode;
pub const DXGI_MSG_IDXGIDecodeSwapChain_SetColorSpace_InvalidFlags = DXGI_Message_Id.IDXGIDecodeSwapChain_SetColorSpace_InvalidFlags;
pub const DXGI_MSG_IDXGIDecodeSwapChain_SetSourceRect_InvalidRect = DXGI_Message_Id.IDXGIDecodeSwapChain_SetSourceRect_InvalidRect;
pub const DXGI_MSG_IDXGIDecodeSwapChain_SetTargetRect_InvalidRect = DXGI_Message_Id.IDXGIDecodeSwapChain_SetTargetRect_InvalidRect;
pub const DXGI_MSG_IDXGIDecodeSwapChain_SetDestSize_InvalidSize = DXGI_Message_Id.IDXGIDecodeSwapChain_SetDestSize_InvalidSize;
pub const DXGI_MSG_IDXGIDecodeSwapChain_GetSourceRect_InvalidPointer = DXGI_Message_Id.IDXGIDecodeSwapChain_GetSourceRect_InvalidPointer;
pub const DXGI_MSG_IDXGIDecodeSwapChain_GetTargetRect_InvalidPointer = DXGI_Message_Id.IDXGIDecodeSwapChain_GetTargetRect_InvalidPointer;
pub const DXGI_MSG_IDXGIDecodeSwapChain_GetDestSize_InvalidPointer = DXGI_Message_Id.IDXGIDecodeSwapChain_GetDestSize_InvalidPointer;
pub const DXGI_MSG_IDXGISwapChain_PresentBuffer_YUV = DXGI_Message_Id.IDXGISwapChain_PresentBuffer_YUV;
pub const DXGI_MSG_IDXGISwapChain_SetSourceSize_YUV = DXGI_Message_Id.IDXGISwapChain_SetSourceSize_YUV;
pub const DXGI_MSG_IDXGISwapChain_GetSourceSize_YUV = DXGI_Message_Id.IDXGISwapChain_GetSourceSize_YUV;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_YUV = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_YUV;
pub const DXGI_MSG_IDXGISwapChain_GetMatrixTransform_YUV = DXGI_Message_Id.IDXGISwapChain_GetMatrixTransform_YUV;
pub const DXGI_MSG_IDXGISwapChain_Present_PartialPresentation_YUV = DXGI_Message_Id.IDXGISwapChain_Present_PartialPresentation_YUV;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveFlag_YUV = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveFlag_YUV;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_Alignment_YUV = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_Alignment_YUV;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ShaderInputUnsupported_YUV = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ShaderInputUnsupported_YUV;
pub const DXGI_MSG_IDXGIOutput3_CheckOverlaySupport_NullPointers = DXGI_Message_Id.IDXGIOutput3_CheckOverlaySupport_NullPointers;
pub const DXGI_MSG_IDXGIOutput3_CheckOverlaySupport_IDXGIDeviceNotSupportedBypConcernedDevice = DXGI_Message_Id.IDXGIOutput3_CheckOverlaySupport_IDXGIDeviceNotSupportedBypConcernedDevice;
pub const DXGI_MSG_IDXGIAdapter_EnumOutputs2_InvalidEnumOutputs2Flag = DXGI_Message_Id.IDXGIAdapter_EnumOutputs2_InvalidEnumOutputs2Flag;
pub const DXGI_MSG_IDXGISwapChain_CreationOrSetFullscreenState_FSUnsupportedForFlipDiscard = DXGI_Message_Id.IDXGISwapChain_CreationOrSetFullscreenState_FSUnsupportedForFlipDiscard;
pub const DXGI_MSG_IDXGIOutput4_CheckOverlayColorSpaceSupport_NullPointers = DXGI_Message_Id.IDXGIOutput4_CheckOverlayColorSpaceSupport_NullPointers;
pub const DXGI_MSG_IDXGIOutput4_CheckOverlayColorSpaceSupport_IDXGIDeviceNotSupportedBypConcernedDevice = DXGI_Message_Id.IDXGIOutput4_CheckOverlayColorSpaceSupport_IDXGIDeviceNotSupportedBypConcernedDevice;
pub const DXGI_MSG_IDXGISwapChain3_CheckColorSpaceSupport_NullPointers = DXGI_Message_Id.IDXGISwapChain3_CheckColorSpaceSupport_NullPointers;
pub const DXGI_MSG_IDXGISwapChain3_SetColorSpace1_InvalidColorSpace = DXGI_Message_Id.IDXGISwapChain3_SetColorSpace1_InvalidColorSpace;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidHwProtect = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidHwProtect;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_HwProtectUnsupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_HwProtectUnsupported;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidHwProtect = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidHwProtect;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_HwProtectUnsupported = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_HwProtectUnsupported;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers1_D3D12Only = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers1_D3D12Only;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers1_FlipModel = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers1_FlipModel;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers1_NodeMaskAndQueueRequired = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers1_NodeMaskAndQueueRequired;
pub const DXGI_MSG_IDXGISwapChain_CreateSwapChain_InvalidHwProtectGdiFlag = DXGI_Message_Id.IDXGISwapChain_CreateSwapChain_InvalidHwProtectGdiFlag;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidHwProtectGdiFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidHwProtectGdiFlag;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_10BitFormatNotSupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_10BitFormatNotSupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_FlipSwapEffectRequired = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_FlipSwapEffectRequired;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidDevice = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidDevice;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_Unsupported = DXGI_Message_Id.IDXGIOutput_TakeOwnership_Unsupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidQueue = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidQueue;
pub const DXGI_MSG_IDXGISwapChain3_ResizeBuffers1_InvalidQueue = DXGI_Message_Id.IDXGISwapChain3_ResizeBuffers1_InvalidQueue;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForHwnd_InvalidScaling = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForHwnd_InvalidScaling;
pub const DXGI_MSG_IDXGISwapChain3_SetHDRMetaData_InvalidSize = DXGI_Message_Id.IDXGISwapChain3_SetHDRMetaData_InvalidSize;
pub const DXGI_MSG_IDXGISwapChain3_SetHDRMetaData_InvalidPointer = DXGI_Message_Id.IDXGISwapChain3_SetHDRMetaData_InvalidPointer;
pub const DXGI_MSG_IDXGISwapChain3_SetHDRMetaData_InvalidType = DXGI_Message_Id.IDXGISwapChain3_SetHDRMetaData_InvalidType;
pub const DXGI_MSG_IDXGISwapChain_Present_FullscreenAllowTearingIsInvalid = DXGI_Message_Id.IDXGISwapChain_Present_FullscreenAllowTearingIsInvalid;
pub const DXGI_MSG_IDXGISwapChain_Present_AllowTearingRequiresPresentIntervalZero = DXGI_Message_Id.IDXGISwapChain_Present_AllowTearingRequiresPresentIntervalZero;
pub const DXGI_MSG_IDXGISwapChain_Present_AllowTearingRequiresCreationFlag = DXGI_Message_Id.IDXGISwapChain_Present_AllowTearingRequiresCreationFlag;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveAllowTearingFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveAllowTearingFlag;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_AllowTearingFlagIsFlipModelOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_AllowTearingFlagIsFlipModelOnly;
pub const DXGI_MSG_IDXGIFactory_CheckFeatureSupport_InvalidFeature = DXGI_Message_Id.IDXGIFactory_CheckFeatureSupport_InvalidFeature;
pub const DXGI_MSG_IDXGIFactory_CheckFeatureSupport_InvalidSize = DXGI_Message_Id.IDXGIFactory_CheckFeatureSupport_InvalidSize;
pub const DXGI_MSG_IDXGIOutput6_CheckHardwareCompositionSupport_NullPointer = DXGI_Message_Id.IDXGIOutput6_CheckHardwareCompositionSupport_NullPointer;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_PerMonitorDpiShimApplied = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_PerMonitorDpiShimApplied;
pub const DXGI_MSG_IDXGIOutput_DuplicateOutput_PerMonitorDpiShimApplied = DXGI_Message_Id.IDXGIOutput_DuplicateOutput_PerMonitorDpiShimApplied;
pub const DXGI_MSG_IDXGIOutput_DuplicateOutput1_PerMonitorDpiRequired = DXGI_Message_Id.IDXGIOutput_DuplicateOutput1_PerMonitorDpiRequired;
pub const DXGI_MSG_IDXGIFactory7_UnregisterAdaptersChangedEvent_CookieNotFound = DXGI_Message_Id.IDXGIFactory7_UnregisterAdaptersChangedEvent_CookieNotFound;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_LegacyBltModelSwapEffect = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_LegacyBltModelSwapEffect;
pub const DXGI_MSG_IDXGISwapChain4_SetHDRMetaData_MetadataUnchanged = DXGI_Message_Id.IDXGISwapChain4_SetHDRMetaData_MetadataUnchanged;
pub const DXGI_MSG_IDXGISwapChain_Present_11On12_Released_Resource = DXGI_Message_Id.IDXGISwapChain_Present_11On12_Released_Resource;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_MultipleSwapchainRefToSurface_DeferredDtr = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_MultipleSwapchainRefToSurface_DeferredDtr;
pub const DXGI_MSG_IDXGIFactory_MakeWindowAssociation_NoOpBehavior = DXGI_Message_Id.IDXGIFactory_MakeWindowAssociation_NoOpBehavior;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_DISCARD_BufferCount = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_DISCARD_BufferCount;
pub const DXGI_MSG_Phone_IDXGISwapChain_SetFullscreenState_NotAvailable = DXGI_Message_Id.Phone_IDXGISwapChain_SetFullscreenState_NotAvailable;
pub const DXGI_MSG_Phone_IDXGISwapChain_ResizeBuffers_NotAvailable = DXGI_Message_Id.Phone_IDXGISwapChain_ResizeBuffers_NotAvailable;
pub const DXGI_MSG_Phone_IDXGISwapChain_ResizeTarget_NotAvailable = DXGI_Message_Id.Phone_IDXGISwapChain_ResizeTarget_NotAvailable;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidLayerIndex = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidLayerIndex;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_MultipleLayerIndex = DXGI_Message_Id.Phone_IDXGISwapChain_Present_MultipleLayerIndex;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidLayerFlag = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidLayerFlag;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidRotation = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidRotation;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidBlend = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidBlend;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidResource = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidResource;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidMultiPlaneOverlayResource = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidMultiPlaneOverlayResource;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidIndexForPrimary = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidIndexForPrimary;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidIndexForOverlay = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidIndexForOverlay;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidSubResourceIndex = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidSubResourceIndex;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidSourceRect = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidSourceRect;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidDestinationRect = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidDestinationRect;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_MultipleResource = DXGI_Message_Id.Phone_IDXGISwapChain_Present_MultipleResource;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_NotSharedResource = DXGI_Message_Id.Phone_IDXGISwapChain_Present_NotSharedResource;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidFlag = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidFlag;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidInterval = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidInterval;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_MSAA_NotSupported = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_MSAA_NotSupported;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_ScalingAspectRatioStretch_Supported_ModernApp = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_ScalingAspectRatioStretch_Supported_ModernApp;
pub const DXGI_MSG_Phone_IDXGISwapChain_GetFrameStatistics_NotAvailable_ModernApp = DXGI_Message_Id.Phone_IDXGISwapChain_GetFrameStatistics_NotAvailable_ModernApp;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_ReplaceInterval0With1 = DXGI_Message_Id.Phone_IDXGISwapChain_Present_ReplaceInterval0With1;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_FailedRegisterWithCompositor = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_FailedRegisterWithCompositor;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow_AtRendering = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow_AtRendering;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_FLIP_SEQUENTIAL_BufferCount = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_FLIP_SEQUENTIAL_BufferCount;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_FLIP_Modern_CoreWindow_Only = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_FLIP_Modern_CoreWindow_Only;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present1_RequiresOverlays = DXGI_Message_Id.Phone_IDXGISwapChain_Present1_RequiresOverlays;
pub const DXGI_MSG_Phone_IDXGISwapChain_SetBackgroundColor_FlipSequentialRequired = DXGI_Message_Id.Phone_IDXGISwapChain_SetBackgroundColor_FlipSequentialRequired;
pub const DXGI_MSG_Phone_IDXGISwapChain_GetBackgroundColor_FlipSequentialRequired = DXGI_Message_Id.Phone_IDXGISwapChain_GetBackgroundColor_FlipSequentialRequired;

const IID_IDXGraphicsAnalysis_Value = Guid.initString("9f251514-9d4d-4902-9d60-18988ab7d4b5");
pub const IID_IDXGraphicsAnalysis = &IID_IDXGraphicsAnalysis_Value;
pub const IDXGraphicsAnalysis = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginCapture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGraphicsAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGraphicsAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EndCapture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDXGraphicsAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDXGraphicsAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGraphicsAnalysis_BeginCapture(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGraphicsAnalysis.VTable, self.vtable).BeginCapture(@ptrCast(*const IDXGraphicsAnalysis, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGraphicsAnalysis_EndCapture(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGraphicsAnalysis.VTable, self.vtable).EndCapture(@ptrCast(*const IDXGraphicsAnalysis, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (5)
//--------------------------------------------------------------------------------
pub extern "dxgi" fn CreateDXGIFactory(
    riid: ?*const Guid,
    ppFactory: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "dxgi" fn CreateDXGIFactory1(
    riid: ?*const Guid,
    ppFactory: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "dxgi" fn CreateDXGIFactory2(
    Flags: u32,
    riid: ?*const Guid,
    ppFactory: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "dxgi" fn DXGIGetDebugInterface1(
    Flags: u32,
    riid: ?*const Guid,
    pDebug: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.17134'
pub extern "dxgi" fn DXGIDeclareAdapterRemovalSupport(
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (27)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const DXGI_ALPHA_MODE = @import("../graphics/dxgi/common.zig").DXGI_ALPHA_MODE;
const DXGI_COLOR_SPACE_TYPE = @import("../graphics/dxgi/common.zig").DXGI_COLOR_SPACE_TYPE;
const DXGI_FORMAT = @import("../graphics/dxgi/common.zig").DXGI_FORMAT;
const DXGI_GAMMA_CONTROL = @import("../graphics/dxgi/common.zig").DXGI_GAMMA_CONTROL;
const DXGI_GAMMA_CONTROL_CAPABILITIES = @import("../graphics/dxgi/common.zig").DXGI_GAMMA_CONTROL_CAPABILITIES;
const DXGI_MODE_DESC = @import("../graphics/dxgi/common.zig").DXGI_MODE_DESC;
const DXGI_MODE_ROTATION = @import("../graphics/dxgi/common.zig").DXGI_MODE_ROTATION;
const DXGI_MODE_SCALING = @import("../graphics/dxgi/common.zig").DXGI_MODE_SCALING;
const DXGI_MODE_SCANLINE_ORDER = @import("../graphics/dxgi/common.zig").DXGI_MODE_SCANLINE_ORDER;
const DXGI_RATIONAL = @import("../graphics/dxgi/common.zig").DXGI_RATIONAL;
const DXGI_SAMPLE_DESC = @import("../graphics/dxgi/common.zig").DXGI_SAMPLE_DESC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDC = @import("../graphics/gdi.zig").HDC;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const LUID = @import("../foundation.zig").LUID;
const POINT = @import("../foundation.zig").POINT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (1)
//--------------------------------------------------------------------------------
pub const common = @import("dxgi/common.zig");
