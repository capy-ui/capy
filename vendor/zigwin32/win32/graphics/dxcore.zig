//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (4)
//--------------------------------------------------------------------------------
pub const _FACDXCORE = @as(u32, 2176);
pub const DXCORE_ADAPTER_ATTRIBUTE_D3D11_GRAPHICS = Guid.initString("8c47866b-7583-450d-f0f0-6bada895af4b");
pub const DXCORE_ADAPTER_ATTRIBUTE_D3D12_GRAPHICS = Guid.initString("0c9ece4d-2f6e-4f01-8c96-e89e331b47b1");
pub const DXCORE_ADAPTER_ATTRIBUTE_D3D12_CORE_COMPUTE = Guid.initString("248e2800-a793-4724-abaa-23a6de1be090");

//--------------------------------------------------------------------------------
// Section: Types (13)
//--------------------------------------------------------------------------------
pub const DXCoreAdapterProperty = enum(u32) {
    InstanceLuid = 0,
    DriverVersion = 1,
    DriverDescription = 2,
    HardwareID = 3,
    KmdModelVersion = 4,
    ComputePreemptionGranularity = 5,
    GraphicsPreemptionGranularity = 6,
    DedicatedAdapterMemory = 7,
    DedicatedSystemMemory = 8,
    SharedSystemMemory = 9,
    AcgCompatible = 10,
    IsHardware = 11,
    IsIntegrated = 12,
    IsDetachable = 13,
    HardwareIDParts = 14,
};
pub const InstanceLuid = DXCoreAdapterProperty.InstanceLuid;
pub const DriverVersion = DXCoreAdapterProperty.DriverVersion;
pub const DriverDescription = DXCoreAdapterProperty.DriverDescription;
pub const HardwareID = DXCoreAdapterProperty.HardwareID;
pub const KmdModelVersion = DXCoreAdapterProperty.KmdModelVersion;
pub const ComputePreemptionGranularity = DXCoreAdapterProperty.ComputePreemptionGranularity;
pub const GraphicsPreemptionGranularity = DXCoreAdapterProperty.GraphicsPreemptionGranularity;
pub const DedicatedAdapterMemory = DXCoreAdapterProperty.DedicatedAdapterMemory;
pub const DedicatedSystemMemory = DXCoreAdapterProperty.DedicatedSystemMemory;
pub const SharedSystemMemory = DXCoreAdapterProperty.SharedSystemMemory;
pub const AcgCompatible = DXCoreAdapterProperty.AcgCompatible;
pub const IsHardware = DXCoreAdapterProperty.IsHardware;
pub const IsIntegrated = DXCoreAdapterProperty.IsIntegrated;
pub const IsDetachable = DXCoreAdapterProperty.IsDetachable;
pub const HardwareIDParts = DXCoreAdapterProperty.HardwareIDParts;

pub const DXCoreAdapterState = enum(u32) {
    IsDriverUpdateInProgress = 0,
    AdapterMemoryBudget = 1,
};
pub const IsDriverUpdateInProgress = DXCoreAdapterState.IsDriverUpdateInProgress;
pub const AdapterMemoryBudget = DXCoreAdapterState.AdapterMemoryBudget;

pub const DXCoreSegmentGroup = enum(u32) {
    Local = 0,
    NonLocal = 1,
};
pub const Local = DXCoreSegmentGroup.Local;
pub const NonLocal = DXCoreSegmentGroup.NonLocal;

pub const DXCoreNotificationType = enum(u32) {
    ListStale = 0,
    NoLongerValid = 1,
    BudgetChange = 2,
    HardwareContentProtectionTeardown = 3,
};
pub const AdapterListStale = DXCoreNotificationType.ListStale;
pub const AdapterNoLongerValid = DXCoreNotificationType.NoLongerValid;
pub const AdapterBudgetChange = DXCoreNotificationType.BudgetChange;
pub const AdapterHardwareContentProtectionTeardown = DXCoreNotificationType.HardwareContentProtectionTeardown;

pub const DXCoreAdapterPreference = enum(u32) {
    Hardware = 0,
    MinimumPower = 1,
    HighPerformance = 2,
};
pub const Hardware = DXCoreAdapterPreference.Hardware;
pub const MinimumPower = DXCoreAdapterPreference.MinimumPower;
pub const HighPerformance = DXCoreAdapterPreference.HighPerformance;

pub const DXCoreHardwareID = extern struct {
    vendorID: u32,
    deviceID: u32,
    subSysID: u32,
    revision: u32,
};

pub const DXCoreHardwareIDParts = extern struct {
    vendorID: u32,
    deviceID: u32,
    subSystemID: u32,
    subVendorID: u32,
    revisionID: u32,
};

pub const DXCoreAdapterMemoryBudgetNodeSegmentGroup = extern struct {
    nodeIndex: u32,
    segmentGroup: DXCoreSegmentGroup,
};

pub const DXCoreAdapterMemoryBudget = extern struct {
    budget: u64,
    currentUsage: u64,
    availableForReservation: u64,
    currentReservation: u64,
};

pub const PFN_DXCORE_NOTIFICATION_CALLBACK = *const fn(
    notificationType: DXCoreNotificationType,
    object: ?*IUnknown,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

const IID_IDXCoreAdapter_Value = Guid.initString("f0db4c7f-fe5a-42a2-bd62-f2a6cf6fc83e");
pub const IID_IDXCoreAdapter = &IID_IDXCoreAdapter_Value;
pub const IDXCoreAdapter = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsValid: *const fn(
            self: *const IDXCoreAdapter,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        IsAttributeSupported: *const fn(
            self: *const IDXCoreAdapter,
            attributeGUID: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        IsPropertySupported: *const fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterProperty,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        GetProperty: *const fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterProperty,
            bufferSize: usize,
            // TODO: what to do with BytesParamIndex 1?
            propertyData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertySize: *const fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterProperty,
            bufferSize: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsQueryStateSupported: *const fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterState,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        QueryState: *const fn(
            self: *const IDXCoreAdapter,
            state: DXCoreAdapterState,
            inputStateDetailsSize: usize,
            // TODO: what to do with BytesParamIndex 1?
            inputStateDetails: ?*const anyopaque,
            outputBufferSize: usize,
            // TODO: what to do with BytesParamIndex 3?
            outputBuffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSetStateSupported: *const fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterState,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        SetState: *const fn(
            self: *const IDXCoreAdapter,
            state: DXCoreAdapterState,
            inputStateDetailsSize: usize,
            // TODO: what to do with BytesParamIndex 1?
            inputStateDetails: ?*const anyopaque,
            inputDataSize: usize,
            // TODO: what to do with BytesParamIndex 3?
            inputData: ?*const anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFactory: *const fn(
            self: *const IDXCoreAdapter,
            riid: ?*const Guid,
            ppvFactory: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn IsValid(self: *const IDXCoreAdapter) callconv(.Inline) bool {
        return self.vtable.IsValid(self);
    }
    pub fn IsAttributeSupported(self: *const IDXCoreAdapter, attributeGUID: ?*const Guid) callconv(.Inline) bool {
        return self.vtable.IsAttributeSupported(self, attributeGUID);
    }
    pub fn IsPropertySupported(self: *const IDXCoreAdapter, property: DXCoreAdapterProperty) callconv(.Inline) bool {
        return self.vtable.IsPropertySupported(self, property);
    }
    pub fn GetProperty(self: *const IDXCoreAdapter, property: DXCoreAdapterProperty, bufferSize: usize, propertyData: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetProperty(self, property, bufferSize, propertyData);
    }
    pub fn GetPropertySize(self: *const IDXCoreAdapter, property: DXCoreAdapterProperty, bufferSize: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.GetPropertySize(self, property, bufferSize);
    }
    pub fn IsQueryStateSupported(self: *const IDXCoreAdapter, property: DXCoreAdapterState) callconv(.Inline) bool {
        return self.vtable.IsQueryStateSupported(self, property);
    }
    pub fn QueryState(self: *const IDXCoreAdapter, state: DXCoreAdapterState, inputStateDetailsSize: usize, inputStateDetails: ?*const anyopaque, outputBufferSize: usize, outputBuffer: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.QueryState(self, state, inputStateDetailsSize, inputStateDetails, outputBufferSize, outputBuffer);
    }
    pub fn IsSetStateSupported(self: *const IDXCoreAdapter, property: DXCoreAdapterState) callconv(.Inline) bool {
        return self.vtable.IsSetStateSupported(self, property);
    }
    pub fn SetState(self: *const IDXCoreAdapter, state: DXCoreAdapterState, inputStateDetailsSize: usize, inputStateDetails: ?*const anyopaque, inputDataSize: usize, inputData: ?*const anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.SetState(self, state, inputStateDetailsSize, inputStateDetails, inputDataSize, inputData);
    }
    pub fn GetFactory(self: *const IDXCoreAdapter, riid: ?*const Guid, ppvFactory: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetFactory(self, riid, ppvFactory);
    }
};

const IID_IDXCoreAdapterList_Value = Guid.initString("526c7776-40e9-459b-b711-f32ad76dfc28");
pub const IID_IDXCoreAdapterList = &IID_IDXCoreAdapterList_Value;
pub const IDXCoreAdapterList = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAdapter: *const fn(
            self: *const IDXCoreAdapterList,
            index: u32,
            riid: ?*const Guid,
            ppvAdapter: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterCount: *const fn(
            self: *const IDXCoreAdapterList,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        IsStale: *const fn(
            self: *const IDXCoreAdapterList,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        GetFactory: *const fn(
            self: *const IDXCoreAdapterList,
            riid: ?*const Guid,
            ppvFactory: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Sort: *const fn(
            self: *const IDXCoreAdapterList,
            numPreferences: u32,
            preferences: [*]const DXCoreAdapterPreference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAdapterPreferenceSupported: *const fn(
            self: *const IDXCoreAdapterList,
            preference: DXCoreAdapterPreference,
        ) callconv(@import("std").os.windows.WINAPI) bool,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetAdapter(self: *const IDXCoreAdapterList, index: u32, riid: ?*const Guid, ppvAdapter: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetAdapter(self, index, riid, ppvAdapter);
    }
    pub fn GetAdapterCount(self: *const IDXCoreAdapterList) callconv(.Inline) u32 {
        return self.vtable.GetAdapterCount(self);
    }
    pub fn IsStale(self: *const IDXCoreAdapterList) callconv(.Inline) bool {
        return self.vtable.IsStale(self);
    }
    pub fn GetFactory(self: *const IDXCoreAdapterList, riid: ?*const Guid, ppvFactory: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetFactory(self, riid, ppvFactory);
    }
    pub fn Sort(self: *const IDXCoreAdapterList, numPreferences: u32, preferences: [*]const DXCoreAdapterPreference) callconv(.Inline) HRESULT {
        return self.vtable.Sort(self, numPreferences, preferences);
    }
    pub fn IsAdapterPreferenceSupported(self: *const IDXCoreAdapterList, preference: DXCoreAdapterPreference) callconv(.Inline) bool {
        return self.vtable.IsAdapterPreferenceSupported(self, preference);
    }
};

const IID_IDXCoreAdapterFactory_Value = Guid.initString("78ee5945-c36e-4b13-a669-005dd11c0f06");
pub const IID_IDXCoreAdapterFactory = &IID_IDXCoreAdapterFactory_Value;
pub const IDXCoreAdapterFactory = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateAdapterList: *const fn(
            self: *const IDXCoreAdapterFactory,
            numAttributes: u32,
            filterAttributes: [*]const Guid,
            riid: ?*const Guid,
            ppvAdapterList: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterByLuid: *const fn(
            self: *const IDXCoreAdapterFactory,
            adapterLUID: ?*const LUID,
            riid: ?*const Guid,
            ppvAdapter: **anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsNotificationTypeSupported: *const fn(
            self: *const IDXCoreAdapterFactory,
            notificationType: DXCoreNotificationType,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        RegisterEventNotification: *const fn(
            self: *const IDXCoreAdapterFactory,
            dxCoreObject: ?*IUnknown,
            notificationType: DXCoreNotificationType,
            callbackFunction: ?PFN_DXCORE_NOTIFICATION_CALLBACK,
            callbackContext: ?*anyopaque,
            eventCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterEventNotification: *const fn(
            self: *const IDXCoreAdapterFactory,
            eventCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateAdapterList(self: *const IDXCoreAdapterFactory, numAttributes: u32, filterAttributes: [*]const Guid, riid: ?*const Guid, ppvAdapterList: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.CreateAdapterList(self, numAttributes, filterAttributes, riid, ppvAdapterList);
    }
    pub fn GetAdapterByLuid(self: *const IDXCoreAdapterFactory, adapterLUID: ?*const LUID, riid: ?*const Guid, ppvAdapter: **anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.GetAdapterByLuid(self, adapterLUID, riid, ppvAdapter);
    }
    pub fn IsNotificationTypeSupported(self: *const IDXCoreAdapterFactory, notificationType: DXCoreNotificationType) callconv(.Inline) bool {
        return self.vtable.IsNotificationTypeSupported(self, notificationType);
    }
    pub fn RegisterEventNotification(self: *const IDXCoreAdapterFactory, dxCoreObject: ?*IUnknown, notificationType: DXCoreNotificationType, callbackFunction: ?PFN_DXCORE_NOTIFICATION_CALLBACK, callbackContext: ?*anyopaque, eventCookie: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.RegisterEventNotification(self, dxCoreObject, notificationType, callbackFunction, callbackContext, eventCookie);
    }
    pub fn UnregisterEventNotification(self: *const IDXCoreAdapterFactory, eventCookie: u32) callconv(.Inline) HRESULT {
        return self.vtable.UnregisterEventNotification(self, eventCookie);
    }
};


//--------------------------------------------------------------------------------
// Section: Functions (1)
//--------------------------------------------------------------------------------
pub extern "dxcore" fn DXCoreCreateAdapterFactory(
    riid: ?*const Guid,
    ppvFactory: **anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
// Section: Imports (4)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const HRESULT = @import("../foundation.zig").HRESULT;
const IUnknown = @import("../system/com.zig").IUnknown;
const LUID = @import("../foundation.zig").LUID;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFN_DXCORE_NOTIFICATION_CALLBACK")) { _ = PFN_DXCORE_NOTIFICATION_CALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
