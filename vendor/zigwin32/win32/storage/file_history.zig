//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (42)
//--------------------------------------------------------------------------------
pub const FHCFG_E_CORRUPT_CONFIG_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220736));
pub const FHCFG_E_CONFIG_FILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220735));
pub const FHCFG_E_CONFIG_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220734));
pub const FHCFG_E_NO_VALID_CONFIGURATION_LOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220733));
pub const FHCFG_E_TARGET_NOT_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220732));
pub const FHCFG_E_CONFIGURATION_PREVIOUSLY_LOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220731));
pub const FHCFG_E_TARGET_VERIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220730));
pub const FHCFG_E_TARGET_NOT_CONFIGURED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220729));
pub const FHCFG_E_TARGET_NOT_ENOUGH_FREE_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220728));
pub const FHCFG_E_TARGET_CANNOT_BE_USED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220727));
pub const FHCFG_E_INVALID_REHYDRATION_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220726));
pub const FHCFG_E_RECOMMENDATION_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220720));
pub const FHCFG_E_TARGET_REHYDRATED_ELSEWHERE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220719));
pub const FHCFG_E_LEGACY_TARGET_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220718));
pub const FHCFG_E_LEGACY_TARGET_VALIDATION_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220717));
pub const FHCFG_E_LEGACY_BACKUP_USER_EXCLUDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220716));
pub const FHCFG_E_LEGACY_BACKUP_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220715));
pub const FHSVC_E_BACKUP_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219968));
pub const FHSVC_E_NOT_CONFIGURED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219967));
pub const FHSVC_E_CONFIG_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219966));
pub const FHSVC_E_CONFIG_DISABLED_GP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219965));
pub const FHSVC_E_FATAL_CONFIG_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219964));
pub const FHSVC_E_CONFIG_REHYDRATING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219963));
pub const FH_STATE_NOT_TRACKED = @as(u32, 0);
pub const FH_STATE_OFF = @as(u32, 1);
pub const FH_STATE_DISABLED_BY_GP = @as(u32, 2);
pub const FH_STATE_FATAL_CONFIG_ERROR = @as(u32, 3);
pub const FH_STATE_MIGRATING = @as(u32, 4);
pub const FH_STATE_REHYDRATING = @as(u32, 5);
pub const FH_STATE_TARGET_FS_LIMITATION = @as(u32, 13);
pub const FH_STATE_TARGET_ACCESS_DENIED = @as(u32, 14);
pub const FH_STATE_TARGET_VOLUME_DIRTY = @as(u32, 15);
pub const FH_STATE_TARGET_FULL_RETENTION_MAX = @as(u32, 16);
pub const FH_STATE_TARGET_FULL = @as(u32, 17);
pub const FH_STATE_STAGING_FULL = @as(u32, 18);
pub const FH_STATE_TARGET_LOW_SPACE_RETENTION_MAX = @as(u32, 19);
pub const FH_STATE_TARGET_LOW_SPACE = @as(u32, 20);
pub const FH_STATE_TARGET_ABSENT = @as(u32, 21);
pub const FH_STATE_TOO_MUCH_BEHIND = @as(u32, 240);
pub const FH_STATE_NO_ERROR = @as(u32, 255);
pub const FH_STATE_BACKUP_NOT_SUPPORTED = @as(u32, 2064);
pub const FH_STATE_RUNNING = @as(u32, 256);

//--------------------------------------------------------------------------------
// Section: Types (14)
//--------------------------------------------------------------------------------
const CLSID_FhConfigMgr_Value = Guid.initString("ed43bb3c-09e9-498a-9df6-2177244c6db4");
pub const CLSID_FhConfigMgr = &CLSID_FhConfigMgr_Value;

const CLSID_FhReassociation_Value = Guid.initString("4d728e35-16fa-4320-9e8b-bfd7100a8846");
pub const CLSID_FhReassociation = &CLSID_FhReassociation_Value;

pub const FH_TARGET_PROPERTY_TYPE = enum(i32) {
    FH_TARGET_NAME = 0,
    FH_TARGET_URL = 1,
    FH_TARGET_DRIVE_TYPE = 2,
    MAX_TARGET_PROPERTY = 3,
};
pub const FH_TARGET_NAME = FH_TARGET_PROPERTY_TYPE.FH_TARGET_NAME;
pub const FH_TARGET_URL = FH_TARGET_PROPERTY_TYPE.FH_TARGET_URL;
pub const FH_TARGET_DRIVE_TYPE = FH_TARGET_PROPERTY_TYPE.FH_TARGET_DRIVE_TYPE;
pub const MAX_TARGET_PROPERTY = FH_TARGET_PROPERTY_TYPE.MAX_TARGET_PROPERTY;

pub const FH_TARGET_DRIVE_TYPES = enum(i32) {
    UNKNOWN = 0,
    REMOVABLE = 2,
    FIXED = 3,
    REMOTE = 4,
};
pub const FH_DRIVE_UNKNOWN = FH_TARGET_DRIVE_TYPES.UNKNOWN;
pub const FH_DRIVE_REMOVABLE = FH_TARGET_DRIVE_TYPES.REMOVABLE;
pub const FH_DRIVE_FIXED = FH_TARGET_DRIVE_TYPES.FIXED;
pub const FH_DRIVE_REMOTE = FH_TARGET_DRIVE_TYPES.REMOTE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhTarget_Value = Guid.initString("d87965fd-2bad-4657-bd3b-9567eb300ced");
pub const IID_IFhTarget = &IID_IFhTarget_Value;
pub const IFhTarget = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringProperty: *const fn(
            self: *const IFhTarget,
            PropertyType: FH_TARGET_PROPERTY_TYPE,
            PropertyValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumericalProperty: *const fn(
            self: *const IFhTarget,
            PropertyType: FH_TARGET_PROPERTY_TYPE,
            PropertyValue: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetStringProperty(self: *const IFhTarget, PropertyType: FH_TARGET_PROPERTY_TYPE, PropertyValue: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetStringProperty(self, PropertyType, PropertyValue);
    }
    pub fn GetNumericalProperty(self: *const IFhTarget, PropertyType: FH_TARGET_PROPERTY_TYPE, PropertyValue: ?*u64) callconv(.Inline) HRESULT {
        return self.vtable.GetNumericalProperty(self, PropertyType, PropertyValue);
    }
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhScopeIterator_Value = Guid.initString("3197abce-532a-44c6-8615-f3666566a720");
pub const IID_IFhScopeIterator = &IID_IFhScopeIterator_Value;
pub const IFhScopeIterator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveToNextItem: *const fn(
            self: *const IFhScopeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: *const fn(
            self: *const IFhScopeIterator,
            Item: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn MoveToNextItem(self: *const IFhScopeIterator) callconv(.Inline) HRESULT {
        return self.vtable.MoveToNextItem(self);
    }
    pub fn GetItem(self: *const IFhScopeIterator, Item: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetItem(self, Item);
    }
};

pub const FH_PROTECTED_ITEM_CATEGORY = enum(i32) {
    FH_FOLDER = 0,
    FH_LIBRARY = 1,
    MAX_PROTECTED_ITEM_CATEGORY = 2,
};
pub const FH_FOLDER = FH_PROTECTED_ITEM_CATEGORY.FH_FOLDER;
pub const FH_LIBRARY = FH_PROTECTED_ITEM_CATEGORY.FH_LIBRARY;
pub const MAX_PROTECTED_ITEM_CATEGORY = FH_PROTECTED_ITEM_CATEGORY.MAX_PROTECTED_ITEM_CATEGORY;

pub const FH_LOCAL_POLICY_TYPE = enum(i32) {
    FH_FREQUENCY = 0,
    FH_RETENTION_TYPE = 1,
    FH_RETENTION_AGE = 2,
    MAX_LOCAL_POLICY = 3,
};
pub const FH_FREQUENCY = FH_LOCAL_POLICY_TYPE.FH_FREQUENCY;
pub const FH_RETENTION_TYPE = FH_LOCAL_POLICY_TYPE.FH_RETENTION_TYPE;
pub const FH_RETENTION_AGE = FH_LOCAL_POLICY_TYPE.FH_RETENTION_AGE;
pub const MAX_LOCAL_POLICY = FH_LOCAL_POLICY_TYPE.MAX_LOCAL_POLICY;

pub const FH_RETENTION_TYPES = enum(i32) {
    FH_RETENTION_DISABLED = 0,
    FH_RETENTION_UNLIMITED = 1,
    FH_RETENTION_AGE_BASED = 2,
    MAX_RETENTION_TYPE = 3,
};
pub const FH_RETENTION_DISABLED = FH_RETENTION_TYPES.FH_RETENTION_DISABLED;
pub const FH_RETENTION_UNLIMITED = FH_RETENTION_TYPES.FH_RETENTION_UNLIMITED;
pub const FH_RETENTION_AGE_BASED = FH_RETENTION_TYPES.FH_RETENTION_AGE_BASED;
pub const MAX_RETENTION_TYPE = FH_RETENTION_TYPES.MAX_RETENTION_TYPE;

pub const FH_BACKUP_STATUS = enum(i32) {
    FH_STATUS_DISABLED = 0,
    FH_STATUS_DISABLED_BY_GP = 1,
    FH_STATUS_ENABLED = 2,
    FH_STATUS_REHYDRATING = 3,
    MAX_BACKUP_STATUS = 4,
};
pub const FH_STATUS_DISABLED = FH_BACKUP_STATUS.FH_STATUS_DISABLED;
pub const FH_STATUS_DISABLED_BY_GP = FH_BACKUP_STATUS.FH_STATUS_DISABLED_BY_GP;
pub const FH_STATUS_ENABLED = FH_BACKUP_STATUS.FH_STATUS_ENABLED;
pub const FH_STATUS_REHYDRATING = FH_BACKUP_STATUS.FH_STATUS_REHYDRATING;
pub const MAX_BACKUP_STATUS = FH_BACKUP_STATUS.MAX_BACKUP_STATUS;

pub const FH_DEVICE_VALIDATION_RESULT = enum(i32) {
    FH_ACCESS_DENIED = 0,
    FH_INVALID_DRIVE_TYPE = 1,
    FH_READ_ONLY_PERMISSION = 2,
    FH_CURRENT_DEFAULT = 3,
    FH_NAMESPACE_EXISTS = 4,
    FH_TARGET_PART_OF_LIBRARY = 5,
    FH_VALID_TARGET = 6,
    MAX_VALIDATION_RESULT = 7,
};
pub const FH_ACCESS_DENIED = FH_DEVICE_VALIDATION_RESULT.FH_ACCESS_DENIED;
pub const FH_INVALID_DRIVE_TYPE = FH_DEVICE_VALIDATION_RESULT.FH_INVALID_DRIVE_TYPE;
pub const FH_READ_ONLY_PERMISSION = FH_DEVICE_VALIDATION_RESULT.FH_READ_ONLY_PERMISSION;
pub const FH_CURRENT_DEFAULT = FH_DEVICE_VALIDATION_RESULT.FH_CURRENT_DEFAULT;
pub const FH_NAMESPACE_EXISTS = FH_DEVICE_VALIDATION_RESULT.FH_NAMESPACE_EXISTS;
pub const FH_TARGET_PART_OF_LIBRARY = FH_DEVICE_VALIDATION_RESULT.FH_TARGET_PART_OF_LIBRARY;
pub const FH_VALID_TARGET = FH_DEVICE_VALIDATION_RESULT.FH_VALID_TARGET;
pub const MAX_VALIDATION_RESULT = FH_DEVICE_VALIDATION_RESULT.MAX_VALIDATION_RESULT;

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhConfigMgr_Value = Guid.initString("6a5fea5b-bf8f-4ee5-b8c3-44d8a0d7331c");
pub const IID_IFhConfigMgr = &IID_IFhConfigMgr_Value;
pub const IFhConfigMgr = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadConfiguration: *const fn(
            self: *const IFhConfigMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDefaultConfiguration: *const fn(
            self: *const IFhConfigMgr,
            OverwriteIfExists: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveConfiguration: *const fn(
            self: *const IFhConfigMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRemoveExcludeRule: *const fn(
            self: *const IFhConfigMgr,
            Add: BOOL,
            Category: FH_PROTECTED_ITEM_CATEGORY,
            Item: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIncludeExcludeRules: *const fn(
            self: *const IFhConfigMgr,
            Include: BOOL,
            Category: FH_PROTECTED_ITEM_CATEGORY,
            Iterator: ?*?*IFhScopeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalPolicy: *const fn(
            self: *const IFhConfigMgr,
            LocalPolicyType: FH_LOCAL_POLICY_TYPE,
            PolicyValue: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLocalPolicy: *const fn(
            self: *const IFhConfigMgr,
            LocalPolicyType: FH_LOCAL_POLICY_TYPE,
            PolicyValue: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupStatus: *const fn(
            self: *const IFhConfigMgr,
            BackupStatus: ?*FH_BACKUP_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupStatus: *const fn(
            self: *const IFhConfigMgr,
            BackupStatus: FH_BACKUP_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTarget: *const fn(
            self: *const IFhConfigMgr,
            DefaultTarget: ?*?*IFhTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateTarget: *const fn(
            self: *const IFhConfigMgr,
            TargetUrl: ?BSTR,
            ValidationResult: ?*FH_DEVICE_VALIDATION_RESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProvisionAndSetNewTarget: *const fn(
            self: *const IFhConfigMgr,
            TargetUrl: ?BSTR,
            TargetName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDefaultTargetRecommendation: *const fn(
            self: *const IFhConfigMgr,
            Recommend: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryProtectionStatus: *const fn(
            self: *const IFhConfigMgr,
            ProtectionState: ?*u32,
            ProtectedUntilTime: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn LoadConfiguration(self: *const IFhConfigMgr) callconv(.Inline) HRESULT {
        return self.vtable.LoadConfiguration(self);
    }
    pub fn CreateDefaultConfiguration(self: *const IFhConfigMgr, OverwriteIfExists: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.CreateDefaultConfiguration(self, OverwriteIfExists);
    }
    pub fn SaveConfiguration(self: *const IFhConfigMgr) callconv(.Inline) HRESULT {
        return self.vtable.SaveConfiguration(self);
    }
    pub fn AddRemoveExcludeRule(self: *const IFhConfigMgr, Add: BOOL, Category: FH_PROTECTED_ITEM_CATEGORY, Item: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.AddRemoveExcludeRule(self, Add, Category, Item);
    }
    pub fn GetIncludeExcludeRules(self: *const IFhConfigMgr, Include: BOOL, Category: FH_PROTECTED_ITEM_CATEGORY, Iterator: ?*?*IFhScopeIterator) callconv(.Inline) HRESULT {
        return self.vtable.GetIncludeExcludeRules(self, Include, Category, Iterator);
    }
    pub fn GetLocalPolicy(self: *const IFhConfigMgr, LocalPolicyType: FH_LOCAL_POLICY_TYPE, PolicyValue: ?*u64) callconv(.Inline) HRESULT {
        return self.vtable.GetLocalPolicy(self, LocalPolicyType, PolicyValue);
    }
    pub fn SetLocalPolicy(self: *const IFhConfigMgr, LocalPolicyType: FH_LOCAL_POLICY_TYPE, PolicyValue: u64) callconv(.Inline) HRESULT {
        return self.vtable.SetLocalPolicy(self, LocalPolicyType, PolicyValue);
    }
    pub fn GetBackupStatus(self: *const IFhConfigMgr, BackupStatus: ?*FH_BACKUP_STATUS) callconv(.Inline) HRESULT {
        return self.vtable.GetBackupStatus(self, BackupStatus);
    }
    pub fn SetBackupStatus(self: *const IFhConfigMgr, BackupStatus: FH_BACKUP_STATUS) callconv(.Inline) HRESULT {
        return self.vtable.SetBackupStatus(self, BackupStatus);
    }
    pub fn GetDefaultTarget(self: *const IFhConfigMgr, DefaultTarget: ?*?*IFhTarget) callconv(.Inline) HRESULT {
        return self.vtable.GetDefaultTarget(self, DefaultTarget);
    }
    pub fn ValidateTarget(self: *const IFhConfigMgr, TargetUrl: ?BSTR, ValidationResult: ?*FH_DEVICE_VALIDATION_RESULT) callconv(.Inline) HRESULT {
        return self.vtable.ValidateTarget(self, TargetUrl, ValidationResult);
    }
    pub fn ProvisionAndSetNewTarget(self: *const IFhConfigMgr, TargetUrl: ?BSTR, TargetName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.ProvisionAndSetNewTarget(self, TargetUrl, TargetName);
    }
    pub fn ChangeDefaultTargetRecommendation(self: *const IFhConfigMgr, Recommend: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.ChangeDefaultTargetRecommendation(self, Recommend);
    }
    pub fn QueryProtectionStatus(self: *const IFhConfigMgr, ProtectionState: ?*u32, ProtectedUntilTime: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.QueryProtectionStatus(self, ProtectionState, ProtectedUntilTime);
    }
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhReassociation_Value = Guid.initString("6544a28a-f68d-47ac-91ef-16b2b36aa3ee");
pub const IID_IFhReassociation = &IID_IFhReassociation_Value;
pub const IFhReassociation = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateTarget: *const fn(
            self: *const IFhReassociation,
            TargetUrl: ?BSTR,
            ValidationResult: ?*FH_DEVICE_VALIDATION_RESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScanTargetForConfigurations: *const fn(
            self: *const IFhReassociation,
            TargetUrl: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfigurationDetails: *const fn(
            self: *const IFhReassociation,
            Index: u32,
            UserName: ?*?BSTR,
            PcName: ?*?BSTR,
            BackupTime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectConfiguration: *const fn(
            self: *const IFhReassociation,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PerformReassociation: *const fn(
            self: *const IFhReassociation,
            OverwriteIfExists: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn ValidateTarget(self: *const IFhReassociation, TargetUrl: ?BSTR, ValidationResult: ?*FH_DEVICE_VALIDATION_RESULT) callconv(.Inline) HRESULT {
        return self.vtable.ValidateTarget(self, TargetUrl, ValidationResult);
    }
    pub fn ScanTargetForConfigurations(self: *const IFhReassociation, TargetUrl: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.ScanTargetForConfigurations(self, TargetUrl);
    }
    pub fn GetConfigurationDetails(self: *const IFhReassociation, Index: u32, UserName: ?*?BSTR, PcName: ?*?BSTR, BackupTime: ?*FILETIME) callconv(.Inline) HRESULT {
        return self.vtable.GetConfigurationDetails(self, Index, UserName, PcName, BackupTime);
    }
    pub fn SelectConfiguration(self: *const IFhReassociation, Index: u32) callconv(.Inline) HRESULT {
        return self.vtable.SelectConfiguration(self, Index);
    }
    pub fn PerformReassociation(self: *const IFhReassociation, OverwriteIfExists: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.PerformReassociation(self, OverwriteIfExists);
    }
};

pub const FhBackupStopReason = enum(i32) {
    InvalidStopReason = 0,
    LimitUserBusyMachineOnAC = 1,
    LimitUserIdleMachineOnDC = 2,
    LimitUserBusyMachineOnDC = 3,
    Cancelled = 4,
};
pub const BackupInvalidStopReason = FhBackupStopReason.InvalidStopReason;
pub const BackupLimitUserBusyMachineOnAC = FhBackupStopReason.LimitUserBusyMachineOnAC;
pub const BackupLimitUserIdleMachineOnDC = FhBackupStopReason.LimitUserIdleMachineOnDC;
pub const BackupLimitUserBusyMachineOnDC = FhBackupStopReason.LimitUserBusyMachineOnDC;
pub const BackupCancelled = FhBackupStopReason.Cancelled;


//--------------------------------------------------------------------------------
// Section: Functions (7)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceOpenPipe(
    StartServiceIfStopped: BOOL,
    Pipe: ?*FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceClosePipe(
    Pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceStartBackup(
    Pipe: FH_SERVICE_PIPE_HANDLE,
    LowPriorityIo: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceStopBackup(
    Pipe: FH_SERVICE_PIPE_HANDLE,
    StopTracking: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceReloadConfiguration(
    Pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceBlockBackup(
    Pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceUnblockBackup(
    Pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const FH_SERVICE_PIPE_HANDLE = @import("../system/windows_programming.zig").FH_SERVICE_PIPE_HANDLE;
const FILETIME = @import("../foundation.zig").FILETIME;
const HRESULT = @import("../foundation.zig").HRESULT;
const IUnknown = @import("../system/com.zig").IUnknown;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
