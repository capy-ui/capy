//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (97)
//--------------------------------------------------------------------------------
pub const OFFLINEFILES_SYNC_STATE_LOCAL_KNOWN = @as(u32, 1);
pub const OFFLINEFILES_SYNC_STATE_REMOTE_KNOWN = @as(u32, 2);
pub const OFFLINEFILES_CHANGES_NONE = @as(u32, 0);
pub const OFFLINEFILES_CHANGES_LOCAL_SIZE = @as(u32, 1);
pub const OFFLINEFILES_CHANGES_LOCAL_ATTRIBUTES = @as(u32, 2);
pub const OFFLINEFILES_CHANGES_LOCAL_TIME = @as(u32, 4);
pub const OFFLINEFILES_CHANGES_REMOTE_SIZE = @as(u32, 8);
pub const OFFLINEFILES_CHANGES_REMOTE_ATTRIBUTES = @as(u32, 16);
pub const OFFLINEFILES_CHANGES_REMOTE_TIME = @as(u32, 32);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_MODIFIED_DATA = @as(u32, 1);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_MODIFIED_ATTRIBUTES = @as(u32, 2);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_MODIFIED = @as(u32, 4);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_CREATED = @as(u32, 8);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_DELETED = @as(u32, 16);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_DIRTY = @as(u32, 32);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_SPARSE = @as(u32, 64);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_FILE = @as(u32, 128);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_DIRECTORY = @as(u32, 256);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_PINNED_USER = @as(u32, 512);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_PINNED_OTHERS = @as(u32, 1024);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_PINNED_COMPUTER = @as(u32, 2048);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_PINNED = @as(u32, 4096);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_GHOST = @as(u32, 8192);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_SUSPENDED = @as(u32, 16384);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_OFFLINE = @as(u32, 32768);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_ONLINE = @as(u32, 65536);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_USER_WRITE = @as(u32, 131072);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_USER_READ = @as(u32, 262144);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_USER_ANYACCESS = @as(u32, 524288);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_OTHER_WRITE = @as(u32, 1048576);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_OTHER_READ = @as(u32, 2097152);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_OTHER_ANYACCESS = @as(u32, 4194304);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_GUEST_WRITE = @as(u32, 8388608);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_GUEST_READ = @as(u32, 16777216);
pub const OFFLINEFILES_ITEM_FILTER_FLAG_GUEST_ANYACCESS = @as(u32, 33554432);
pub const OFFLINEFILES_ITEM_QUERY_REMOTEINFO = @as(u32, 1);
pub const OFFLINEFILES_ITEM_QUERY_CONNECTIONSTATE = @as(u32, 2);
pub const OFFLINEFILES_ITEM_QUERY_LOCALDIRTYBYTECOUNT = @as(u32, 4);
pub const OFFLINEFILES_ITEM_QUERY_REMOTEDIRTYBYTECOUNT = @as(u32, 8);
pub const OFFLINEFILES_ITEM_QUERY_INCLUDETRANSPARENTCACHE = @as(u32, 16);
pub const OFFLINEFILES_ITEM_QUERY_ATTEMPT_TRANSITIONONLINE = @as(u32, 32);
pub const OFFLINEFILES_ITEM_QUERY_ADMIN = @as(u32, 2147483648);
pub const OFFLINEFILES_ENUM_FLAT = @as(u32, 1);
pub const OFFLINEFILES_ENUM_FLAT_FILESONLY = @as(u32, 2);
pub const OFFLINEFILES_SETTING_SCOPE_USER = @as(u32, 1);
pub const OFFLINEFILES_SETTING_SCOPE_COMPUTER = @as(u32, 2);
pub const OFFLINEFILES_PINLINKTARGETS_NEVER = @as(u32, 0);
pub const OFFLINEFILES_PINLINKTARGETS_EXPLICIT = @as(u32, 1);
pub const OFFLINEFILES_PINLINKTARGETS_ALWAYS = @as(u32, 2);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_FILLSPARSE = @as(u32, 1);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_SYNCIN = @as(u32, 2);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_SYNCOUT = @as(u32, 4);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_PINNEWFILES = @as(u32, 8);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_PINLINKTARGETS = @as(u32, 16);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_PINFORUSER = @as(u32, 32);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_PINFORUSER_POLICY = @as(u32, 64);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_PINFORALL = @as(u32, 128);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_PINFORREDIR = @as(u32, 256);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_LOWPRIORITY = @as(u32, 512);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_ASYNCPROGRESS = @as(u32, 1024);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_INTERACTIVE = @as(u32, 2048);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_CONSOLE = @as(u32, 4096);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_SKIPSUSPENDEDDIRS = @as(u32, 8192);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_BACKGROUND = @as(u32, 65536);
pub const OFFLINEFILES_SYNC_CONTROL_FLAG_NONEWFILESOUT = @as(u32, 131072);
pub const OFFLINEFILES_SYNC_CONTROL_CR_MASK = @as(u32, 4026531840);
pub const OFFLINEFILES_SYNC_CONTROL_CR_DEFAULT = @as(u32, 0);
pub const OFFLINEFILES_SYNC_CONTROL_CR_KEEPLOCAL = @as(u32, 268435456);
pub const OFFLINEFILES_SYNC_CONTROL_CR_KEEPREMOTE = @as(u32, 536870912);
pub const OFFLINEFILES_SYNC_CONTROL_CR_KEEPLATEST = @as(u32, 805306368);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_FORUSER = @as(u32, 32);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_FORUSER_POLICY = @as(u32, 64);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_FORALL = @as(u32, 128);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_FORREDIR = @as(u32, 256);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_FILL = @as(u32, 1);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_LOWPRIORITY = @as(u32, 512);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_ASYNCPROGRESS = @as(u32, 1024);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_INTERACTIVE = @as(u32, 2048);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_CONSOLE = @as(u32, 4096);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_PINLINKTARGETS = @as(u32, 16);
pub const OFFLINEFILES_PIN_CONTROL_FLAG_BACKGROUND = @as(u32, 65536);
pub const OFFLINEFILES_ENCRYPTION_CONTROL_FLAG_LOWPRIORITY = @as(u32, 512);
pub const OFFLINEFILES_ENCRYPTION_CONTROL_FLAG_ASYNCPROGRESS = @as(u32, 1024);
pub const OFFLINEFILES_ENCRYPTION_CONTROL_FLAG_INTERACTIVE = @as(u32, 2048);
pub const OFFLINEFILES_ENCRYPTION_CONTROL_FLAG_CONSOLE = @as(u32, 4096);
pub const OFFLINEFILES_ENCRYPTION_CONTROL_FLAG_BACKGROUND = @as(u32, 65536);
pub const OFFLINEFILES_DELETE_FLAG_NOAUTOCACHED = @as(u32, 1);
pub const OFFLINEFILES_DELETE_FLAG_NOPINNED = @as(u32, 2);
pub const OFFLINEFILES_DELETE_FLAG_DELMODIFIED = @as(u32, 4);
pub const OFFLINEFILES_DELETE_FLAG_ADMIN = @as(u32, 2147483648);
pub const OFFLINEFILES_TRANSITION_FLAG_INTERACTIVE = @as(u32, 1);
pub const OFFLINEFILES_TRANSITION_FLAG_CONSOLE = @as(u32, 2);
pub const OFFLINEFILES_SYNC_ITEM_CHANGE_NONE = @as(u32, 0);
pub const OFFLINEFILES_SYNC_ITEM_CHANGE_CHANGETIME = @as(u32, 1);
pub const OFFLINEFILES_SYNC_ITEM_CHANGE_WRITETIME = @as(u32, 2);
pub const OFFLINEFILES_SYNC_ITEM_CHANGE_FILESIZE = @as(u32, 4);
pub const OFFLINEFILES_SYNC_ITEM_CHANGE_ATTRIBUTES = @as(u32, 8);

//--------------------------------------------------------------------------------
// Section: Types (51)
//--------------------------------------------------------------------------------
const CLSID_OfflineFilesSetting_Value = Guid.initString("fd3659e9-a920-4123-ad64-7fc76c7aacdf");
pub const CLSID_OfflineFilesSetting = &CLSID_OfflineFilesSetting_Value;

const CLSID_OfflineFilesCache_Value = Guid.initString("48c6be7c-3871-43cc-b46f-1449a1bb2ff3");
pub const CLSID_OfflineFilesCache = &CLSID_OfflineFilesCache_Value;

pub const OFFLINEFILES_ITEM_TYPE = enum(i32) {
    FILE = 0,
    DIRECTORY = 1,
    SHARE = 2,
    SERVER = 3,
};
pub const OFFLINEFILES_ITEM_TYPE_FILE = OFFLINEFILES_ITEM_TYPE.FILE;
pub const OFFLINEFILES_ITEM_TYPE_DIRECTORY = OFFLINEFILES_ITEM_TYPE.DIRECTORY;
pub const OFFLINEFILES_ITEM_TYPE_SHARE = OFFLINEFILES_ITEM_TYPE.SHARE;
pub const OFFLINEFILES_ITEM_TYPE_SERVER = OFFLINEFILES_ITEM_TYPE.SERVER;

pub const OFFLINEFILES_ITEM_COPY = enum(i32) {
    LOCAL = 0,
    REMOTE = 1,
    ORIGINAL = 2,
};
pub const OFFLINEFILES_ITEM_COPY_LOCAL = OFFLINEFILES_ITEM_COPY.LOCAL;
pub const OFFLINEFILES_ITEM_COPY_REMOTE = OFFLINEFILES_ITEM_COPY.REMOTE;
pub const OFFLINEFILES_ITEM_COPY_ORIGINAL = OFFLINEFILES_ITEM_COPY.ORIGINAL;

pub const OFFLINEFILES_CONNECT_STATE = enum(i32) {
    UNKNOWN = 0,
    OFFLINE = 1,
    ONLINE = 2,
    TRANSPARENTLY_CACHED = 3,
    PARTLY_TRANSPARENTLY_CACHED = 4,
};
pub const OFFLINEFILES_CONNECT_STATE_UNKNOWN = OFFLINEFILES_CONNECT_STATE.UNKNOWN;
pub const OFFLINEFILES_CONNECT_STATE_OFFLINE = OFFLINEFILES_CONNECT_STATE.OFFLINE;
pub const OFFLINEFILES_CONNECT_STATE_ONLINE = OFFLINEFILES_CONNECT_STATE.ONLINE;
pub const OFFLINEFILES_CONNECT_STATE_TRANSPARENTLY_CACHED = OFFLINEFILES_CONNECT_STATE.TRANSPARENTLY_CACHED;
pub const OFFLINEFILES_CONNECT_STATE_PARTLY_TRANSPARENTLY_CACHED = OFFLINEFILES_CONNECT_STATE.PARTLY_TRANSPARENTLY_CACHED;

pub const OFFLINEFILES_OFFLINE_REASON = enum(i32) {
    UNKNOWN = 0,
    NOT_APPLICABLE = 1,
    CONNECTION_FORCED = 2,
    CONNECTION_SLOW = 3,
    CONNECTION_ERROR = 4,
    ITEM_VERSION_CONFLICT = 5,
    ITEM_SUSPENDED = 6,
};
pub const OFFLINEFILES_OFFLINE_REASON_UNKNOWN = OFFLINEFILES_OFFLINE_REASON.UNKNOWN;
pub const OFFLINEFILES_OFFLINE_REASON_NOT_APPLICABLE = OFFLINEFILES_OFFLINE_REASON.NOT_APPLICABLE;
pub const OFFLINEFILES_OFFLINE_REASON_CONNECTION_FORCED = OFFLINEFILES_OFFLINE_REASON.CONNECTION_FORCED;
pub const OFFLINEFILES_OFFLINE_REASON_CONNECTION_SLOW = OFFLINEFILES_OFFLINE_REASON.CONNECTION_SLOW;
pub const OFFLINEFILES_OFFLINE_REASON_CONNECTION_ERROR = OFFLINEFILES_OFFLINE_REASON.CONNECTION_ERROR;
pub const OFFLINEFILES_OFFLINE_REASON_ITEM_VERSION_CONFLICT = OFFLINEFILES_OFFLINE_REASON.ITEM_VERSION_CONFLICT;
pub const OFFLINEFILES_OFFLINE_REASON_ITEM_SUSPENDED = OFFLINEFILES_OFFLINE_REASON.ITEM_SUSPENDED;

pub const OFFLINEFILES_CACHING_MODE = enum(i32) {
    NONE = 0,
    NOCACHING = 1,
    MANUAL = 2,
    AUTO_DOC = 3,
    AUTO_PROGANDDOC = 4,
};
pub const OFFLINEFILES_CACHING_MODE_NONE = OFFLINEFILES_CACHING_MODE.NONE;
pub const OFFLINEFILES_CACHING_MODE_NOCACHING = OFFLINEFILES_CACHING_MODE.NOCACHING;
pub const OFFLINEFILES_CACHING_MODE_MANUAL = OFFLINEFILES_CACHING_MODE.MANUAL;
pub const OFFLINEFILES_CACHING_MODE_AUTO_DOC = OFFLINEFILES_CACHING_MODE.AUTO_DOC;
pub const OFFLINEFILES_CACHING_MODE_AUTO_PROGANDDOC = OFFLINEFILES_CACHING_MODE.AUTO_PROGANDDOC;

pub const OFFLINEFILES_OP_RESPONSE = enum(i32) {
    CONTINUE = 0,
    RETRY = 1,
    ABORT = 2,
};
pub const OFFLINEFILES_OP_CONTINUE = OFFLINEFILES_OP_RESPONSE.CONTINUE;
pub const OFFLINEFILES_OP_RETRY = OFFLINEFILES_OP_RESPONSE.RETRY;
pub const OFFLINEFILES_OP_ABORT = OFFLINEFILES_OP_RESPONSE.ABORT;

pub const OFFLINEFILES_EVENTS = enum(i32) {
    EVENT_CACHEMOVED = 0,
    EVENT_CACHEISFULL = 1,
    EVENT_CACHEISCORRUPTED = 2,
    EVENT_ENABLED = 3,
    EVENT_ENCRYPTIONCHANGED = 4,
    EVENT_SYNCBEGIN = 5,
    EVENT_SYNCFILERESULT = 6,
    EVENT_SYNCCONFLICTRECADDED = 7,
    EVENT_SYNCCONFLICTRECUPDATED = 8,
    EVENT_SYNCCONFLICTRECREMOVED = 9,
    EVENT_SYNCEND = 10,
    EVENT_BACKGROUNDSYNCBEGIN = 11,
    EVENT_BACKGROUNDSYNCEND = 12,
    EVENT_NETTRANSPORTARRIVED = 13,
    EVENT_NONETTRANSPORTS = 14,
    EVENT_ITEMDISCONNECTED = 15,
    EVENT_ITEMRECONNECTED = 16,
    EVENT_ITEMAVAILABLEOFFLINE = 17,
    EVENT_ITEMNOTAVAILABLEOFFLINE = 18,
    EVENT_ITEMPINNED = 19,
    EVENT_ITEMNOTPINNED = 20,
    EVENT_ITEMMODIFIED = 21,
    EVENT_ITEMADDEDTOCACHE = 22,
    EVENT_ITEMDELETEDFROMCACHE = 23,
    EVENT_ITEMRENAMED = 24,
    EVENT_DATALOST = 25,
    EVENT_PING = 26,
    EVENT_ITEMRECONNECTBEGIN = 27,
    EVENT_ITEMRECONNECTEND = 28,
    EVENT_CACHEEVICTBEGIN = 29,
    EVENT_CACHEEVICTEND = 30,
    EVENT_POLICYCHANGEDETECTED = 31,
    EVENT_PREFERENCECHANGEDETECTED = 32,
    EVENT_SETTINGSCHANGESAPPLIED = 33,
    EVENT_TRANSPARENTCACHEITEMNOTIFY = 34,
    EVENT_PREFETCHFILEBEGIN = 35,
    EVENT_PREFETCHFILEEND = 36,
    EVENT_PREFETCHCLOSEHANDLEBEGIN = 37,
    EVENT_PREFETCHCLOSEHANDLEEND = 38,
    NUM_EVENTS = 39,
};
pub const OFFLINEFILES_EVENT_CACHEMOVED = OFFLINEFILES_EVENTS.EVENT_CACHEMOVED;
pub const OFFLINEFILES_EVENT_CACHEISFULL = OFFLINEFILES_EVENTS.EVENT_CACHEISFULL;
pub const OFFLINEFILES_EVENT_CACHEISCORRUPTED = OFFLINEFILES_EVENTS.EVENT_CACHEISCORRUPTED;
pub const OFFLINEFILES_EVENT_ENABLED = OFFLINEFILES_EVENTS.EVENT_ENABLED;
pub const OFFLINEFILES_EVENT_ENCRYPTIONCHANGED = OFFLINEFILES_EVENTS.EVENT_ENCRYPTIONCHANGED;
pub const OFFLINEFILES_EVENT_SYNCBEGIN = OFFLINEFILES_EVENTS.EVENT_SYNCBEGIN;
pub const OFFLINEFILES_EVENT_SYNCFILERESULT = OFFLINEFILES_EVENTS.EVENT_SYNCFILERESULT;
pub const OFFLINEFILES_EVENT_SYNCCONFLICTRECADDED = OFFLINEFILES_EVENTS.EVENT_SYNCCONFLICTRECADDED;
pub const OFFLINEFILES_EVENT_SYNCCONFLICTRECUPDATED = OFFLINEFILES_EVENTS.EVENT_SYNCCONFLICTRECUPDATED;
pub const OFFLINEFILES_EVENT_SYNCCONFLICTRECREMOVED = OFFLINEFILES_EVENTS.EVENT_SYNCCONFLICTRECREMOVED;
pub const OFFLINEFILES_EVENT_SYNCEND = OFFLINEFILES_EVENTS.EVENT_SYNCEND;
pub const OFFLINEFILES_EVENT_BACKGROUNDSYNCBEGIN = OFFLINEFILES_EVENTS.EVENT_BACKGROUNDSYNCBEGIN;
pub const OFFLINEFILES_EVENT_BACKGROUNDSYNCEND = OFFLINEFILES_EVENTS.EVENT_BACKGROUNDSYNCEND;
pub const OFFLINEFILES_EVENT_NETTRANSPORTARRIVED = OFFLINEFILES_EVENTS.EVENT_NETTRANSPORTARRIVED;
pub const OFFLINEFILES_EVENT_NONETTRANSPORTS = OFFLINEFILES_EVENTS.EVENT_NONETTRANSPORTS;
pub const OFFLINEFILES_EVENT_ITEMDISCONNECTED = OFFLINEFILES_EVENTS.EVENT_ITEMDISCONNECTED;
pub const OFFLINEFILES_EVENT_ITEMRECONNECTED = OFFLINEFILES_EVENTS.EVENT_ITEMRECONNECTED;
pub const OFFLINEFILES_EVENT_ITEMAVAILABLEOFFLINE = OFFLINEFILES_EVENTS.EVENT_ITEMAVAILABLEOFFLINE;
pub const OFFLINEFILES_EVENT_ITEMNOTAVAILABLEOFFLINE = OFFLINEFILES_EVENTS.EVENT_ITEMNOTAVAILABLEOFFLINE;
pub const OFFLINEFILES_EVENT_ITEMPINNED = OFFLINEFILES_EVENTS.EVENT_ITEMPINNED;
pub const OFFLINEFILES_EVENT_ITEMNOTPINNED = OFFLINEFILES_EVENTS.EVENT_ITEMNOTPINNED;
pub const OFFLINEFILES_EVENT_ITEMMODIFIED = OFFLINEFILES_EVENTS.EVENT_ITEMMODIFIED;
pub const OFFLINEFILES_EVENT_ITEMADDEDTOCACHE = OFFLINEFILES_EVENTS.EVENT_ITEMADDEDTOCACHE;
pub const OFFLINEFILES_EVENT_ITEMDELETEDFROMCACHE = OFFLINEFILES_EVENTS.EVENT_ITEMDELETEDFROMCACHE;
pub const OFFLINEFILES_EVENT_ITEMRENAMED = OFFLINEFILES_EVENTS.EVENT_ITEMRENAMED;
pub const OFFLINEFILES_EVENT_DATALOST = OFFLINEFILES_EVENTS.EVENT_DATALOST;
pub const OFFLINEFILES_EVENT_PING = OFFLINEFILES_EVENTS.EVENT_PING;
pub const OFFLINEFILES_EVENT_ITEMRECONNECTBEGIN = OFFLINEFILES_EVENTS.EVENT_ITEMRECONNECTBEGIN;
pub const OFFLINEFILES_EVENT_ITEMRECONNECTEND = OFFLINEFILES_EVENTS.EVENT_ITEMRECONNECTEND;
pub const OFFLINEFILES_EVENT_CACHEEVICTBEGIN = OFFLINEFILES_EVENTS.EVENT_CACHEEVICTBEGIN;
pub const OFFLINEFILES_EVENT_CACHEEVICTEND = OFFLINEFILES_EVENTS.EVENT_CACHEEVICTEND;
pub const OFFLINEFILES_EVENT_POLICYCHANGEDETECTED = OFFLINEFILES_EVENTS.EVENT_POLICYCHANGEDETECTED;
pub const OFFLINEFILES_EVENT_PREFERENCECHANGEDETECTED = OFFLINEFILES_EVENTS.EVENT_PREFERENCECHANGEDETECTED;
pub const OFFLINEFILES_EVENT_SETTINGSCHANGESAPPLIED = OFFLINEFILES_EVENTS.EVENT_SETTINGSCHANGESAPPLIED;
pub const OFFLINEFILES_EVENT_TRANSPARENTCACHEITEMNOTIFY = OFFLINEFILES_EVENTS.EVENT_TRANSPARENTCACHEITEMNOTIFY;
pub const OFFLINEFILES_EVENT_PREFETCHFILEBEGIN = OFFLINEFILES_EVENTS.EVENT_PREFETCHFILEBEGIN;
pub const OFFLINEFILES_EVENT_PREFETCHFILEEND = OFFLINEFILES_EVENTS.EVENT_PREFETCHFILEEND;
pub const OFFLINEFILES_EVENT_PREFETCHCLOSEHANDLEBEGIN = OFFLINEFILES_EVENTS.EVENT_PREFETCHCLOSEHANDLEBEGIN;
pub const OFFLINEFILES_EVENT_PREFETCHCLOSEHANDLEEND = OFFLINEFILES_EVENTS.EVENT_PREFETCHCLOSEHANDLEEND;
pub const OFFLINEFILES_NUM_EVENTS = OFFLINEFILES_EVENTS.NUM_EVENTS;

pub const OFFLINEFILES_PATHFILTER_MATCH = enum(i32) {
    SELF = 0,
    CHILD = 1,
    DESCENDENT = 2,
    SELFORCHILD = 3,
    SELFORDESCENDENT = 4,
};
pub const OFFLINEFILES_PATHFILTER_SELF = OFFLINEFILES_PATHFILTER_MATCH.SELF;
pub const OFFLINEFILES_PATHFILTER_CHILD = OFFLINEFILES_PATHFILTER_MATCH.CHILD;
pub const OFFLINEFILES_PATHFILTER_DESCENDENT = OFFLINEFILES_PATHFILTER_MATCH.DESCENDENT;
pub const OFFLINEFILES_PATHFILTER_SELFORCHILD = OFFLINEFILES_PATHFILTER_MATCH.SELFORCHILD;
pub const OFFLINEFILES_PATHFILTER_SELFORDESCENDENT = OFFLINEFILES_PATHFILTER_MATCH.SELFORDESCENDENT;

pub const OFFLINEFILES_SYNC_CONFLICT_RESOLVE = enum(i32) {
    RESOLVE_NONE = 0,
    RESOLVE_KEEPLOCAL = 1,
    RESOLVE_KEEPREMOTE = 2,
    RESOLVE_KEEPALLCHANGES = 3,
    RESOLVE_KEEPLATEST = 4,
    RESOLVE_LOG = 5,
    RESOLVE_SKIP = 6,
    ABORT = 7,
    RESOLVE_NUMCODES = 8,
};
pub const OFFLINEFILES_SYNC_CONFLICT_RESOLVE_NONE = OFFLINEFILES_SYNC_CONFLICT_RESOLVE.RESOLVE_NONE;
pub const OFFLINEFILES_SYNC_CONFLICT_RESOLVE_KEEPLOCAL = OFFLINEFILES_SYNC_CONFLICT_RESOLVE.RESOLVE_KEEPLOCAL;
pub const OFFLINEFILES_SYNC_CONFLICT_RESOLVE_KEEPREMOTE = OFFLINEFILES_SYNC_CONFLICT_RESOLVE.RESOLVE_KEEPREMOTE;
pub const OFFLINEFILES_SYNC_CONFLICT_RESOLVE_KEEPALLCHANGES = OFFLINEFILES_SYNC_CONFLICT_RESOLVE.RESOLVE_KEEPALLCHANGES;
pub const OFFLINEFILES_SYNC_CONFLICT_RESOLVE_KEEPLATEST = OFFLINEFILES_SYNC_CONFLICT_RESOLVE.RESOLVE_KEEPLATEST;
pub const OFFLINEFILES_SYNC_CONFLICT_RESOLVE_LOG = OFFLINEFILES_SYNC_CONFLICT_RESOLVE.RESOLVE_LOG;
pub const OFFLINEFILES_SYNC_CONFLICT_RESOLVE_SKIP = OFFLINEFILES_SYNC_CONFLICT_RESOLVE.RESOLVE_SKIP;
pub const OFFLINEFILES_SYNC_CONFLICT_ABORT = OFFLINEFILES_SYNC_CONFLICT_RESOLVE.ABORT;
pub const OFFLINEFILES_SYNC_CONFLICT_RESOLVE_NUMCODES = OFFLINEFILES_SYNC_CONFLICT_RESOLVE.RESOLVE_NUMCODES;

pub const OFFLINEFILES_ITEM_TIME = enum(i32) {
    CREATION = 0,
    LASTACCESS = 1,
    LASTWRITE = 2,
};
pub const OFFLINEFILES_ITEM_TIME_CREATION = OFFLINEFILES_ITEM_TIME.CREATION;
pub const OFFLINEFILES_ITEM_TIME_LASTACCESS = OFFLINEFILES_ITEM_TIME.LASTACCESS;
pub const OFFLINEFILES_ITEM_TIME_LASTWRITE = OFFLINEFILES_ITEM_TIME.LASTWRITE;

pub const OFFLINEFILES_COMPARE = enum(i32) {
    EQ = 0,
    NEQ = 1,
    LT = 2,
    GT = 3,
    LTE = 4,
    GTE = 5,
};
pub const OFFLINEFILES_COMPARE_EQ = OFFLINEFILES_COMPARE.EQ;
pub const OFFLINEFILES_COMPARE_NEQ = OFFLINEFILES_COMPARE.NEQ;
pub const OFFLINEFILES_COMPARE_LT = OFFLINEFILES_COMPARE.LT;
pub const OFFLINEFILES_COMPARE_GT = OFFLINEFILES_COMPARE.GT;
pub const OFFLINEFILES_COMPARE_LTE = OFFLINEFILES_COMPARE.LTE;
pub const OFFLINEFILES_COMPARE_GTE = OFFLINEFILES_COMPARE.GTE;

pub const OFFLINEFILES_SETTING_VALUE_TYPE = enum(i32) {
    UI4 = 0,
    BSTR = 1,
    BSTR_DBLNULTERM = 2,
    @"2DIM_ARRAY_BSTR_UI4" = 3,
    @"2DIM_ARRAY_BSTR_BSTR" = 4,
};
pub const OFFLINEFILES_SETTING_VALUE_UI4 = OFFLINEFILES_SETTING_VALUE_TYPE.UI4;
pub const OFFLINEFILES_SETTING_VALUE_BSTR = OFFLINEFILES_SETTING_VALUE_TYPE.BSTR;
pub const OFFLINEFILES_SETTING_VALUE_BSTR_DBLNULTERM = OFFLINEFILES_SETTING_VALUE_TYPE.BSTR_DBLNULTERM;
pub const OFFLINEFILES_SETTING_VALUE_2DIM_ARRAY_BSTR_UI4 = OFFLINEFILES_SETTING_VALUE_TYPE.@"2DIM_ARRAY_BSTR_UI4";
pub const OFFLINEFILES_SETTING_VALUE_2DIM_ARRAY_BSTR_BSTR = OFFLINEFILES_SETTING_VALUE_TYPE.@"2DIM_ARRAY_BSTR_BSTR";

pub const OFFLINEFILES_SYNC_OPERATION = enum(i32) {
    CREATE_COPY_ON_SERVER = 0,
    CREATE_COPY_ON_CLIENT = 1,
    SYNC_TO_SERVER = 2,
    SYNC_TO_CLIENT = 3,
    DELETE_SERVER_COPY = 4,
    DELETE_CLIENT_COPY = 5,
    PIN = 6,
    PREPARE = 7,
};
pub const OFFLINEFILES_SYNC_OPERATION_CREATE_COPY_ON_SERVER = OFFLINEFILES_SYNC_OPERATION.CREATE_COPY_ON_SERVER;
pub const OFFLINEFILES_SYNC_OPERATION_CREATE_COPY_ON_CLIENT = OFFLINEFILES_SYNC_OPERATION.CREATE_COPY_ON_CLIENT;
pub const OFFLINEFILES_SYNC_OPERATION_SYNC_TO_SERVER = OFFLINEFILES_SYNC_OPERATION.SYNC_TO_SERVER;
pub const OFFLINEFILES_SYNC_OPERATION_SYNC_TO_CLIENT = OFFLINEFILES_SYNC_OPERATION.SYNC_TO_CLIENT;
pub const OFFLINEFILES_SYNC_OPERATION_DELETE_SERVER_COPY = OFFLINEFILES_SYNC_OPERATION.DELETE_SERVER_COPY;
pub const OFFLINEFILES_SYNC_OPERATION_DELETE_CLIENT_COPY = OFFLINEFILES_SYNC_OPERATION.DELETE_CLIENT_COPY;
pub const OFFLINEFILES_SYNC_OPERATION_PIN = OFFLINEFILES_SYNC_OPERATION.PIN;
pub const OFFLINEFILES_SYNC_OPERATION_PREPARE = OFFLINEFILES_SYNC_OPERATION.PREPARE;

pub const OFFLINEFILES_SYNC_STATE = enum(i32) {
    Stable = 0,
    FileOnClient_DirOnServer = 1,
    FileOnClient_NoServerCopy = 2,
    DirOnClient_FileOnServer = 3,
    DirOnClient_FileChangedOnServer = 4,
    DirOnClient_NoServerCopy = 5,
    FileCreatedOnClient_NoServerCopy = 6,
    FileCreatedOnClient_FileChangedOnServer = 7,
    FileCreatedOnClient_DirChangedOnServer = 8,
    FileCreatedOnClient_FileOnServer = 9,
    FileCreatedOnClient_DirOnServer = 10,
    FileCreatedOnClient_DeletedOnServer = 11,
    FileChangedOnClient_ChangedOnServer = 12,
    FileChangedOnClient_DirOnServer = 13,
    FileChangedOnClient_DirChangedOnServer = 14,
    FileChangedOnClient_DeletedOnServer = 15,
    FileSparseOnClient_ChangedOnServer = 16,
    FileSparseOnClient_DeletedOnServer = 17,
    FileSparseOnClient_DirOnServer = 18,
    FileSparseOnClient_DirChangedOnServer = 19,
    DirCreatedOnClient_NoServerCopy = 20,
    DirCreatedOnClient_DirOnServer = 21,
    DirCreatedOnClient_FileOnServer = 22,
    DirCreatedOnClient_FileChangedOnServer = 23,
    DirCreatedOnClient_DirChangedOnServer = 24,
    DirCreatedOnClient_DeletedOnServer = 25,
    DirChangedOnClient_FileOnServer = 26,
    DirChangedOnClient_FileChangedOnServer = 27,
    DirChangedOnClient_ChangedOnServer = 28,
    DirChangedOnClient_DeletedOnServer = 29,
    NoClientCopy_FileOnServer = 30,
    NoClientCopy_DirOnServer = 31,
    NoClientCopy_FileChangedOnServer = 32,
    NoClientCopy_DirChangedOnServer = 33,
    DeletedOnClient_FileOnServer = 34,
    DeletedOnClient_DirOnServer = 35,
    DeletedOnClient_FileChangedOnServer = 36,
    DeletedOnClient_DirChangedOnServer = 37,
    FileSparseOnClient = 38,
    FileChangedOnClient = 39,
    FileRenamedOnClient = 40,
    DirSparseOnClient = 41,
    DirChangedOnClient = 42,
    DirRenamedOnClient = 43,
    FileChangedOnServer = 44,
    FileRenamedOnServer = 45,
    FileDeletedOnServer = 46,
    DirChangedOnServer = 47,
    DirRenamedOnServer = 48,
    DirDeletedOnServer = 49,
    FileReplacedAndDeletedOnClient_FileOnServer = 50,
    FileReplacedAndDeletedOnClient_FileChangedOnServer = 51,
    FileReplacedAndDeletedOnClient_DirOnServer = 52,
    FileReplacedAndDeletedOnClient_DirChangedOnServer = 53,
    NUMSTATES = 54,
};
pub const OFFLINEFILES_SYNC_STATE_Stable = OFFLINEFILES_SYNC_STATE.Stable;
pub const OFFLINEFILES_SYNC_STATE_FileOnClient_DirOnServer = OFFLINEFILES_SYNC_STATE.FileOnClient_DirOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileOnClient_NoServerCopy = OFFLINEFILES_SYNC_STATE.FileOnClient_NoServerCopy;
pub const OFFLINEFILES_SYNC_STATE_DirOnClient_FileOnServer = OFFLINEFILES_SYNC_STATE.DirOnClient_FileOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirOnClient_FileChangedOnServer = OFFLINEFILES_SYNC_STATE.DirOnClient_FileChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirOnClient_NoServerCopy = OFFLINEFILES_SYNC_STATE.DirOnClient_NoServerCopy;
pub const OFFLINEFILES_SYNC_STATE_FileCreatedOnClient_NoServerCopy = OFFLINEFILES_SYNC_STATE.FileCreatedOnClient_NoServerCopy;
pub const OFFLINEFILES_SYNC_STATE_FileCreatedOnClient_FileChangedOnServer = OFFLINEFILES_SYNC_STATE.FileCreatedOnClient_FileChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileCreatedOnClient_DirChangedOnServer = OFFLINEFILES_SYNC_STATE.FileCreatedOnClient_DirChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileCreatedOnClient_FileOnServer = OFFLINEFILES_SYNC_STATE.FileCreatedOnClient_FileOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileCreatedOnClient_DirOnServer = OFFLINEFILES_SYNC_STATE.FileCreatedOnClient_DirOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileCreatedOnClient_DeletedOnServer = OFFLINEFILES_SYNC_STATE.FileCreatedOnClient_DeletedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileChangedOnClient_ChangedOnServer = OFFLINEFILES_SYNC_STATE.FileChangedOnClient_ChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileChangedOnClient_DirOnServer = OFFLINEFILES_SYNC_STATE.FileChangedOnClient_DirOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileChangedOnClient_DirChangedOnServer = OFFLINEFILES_SYNC_STATE.FileChangedOnClient_DirChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileChangedOnClient_DeletedOnServer = OFFLINEFILES_SYNC_STATE.FileChangedOnClient_DeletedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileSparseOnClient_ChangedOnServer = OFFLINEFILES_SYNC_STATE.FileSparseOnClient_ChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileSparseOnClient_DeletedOnServer = OFFLINEFILES_SYNC_STATE.FileSparseOnClient_DeletedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileSparseOnClient_DirOnServer = OFFLINEFILES_SYNC_STATE.FileSparseOnClient_DirOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileSparseOnClient_DirChangedOnServer = OFFLINEFILES_SYNC_STATE.FileSparseOnClient_DirChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirCreatedOnClient_NoServerCopy = OFFLINEFILES_SYNC_STATE.DirCreatedOnClient_NoServerCopy;
pub const OFFLINEFILES_SYNC_STATE_DirCreatedOnClient_DirOnServer = OFFLINEFILES_SYNC_STATE.DirCreatedOnClient_DirOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirCreatedOnClient_FileOnServer = OFFLINEFILES_SYNC_STATE.DirCreatedOnClient_FileOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirCreatedOnClient_FileChangedOnServer = OFFLINEFILES_SYNC_STATE.DirCreatedOnClient_FileChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirCreatedOnClient_DirChangedOnServer = OFFLINEFILES_SYNC_STATE.DirCreatedOnClient_DirChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirCreatedOnClient_DeletedOnServer = OFFLINEFILES_SYNC_STATE.DirCreatedOnClient_DeletedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirChangedOnClient_FileOnServer = OFFLINEFILES_SYNC_STATE.DirChangedOnClient_FileOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirChangedOnClient_FileChangedOnServer = OFFLINEFILES_SYNC_STATE.DirChangedOnClient_FileChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirChangedOnClient_ChangedOnServer = OFFLINEFILES_SYNC_STATE.DirChangedOnClient_ChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirChangedOnClient_DeletedOnServer = OFFLINEFILES_SYNC_STATE.DirChangedOnClient_DeletedOnServer;
pub const OFFLINEFILES_SYNC_STATE_NoClientCopy_FileOnServer = OFFLINEFILES_SYNC_STATE.NoClientCopy_FileOnServer;
pub const OFFLINEFILES_SYNC_STATE_NoClientCopy_DirOnServer = OFFLINEFILES_SYNC_STATE.NoClientCopy_DirOnServer;
pub const OFFLINEFILES_SYNC_STATE_NoClientCopy_FileChangedOnServer = OFFLINEFILES_SYNC_STATE.NoClientCopy_FileChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_NoClientCopy_DirChangedOnServer = OFFLINEFILES_SYNC_STATE.NoClientCopy_DirChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DeletedOnClient_FileOnServer = OFFLINEFILES_SYNC_STATE.DeletedOnClient_FileOnServer;
pub const OFFLINEFILES_SYNC_STATE_DeletedOnClient_DirOnServer = OFFLINEFILES_SYNC_STATE.DeletedOnClient_DirOnServer;
pub const OFFLINEFILES_SYNC_STATE_DeletedOnClient_FileChangedOnServer = OFFLINEFILES_SYNC_STATE.DeletedOnClient_FileChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DeletedOnClient_DirChangedOnServer = OFFLINEFILES_SYNC_STATE.DeletedOnClient_DirChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileSparseOnClient = OFFLINEFILES_SYNC_STATE.FileSparseOnClient;
pub const OFFLINEFILES_SYNC_STATE_FileChangedOnClient = OFFLINEFILES_SYNC_STATE.FileChangedOnClient;
pub const OFFLINEFILES_SYNC_STATE_FileRenamedOnClient = OFFLINEFILES_SYNC_STATE.FileRenamedOnClient;
pub const OFFLINEFILES_SYNC_STATE_DirSparseOnClient = OFFLINEFILES_SYNC_STATE.DirSparseOnClient;
pub const OFFLINEFILES_SYNC_STATE_DirChangedOnClient = OFFLINEFILES_SYNC_STATE.DirChangedOnClient;
pub const OFFLINEFILES_SYNC_STATE_DirRenamedOnClient = OFFLINEFILES_SYNC_STATE.DirRenamedOnClient;
pub const OFFLINEFILES_SYNC_STATE_FileChangedOnServer = OFFLINEFILES_SYNC_STATE.FileChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileRenamedOnServer = OFFLINEFILES_SYNC_STATE.FileRenamedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileDeletedOnServer = OFFLINEFILES_SYNC_STATE.FileDeletedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirChangedOnServer = OFFLINEFILES_SYNC_STATE.DirChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirRenamedOnServer = OFFLINEFILES_SYNC_STATE.DirRenamedOnServer;
pub const OFFLINEFILES_SYNC_STATE_DirDeletedOnServer = OFFLINEFILES_SYNC_STATE.DirDeletedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileReplacedAndDeletedOnClient_FileOnServer = OFFLINEFILES_SYNC_STATE.FileReplacedAndDeletedOnClient_FileOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileReplacedAndDeletedOnClient_FileChangedOnServer = OFFLINEFILES_SYNC_STATE.FileReplacedAndDeletedOnClient_FileChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileReplacedAndDeletedOnClient_DirOnServer = OFFLINEFILES_SYNC_STATE.FileReplacedAndDeletedOnClient_DirOnServer;
pub const OFFLINEFILES_SYNC_STATE_FileReplacedAndDeletedOnClient_DirChangedOnServer = OFFLINEFILES_SYNC_STATE.FileReplacedAndDeletedOnClient_DirChangedOnServer;
pub const OFFLINEFILES_SYNC_STATE_NUMSTATES = OFFLINEFILES_SYNC_STATE.NUMSTATES;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesEvents_Value = Guid.initString("e25585c1-0caa-4eb1-873b-1cae5b77c314");
pub const IID_IOfflineFilesEvents = &IID_IOfflineFilesEvents_Value;
pub const IOfflineFilesEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CacheMoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszOldPath: ?[*:0]const u16,
                pszNewPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszOldPath: ?[*:0]const u16,
                pszNewPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CacheIsFull: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CacheIsCorrupted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                bEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                bEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EncryptionChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                bWasEncrypted: BOOL,
                bWasPartial: BOOL,
                bIsEncrypted: BOOL,
                bIsPartial: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                bWasEncrypted: BOOL,
                bWasPartial: BOOL,
                bIsEncrypted: BOOL,
                bIsPartial: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                rSyncId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                rSyncId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncFileResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                rSyncId: ?*const Guid,
                pszFile: ?[*:0]const u16,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                rSyncId: ?*const Guid,
                pszFile: ?[*:0]const u16,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncConflictRecAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszConflictPath: ?[*:0]const u16,
                pftConflictDateTime: ?*const FILETIME,
                ConflictSyncState: OFFLINEFILES_SYNC_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszConflictPath: ?[*:0]const u16,
                pftConflictDateTime: ?*const FILETIME,
                ConflictSyncState: OFFLINEFILES_SYNC_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncConflictRecUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszConflictPath: ?[*:0]const u16,
                pftConflictDateTime: ?*const FILETIME,
                ConflictSyncState: OFFLINEFILES_SYNC_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszConflictPath: ?[*:0]const u16,
                pftConflictDateTime: ?*const FILETIME,
                ConflictSyncState: OFFLINEFILES_SYNC_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncConflictRecRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszConflictPath: ?[*:0]const u16,
                pftConflictDateTime: ?*const FILETIME,
                ConflictSyncState: OFFLINEFILES_SYNC_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszConflictPath: ?[*:0]const u16,
                pftConflictDateTime: ?*const FILETIME,
                ConflictSyncState: OFFLINEFILES_SYNC_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                rSyncId: ?*const Guid,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                rSyncId: ?*const Guid,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NetTransportArrived: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NoNetTransports: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemDisconnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemReconnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemAvailableOffline: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemNotAvailableOffline: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemPinned: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemNotPinned: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemModified: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
                bModifiedData: BOOL,
                bModifiedAttributes: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
                bModifiedData: BOOL,
                bModifiedAttributes: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemAddedToCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemDeletedFromCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemRenamed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
                pszOldPath: ?[*:0]const u16,
                pszNewPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
                pszOldPath: ?[*:0]const u16,
                pszNewPath: ?[*:0]const u16,
                ItemType: OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DataLost: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Ping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_CacheMoved(self: *const T, pszOldPath: ?[*:0]const u16, pszNewPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).CacheMoved(@ptrCast(*const IOfflineFilesEvents, self), pszOldPath, pszNewPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_CacheIsFull(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).CacheIsFull(@ptrCast(*const IOfflineFilesEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_CacheIsCorrupted(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).CacheIsCorrupted(@ptrCast(*const IOfflineFilesEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_Enabled(self: *const T, bEnabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).Enabled(@ptrCast(*const IOfflineFilesEvents, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_EncryptionChanged(self: *const T, bWasEncrypted: BOOL, bWasPartial: BOOL, bIsEncrypted: BOOL, bIsPartial: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).EncryptionChanged(@ptrCast(*const IOfflineFilesEvents, self), bWasEncrypted, bWasPartial, bIsEncrypted, bIsPartial);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_SyncBegin(self: *const T, rSyncId: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).SyncBegin(@ptrCast(*const IOfflineFilesEvents, self), rSyncId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_SyncFileResult(self: *const T, rSyncId: ?*const Guid, pszFile: ?[*:0]const u16, hrResult: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).SyncFileResult(@ptrCast(*const IOfflineFilesEvents, self), rSyncId, pszFile, hrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_SyncConflictRecAdded(self: *const T, pszConflictPath: ?[*:0]const u16, pftConflictDateTime: ?*const FILETIME, ConflictSyncState: OFFLINEFILES_SYNC_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).SyncConflictRecAdded(@ptrCast(*const IOfflineFilesEvents, self), pszConflictPath, pftConflictDateTime, ConflictSyncState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_SyncConflictRecUpdated(self: *const T, pszConflictPath: ?[*:0]const u16, pftConflictDateTime: ?*const FILETIME, ConflictSyncState: OFFLINEFILES_SYNC_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).SyncConflictRecUpdated(@ptrCast(*const IOfflineFilesEvents, self), pszConflictPath, pftConflictDateTime, ConflictSyncState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_SyncConflictRecRemoved(self: *const T, pszConflictPath: ?[*:0]const u16, pftConflictDateTime: ?*const FILETIME, ConflictSyncState: OFFLINEFILES_SYNC_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).SyncConflictRecRemoved(@ptrCast(*const IOfflineFilesEvents, self), pszConflictPath, pftConflictDateTime, ConflictSyncState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_SyncEnd(self: *const T, rSyncId: ?*const Guid, hrResult: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).SyncEnd(@ptrCast(*const IOfflineFilesEvents, self), rSyncId, hrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_NetTransportArrived(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).NetTransportArrived(@ptrCast(*const IOfflineFilesEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_NoNetTransports(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).NoNetTransports(@ptrCast(*const IOfflineFilesEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemDisconnected(self: *const T, pszPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemDisconnected(@ptrCast(*const IOfflineFilesEvents, self), pszPath, ItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemReconnected(self: *const T, pszPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemReconnected(@ptrCast(*const IOfflineFilesEvents, self), pszPath, ItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemAvailableOffline(self: *const T, pszPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemAvailableOffline(@ptrCast(*const IOfflineFilesEvents, self), pszPath, ItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemNotAvailableOffline(self: *const T, pszPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemNotAvailableOffline(@ptrCast(*const IOfflineFilesEvents, self), pszPath, ItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemPinned(self: *const T, pszPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemPinned(@ptrCast(*const IOfflineFilesEvents, self), pszPath, ItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemNotPinned(self: *const T, pszPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemNotPinned(@ptrCast(*const IOfflineFilesEvents, self), pszPath, ItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemModified(self: *const T, pszPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE, bModifiedData: BOOL, bModifiedAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemModified(@ptrCast(*const IOfflineFilesEvents, self), pszPath, ItemType, bModifiedData, bModifiedAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemAddedToCache(self: *const T, pszPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemAddedToCache(@ptrCast(*const IOfflineFilesEvents, self), pszPath, ItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemDeletedFromCache(self: *const T, pszPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemDeletedFromCache(@ptrCast(*const IOfflineFilesEvents, self), pszPath, ItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_ItemRenamed(self: *const T, pszOldPath: ?[*:0]const u16, pszNewPath: ?[*:0]const u16, ItemType: OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).ItemRenamed(@ptrCast(*const IOfflineFilesEvents, self), pszOldPath, pszNewPath, ItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_DataLost(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).DataLost(@ptrCast(*const IOfflineFilesEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents_Ping(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents.VTable, self.vtable).Ping(@ptrCast(*const IOfflineFilesEvents, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesEvents2_Value = Guid.initString("1ead8f56-ff76-4faa-a795-6f6ef792498b");
pub const IID_IOfflineFilesEvents2 = &IID_IOfflineFilesEvents2_Value;
pub const IOfflineFilesEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesEvents.VTable,
        ItemReconnectBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemReconnectEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CacheEvictBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CacheEvictEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BackgroundSyncBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents2,
                dwSyncControlFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents2,
                dwSyncControlFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BackgroundSyncEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents2,
                dwSyncControlFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents2,
                dwSyncControlFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PolicyChangeDetected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreferenceChangeDetected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SettingsChangesApplied: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesEvents.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents2_ItemReconnectBegin(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents2.VTable, self.vtable).ItemReconnectBegin(@ptrCast(*const IOfflineFilesEvents2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents2_ItemReconnectEnd(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents2.VTable, self.vtable).ItemReconnectEnd(@ptrCast(*const IOfflineFilesEvents2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents2_CacheEvictBegin(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents2.VTable, self.vtable).CacheEvictBegin(@ptrCast(*const IOfflineFilesEvents2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents2_CacheEvictEnd(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents2.VTable, self.vtable).CacheEvictEnd(@ptrCast(*const IOfflineFilesEvents2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents2_BackgroundSyncBegin(self: *const T, dwSyncControlFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents2.VTable, self.vtable).BackgroundSyncBegin(@ptrCast(*const IOfflineFilesEvents2, self), dwSyncControlFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents2_BackgroundSyncEnd(self: *const T, dwSyncControlFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents2.VTable, self.vtable).BackgroundSyncEnd(@ptrCast(*const IOfflineFilesEvents2, self), dwSyncControlFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents2_PolicyChangeDetected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents2.VTable, self.vtable).PolicyChangeDetected(@ptrCast(*const IOfflineFilesEvents2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents2_PreferenceChangeDetected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents2.VTable, self.vtable).PreferenceChangeDetected(@ptrCast(*const IOfflineFilesEvents2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents2_SettingsChangesApplied(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents2.VTable, self.vtable).SettingsChangesApplied(@ptrCast(*const IOfflineFilesEvents2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOfflineFilesEvents3_Value = Guid.initString("9ba04a45-ee69-42f0-9ab1-7db5c8805808");
pub const IID_IOfflineFilesEvents3 = &IID_IOfflineFilesEvents3_Value;
pub const IOfflineFilesEvents3 = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesEvents2.VTable,
        TransparentCacheItemNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents3,
                pszPath: ?[*:0]const u16,
                EventType: OFFLINEFILES_EVENTS,
                ItemType: OFFLINEFILES_ITEM_TYPE,
                bModifiedData: BOOL,
                bModifiedAttributes: BOOL,
                pzsOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents3,
                pszPath: ?[*:0]const u16,
                EventType: OFFLINEFILES_EVENTS,
                ItemType: OFFLINEFILES_ITEM_TYPE,
                bModifiedData: BOOL,
                bModifiedAttributes: BOOL,
                pzsOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrefetchFileBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents3,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents3,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrefetchFileEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents3,
                pszPath: ?[*:0]const u16,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents3,
                pszPath: ?[*:0]const u16,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesEvents2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents3_TransparentCacheItemNotify(self: *const T, pszPath: ?[*:0]const u16, EventType: OFFLINEFILES_EVENTS, ItemType: OFFLINEFILES_ITEM_TYPE, bModifiedData: BOOL, bModifiedAttributes: BOOL, pzsOldPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents3.VTable, self.vtable).TransparentCacheItemNotify(@ptrCast(*const IOfflineFilesEvents3, self), pszPath, EventType, ItemType, bModifiedData, bModifiedAttributes, pzsOldPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents3_PrefetchFileBegin(self: *const T, pszPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents3.VTable, self.vtable).PrefetchFileBegin(@ptrCast(*const IOfflineFilesEvents3, self), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents3_PrefetchFileEnd(self: *const T, pszPath: ?[*:0]const u16, hrResult: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents3.VTable, self.vtable).PrefetchFileEnd(@ptrCast(*const IOfflineFilesEvents3, self), pszPath, hrResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOfflineFilesEvents4_Value = Guid.initString("dbd69b1e-c7d2-473e-b35f-9d8c24c0c484");
pub const IID_IOfflineFilesEvents4 = &IID_IOfflineFilesEvents4_Value;
pub const IOfflineFilesEvents4 = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesEvents3.VTable,
        PrefetchCloseHandleBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrefetchCloseHandleEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEvents4,
                dwClosedHandleCount: u32,
                dwOpenHandleCount: u32,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEvents4,
                dwClosedHandleCount: u32,
                dwOpenHandleCount: u32,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesEvents3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents4_PrefetchCloseHandleBegin(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents4.VTable, self.vtable).PrefetchCloseHandleBegin(@ptrCast(*const IOfflineFilesEvents4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEvents4_PrefetchCloseHandleEnd(self: *const T, dwClosedHandleCount: u32, dwOpenHandleCount: u32, hrResult: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEvents4.VTable, self.vtable).PrefetchCloseHandleEnd(@ptrCast(*const IOfflineFilesEvents4, self), dwClosedHandleCount, dwOpenHandleCount, hrResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesEventsFilter_Value = Guid.initString("33fc4e1b-0716-40fa-ba65-6e62a84a846f");
pub const IID_IOfflineFilesEventsFilter = &IID_IOfflineFilesEventsFilter_Value;
pub const IOfflineFilesEventsFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPathFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEventsFilter,
                ppszFilter: ?*?PWSTR,
                pMatch: ?*OFFLINEFILES_PATHFILTER_MATCH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEventsFilter,
                ppszFilter: ?*?PWSTR,
                pMatch: ?*OFFLINEFILES_PATHFILTER_MATCH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIncludedEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEventsFilter,
                cElements: u32,
                prgEvents: [*]OFFLINEFILES_EVENTS,
                pcEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEventsFilter,
                cElements: u32,
                prgEvents: [*]OFFLINEFILES_EVENTS,
                pcEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExcludedEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesEventsFilter,
                cElements: u32,
                prgEvents: [*]OFFLINEFILES_EVENTS,
                pcEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesEventsFilter,
                cElements: u32,
                prgEvents: [*]OFFLINEFILES_EVENTS,
                pcEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEventsFilter_GetPathFilter(self: *const T, ppszFilter: ?*?PWSTR, pMatch: ?*OFFLINEFILES_PATHFILTER_MATCH) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEventsFilter.VTable, self.vtable).GetPathFilter(@ptrCast(*const IOfflineFilesEventsFilter, self), ppszFilter, pMatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEventsFilter_GetIncludedEvents(self: *const T, cElements: u32, prgEvents: [*]OFFLINEFILES_EVENTS, pcEvents: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEventsFilter.VTable, self.vtable).GetIncludedEvents(@ptrCast(*const IOfflineFilesEventsFilter, self), cElements, prgEvents, pcEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesEventsFilter_GetExcludedEvents(self: *const T, cElements: u32, prgEvents: [*]OFFLINEFILES_EVENTS, pcEvents: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesEventsFilter.VTable, self.vtable).GetExcludedEvents(@ptrCast(*const IOfflineFilesEventsFilter, self), cElements, prgEvents, pcEvents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesErrorInfo_Value = Guid.initString("7112fa5f-7571-435a-8eb7-195c7c1429bc");
pub const IID_IOfflineFilesErrorInfo = &IID_IOfflineFilesErrorInfo_Value;
pub const IOfflineFilesErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRawData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesErrorInfo,
                ppBlob: ?*?*BYTE_BLOB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesErrorInfo,
                ppBlob: ?*?*BYTE_BLOB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesErrorInfo,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesErrorInfo,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesErrorInfo_GetRawData(self: *const T, ppBlob: ?*?*BYTE_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesErrorInfo.VTable, self.vtable).GetRawData(@ptrCast(*const IOfflineFilesErrorInfo, self), ppBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesErrorInfo_GetDescription(self: *const T, ppszDescription: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesErrorInfo.VTable, self.vtable).GetDescription(@ptrCast(*const IOfflineFilesErrorInfo, self), ppszDescription);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesSyncErrorItemInfo_Value = Guid.initString("ecdbaf0d-6a18-4d55-8017-108f7660ba44");
pub const IID_IOfflineFilesSyncErrorItemInfo = &IID_IOfflineFilesSyncErrorItemInfo_Value;
pub const IOfflineFilesSyncErrorItemInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFileAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorItemInfo,
                pdwAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorItemInfo,
                pdwAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorItemInfo,
                pftLastWrite: ?*FILETIME,
                pftChange: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorItemInfo,
                pftLastWrite: ?*FILETIME,
                pftChange: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorItemInfo,
                pSize: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorItemInfo,
                pSize: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorItemInfo_GetFileAttributes(self: *const T, pdwAttributes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorItemInfo.VTable, self.vtable).GetFileAttributes(@ptrCast(*const IOfflineFilesSyncErrorItemInfo, self), pdwAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorItemInfo_GetFileTimes(self: *const T, pftLastWrite: ?*FILETIME, pftChange: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorItemInfo.VTable, self.vtable).GetFileTimes(@ptrCast(*const IOfflineFilesSyncErrorItemInfo, self), pftLastWrite, pftChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorItemInfo_GetFileSize(self: *const T, pSize: ?*LARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorItemInfo.VTable, self.vtable).GetFileSize(@ptrCast(*const IOfflineFilesSyncErrorItemInfo, self), pSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesSyncErrorInfo_Value = Guid.initString("59f95e46-eb54-49d1-be76-de95458d01b0");
pub const IID_IOfflineFilesSyncErrorInfo = &IID_IOfflineFilesSyncErrorInfo_Value;
pub const IOfflineFilesSyncErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesErrorInfo.VTable,
        GetSyncOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorInfo,
                pSyncOp: ?*OFFLINEFILES_SYNC_OPERATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorInfo,
                pSyncOp: ?*OFFLINEFILES_SYNC_OPERATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemChangeFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorInfo,
                pdwItemChangeFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorInfo,
                pdwItemChangeFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InfoEnumerated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorInfo,
                pbLocalEnumerated: ?*BOOL,
                pbRemoteEnumerated: ?*BOOL,
                pbOriginalEnumerated: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorInfo,
                pbLocalEnumerated: ?*BOOL,
                pbRemoteEnumerated: ?*BOOL,
                pbOriginalEnumerated: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InfoAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorInfo,
                pbLocalInfo: ?*BOOL,
                pbRemoteInfo: ?*BOOL,
                pbOriginalInfo: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorInfo,
                pbLocalInfo: ?*BOOL,
                pbRemoteInfo: ?*BOOL,
                pbOriginalInfo: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocalInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorInfo,
                ppInfo: ?*?*IOfflineFilesSyncErrorItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorInfo,
                ppInfo: ?*?*IOfflineFilesSyncErrorItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRemoteInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorInfo,
                ppInfo: ?*?*IOfflineFilesSyncErrorItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorInfo,
                ppInfo: ?*?*IOfflineFilesSyncErrorItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncErrorInfo,
                ppInfo: ?*?*IOfflineFilesSyncErrorItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncErrorInfo,
                ppInfo: ?*?*IOfflineFilesSyncErrorItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesErrorInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorInfo_GetSyncOperation(self: *const T, pSyncOp: ?*OFFLINEFILES_SYNC_OPERATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorInfo.VTable, self.vtable).GetSyncOperation(@ptrCast(*const IOfflineFilesSyncErrorInfo, self), pSyncOp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorInfo_GetItemChangeFlags(self: *const T, pdwItemChangeFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorInfo.VTable, self.vtable).GetItemChangeFlags(@ptrCast(*const IOfflineFilesSyncErrorInfo, self), pdwItemChangeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorInfo_InfoEnumerated(self: *const T, pbLocalEnumerated: ?*BOOL, pbRemoteEnumerated: ?*BOOL, pbOriginalEnumerated: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorInfo.VTable, self.vtable).InfoEnumerated(@ptrCast(*const IOfflineFilesSyncErrorInfo, self), pbLocalEnumerated, pbRemoteEnumerated, pbOriginalEnumerated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorInfo_InfoAvailable(self: *const T, pbLocalInfo: ?*BOOL, pbRemoteInfo: ?*BOOL, pbOriginalInfo: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorInfo.VTable, self.vtable).InfoAvailable(@ptrCast(*const IOfflineFilesSyncErrorInfo, self), pbLocalInfo, pbRemoteInfo, pbOriginalInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorInfo_GetLocalInfo(self: *const T, ppInfo: ?*?*IOfflineFilesSyncErrorItemInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorInfo.VTable, self.vtable).GetLocalInfo(@ptrCast(*const IOfflineFilesSyncErrorInfo, self), ppInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorInfo_GetRemoteInfo(self: *const T, ppInfo: ?*?*IOfflineFilesSyncErrorItemInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorInfo.VTable, self.vtable).GetRemoteInfo(@ptrCast(*const IOfflineFilesSyncErrorInfo, self), ppInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncErrorInfo_GetOriginalInfo(self: *const T, ppInfo: ?*?*IOfflineFilesSyncErrorItemInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncErrorInfo.VTable, self.vtable).GetOriginalInfo(@ptrCast(*const IOfflineFilesSyncErrorInfo, self), ppInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesProgress_Value = Guid.initString("fad63237-c55b-4911-9850-bcf96d4c979e");
pub const IID_IOfflineFilesProgress = &IID_IOfflineFilesProgress_Value;
pub const IOfflineFilesProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesProgress,
                pbAbort: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesProgress,
                pbAbort: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesProgress,
                pbAbort: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesProgress,
                pbAbort: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        End: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesProgress,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesProgress,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesProgress_Begin(self: *const T, pbAbort: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesProgress.VTable, self.vtable).Begin(@ptrCast(*const IOfflineFilesProgress, self), pbAbort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesProgress_QueryAbort(self: *const T, pbAbort: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesProgress.VTable, self.vtable).QueryAbort(@ptrCast(*const IOfflineFilesProgress, self), pbAbort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesProgress_End(self: *const T, hrResult: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesProgress.VTable, self.vtable).End(@ptrCast(*const IOfflineFilesProgress, self), hrResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesSimpleProgress_Value = Guid.initString("c34f7f9b-c43d-4f9d-a776-c0eb6de5d401");
pub const IID_IOfflineFilesSimpleProgress = &IID_IOfflineFilesSimpleProgress_Value;
pub const IOfflineFilesSimpleProgress = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesProgress.VTable,
        ItemBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSimpleProgress,
                pszFile: ?[*:0]const u16,
                pResponse: ?*OFFLINEFILES_OP_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSimpleProgress,
                pszFile: ?[*:0]const u16,
                pResponse: ?*OFFLINEFILES_OP_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSimpleProgress,
                pszFile: ?[*:0]const u16,
                hrResult: HRESULT,
                pResponse: ?*OFFLINEFILES_OP_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSimpleProgress,
                pszFile: ?[*:0]const u16,
                hrResult: HRESULT,
                pResponse: ?*OFFLINEFILES_OP_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesProgress.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSimpleProgress_ItemBegin(self: *const T, pszFile: ?[*:0]const u16, pResponse: ?*OFFLINEFILES_OP_RESPONSE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSimpleProgress.VTable, self.vtable).ItemBegin(@ptrCast(*const IOfflineFilesSimpleProgress, self), pszFile, pResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSimpleProgress_ItemResult(self: *const T, pszFile: ?[*:0]const u16, hrResult: HRESULT, pResponse: ?*OFFLINEFILES_OP_RESPONSE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSimpleProgress.VTable, self.vtable).ItemResult(@ptrCast(*const IOfflineFilesSimpleProgress, self), pszFile, hrResult, pResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesSyncProgress_Value = Guid.initString("6931f49a-6fc7-4c1b-b265-56793fc451b7");
pub const IID_IOfflineFilesSyncProgress = &IID_IOfflineFilesSyncProgress_Value;
pub const IOfflineFilesSyncProgress = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesProgress.VTable,
        SyncItemBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncProgress,
                pszFile: ?[*:0]const u16,
                pResponse: ?*OFFLINEFILES_OP_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncProgress,
                pszFile: ?[*:0]const u16,
                pResponse: ?*OFFLINEFILES_OP_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncItemResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncProgress,
                pszFile: ?[*:0]const u16,
                hrResult: HRESULT,
                pErrorInfo: ?*IOfflineFilesSyncErrorInfo,
                pResponse: ?*OFFLINEFILES_OP_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncProgress,
                pszFile: ?[*:0]const u16,
                hrResult: HRESULT,
                pErrorInfo: ?*IOfflineFilesSyncErrorInfo,
                pResponse: ?*OFFLINEFILES_OP_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesProgress.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncProgress_SyncItemBegin(self: *const T, pszFile: ?[*:0]const u16, pResponse: ?*OFFLINEFILES_OP_RESPONSE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncProgress.VTable, self.vtable).SyncItemBegin(@ptrCast(*const IOfflineFilesSyncProgress, self), pszFile, pResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncProgress_SyncItemResult(self: *const T, pszFile: ?[*:0]const u16, hrResult: HRESULT, pErrorInfo: ?*IOfflineFilesSyncErrorInfo, pResponse: ?*OFFLINEFILES_OP_RESPONSE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncProgress.VTable, self.vtable).SyncItemResult(@ptrCast(*const IOfflineFilesSyncProgress, self), pszFile, hrResult, pErrorInfo, pResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesSyncConflictHandler_Value = Guid.initString("b6dd5092-c65c-46b6-97b8-fadd08e7e1be");
pub const IID_IOfflineFilesSyncConflictHandler = &IID_IOfflineFilesSyncConflictHandler_Value;
pub const IOfflineFilesSyncConflictHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResolveConflict: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSyncConflictHandler,
                pszPath: ?[*:0]const u16,
                fStateKnown: u32,
                state: OFFLINEFILES_SYNC_STATE,
                fChangeDetails: u32,
                pConflictResolution: ?*OFFLINEFILES_SYNC_CONFLICT_RESOLVE,
                ppszNewName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSyncConflictHandler,
                pszPath: ?[*:0]const u16,
                fStateKnown: u32,
                state: OFFLINEFILES_SYNC_STATE,
                fChangeDetails: u32,
                pConflictResolution: ?*OFFLINEFILES_SYNC_CONFLICT_RESOLVE,
                ppszNewName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSyncConflictHandler_ResolveConflict(self: *const T, pszPath: ?[*:0]const u16, fStateKnown: u32, state: OFFLINEFILES_SYNC_STATE, fChangeDetails: u32, pConflictResolution: ?*OFFLINEFILES_SYNC_CONFLICT_RESOLVE, ppszNewName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSyncConflictHandler.VTable, self.vtable).ResolveConflict(@ptrCast(*const IOfflineFilesSyncConflictHandler, self), pszPath, fStateKnown, state, fChangeDetails, pConflictResolution, ppszNewName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesItemFilter_Value = Guid.initString("f4b5a26c-dc05-4f20-ada4-551f1077be5c");
pub const IID_IOfflineFilesItemFilter = &IID_IOfflineFilesItemFilter_Value;
pub const IOfflineFilesItemFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilterFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItemFilter,
                pullFlags: ?*u64,
                pullMask: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItemFilter,
                pullFlags: ?*u64,
                pullMask: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItemFilter,
                pftTime: ?*FILETIME,
                pbEvalTimeOfDay: ?*BOOL,
                pTimeType: ?*OFFLINEFILES_ITEM_TIME,
                pCompare: ?*OFFLINEFILES_COMPARE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItemFilter,
                pftTime: ?*FILETIME,
                pbEvalTimeOfDay: ?*BOOL,
                pTimeType: ?*OFFLINEFILES_ITEM_TIME,
                pCompare: ?*OFFLINEFILES_COMPARE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPatternFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItemFilter,
                pszPattern: [*:0]u16,
                cchPattern: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItemFilter,
                pszPattern: [*:0]u16,
                cchPattern: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItemFilter_GetFilterFlags(self: *const T, pullFlags: ?*u64, pullMask: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItemFilter.VTable, self.vtable).GetFilterFlags(@ptrCast(*const IOfflineFilesItemFilter, self), pullFlags, pullMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItemFilter_GetTimeFilter(self: *const T, pftTime: ?*FILETIME, pbEvalTimeOfDay: ?*BOOL, pTimeType: ?*OFFLINEFILES_ITEM_TIME, pCompare: ?*OFFLINEFILES_COMPARE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItemFilter.VTable, self.vtable).GetTimeFilter(@ptrCast(*const IOfflineFilesItemFilter, self), pftTime, pbEvalTimeOfDay, pTimeType, pCompare);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItemFilter_GetPatternFilter(self: *const T, pszPattern: [*:0]u16, cchPattern: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItemFilter.VTable, self.vtable).GetPatternFilter(@ptrCast(*const IOfflineFilesItemFilter, self), pszPattern, cchPattern);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesItem_Value = Guid.initString("4a753da6-e044-4f12-a718-5d14d079a906");
pub const IID_IOfflineFilesItem = &IID_IOfflineFilesItem_Value;
pub const IOfflineFilesItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItem,
                pItemType: ?*OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItem,
                pItemType: ?*OFFLINEFILES_ITEM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItem,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItem,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItem,
                ppItem: ?*?*IOfflineFilesItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItem,
                ppItem: ?*?*IOfflineFilesItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItem,
                dwQueryFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItem,
                dwQueryFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsMarkedForDeletion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItem,
                pbMarkedForDeletion: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItem,
                pbMarkedForDeletion: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItem_GetItemType(self: *const T, pItemType: ?*OFFLINEFILES_ITEM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItem.VTable, self.vtable).GetItemType(@ptrCast(*const IOfflineFilesItem, self), pItemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItem_GetPath(self: *const T, ppszPath: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItem.VTable, self.vtable).GetPath(@ptrCast(*const IOfflineFilesItem, self), ppszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItem_GetParentItem(self: *const T, ppItem: ?*?*IOfflineFilesItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItem.VTable, self.vtable).GetParentItem(@ptrCast(*const IOfflineFilesItem, self), ppItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItem_Refresh(self: *const T, dwQueryFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItem.VTable, self.vtable).Refresh(@ptrCast(*const IOfflineFilesItem, self), dwQueryFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItem_IsMarkedForDeletion(self: *const T, pbMarkedForDeletion: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItem.VTable, self.vtable).IsMarkedForDeletion(@ptrCast(*const IOfflineFilesItem, self), pbMarkedForDeletion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesServerItem_Value = Guid.initString("9b1c9576-a92b-4151-8e9e-7c7b3ec2e016");
pub const IID_IOfflineFilesServerItem = &IID_IOfflineFilesServerItem_Value;
pub const IOfflineFilesServerItem = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesShareItem_Value = Guid.initString("bab7e48d-4804-41b5-a44d-0f199b06b145");
pub const IID_IOfflineFilesShareItem = &IID_IOfflineFilesShareItem_Value;
pub const IOfflineFilesShareItem = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesDirectoryItem_Value = Guid.initString("2273597a-a08c-4a00-a37a-c1ae4e9a1cfd");
pub const IID_IOfflineFilesDirectoryItem = &IID_IOfflineFilesDirectoryItem_Value;
pub const IOfflineFilesDirectoryItem = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesFileItem_Value = Guid.initString("8dfadead-26c2-4eff-8a72-6b50723d9a00");
pub const IID_IOfflineFilesFileItem = &IID_IOfflineFilesFileItem_Value;
pub const IOfflineFilesFileItem = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesItem.VTable,
        IsSparse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesFileItem,
                pbIsSparse: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesFileItem,
                pbIsSparse: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEncrypted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesFileItem,
                pbIsEncrypted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesFileItem,
                pbIsEncrypted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesFileItem_IsSparse(self: *const T, pbIsSparse: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesFileItem.VTable, self.vtable).IsSparse(@ptrCast(*const IOfflineFilesFileItem, self), pbIsSparse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesFileItem_IsEncrypted(self: *const T, pbIsEncrypted: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesFileItem.VTable, self.vtable).IsEncrypted(@ptrCast(*const IOfflineFilesFileItem, self), pbIsEncrypted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumOfflineFilesItems_Value = Guid.initString("da70e815-c361-4407-bc0b-0d7046e5f2cd");
pub const IID_IEnumOfflineFilesItems = &IID_IEnumOfflineFilesItems_Value;
pub const IEnumOfflineFilesItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOfflineFilesItems,
                celt: u32,
                rgelt: [*]?*IOfflineFilesItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOfflineFilesItems,
                celt: u32,
                rgelt: [*]?*IOfflineFilesItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOfflineFilesItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOfflineFilesItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOfflineFilesItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOfflineFilesItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOfflineFilesItems,
                ppenum: ?*?*IEnumOfflineFilesItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOfflineFilesItems,
                ppenum: ?*?*IEnumOfflineFilesItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOfflineFilesItems_Next(self: *const T, celt: u32, rgelt: [*]?*IOfflineFilesItem, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOfflineFilesItems.VTable, self.vtable).Next(@ptrCast(*const IEnumOfflineFilesItems, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOfflineFilesItems_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOfflineFilesItems.VTable, self.vtable).Skip(@ptrCast(*const IEnumOfflineFilesItems, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOfflineFilesItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOfflineFilesItems.VTable, self.vtable).Reset(@ptrCast(*const IEnumOfflineFilesItems, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOfflineFilesItems_Clone(self: *const T, ppenum: ?*?*IEnumOfflineFilesItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOfflineFilesItems.VTable, self.vtable).Clone(@ptrCast(*const IEnumOfflineFilesItems, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesItemContainer_Value = Guid.initString("3836f049-9413-45dd-bf46-b5aaa82dc310");
pub const IID_IOfflineFilesItemContainer = &IID_IOfflineFilesItemContainer_Value;
pub const IOfflineFilesItemContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItemContainer,
                dwQueryFlags: u32,
                ppenum: ?*?*IEnumOfflineFilesItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItemContainer,
                dwQueryFlags: u32,
                ppenum: ?*?*IEnumOfflineFilesItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumItemsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesItemContainer,
                pIncludeFileFilter: ?*IOfflineFilesItemFilter,
                pIncludeDirFilter: ?*IOfflineFilesItemFilter,
                pExcludeFileFilter: ?*IOfflineFilesItemFilter,
                pExcludeDirFilter: ?*IOfflineFilesItemFilter,
                dwEnumFlags: u32,
                dwQueryFlags: u32,
                ppenum: ?*?*IEnumOfflineFilesItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesItemContainer,
                pIncludeFileFilter: ?*IOfflineFilesItemFilter,
                pIncludeDirFilter: ?*IOfflineFilesItemFilter,
                pExcludeFileFilter: ?*IOfflineFilesItemFilter,
                pExcludeDirFilter: ?*IOfflineFilesItemFilter,
                dwEnumFlags: u32,
                dwQueryFlags: u32,
                ppenum: ?*?*IEnumOfflineFilesItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItemContainer_EnumItems(self: *const T, dwQueryFlags: u32, ppenum: ?*?*IEnumOfflineFilesItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItemContainer.VTable, self.vtable).EnumItems(@ptrCast(*const IOfflineFilesItemContainer, self), dwQueryFlags, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesItemContainer_EnumItemsEx(self: *const T, pIncludeFileFilter: ?*IOfflineFilesItemFilter, pIncludeDirFilter: ?*IOfflineFilesItemFilter, pExcludeFileFilter: ?*IOfflineFilesItemFilter, pExcludeDirFilter: ?*IOfflineFilesItemFilter, dwEnumFlags: u32, dwQueryFlags: u32, ppenum: ?*?*IEnumOfflineFilesItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesItemContainer.VTable, self.vtable).EnumItemsEx(@ptrCast(*const IOfflineFilesItemContainer, self), pIncludeFileFilter, pIncludeDirFilter, pExcludeFileFilter, pExcludeDirFilter, dwEnumFlags, dwQueryFlags, ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesChangeInfo_Value = Guid.initString("a96e6fa4-e0d1-4c29-960b-ee508fe68c72");
pub const IID_IOfflineFilesChangeInfo = &IID_IOfflineFilesChangeInfo_Value;
pub const IOfflineFilesChangeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesChangeInfo,
                pbDirty: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesChangeInfo,
                pbDirty: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDeletedOffline: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesChangeInfo,
                pbDeletedOffline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesChangeInfo,
                pbDeletedOffline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsCreatedOffline: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesChangeInfo,
                pbCreatedOffline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesChangeInfo,
                pbCreatedOffline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsLocallyModifiedData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesChangeInfo,
                pbLocallyModifiedData: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesChangeInfo,
                pbLocallyModifiedData: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsLocallyModifiedAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesChangeInfo,
                pbLocallyModifiedAttributes: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesChangeInfo,
                pbLocallyModifiedAttributes: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsLocallyModifiedTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesChangeInfo,
                pbLocallyModifiedTime: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesChangeInfo,
                pbLocallyModifiedTime: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesChangeInfo_IsDirty(self: *const T, pbDirty: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesChangeInfo.VTable, self.vtable).IsDirty(@ptrCast(*const IOfflineFilesChangeInfo, self), pbDirty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesChangeInfo_IsDeletedOffline(self: *const T, pbDeletedOffline: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesChangeInfo.VTable, self.vtable).IsDeletedOffline(@ptrCast(*const IOfflineFilesChangeInfo, self), pbDeletedOffline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesChangeInfo_IsCreatedOffline(self: *const T, pbCreatedOffline: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesChangeInfo.VTable, self.vtable).IsCreatedOffline(@ptrCast(*const IOfflineFilesChangeInfo, self), pbCreatedOffline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesChangeInfo_IsLocallyModifiedData(self: *const T, pbLocallyModifiedData: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesChangeInfo.VTable, self.vtable).IsLocallyModifiedData(@ptrCast(*const IOfflineFilesChangeInfo, self), pbLocallyModifiedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesChangeInfo_IsLocallyModifiedAttributes(self: *const T, pbLocallyModifiedAttributes: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesChangeInfo.VTable, self.vtable).IsLocallyModifiedAttributes(@ptrCast(*const IOfflineFilesChangeInfo, self), pbLocallyModifiedAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesChangeInfo_IsLocallyModifiedTime(self: *const T, pbLocallyModifiedTime: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesChangeInfo.VTable, self.vtable).IsLocallyModifiedTime(@ptrCast(*const IOfflineFilesChangeInfo, self), pbLocallyModifiedTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesDirtyInfo_Value = Guid.initString("0f50ce33-bac9-4eaa-a11d-da0e527d047d");
pub const IID_IOfflineFilesDirtyInfo = &IID_IOfflineFilesDirtyInfo_Value;
pub const IOfflineFilesDirtyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LocalDirtyByteCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesDirtyInfo,
                pDirtyByteCount: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesDirtyInfo,
                pDirtyByteCount: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoteDirtyByteCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesDirtyInfo,
                pDirtyByteCount: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesDirtyInfo,
                pDirtyByteCount: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesDirtyInfo_LocalDirtyByteCount(self: *const T, pDirtyByteCount: ?*LARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesDirtyInfo.VTable, self.vtable).LocalDirtyByteCount(@ptrCast(*const IOfflineFilesDirtyInfo, self), pDirtyByteCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesDirtyInfo_RemoteDirtyByteCount(self: *const T, pDirtyByteCount: ?*LARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesDirtyInfo.VTable, self.vtable).RemoteDirtyByteCount(@ptrCast(*const IOfflineFilesDirtyInfo, self), pDirtyByteCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesFileSysInfo_Value = Guid.initString("bc1a163f-7bfd-4d88-9c66-96ea9a6a3d6b");
pub const IID_IOfflineFilesFileSysInfo = &IID_IOfflineFilesFileSysInfo_Value;
pub const IOfflineFilesFileSysInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesFileSysInfo,
                copy: OFFLINEFILES_ITEM_COPY,
                pdwAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesFileSysInfo,
                copy: OFFLINEFILES_ITEM_COPY,
                pdwAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesFileSysInfo,
                copy: OFFLINEFILES_ITEM_COPY,
                pftCreationTime: ?*FILETIME,
                pftLastWriteTime: ?*FILETIME,
                pftChangeTime: ?*FILETIME,
                pftLastAccessTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesFileSysInfo,
                copy: OFFLINEFILES_ITEM_COPY,
                pftCreationTime: ?*FILETIME,
                pftLastWriteTime: ?*FILETIME,
                pftChangeTime: ?*FILETIME,
                pftLastAccessTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesFileSysInfo,
                copy: OFFLINEFILES_ITEM_COPY,
                pSize: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesFileSysInfo,
                copy: OFFLINEFILES_ITEM_COPY,
                pSize: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesFileSysInfo_GetAttributes(self: *const T, copy: OFFLINEFILES_ITEM_COPY, pdwAttributes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesFileSysInfo.VTable, self.vtable).GetAttributes(@ptrCast(*const IOfflineFilesFileSysInfo, self), copy, pdwAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesFileSysInfo_GetTimes(self: *const T, copy: OFFLINEFILES_ITEM_COPY, pftCreationTime: ?*FILETIME, pftLastWriteTime: ?*FILETIME, pftChangeTime: ?*FILETIME, pftLastAccessTime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesFileSysInfo.VTable, self.vtable).GetTimes(@ptrCast(*const IOfflineFilesFileSysInfo, self), copy, pftCreationTime, pftLastWriteTime, pftChangeTime, pftLastAccessTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesFileSysInfo_GetFileSize(self: *const T, copy: OFFLINEFILES_ITEM_COPY, pSize: ?*LARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesFileSysInfo.VTable, self.vtable).GetFileSize(@ptrCast(*const IOfflineFilesFileSysInfo, self), copy, pSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesPinInfo_Value = Guid.initString("5b2b0655-b3fd-497d-adeb-bd156bc8355b");
pub const IID_IOfflineFilesPinInfo = &IID_IOfflineFilesPinInfo_Value;
pub const IOfflineFilesPinInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsPinned: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesPinInfo,
                pbPinned: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesPinInfo,
                pbPinned: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPinnedForUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesPinInfo,
                pbPinnedForUser: ?*BOOL,
                pbInherit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesPinInfo,
                pbPinnedForUser: ?*BOOL,
                pbInherit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPinnedForUserByPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesPinInfo,
                pbPinnedForUser: ?*BOOL,
                pbInherit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesPinInfo,
                pbPinnedForUser: ?*BOOL,
                pbInherit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPinnedForComputer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesPinInfo,
                pbPinnedForComputer: ?*BOOL,
                pbInherit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesPinInfo,
                pbPinnedForComputer: ?*BOOL,
                pbInherit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPinnedForFolderRedirection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesPinInfo,
                pbPinnedForFolderRedirection: ?*BOOL,
                pbInherit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesPinInfo,
                pbPinnedForFolderRedirection: ?*BOOL,
                pbInherit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesPinInfo_IsPinned(self: *const T, pbPinned: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesPinInfo.VTable, self.vtable).IsPinned(@ptrCast(*const IOfflineFilesPinInfo, self), pbPinned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesPinInfo_IsPinnedForUser(self: *const T, pbPinnedForUser: ?*BOOL, pbInherit: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesPinInfo.VTable, self.vtable).IsPinnedForUser(@ptrCast(*const IOfflineFilesPinInfo, self), pbPinnedForUser, pbInherit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesPinInfo_IsPinnedForUserByPolicy(self: *const T, pbPinnedForUser: ?*BOOL, pbInherit: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesPinInfo.VTable, self.vtable).IsPinnedForUserByPolicy(@ptrCast(*const IOfflineFilesPinInfo, self), pbPinnedForUser, pbInherit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesPinInfo_IsPinnedForComputer(self: *const T, pbPinnedForComputer: ?*BOOL, pbInherit: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesPinInfo.VTable, self.vtable).IsPinnedForComputer(@ptrCast(*const IOfflineFilesPinInfo, self), pbPinnedForComputer, pbInherit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesPinInfo_IsPinnedForFolderRedirection(self: *const T, pbPinnedForFolderRedirection: ?*BOOL, pbInherit: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesPinInfo.VTable, self.vtable).IsPinnedForFolderRedirection(@ptrCast(*const IOfflineFilesPinInfo, self), pbPinnedForFolderRedirection, pbInherit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesPinInfo2_Value = Guid.initString("623c58a2-42ed-4ad7-b69a-0f1b30a72d0d");
pub const IID_IOfflineFilesPinInfo2 = &IID_IOfflineFilesPinInfo2_Value;
pub const IOfflineFilesPinInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesPinInfo.VTable,
        IsPartlyPinned: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesPinInfo2,
                pbPartlyPinned: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesPinInfo2,
                pbPartlyPinned: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesPinInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesPinInfo2_IsPartlyPinned(self: *const T, pbPartlyPinned: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesPinInfo2.VTable, self.vtable).IsPartlyPinned(@ptrCast(*const IOfflineFilesPinInfo2, self), pbPartlyPinned);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOfflineFilesTransparentCacheInfo_Value = Guid.initString("bcaf4a01-5b68-4b56-a6a1-8d2786ede8e3");
pub const IID_IOfflineFilesTransparentCacheInfo = &IID_IOfflineFilesTransparentCacheInfo_Value;
pub const IOfflineFilesTransparentCacheInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsTransparentlyCached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesTransparentCacheInfo,
                pbTransparentlyCached: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesTransparentCacheInfo,
                pbTransparentlyCached: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesTransparentCacheInfo_IsTransparentlyCached(self: *const T, pbTransparentlyCached: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesTransparentCacheInfo.VTable, self.vtable).IsTransparentlyCached(@ptrCast(*const IOfflineFilesTransparentCacheInfo, self), pbTransparentlyCached);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesGhostInfo_Value = Guid.initString("2b09d48c-8ab5-464f-a755-a59d92f99429");
pub const IID_IOfflineFilesGhostInfo = &IID_IOfflineFilesGhostInfo_Value;
pub const IOfflineFilesGhostInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsGhosted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesGhostInfo,
                pbGhosted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesGhostInfo,
                pbGhosted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesGhostInfo_IsGhosted(self: *const T, pbGhosted: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesGhostInfo.VTable, self.vtable).IsGhosted(@ptrCast(*const IOfflineFilesGhostInfo, self), pbGhosted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesConnectionInfo_Value = Guid.initString("efb23a09-a867-4be8-83a6-86969a7d0856");
pub const IID_IOfflineFilesConnectionInfo = &IID_IOfflineFilesConnectionInfo_Value;
pub const IOfflineFilesConnectionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesConnectionInfo,
                pConnectState: ?*OFFLINEFILES_CONNECT_STATE,
                pOfflineReason: ?*OFFLINEFILES_OFFLINE_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesConnectionInfo,
                pConnectState: ?*OFFLINEFILES_CONNECT_STATE,
                pOfflineReason: ?*OFFLINEFILES_OFFLINE_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConnectState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesConnectionInfo,
                hwndParent: ?HWND,
                dwFlags: u32,
                ConnectState: OFFLINEFILES_CONNECT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesConnectionInfo,
                hwndParent: ?HWND,
                dwFlags: u32,
                ConnectState: OFFLINEFILES_CONNECT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TransitionOnline: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesConnectionInfo,
                hwndParent: ?HWND,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesConnectionInfo,
                hwndParent: ?HWND,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TransitionOffline: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesConnectionInfo,
                hwndParent: ?HWND,
                dwFlags: u32,
                bForceOpenFilesClosed: BOOL,
                pbOpenFilesPreventedTransition: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesConnectionInfo,
                hwndParent: ?HWND,
                dwFlags: u32,
                bForceOpenFilesClosed: BOOL,
                pbOpenFilesPreventedTransition: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesConnectionInfo_GetConnectState(self: *const T, pConnectState: ?*OFFLINEFILES_CONNECT_STATE, pOfflineReason: ?*OFFLINEFILES_OFFLINE_REASON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesConnectionInfo.VTable, self.vtable).GetConnectState(@ptrCast(*const IOfflineFilesConnectionInfo, self), pConnectState, pOfflineReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesConnectionInfo_SetConnectState(self: *const T, hwndParent: ?HWND, dwFlags: u32, ConnectState: OFFLINEFILES_CONNECT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesConnectionInfo.VTable, self.vtable).SetConnectState(@ptrCast(*const IOfflineFilesConnectionInfo, self), hwndParent, dwFlags, ConnectState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesConnectionInfo_TransitionOnline(self: *const T, hwndParent: ?HWND, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesConnectionInfo.VTable, self.vtable).TransitionOnline(@ptrCast(*const IOfflineFilesConnectionInfo, self), hwndParent, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesConnectionInfo_TransitionOffline(self: *const T, hwndParent: ?HWND, dwFlags: u32, bForceOpenFilesClosed: BOOL, pbOpenFilesPreventedTransition: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesConnectionInfo.VTable, self.vtable).TransitionOffline(@ptrCast(*const IOfflineFilesConnectionInfo, self), hwndParent, dwFlags, bForceOpenFilesClosed, pbOpenFilesPreventedTransition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesShareInfo_Value = Guid.initString("7bcc43e7-31ce-4ca4-8ccd-1cff2dc494da");
pub const IID_IOfflineFilesShareInfo = &IID_IOfflineFilesShareInfo_Value;
pub const IOfflineFilesShareInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetShareItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesShareInfo,
                ppShareItem: ?*?*IOfflineFilesShareItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesShareInfo,
                ppShareItem: ?*?*IOfflineFilesShareItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShareCachingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesShareInfo,
                pCachingMode: ?*OFFLINEFILES_CACHING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesShareInfo,
                pCachingMode: ?*OFFLINEFILES_CACHING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsShareDfsJunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesShareInfo,
                pbIsDfsJunction: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesShareInfo,
                pbIsDfsJunction: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesShareInfo_GetShareItem(self: *const T, ppShareItem: ?*?*IOfflineFilesShareItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesShareInfo.VTable, self.vtable).GetShareItem(@ptrCast(*const IOfflineFilesShareInfo, self), ppShareItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesShareInfo_GetShareCachingMode(self: *const T, pCachingMode: ?*OFFLINEFILES_CACHING_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesShareInfo.VTable, self.vtable).GetShareCachingMode(@ptrCast(*const IOfflineFilesShareInfo, self), pCachingMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesShareInfo_IsShareDfsJunction(self: *const T, pbIsDfsJunction: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesShareInfo.VTable, self.vtable).IsShareDfsJunction(@ptrCast(*const IOfflineFilesShareInfo, self), pbIsDfsJunction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesSuspend_Value = Guid.initString("62c4560f-bc0b-48ca-ad9d-34cb528d99a9");
pub const IID_IOfflineFilesSuspend = &IID_IOfflineFilesSuspend_Value;
pub const IOfflineFilesSuspend = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SuspendRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSuspend,
                bSuspend: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSuspend,
                bSuspend: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSuspend_SuspendRoot(self: *const T, bSuspend: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSuspend.VTable, self.vtable).SuspendRoot(@ptrCast(*const IOfflineFilesSuspend, self), bSuspend);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesSuspendInfo_Value = Guid.initString("a457c25b-4e9c-4b04-85af-8932ccd97889");
pub const IID_IOfflineFilesSuspendInfo = &IID_IOfflineFilesSuspendInfo_Value;
pub const IOfflineFilesSuspendInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSuspended: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSuspendInfo,
                pbSuspended: ?*BOOL,
                pbSuspendedRoot: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSuspendInfo,
                pbSuspended: ?*BOOL,
                pbSuspendedRoot: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSuspendInfo_IsSuspended(self: *const T, pbSuspended: ?*BOOL, pbSuspendedRoot: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSuspendInfo.VTable, self.vtable).IsSuspended(@ptrCast(*const IOfflineFilesSuspendInfo, self), pbSuspended, pbSuspendedRoot);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesSetting_Value = Guid.initString("d871d3f7-f613-48a1-827e-7a34e560fff6");
pub const IID_IOfflineFilesSetting = &IID_IOfflineFilesSetting_Value;
pub const IOfflineFilesSetting = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSetting,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSetting,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValueType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSetting,
                pType: ?*OFFLINEFILES_SETTING_VALUE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSetting,
                pType: ?*OFFLINEFILES_SETTING_VALUE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSetting,
                pvarValue: ?*VARIANT,
                dwScope: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSetting,
                pvarValue: ?*VARIANT,
                dwScope: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreferenceScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSetting,
                pdwScope: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSetting,
                pdwScope: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSetting,
                pvarValue: ?*const VARIANT,
                dwScope: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSetting,
                pvarValue: ?*const VARIANT,
                dwScope: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeletePreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSetting,
                dwScope: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSetting,
                dwScope: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSetting,
                pvarValue: ?*VARIANT,
                dwScope: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSetting,
                pvarValue: ?*VARIANT,
                dwScope: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPolicyScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSetting,
                pdwScope: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSetting,
                pdwScope: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesSetting,
                pvarValue: ?*VARIANT,
                pbSetByPolicy: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesSetting,
                pvarValue: ?*VARIANT,
                pbSetByPolicy: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSetting_GetName(self: *const T, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSetting.VTable, self.vtable).GetName(@ptrCast(*const IOfflineFilesSetting, self), ppszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSetting_GetValueType(self: *const T, pType: ?*OFFLINEFILES_SETTING_VALUE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSetting.VTable, self.vtable).GetValueType(@ptrCast(*const IOfflineFilesSetting, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSetting_GetPreference(self: *const T, pvarValue: ?*VARIANT, dwScope: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSetting.VTable, self.vtable).GetPreference(@ptrCast(*const IOfflineFilesSetting, self), pvarValue, dwScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSetting_GetPreferenceScope(self: *const T, pdwScope: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSetting.VTable, self.vtable).GetPreferenceScope(@ptrCast(*const IOfflineFilesSetting, self), pdwScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSetting_SetPreference(self: *const T, pvarValue: ?*const VARIANT, dwScope: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSetting.VTable, self.vtable).SetPreference(@ptrCast(*const IOfflineFilesSetting, self), pvarValue, dwScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSetting_DeletePreference(self: *const T, dwScope: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSetting.VTable, self.vtable).DeletePreference(@ptrCast(*const IOfflineFilesSetting, self), dwScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSetting_GetPolicy(self: *const T, pvarValue: ?*VARIANT, dwScope: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSetting.VTable, self.vtable).GetPolicy(@ptrCast(*const IOfflineFilesSetting, self), pvarValue, dwScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSetting_GetPolicyScope(self: *const T, pdwScope: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSetting.VTable, self.vtable).GetPolicyScope(@ptrCast(*const IOfflineFilesSetting, self), pdwScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesSetting_GetValue(self: *const T, pvarValue: ?*VARIANT, pbSetByPolicy: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesSetting.VTable, self.vtable).GetValue(@ptrCast(*const IOfflineFilesSetting, self), pvarValue, pbSetByPolicy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumOfflineFilesSettings_Value = Guid.initString("729680c4-1a38-47bc-9e5c-02c51562ac30");
pub const IID_IEnumOfflineFilesSettings = &IID_IEnumOfflineFilesSettings_Value;
pub const IEnumOfflineFilesSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOfflineFilesSettings,
                celt: u32,
                rgelt: [*]?*IOfflineFilesSetting,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOfflineFilesSettings,
                celt: u32,
                rgelt: [*]?*IOfflineFilesSetting,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOfflineFilesSettings,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOfflineFilesSettings,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOfflineFilesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOfflineFilesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOfflineFilesSettings,
                ppenum: ?*?*IEnumOfflineFilesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOfflineFilesSettings,
                ppenum: ?*?*IEnumOfflineFilesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOfflineFilesSettings_Next(self: *const T, celt: u32, rgelt: [*]?*IOfflineFilesSetting, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOfflineFilesSettings.VTable, self.vtable).Next(@ptrCast(*const IEnumOfflineFilesSettings, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOfflineFilesSettings_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOfflineFilesSettings.VTable, self.vtable).Skip(@ptrCast(*const IEnumOfflineFilesSettings, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOfflineFilesSettings_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOfflineFilesSettings.VTable, self.vtable).Reset(@ptrCast(*const IEnumOfflineFilesSettings, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOfflineFilesSettings_Clone(self: *const T, ppenum: ?*?*IEnumOfflineFilesSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOfflineFilesSettings.VTable, self.vtable).Clone(@ptrCast(*const IEnumOfflineFilesSettings, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOfflineFilesCache_Value = Guid.initString("855d6203-7914-48b9-8d40-4c56f5acffc5");
pub const IID_IOfflineFilesCache = &IID_IOfflineFilesCache_Value;
pub const IOfflineFilesCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Synchronize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                hwndParent: ?HWND,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                bAsync: BOOL,
                dwSyncControl: u32,
                pISyncConflictHandler: ?*IOfflineFilesSyncConflictHandler,
                pIProgress: ?*IOfflineFilesSyncProgress,
                pSyncId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                hwndParent: ?HWND,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                bAsync: BOOL,
                dwSyncControl: u32,
                pISyncConflictHandler: ?*IOfflineFilesSyncConflictHandler,
                pIProgress: ?*IOfflineFilesSyncProgress,
                pSyncId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                dwFlags: u32,
                bAsync: BOOL,
                pIProgress: ?*IOfflineFilesSimpleProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                dwFlags: u32,
                bAsync: BOOL,
                pIProgress: ?*IOfflineFilesSimpleProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteItemsForUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                pszUser: ?[*:0]const u16,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                dwFlags: u32,
                bAsync: BOOL,
                pIProgress: ?*IOfflineFilesSimpleProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                pszUser: ?[*:0]const u16,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                dwFlags: u32,
                bAsync: BOOL,
                pIProgress: ?*IOfflineFilesSimpleProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                hwndParent: ?HWND,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                bDeep: BOOL,
                bAsync: BOOL,
                dwPinControlFlags: u32,
                pIProgress: ?*IOfflineFilesSyncProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                hwndParent: ?HWND,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                bDeep: BOOL,
                bAsync: BOOL,
                dwPinControlFlags: u32,
                pIProgress: ?*IOfflineFilesSyncProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unpin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                hwndParent: ?HWND,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                bDeep: BOOL,
                bAsync: BOOL,
                dwPinControlFlags: u32,
                pIProgress: ?*IOfflineFilesSyncProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                hwndParent: ?HWND,
                rgpszPaths: [*]?PWSTR,
                cPaths: u32,
                bDeep: BOOL,
                bAsync: BOOL,
                dwPinControlFlags: u32,
                pIProgress: ?*IOfflineFilesSyncProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEncryptionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                pbEncrypted: ?*BOOL,
                pbPartial: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                pbEncrypted: ?*BOOL,
                pbPartial: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Encrypt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                hwndParent: ?HWND,
                bEncrypt: BOOL,
                dwEncryptionControlFlags: u32,
                bAsync: BOOL,
                pIProgress: ?*IOfflineFilesSyncProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                hwndParent: ?HWND,
                bEncrypt: BOOL,
                dwEncryptionControlFlags: u32,
                bAsync: BOOL,
                pIProgress: ?*IOfflineFilesSyncProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                pszPath: ?[*:0]const u16,
                dwQueryFlags: u32,
                ppItem: ?*?*IOfflineFilesItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                pszPath: ?[*:0]const u16,
                dwQueryFlags: u32,
                ppItem: ?*?*IOfflineFilesItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindItemEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                pszPath: ?[*:0]const u16,
                pIncludeFileFilter: ?*IOfflineFilesItemFilter,
                pIncludeDirFilter: ?*IOfflineFilesItemFilter,
                pExcludeFileFilter: ?*IOfflineFilesItemFilter,
                pExcludeDirFilter: ?*IOfflineFilesItemFilter,
                dwQueryFlags: u32,
                ppItem: ?*?*IOfflineFilesItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                pszPath: ?[*:0]const u16,
                pIncludeFileFilter: ?*IOfflineFilesItemFilter,
                pIncludeDirFilter: ?*IOfflineFilesItemFilter,
                pExcludeFileFilter: ?*IOfflineFilesItemFilter,
                pExcludeDirFilter: ?*IOfflineFilesItemFilter,
                dwQueryFlags: u32,
                ppItem: ?*?*IOfflineFilesItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenameItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                pszPathOriginal: ?[*:0]const u16,
                pszPathNew: ?[*:0]const u16,
                bReplaceIfExists: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                pszPathOriginal: ?[*:0]const u16,
                pszPathNew: ?[*:0]const u16,
                bReplaceIfExists: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDiskSpaceInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                pcbVolumeTotal: ?*u64,
                pcbLimit: ?*u64,
                pcbUsed: ?*u64,
                pcbUnpinnedLimit: ?*u64,
                pcbUnpinnedUsed: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                pcbVolumeTotal: ?*u64,
                pcbLimit: ?*u64,
                pcbUsed: ?*u64,
                pcbUnpinnedLimit: ?*u64,
                pcbUnpinnedUsed: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDiskSpaceLimits: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                cbLimit: u64,
                cbUnpinnedLimit: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                cbLimit: u64,
                cbUnpinnedLimit: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessAdminPinPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                pPinProgress: ?*IOfflineFilesSyncProgress,
                pUnpinProgress: ?*IOfflineFilesSyncProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                pPinProgress: ?*IOfflineFilesSyncProgress,
                pUnpinProgress: ?*IOfflineFilesSyncProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSettingObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                pszSettingName: ?[*:0]const u16,
                ppSetting: ?*?*IOfflineFilesSetting,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                pszSettingName: ?[*:0]const u16,
                ppSetting: ?*?*IOfflineFilesSetting,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumSettingObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                ppEnum: ?*?*IEnumOfflineFilesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                ppEnum: ?*?*IEnumOfflineFilesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPathCacheable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache,
                pszPath: ?[*:0]const u16,
                pbCacheable: ?*BOOL,
                pShareCachingMode: ?*OFFLINEFILES_CACHING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache,
                pszPath: ?[*:0]const u16,
                pbCacheable: ?*BOOL,
                pShareCachingMode: ?*OFFLINEFILES_CACHING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_Synchronize(self: *const T, hwndParent: ?HWND, rgpszPaths: [*]?PWSTR, cPaths: u32, bAsync: BOOL, dwSyncControl: u32, pISyncConflictHandler: ?*IOfflineFilesSyncConflictHandler, pIProgress: ?*IOfflineFilesSyncProgress, pSyncId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).Synchronize(@ptrCast(*const IOfflineFilesCache, self), hwndParent, rgpszPaths, cPaths, bAsync, dwSyncControl, pISyncConflictHandler, pIProgress, pSyncId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_DeleteItems(self: *const T, rgpszPaths: [*]?PWSTR, cPaths: u32, dwFlags: u32, bAsync: BOOL, pIProgress: ?*IOfflineFilesSimpleProgress) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).DeleteItems(@ptrCast(*const IOfflineFilesCache, self), rgpszPaths, cPaths, dwFlags, bAsync, pIProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_DeleteItemsForUser(self: *const T, pszUser: ?[*:0]const u16, rgpszPaths: [*]?PWSTR, cPaths: u32, dwFlags: u32, bAsync: BOOL, pIProgress: ?*IOfflineFilesSimpleProgress) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).DeleteItemsForUser(@ptrCast(*const IOfflineFilesCache, self), pszUser, rgpszPaths, cPaths, dwFlags, bAsync, pIProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_Pin(self: *const T, hwndParent: ?HWND, rgpszPaths: [*]?PWSTR, cPaths: u32, bDeep: BOOL, bAsync: BOOL, dwPinControlFlags: u32, pIProgress: ?*IOfflineFilesSyncProgress) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).Pin(@ptrCast(*const IOfflineFilesCache, self), hwndParent, rgpszPaths, cPaths, bDeep, bAsync, dwPinControlFlags, pIProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_Unpin(self: *const T, hwndParent: ?HWND, rgpszPaths: [*]?PWSTR, cPaths: u32, bDeep: BOOL, bAsync: BOOL, dwPinControlFlags: u32, pIProgress: ?*IOfflineFilesSyncProgress) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).Unpin(@ptrCast(*const IOfflineFilesCache, self), hwndParent, rgpszPaths, cPaths, bDeep, bAsync, dwPinControlFlags, pIProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_GetEncryptionStatus(self: *const T, pbEncrypted: ?*BOOL, pbPartial: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).GetEncryptionStatus(@ptrCast(*const IOfflineFilesCache, self), pbEncrypted, pbPartial);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_Encrypt(self: *const T, hwndParent: ?HWND, bEncrypt: BOOL, dwEncryptionControlFlags: u32, bAsync: BOOL, pIProgress: ?*IOfflineFilesSyncProgress) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).Encrypt(@ptrCast(*const IOfflineFilesCache, self), hwndParent, bEncrypt, dwEncryptionControlFlags, bAsync, pIProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_FindItem(self: *const T, pszPath: ?[*:0]const u16, dwQueryFlags: u32, ppItem: ?*?*IOfflineFilesItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).FindItem(@ptrCast(*const IOfflineFilesCache, self), pszPath, dwQueryFlags, ppItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_FindItemEx(self: *const T, pszPath: ?[*:0]const u16, pIncludeFileFilter: ?*IOfflineFilesItemFilter, pIncludeDirFilter: ?*IOfflineFilesItemFilter, pExcludeFileFilter: ?*IOfflineFilesItemFilter, pExcludeDirFilter: ?*IOfflineFilesItemFilter, dwQueryFlags: u32, ppItem: ?*?*IOfflineFilesItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).FindItemEx(@ptrCast(*const IOfflineFilesCache, self), pszPath, pIncludeFileFilter, pIncludeDirFilter, pExcludeFileFilter, pExcludeDirFilter, dwQueryFlags, ppItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_RenameItem(self: *const T, pszPathOriginal: ?[*:0]const u16, pszPathNew: ?[*:0]const u16, bReplaceIfExists: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).RenameItem(@ptrCast(*const IOfflineFilesCache, self), pszPathOriginal, pszPathNew, bReplaceIfExists);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_GetLocation(self: *const T, ppszPath: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).GetLocation(@ptrCast(*const IOfflineFilesCache, self), ppszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_GetDiskSpaceInformation(self: *const T, pcbVolumeTotal: ?*u64, pcbLimit: ?*u64, pcbUsed: ?*u64, pcbUnpinnedLimit: ?*u64, pcbUnpinnedUsed: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).GetDiskSpaceInformation(@ptrCast(*const IOfflineFilesCache, self), pcbVolumeTotal, pcbLimit, pcbUsed, pcbUnpinnedLimit, pcbUnpinnedUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_SetDiskSpaceLimits(self: *const T, cbLimit: u64, cbUnpinnedLimit: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).SetDiskSpaceLimits(@ptrCast(*const IOfflineFilesCache, self), cbLimit, cbUnpinnedLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_ProcessAdminPinPolicy(self: *const T, pPinProgress: ?*IOfflineFilesSyncProgress, pUnpinProgress: ?*IOfflineFilesSyncProgress) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).ProcessAdminPinPolicy(@ptrCast(*const IOfflineFilesCache, self), pPinProgress, pUnpinProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_GetSettingObject(self: *const T, pszSettingName: ?[*:0]const u16, ppSetting: ?*?*IOfflineFilesSetting) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).GetSettingObject(@ptrCast(*const IOfflineFilesCache, self), pszSettingName, ppSetting);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_EnumSettingObjects(self: *const T, ppEnum: ?*?*IEnumOfflineFilesSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).EnumSettingObjects(@ptrCast(*const IOfflineFilesCache, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache_IsPathCacheable(self: *const T, pszPath: ?[*:0]const u16, pbCacheable: ?*BOOL, pShareCachingMode: ?*OFFLINEFILES_CACHING_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache.VTable, self.vtable).IsPathCacheable(@ptrCast(*const IOfflineFilesCache, self), pszPath, pbCacheable, pShareCachingMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOfflineFilesCache2_Value = Guid.initString("8c075039-1551-4ed9-8781-56705c04d3c0");
pub const IID_IOfflineFilesCache2 = &IID_IOfflineFilesCache2_Value;
pub const IOfflineFilesCache2 = extern struct {
    pub const VTable = extern struct {
        base: IOfflineFilesCache.VTable,
        RenameItemEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOfflineFilesCache2,
                pszPathOriginal: ?[*:0]const u16,
                pszPathNew: ?[*:0]const u16,
                bReplaceIfExists: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOfflineFilesCache2,
                pszPathOriginal: ?[*:0]const u16,
                pszPathNew: ?[*:0]const u16,
                bReplaceIfExists: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOfflineFilesCache.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOfflineFilesCache2_RenameItemEx(self: *const T, pszPathOriginal: ?[*:0]const u16, pszPathNew: ?[*:0]const u16, bReplaceIfExists: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOfflineFilesCache2.VTable, self.vtable).RenameItemEx(@ptrCast(*const IOfflineFilesCache2, self), pszPathOriginal, pszPathNew, bReplaceIfExists);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (4)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "cscapi" fn OfflineFilesEnable(
    bEnable: BOOL,
    pbRebootRequired: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "cscapi" fn OfflineFilesStart(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "cscapi" fn OfflineFilesQueryStatus(
    pbActive: ?*BOOL,
    pbEnabled: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "cscapi" fn OfflineFilesQueryStatusEx(
    pbActive: ?*BOOL,
    pbEnabled: ?*BOOL,
    pbAvailable: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (10)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BYTE_BLOB = @import("../system/com.zig").BYTE_BLOB;
const FILETIME = @import("../foundation.zig").FILETIME;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PWSTR = @import("../foundation.zig").PWSTR;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
