//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1117)
//--------------------------------------------------------------------------------
pub const TAPI_CURRENT_VERSION = @as(u32, 131074);
pub const LINE_ADDRESSSTATE = @as(i32, 0);
pub const LINE_CALLINFO = @as(i32, 1);
pub const LINE_CALLSTATE = @as(i32, 2);
pub const LINE_CLOSE = @as(i32, 3);
pub const LINE_DEVSPECIFIC = @as(i32, 4);
pub const LINE_DEVSPECIFICFEATURE = @as(i32, 5);
pub const LINE_GATHERDIGITS = @as(i32, 6);
pub const LINE_GENERATE = @as(i32, 7);
pub const LINE_LINEDEVSTATE = @as(i32, 8);
pub const LINE_MONITORDIGITS = @as(i32, 9);
pub const LINE_MONITORMEDIA = @as(i32, 10);
pub const LINE_MONITORTONE = @as(i32, 11);
pub const LINE_REPLY = @as(i32, 12);
pub const LINE_REQUEST = @as(i32, 13);
pub const PHONE_BUTTON = @as(i32, 14);
pub const PHONE_CLOSE = @as(i32, 15);
pub const PHONE_DEVSPECIFIC = @as(i32, 16);
pub const PHONE_REPLY = @as(i32, 17);
pub const PHONE_STATE = @as(i32, 18);
pub const LINE_CREATE = @as(i32, 19);
pub const PHONE_CREATE = @as(i32, 20);
pub const LINE_AGENTSPECIFIC = @as(i32, 21);
pub const LINE_AGENTSTATUS = @as(i32, 22);
pub const LINE_APPNEWCALL = @as(i32, 23);
pub const LINE_PROXYREQUEST = @as(i32, 24);
pub const LINE_REMOVE = @as(i32, 25);
pub const PHONE_REMOVE = @as(i32, 26);
pub const LINE_AGENTSESSIONSTATUS = @as(i32, 27);
pub const LINE_QUEUESTATUS = @as(i32, 28);
pub const LINE_AGENTSTATUSEX = @as(i32, 29);
pub const LINE_GROUPSTATUS = @as(i32, 30);
pub const LINE_PROXYSTATUS = @as(i32, 31);
pub const LINE_APPNEWCALLHUB = @as(i32, 32);
pub const LINE_CALLHUBCLOSE = @as(i32, 33);
pub const LINE_DEVSPECIFICEX = @as(i32, 34);
pub const INITIALIZE_NEGOTIATION = @as(u32, 4294967295);
pub const LINEADDRCAPFLAGS_FWDNUMRINGS = @as(u32, 1);
pub const LINEADDRCAPFLAGS_PICKUPGROUPID = @as(u32, 2);
pub const LINEADDRCAPFLAGS_SECURE = @as(u32, 4);
pub const LINEADDRCAPFLAGS_BLOCKIDDEFAULT = @as(u32, 8);
pub const LINEADDRCAPFLAGS_BLOCKIDOVERRIDE = @as(u32, 16);
pub const LINEADDRCAPFLAGS_DIALED = @as(u32, 32);
pub const LINEADDRCAPFLAGS_ORIGOFFHOOK = @as(u32, 64);
pub const LINEADDRCAPFLAGS_DESTOFFHOOK = @as(u32, 128);
pub const LINEADDRCAPFLAGS_FWDCONSULT = @as(u32, 256);
pub const LINEADDRCAPFLAGS_SETUPCONFNULL = @as(u32, 512);
pub const LINEADDRCAPFLAGS_AUTORECONNECT = @as(u32, 1024);
pub const LINEADDRCAPFLAGS_COMPLETIONID = @as(u32, 2048);
pub const LINEADDRCAPFLAGS_TRANSFERHELD = @as(u32, 4096);
pub const LINEADDRCAPFLAGS_TRANSFERMAKE = @as(u32, 8192);
pub const LINEADDRCAPFLAGS_CONFERENCEHELD = @as(u32, 16384);
pub const LINEADDRCAPFLAGS_CONFERENCEMAKE = @as(u32, 32768);
pub const LINEADDRCAPFLAGS_PARTIALDIAL = @as(u32, 65536);
pub const LINEADDRCAPFLAGS_FWDSTATUSVALID = @as(u32, 131072);
pub const LINEADDRCAPFLAGS_FWDINTEXTADDR = @as(u32, 262144);
pub const LINEADDRCAPFLAGS_FWDBUSYNAADDR = @as(u32, 524288);
pub const LINEADDRCAPFLAGS_ACCEPTTOALERT = @as(u32, 1048576);
pub const LINEADDRCAPFLAGS_CONFDROP = @as(u32, 2097152);
pub const LINEADDRCAPFLAGS_PICKUPCALLWAIT = @as(u32, 4194304);
pub const LINEADDRCAPFLAGS_PREDICTIVEDIALER = @as(u32, 8388608);
pub const LINEADDRCAPFLAGS_QUEUE = @as(u32, 16777216);
pub const LINEADDRCAPFLAGS_ROUTEPOINT = @as(u32, 33554432);
pub const LINEADDRCAPFLAGS_HOLDMAKESNEW = @as(u32, 67108864);
pub const LINEADDRCAPFLAGS_NOINTERNALCALLS = @as(u32, 134217728);
pub const LINEADDRCAPFLAGS_NOEXTERNALCALLS = @as(u32, 268435456);
pub const LINEADDRCAPFLAGS_SETCALLINGID = @as(u32, 536870912);
pub const LINEADDRCAPFLAGS_ACDGROUP = @as(u32, 1073741824);
pub const LINEADDRCAPFLAGS_NOPSTNADDRESSTRANSLATION = @as(u32, 2147483648);
pub const LINEADDRESSMODE_ADDRESSID = @as(u32, 1);
pub const LINEADDRESSMODE_DIALABLEADDR = @as(u32, 2);
pub const LINEADDRESSSHARING_PRIVATE = @as(u32, 1);
pub const LINEADDRESSSHARING_BRIDGEDEXCL = @as(u32, 2);
pub const LINEADDRESSSHARING_BRIDGEDNEW = @as(u32, 4);
pub const LINEADDRESSSHARING_BRIDGEDSHARED = @as(u32, 8);
pub const LINEADDRESSSHARING_MONITORED = @as(u32, 16);
pub const LINEADDRESSSTATE_OTHER = @as(u32, 1);
pub const LINEADDRESSSTATE_DEVSPECIFIC = @as(u32, 2);
pub const LINEADDRESSSTATE_INUSEZERO = @as(u32, 4);
pub const LINEADDRESSSTATE_INUSEONE = @as(u32, 8);
pub const LINEADDRESSSTATE_INUSEMANY = @as(u32, 16);
pub const LINEADDRESSSTATE_NUMCALLS = @as(u32, 32);
pub const LINEADDRESSSTATE_FORWARD = @as(u32, 64);
pub const LINEADDRESSSTATE_TERMINALS = @as(u32, 128);
pub const LINEADDRESSSTATE_CAPSCHANGE = @as(u32, 256);
pub const LINEADDRESSTYPE_PHONENUMBER = @as(u32, 1);
pub const LINEADDRESSTYPE_SDP = @as(u32, 2);
pub const LINEADDRESSTYPE_EMAILNAME = @as(u32, 4);
pub const LINEADDRESSTYPE_DOMAINNAME = @as(u32, 8);
pub const LINEADDRESSTYPE_IPADDRESS = @as(u32, 16);
pub const LINEADDRFEATURE_FORWARD = @as(u32, 1);
pub const LINEADDRFEATURE_MAKECALL = @as(u32, 2);
pub const LINEADDRFEATURE_PICKUP = @as(u32, 4);
pub const LINEADDRFEATURE_SETMEDIACONTROL = @as(u32, 8);
pub const LINEADDRFEATURE_SETTERMINAL = @as(u32, 16);
pub const LINEADDRFEATURE_SETUPCONF = @as(u32, 32);
pub const LINEADDRFEATURE_UNCOMPLETECALL = @as(u32, 64);
pub const LINEADDRFEATURE_UNPARK = @as(u32, 128);
pub const LINEADDRFEATURE_PICKUPHELD = @as(u32, 256);
pub const LINEADDRFEATURE_PICKUPGROUP = @as(u32, 512);
pub const LINEADDRFEATURE_PICKUPDIRECT = @as(u32, 1024);
pub const LINEADDRFEATURE_PICKUPWAITING = @as(u32, 2048);
pub const LINEADDRFEATURE_FORWARDFWD = @as(u32, 4096);
pub const LINEADDRFEATURE_FORWARDDND = @as(u32, 8192);
pub const LINEAGENTFEATURE_SETAGENTGROUP = @as(u32, 1);
pub const LINEAGENTFEATURE_SETAGENTSTATE = @as(u32, 2);
pub const LINEAGENTFEATURE_SETAGENTACTIVITY = @as(u32, 4);
pub const LINEAGENTFEATURE_AGENTSPECIFIC = @as(u32, 8);
pub const LINEAGENTFEATURE_GETAGENTACTIVITYLIST = @as(u32, 16);
pub const LINEAGENTFEATURE_GETAGENTGROUP = @as(u32, 32);
pub const LINEAGENTSTATE_LOGGEDOFF = @as(u32, 1);
pub const LINEAGENTSTATE_NOTREADY = @as(u32, 2);
pub const LINEAGENTSTATE_READY = @as(u32, 4);
pub const LINEAGENTSTATE_BUSYACD = @as(u32, 8);
pub const LINEAGENTSTATE_BUSYINCOMING = @as(u32, 16);
pub const LINEAGENTSTATE_BUSYOUTBOUND = @as(u32, 32);
pub const LINEAGENTSTATE_BUSYOTHER = @as(u32, 64);
pub const LINEAGENTSTATE_WORKINGAFTERCALL = @as(u32, 128);
pub const LINEAGENTSTATE_UNKNOWN = @as(u32, 256);
pub const LINEAGENTSTATE_UNAVAIL = @as(u32, 512);
pub const LINEAGENTSTATUS_GROUP = @as(u32, 1);
pub const LINEAGENTSTATUS_STATE = @as(u32, 2);
pub const LINEAGENTSTATUS_NEXTSTATE = @as(u32, 4);
pub const LINEAGENTSTATUS_ACTIVITY = @as(u32, 8);
pub const LINEAGENTSTATUS_ACTIVITYLIST = @as(u32, 16);
pub const LINEAGENTSTATUS_GROUPLIST = @as(u32, 32);
pub const LINEAGENTSTATUS_CAPSCHANGE = @as(u32, 64);
pub const LINEAGENTSTATUS_VALIDSTATES = @as(u32, 128);
pub const LINEAGENTSTATUS_VALIDNEXTSTATES = @as(u32, 256);
pub const LINEAGENTSTATEEX_NOTREADY = @as(u32, 1);
pub const LINEAGENTSTATEEX_READY = @as(u32, 2);
pub const LINEAGENTSTATEEX_BUSYACD = @as(u32, 4);
pub const LINEAGENTSTATEEX_BUSYINCOMING = @as(u32, 8);
pub const LINEAGENTSTATEEX_BUSYOUTGOING = @as(u32, 16);
pub const LINEAGENTSTATEEX_UNKNOWN = @as(u32, 32);
pub const LINEAGENTSTATEEX_RELEASED = @as(u32, 64);
pub const LINEAGENTSTATUSEX_NEWAGENT = @as(u32, 1);
pub const LINEAGENTSTATUSEX_STATE = @as(u32, 2);
pub const LINEAGENTSTATUSEX_UPDATEINFO = @as(u32, 4);
pub const LINEAGENTSESSIONSTATE_NOTREADY = @as(u32, 1);
pub const LINEAGENTSESSIONSTATE_READY = @as(u32, 2);
pub const LINEAGENTSESSIONSTATE_BUSYONCALL = @as(u32, 4);
pub const LINEAGENTSESSIONSTATE_BUSYWRAPUP = @as(u32, 8);
pub const LINEAGENTSESSIONSTATE_ENDED = @as(u32, 16);
pub const LINEAGENTSESSIONSTATE_RELEASED = @as(u32, 32);
pub const LINEAGENTSESSIONSTATUS_NEWSESSION = @as(u32, 1);
pub const LINEAGENTSESSIONSTATUS_STATE = @as(u32, 2);
pub const LINEAGENTSESSIONSTATUS_UPDATEINFO = @as(u32, 4);
pub const LINEQUEUESTATUS_UPDATEINFO = @as(u32, 1);
pub const LINEQUEUESTATUS_NEWQUEUE = @as(u32, 2);
pub const LINEQUEUESTATUS_QUEUEREMOVED = @as(u32, 4);
pub const LINEGROUPSTATUS_NEWGROUP = @as(u32, 1);
pub const LINEGROUPSTATUS_GROUPREMOVED = @as(u32, 2);
pub const LINEPROXYSTATUS_OPEN = @as(u32, 1);
pub const LINEPROXYSTATUS_CLOSE = @as(u32, 2);
pub const LINEPROXYSTATUS_ALLOPENFORACD = @as(u32, 4);
pub const LINEANSWERMODE_NONE = @as(u32, 1);
pub const LINEANSWERMODE_DROP = @as(u32, 2);
pub const LINEANSWERMODE_HOLD = @as(u32, 4);
pub const LINEBEARERMODE_VOICE = @as(u32, 1);
pub const LINEBEARERMODE_SPEECH = @as(u32, 2);
pub const LINEBEARERMODE_MULTIUSE = @as(u32, 4);
pub const LINEBEARERMODE_DATA = @as(u32, 8);
pub const LINEBEARERMODE_ALTSPEECHDATA = @as(u32, 16);
pub const LINEBEARERMODE_NONCALLSIGNALING = @as(u32, 32);
pub const LINEBEARERMODE_PASSTHROUGH = @as(u32, 64);
pub const LINEBEARERMODE_RESTRICTEDDATA = @as(u32, 128);
pub const LINEBUSYMODE_STATION = @as(u32, 1);
pub const LINEBUSYMODE_TRUNK = @as(u32, 2);
pub const LINEBUSYMODE_UNKNOWN = @as(u32, 4);
pub const LINEBUSYMODE_UNAVAIL = @as(u32, 8);
pub const LINECALLCOMPLCOND_BUSY = @as(u32, 1);
pub const LINECALLCOMPLCOND_NOANSWER = @as(u32, 2);
pub const LINECALLCOMPLMODE_CAMPON = @as(u32, 1);
pub const LINECALLCOMPLMODE_CALLBACK = @as(u32, 2);
pub const LINECALLCOMPLMODE_INTRUDE = @as(u32, 4);
pub const LINECALLCOMPLMODE_MESSAGE = @as(u32, 8);
pub const LINECALLFEATURE_ACCEPT = @as(u32, 1);
pub const LINECALLFEATURE_ADDTOCONF = @as(u32, 2);
pub const LINECALLFEATURE_ANSWER = @as(u32, 4);
pub const LINECALLFEATURE_BLINDTRANSFER = @as(u32, 8);
pub const LINECALLFEATURE_COMPLETECALL = @as(u32, 16);
pub const LINECALLFEATURE_COMPLETETRANSF = @as(u32, 32);
pub const LINECALLFEATURE_DIAL = @as(u32, 64);
pub const LINECALLFEATURE_DROP = @as(u32, 128);
pub const LINECALLFEATURE_GATHERDIGITS = @as(u32, 256);
pub const LINECALLFEATURE_GENERATEDIGITS = @as(u32, 512);
pub const LINECALLFEATURE_GENERATETONE = @as(u32, 1024);
pub const LINECALLFEATURE_HOLD = @as(u32, 2048);
pub const LINECALLFEATURE_MONITORDIGITS = @as(u32, 4096);
pub const LINECALLFEATURE_MONITORMEDIA = @as(u32, 8192);
pub const LINECALLFEATURE_MONITORTONES = @as(u32, 16384);
pub const LINECALLFEATURE_PARK = @as(u32, 32768);
pub const LINECALLFEATURE_PREPAREADDCONF = @as(u32, 65536);
pub const LINECALLFEATURE_REDIRECT = @as(u32, 131072);
pub const LINECALLFEATURE_REMOVEFROMCONF = @as(u32, 262144);
pub const LINECALLFEATURE_SECURECALL = @as(u32, 524288);
pub const LINECALLFEATURE_SENDUSERUSER = @as(u32, 1048576);
pub const LINECALLFEATURE_SETCALLPARAMS = @as(u32, 2097152);
pub const LINECALLFEATURE_SETMEDIACONTROL = @as(u32, 4194304);
pub const LINECALLFEATURE_SETTERMINAL = @as(u32, 8388608);
pub const LINECALLFEATURE_SETUPCONF = @as(u32, 16777216);
pub const LINECALLFEATURE_SETUPTRANSFER = @as(u32, 33554432);
pub const LINECALLFEATURE_SWAPHOLD = @as(u32, 67108864);
pub const LINECALLFEATURE_UNHOLD = @as(u32, 134217728);
pub const LINECALLFEATURE_RELEASEUSERUSERINFO = @as(u32, 268435456);
pub const LINECALLFEATURE_SETTREATMENT = @as(u32, 536870912);
pub const LINECALLFEATURE_SETQOS = @as(u32, 1073741824);
pub const LINECALLFEATURE_SETCALLDATA = @as(u32, 2147483648);
pub const LINECALLFEATURE2_NOHOLDCONFERENCE = @as(u32, 1);
pub const LINECALLFEATURE2_ONESTEPTRANSFER = @as(u32, 2);
pub const LINECALLFEATURE2_COMPLCAMPON = @as(u32, 4);
pub const LINECALLFEATURE2_COMPLCALLBACK = @as(u32, 8);
pub const LINECALLFEATURE2_COMPLINTRUDE = @as(u32, 16);
pub const LINECALLFEATURE2_COMPLMESSAGE = @as(u32, 32);
pub const LINECALLFEATURE2_TRANSFERNORM = @as(u32, 64);
pub const LINECALLFEATURE2_TRANSFERCONF = @as(u32, 128);
pub const LINECALLFEATURE2_PARKDIRECT = @as(u32, 256);
pub const LINECALLFEATURE2_PARKNONDIRECT = @as(u32, 512);
pub const LINECALLHUBTRACKING_NONE = @as(u32, 0);
pub const LINECALLHUBTRACKING_PROVIDERLEVEL = @as(u32, 1);
pub const LINECALLHUBTRACKING_ALLCALLS = @as(u32, 2);
pub const LINECALLINFOSTATE_OTHER = @as(u32, 1);
pub const LINECALLINFOSTATE_DEVSPECIFIC = @as(u32, 2);
pub const LINECALLINFOSTATE_BEARERMODE = @as(u32, 4);
pub const LINECALLINFOSTATE_RATE = @as(u32, 8);
pub const LINECALLINFOSTATE_MEDIAMODE = @as(u32, 16);
pub const LINECALLINFOSTATE_APPSPECIFIC = @as(u32, 32);
pub const LINECALLINFOSTATE_CALLID = @as(u32, 64);
pub const LINECALLINFOSTATE_RELATEDCALLID = @as(u32, 128);
pub const LINECALLINFOSTATE_ORIGIN = @as(u32, 256);
pub const LINECALLINFOSTATE_REASON = @as(u32, 512);
pub const LINECALLINFOSTATE_COMPLETIONID = @as(u32, 1024);
pub const LINECALLINFOSTATE_NUMOWNERINCR = @as(u32, 2048);
pub const LINECALLINFOSTATE_NUMOWNERDECR = @as(u32, 4096);
pub const LINECALLINFOSTATE_NUMMONITORS = @as(u32, 8192);
pub const LINECALLINFOSTATE_TRUNK = @as(u32, 16384);
pub const LINECALLINFOSTATE_CALLERID = @as(u32, 32768);
pub const LINECALLINFOSTATE_CALLEDID = @as(u32, 65536);
pub const LINECALLINFOSTATE_CONNECTEDID = @as(u32, 131072);
pub const LINECALLINFOSTATE_REDIRECTIONID = @as(u32, 262144);
pub const LINECALLINFOSTATE_REDIRECTINGID = @as(u32, 524288);
pub const LINECALLINFOSTATE_DISPLAY = @as(u32, 1048576);
pub const LINECALLINFOSTATE_USERUSERINFO = @as(u32, 2097152);
pub const LINECALLINFOSTATE_HIGHLEVELCOMP = @as(u32, 4194304);
pub const LINECALLINFOSTATE_LOWLEVELCOMP = @as(u32, 8388608);
pub const LINECALLINFOSTATE_CHARGINGINFO = @as(u32, 16777216);
pub const LINECALLINFOSTATE_TERMINAL = @as(u32, 33554432);
pub const LINECALLINFOSTATE_DIALPARAMS = @as(u32, 67108864);
pub const LINECALLINFOSTATE_MONITORMODES = @as(u32, 134217728);
pub const LINECALLINFOSTATE_TREATMENT = @as(u32, 268435456);
pub const LINECALLINFOSTATE_QOS = @as(u32, 536870912);
pub const LINECALLINFOSTATE_CALLDATA = @as(u32, 1073741824);
pub const LINECALLORIGIN_OUTBOUND = @as(u32, 1);
pub const LINECALLORIGIN_INTERNAL = @as(u32, 2);
pub const LINECALLORIGIN_EXTERNAL = @as(u32, 4);
pub const LINECALLORIGIN_UNKNOWN = @as(u32, 16);
pub const LINECALLORIGIN_UNAVAIL = @as(u32, 32);
pub const LINECALLORIGIN_CONFERENCE = @as(u32, 64);
pub const LINECALLORIGIN_INBOUND = @as(u32, 128);
pub const LINECALLPARAMFLAGS_SECURE = @as(u32, 1);
pub const LINECALLPARAMFLAGS_IDLE = @as(u32, 2);
pub const LINECALLPARAMFLAGS_BLOCKID = @as(u32, 4);
pub const LINECALLPARAMFLAGS_ORIGOFFHOOK = @as(u32, 8);
pub const LINECALLPARAMFLAGS_DESTOFFHOOK = @as(u32, 16);
pub const LINECALLPARAMFLAGS_NOHOLDCONFERENCE = @as(u32, 32);
pub const LINECALLPARAMFLAGS_PREDICTIVEDIAL = @as(u32, 64);
pub const LINECALLPARAMFLAGS_ONESTEPTRANSFER = @as(u32, 128);
pub const LINECALLPARTYID_BLOCKED = @as(u32, 1);
pub const LINECALLPARTYID_OUTOFAREA = @as(u32, 2);
pub const LINECALLPARTYID_NAME = @as(u32, 4);
pub const LINECALLPARTYID_ADDRESS = @as(u32, 8);
pub const LINECALLPARTYID_PARTIAL = @as(u32, 16);
pub const LINECALLPARTYID_UNKNOWN = @as(u32, 32);
pub const LINECALLPARTYID_UNAVAIL = @as(u32, 64);
pub const LINECALLPRIVILEGE_NONE = @as(u32, 1);
pub const LINECALLPRIVILEGE_MONITOR = @as(u32, 2);
pub const LINECALLPRIVILEGE_OWNER = @as(u32, 4);
pub const LINECALLREASON_DIRECT = @as(u32, 1);
pub const LINECALLREASON_FWDBUSY = @as(u32, 2);
pub const LINECALLREASON_FWDNOANSWER = @as(u32, 4);
pub const LINECALLREASON_FWDUNCOND = @as(u32, 8);
pub const LINECALLREASON_PICKUP = @as(u32, 16);
pub const LINECALLREASON_UNPARK = @as(u32, 32);
pub const LINECALLREASON_REDIRECT = @as(u32, 64);
pub const LINECALLREASON_CALLCOMPLETION = @as(u32, 128);
pub const LINECALLREASON_TRANSFER = @as(u32, 256);
pub const LINECALLREASON_REMINDER = @as(u32, 512);
pub const LINECALLREASON_UNKNOWN = @as(u32, 1024);
pub const LINECALLREASON_UNAVAIL = @as(u32, 2048);
pub const LINECALLREASON_INTRUDE = @as(u32, 4096);
pub const LINECALLREASON_PARKED = @as(u32, 8192);
pub const LINECALLREASON_CAMPEDON = @as(u32, 16384);
pub const LINECALLREASON_ROUTEREQUEST = @as(u32, 32768);
pub const LINECALLSELECT_LINE = @as(u32, 1);
pub const LINECALLSELECT_ADDRESS = @as(u32, 2);
pub const LINECALLSELECT_CALL = @as(u32, 4);
pub const LINECALLSELECT_DEVICEID = @as(u32, 8);
pub const LINECALLSELECT_CALLID = @as(u32, 16);
pub const LINECALLSTATE_IDLE = @as(u32, 1);
pub const LINECALLSTATE_OFFERING = @as(u32, 2);
pub const LINECALLSTATE_ACCEPTED = @as(u32, 4);
pub const LINECALLSTATE_DIALTONE = @as(u32, 8);
pub const LINECALLSTATE_DIALING = @as(u32, 16);
pub const LINECALLSTATE_RINGBACK = @as(u32, 32);
pub const LINECALLSTATE_BUSY = @as(u32, 64);
pub const LINECALLSTATE_SPECIALINFO = @as(u32, 128);
pub const LINECALLSTATE_CONNECTED = @as(u32, 256);
pub const LINECALLSTATE_PROCEEDING = @as(u32, 512);
pub const LINECALLSTATE_ONHOLD = @as(u32, 1024);
pub const LINECALLSTATE_CONFERENCED = @as(u32, 2048);
pub const LINECALLSTATE_ONHOLDPENDCONF = @as(u32, 4096);
pub const LINECALLSTATE_ONHOLDPENDTRANSFER = @as(u32, 8192);
pub const LINECALLSTATE_DISCONNECTED = @as(u32, 16384);
pub const LINECALLSTATE_UNKNOWN = @as(u32, 32768);
pub const LINECALLTREATMENT_SILENCE = @as(u32, 1);
pub const LINECALLTREATMENT_RINGBACK = @as(u32, 2);
pub const LINECALLTREATMENT_BUSY = @as(u32, 3);
pub const LINECALLTREATMENT_MUSIC = @as(u32, 4);
pub const LINECARDOPTION_PREDEFINED = @as(u32, 1);
pub const LINECARDOPTION_HIDDEN = @as(u32, 2);
pub const LINECONNECTEDMODE_ACTIVE = @as(u32, 1);
pub const LINECONNECTEDMODE_INACTIVE = @as(u32, 2);
pub const LINECONNECTEDMODE_ACTIVEHELD = @as(u32, 4);
pub const LINECONNECTEDMODE_INACTIVEHELD = @as(u32, 8);
pub const LINECONNECTEDMODE_CONFIRMED = @as(u32, 16);
pub const LINEDEVCAPFLAGS_CROSSADDRCONF = @as(u32, 1);
pub const LINEDEVCAPFLAGS_HIGHLEVCOMP = @as(u32, 2);
pub const LINEDEVCAPFLAGS_LOWLEVCOMP = @as(u32, 4);
pub const LINEDEVCAPFLAGS_MEDIACONTROL = @as(u32, 8);
pub const LINEDEVCAPFLAGS_MULTIPLEADDR = @as(u32, 16);
pub const LINEDEVCAPFLAGS_CLOSEDROP = @as(u32, 32);
pub const LINEDEVCAPFLAGS_DIALBILLING = @as(u32, 64);
pub const LINEDEVCAPFLAGS_DIALQUIET = @as(u32, 128);
pub const LINEDEVCAPFLAGS_DIALDIALTONE = @as(u32, 256);
pub const LINEDEVCAPFLAGS_MSP = @as(u32, 512);
pub const LINEDEVCAPFLAGS_CALLHUB = @as(u32, 1024);
pub const LINEDEVCAPFLAGS_CALLHUBTRACKING = @as(u32, 2048);
pub const LINEDEVCAPFLAGS_PRIVATEOBJECTS = @as(u32, 4096);
pub const LINEDEVCAPFLAGS_LOCAL = @as(u32, 8192);
pub const LINEDEVSTATE_OTHER = @as(u32, 1);
pub const LINEDEVSTATE_RINGING = @as(u32, 2);
pub const LINEDEVSTATE_CONNECTED = @as(u32, 4);
pub const LINEDEVSTATE_DISCONNECTED = @as(u32, 8);
pub const LINEDEVSTATE_MSGWAITON = @as(u32, 16);
pub const LINEDEVSTATE_MSGWAITOFF = @as(u32, 32);
pub const LINEDEVSTATE_INSERVICE = @as(u32, 64);
pub const LINEDEVSTATE_OUTOFSERVICE = @as(u32, 128);
pub const LINEDEVSTATE_MAINTENANCE = @as(u32, 256);
pub const LINEDEVSTATE_OPEN = @as(u32, 512);
pub const LINEDEVSTATE_CLOSE = @as(u32, 1024);
pub const LINEDEVSTATE_NUMCALLS = @as(u32, 2048);
pub const LINEDEVSTATE_NUMCOMPLETIONS = @as(u32, 4096);
pub const LINEDEVSTATE_TERMINALS = @as(u32, 8192);
pub const LINEDEVSTATE_ROAMMODE = @as(u32, 16384);
pub const LINEDEVSTATE_BATTERY = @as(u32, 32768);
pub const LINEDEVSTATE_SIGNAL = @as(u32, 65536);
pub const LINEDEVSTATE_DEVSPECIFIC = @as(u32, 131072);
pub const LINEDEVSTATE_REINIT = @as(u32, 262144);
pub const LINEDEVSTATE_LOCK = @as(u32, 524288);
pub const LINEDEVSTATE_CAPSCHANGE = @as(u32, 1048576);
pub const LINEDEVSTATE_CONFIGCHANGE = @as(u32, 2097152);
pub const LINEDEVSTATE_TRANSLATECHANGE = @as(u32, 4194304);
pub const LINEDEVSTATE_COMPLCANCEL = @as(u32, 8388608);
pub const LINEDEVSTATE_REMOVED = @as(u32, 16777216);
pub const LINEDEVSTATUSFLAGS_CONNECTED = @as(u32, 1);
pub const LINEDEVSTATUSFLAGS_MSGWAIT = @as(u32, 2);
pub const LINEDEVSTATUSFLAGS_INSERVICE = @as(u32, 4);
pub const LINEDEVSTATUSFLAGS_LOCKED = @as(u32, 8);
pub const LINEDIALTONEMODE_NORMAL = @as(u32, 1);
pub const LINEDIALTONEMODE_SPECIAL = @as(u32, 2);
pub const LINEDIALTONEMODE_INTERNAL = @as(u32, 4);
pub const LINEDIALTONEMODE_EXTERNAL = @as(u32, 8);
pub const LINEDIALTONEMODE_UNKNOWN = @as(u32, 16);
pub const LINEDIALTONEMODE_UNAVAIL = @as(u32, 32);
pub const LINEDIGITMODE_PULSE = @as(u32, 1);
pub const LINEDIGITMODE_DTMF = @as(u32, 2);
pub const LINEDIGITMODE_DTMFEND = @as(u32, 4);
pub const LINEDISCONNECTMODE_NORMAL = @as(u32, 1);
pub const LINEDISCONNECTMODE_UNKNOWN = @as(u32, 2);
pub const LINEDISCONNECTMODE_REJECT = @as(u32, 4);
pub const LINEDISCONNECTMODE_PICKUP = @as(u32, 8);
pub const LINEDISCONNECTMODE_FORWARDED = @as(u32, 16);
pub const LINEDISCONNECTMODE_BUSY = @as(u32, 32);
pub const LINEDISCONNECTMODE_NOANSWER = @as(u32, 64);
pub const LINEDISCONNECTMODE_BADADDRESS = @as(u32, 128);
pub const LINEDISCONNECTMODE_UNREACHABLE = @as(u32, 256);
pub const LINEDISCONNECTMODE_CONGESTION = @as(u32, 512);
pub const LINEDISCONNECTMODE_INCOMPATIBLE = @as(u32, 1024);
pub const LINEDISCONNECTMODE_UNAVAIL = @as(u32, 2048);
pub const LINEDISCONNECTMODE_NODIALTONE = @as(u32, 4096);
pub const LINEDISCONNECTMODE_NUMBERCHANGED = @as(u32, 8192);
pub const LINEDISCONNECTMODE_OUTOFORDER = @as(u32, 16384);
pub const LINEDISCONNECTMODE_TEMPFAILURE = @as(u32, 32768);
pub const LINEDISCONNECTMODE_QOSUNAVAIL = @as(u32, 65536);
pub const LINEDISCONNECTMODE_BLOCKED = @as(u32, 131072);
pub const LINEDISCONNECTMODE_DONOTDISTURB = @as(u32, 262144);
pub const LINEDISCONNECTMODE_CANCELLED = @as(u32, 524288);
pub const LINEDISCONNECTMODE_DESTINATIONBARRED = @as(u32, 1048576);
pub const LINEDISCONNECTMODE_FDNRESTRICT = @as(u32, 2097152);
pub const LINEERR_ALLOCATED = @as(u32, 2147483649);
pub const LINEERR_BADDEVICEID = @as(u32, 2147483650);
pub const LINEERR_BEARERMODEUNAVAIL = @as(u32, 2147483651);
pub const LINEERR_CALLUNAVAIL = @as(u32, 2147483653);
pub const LINEERR_COMPLETIONOVERRUN = @as(u32, 2147483654);
pub const LINEERR_CONFERENCEFULL = @as(u32, 2147483655);
pub const LINEERR_DIALBILLING = @as(u32, 2147483656);
pub const LINEERR_DIALDIALTONE = @as(u32, 2147483657);
pub const LINEERR_DIALPROMPT = @as(u32, 2147483658);
pub const LINEERR_DIALQUIET = @as(u32, 2147483659);
pub const LINEERR_INCOMPATIBLEAPIVERSION = @as(u32, 2147483660);
pub const LINEERR_INCOMPATIBLEEXTVERSION = @as(u32, 2147483661);
pub const LINEERR_INIFILECORRUPT = @as(u32, 2147483662);
pub const LINEERR_INUSE = @as(u32, 2147483663);
pub const LINEERR_INVALADDRESS = @as(u32, 2147483664);
pub const LINEERR_INVALADDRESSID = @as(u32, 2147483665);
pub const LINEERR_INVALADDRESSMODE = @as(u32, 2147483666);
pub const LINEERR_INVALADDRESSSTATE = @as(u32, 2147483667);
pub const LINEERR_INVALAPPHANDLE = @as(u32, 2147483668);
pub const LINEERR_INVALAPPNAME = @as(u32, 2147483669);
pub const LINEERR_INVALBEARERMODE = @as(u32, 2147483670);
pub const LINEERR_INVALCALLCOMPLMODE = @as(u32, 2147483671);
pub const LINEERR_INVALCALLHANDLE = @as(u32, 2147483672);
pub const LINEERR_INVALCALLPARAMS = @as(u32, 2147483673);
pub const LINEERR_INVALCALLPRIVILEGE = @as(u32, 2147483674);
pub const LINEERR_INVALCALLSELECT = @as(u32, 2147483675);
pub const LINEERR_INVALCALLSTATE = @as(u32, 2147483676);
pub const LINEERR_INVALCALLSTATELIST = @as(u32, 2147483677);
pub const LINEERR_INVALCARD = @as(u32, 2147483678);
pub const LINEERR_INVALCOMPLETIONID = @as(u32, 2147483679);
pub const LINEERR_INVALCONFCALLHANDLE = @as(u32, 2147483680);
pub const LINEERR_INVALCONSULTCALLHANDLE = @as(u32, 2147483681);
pub const LINEERR_INVALCOUNTRYCODE = @as(u32, 2147483682);
pub const LINEERR_INVALDEVICECLASS = @as(u32, 2147483683);
pub const LINEERR_INVALDEVICEHANDLE = @as(u32, 2147483684);
pub const LINEERR_INVALDIALPARAMS = @as(u32, 2147483685);
pub const LINEERR_INVALDIGITLIST = @as(u32, 2147483686);
pub const LINEERR_INVALDIGITMODE = @as(u32, 2147483687);
pub const LINEERR_INVALDIGITS = @as(u32, 2147483688);
pub const LINEERR_INVALEXTVERSION = @as(u32, 2147483689);
pub const LINEERR_INVALGROUPID = @as(u32, 2147483690);
pub const LINEERR_INVALLINEHANDLE = @as(u32, 2147483691);
pub const LINEERR_INVALLINESTATE = @as(u32, 2147483692);
pub const LINEERR_INVALLOCATION = @as(u32, 2147483693);
pub const LINEERR_INVALMEDIALIST = @as(u32, 2147483694);
pub const LINEERR_INVALMEDIAMODE = @as(u32, 2147483695);
pub const LINEERR_INVALMESSAGEID = @as(u32, 2147483696);
pub const LINEERR_INVALPARAM = @as(u32, 2147483698);
pub const LINEERR_INVALPARKID = @as(u32, 2147483699);
pub const LINEERR_INVALPARKMODE = @as(u32, 2147483700);
pub const LINEERR_INVALPOINTER = @as(u32, 2147483701);
pub const LINEERR_INVALPRIVSELECT = @as(u32, 2147483702);
pub const LINEERR_INVALRATE = @as(u32, 2147483703);
pub const LINEERR_INVALREQUESTMODE = @as(u32, 2147483704);
pub const LINEERR_INVALTERMINALID = @as(u32, 2147483705);
pub const LINEERR_INVALTERMINALMODE = @as(u32, 2147483706);
pub const LINEERR_INVALTIMEOUT = @as(u32, 2147483707);
pub const LINEERR_INVALTONE = @as(u32, 2147483708);
pub const LINEERR_INVALTONELIST = @as(u32, 2147483709);
pub const LINEERR_INVALTONEMODE = @as(u32, 2147483710);
pub const LINEERR_INVALTRANSFERMODE = @as(u32, 2147483711);
pub const LINEERR_LINEMAPPERFAILED = @as(u32, 2147483712);
pub const LINEERR_NOCONFERENCE = @as(u32, 2147483713);
pub const LINEERR_NODEVICE = @as(u32, 2147483714);
pub const LINEERR_NODRIVER = @as(u32, 2147483715);
pub const LINEERR_NOMEM = @as(u32, 2147483716);
pub const LINEERR_NOREQUEST = @as(u32, 2147483717);
pub const LINEERR_NOTOWNER = @as(u32, 2147483718);
pub const LINEERR_NOTREGISTERED = @as(u32, 2147483719);
pub const LINEERR_OPERATIONFAILED = @as(u32, 2147483720);
pub const LINEERR_OPERATIONUNAVAIL = @as(u32, 2147483721);
pub const LINEERR_RATEUNAVAIL = @as(u32, 2147483722);
pub const LINEERR_RESOURCEUNAVAIL = @as(u32, 2147483723);
pub const LINEERR_REQUESTOVERRUN = @as(u32, 2147483724);
pub const LINEERR_STRUCTURETOOSMALL = @as(u32, 2147483725);
pub const LINEERR_TARGETNOTFOUND = @as(u32, 2147483726);
pub const LINEERR_TARGETSELF = @as(u32, 2147483727);
pub const LINEERR_UNINITIALIZED = @as(u32, 2147483728);
pub const LINEERR_USERUSERINFOTOOBIG = @as(u32, 2147483729);
pub const LINEERR_REINIT = @as(u32, 2147483730);
pub const LINEERR_ADDRESSBLOCKED = @as(u32, 2147483731);
pub const LINEERR_BILLINGREJECTED = @as(u32, 2147483732);
pub const LINEERR_INVALFEATURE = @as(u32, 2147483733);
pub const LINEERR_NOMULTIPLEINSTANCE = @as(u32, 2147483734);
pub const LINEERR_INVALAGENTID = @as(u32, 2147483735);
pub const LINEERR_INVALAGENTGROUP = @as(u32, 2147483736);
pub const LINEERR_INVALPASSWORD = @as(u32, 2147483737);
pub const LINEERR_INVALAGENTSTATE = @as(u32, 2147483738);
pub const LINEERR_INVALAGENTACTIVITY = @as(u32, 2147483739);
pub const LINEERR_DIALVOICEDETECT = @as(u32, 2147483740);
pub const LINEERR_USERCANCELLED = @as(u32, 2147483741);
pub const LINEERR_INVALADDRESSTYPE = @as(u32, 2147483742);
pub const LINEERR_INVALAGENTSESSIONSTATE = @as(u32, 2147483743);
pub const LINEERR_DISCONNECTED = @as(u32, 2147483744);
pub const LINEERR_SERVICE_NOT_RUNNING = @as(u32, 2147483745);
pub const LINEFEATURE_DEVSPECIFIC = @as(u32, 1);
pub const LINEFEATURE_DEVSPECIFICFEAT = @as(u32, 2);
pub const LINEFEATURE_FORWARD = @as(u32, 4);
pub const LINEFEATURE_MAKECALL = @as(u32, 8);
pub const LINEFEATURE_SETMEDIACONTROL = @as(u32, 16);
pub const LINEFEATURE_SETTERMINAL = @as(u32, 32);
pub const LINEFEATURE_SETDEVSTATUS = @as(u32, 64);
pub const LINEFEATURE_FORWARDFWD = @as(u32, 128);
pub const LINEFEATURE_FORWARDDND = @as(u32, 256);
pub const LINEFORWARDMODE_UNCOND = @as(u32, 1);
pub const LINEFORWARDMODE_UNCONDINTERNAL = @as(u32, 2);
pub const LINEFORWARDMODE_UNCONDEXTERNAL = @as(u32, 4);
pub const LINEFORWARDMODE_UNCONDSPECIFIC = @as(u32, 8);
pub const LINEFORWARDMODE_BUSY = @as(u32, 16);
pub const LINEFORWARDMODE_BUSYINTERNAL = @as(u32, 32);
pub const LINEFORWARDMODE_BUSYEXTERNAL = @as(u32, 64);
pub const LINEFORWARDMODE_BUSYSPECIFIC = @as(u32, 128);
pub const LINEFORWARDMODE_NOANSW = @as(u32, 256);
pub const LINEFORWARDMODE_NOANSWINTERNAL = @as(u32, 512);
pub const LINEFORWARDMODE_NOANSWEXTERNAL = @as(u32, 1024);
pub const LINEFORWARDMODE_NOANSWSPECIFIC = @as(u32, 2048);
pub const LINEFORWARDMODE_BUSYNA = @as(u32, 4096);
pub const LINEFORWARDMODE_BUSYNAINTERNAL = @as(u32, 8192);
pub const LINEFORWARDMODE_BUSYNAEXTERNAL = @as(u32, 16384);
pub const LINEFORWARDMODE_BUSYNASPECIFIC = @as(u32, 32768);
pub const LINEFORWARDMODE_UNKNOWN = @as(u32, 65536);
pub const LINEFORWARDMODE_UNAVAIL = @as(u32, 131072);
pub const LINEGATHERTERM_BUFFERFULL = @as(u32, 1);
pub const LINEGATHERTERM_TERMDIGIT = @as(u32, 2);
pub const LINEGATHERTERM_FIRSTTIMEOUT = @as(u32, 4);
pub const LINEGATHERTERM_INTERTIMEOUT = @as(u32, 8);
pub const LINEGATHERTERM_CANCEL = @as(u32, 16);
pub const LINEGENERATETERM_DONE = @as(u32, 1);
pub const LINEGENERATETERM_CANCEL = @as(u32, 2);
pub const LINEINITIALIZEEXOPTION_USEHIDDENWINDOW = @as(u32, 1);
pub const LINEINITIALIZEEXOPTION_USEEVENT = @as(u32, 2);
pub const LINEINITIALIZEEXOPTION_USECOMPLETIONPORT = @as(u32, 3);
pub const LINEINITIALIZEEXOPTION_CALLHUBTRACKING = @as(u32, 2147483648);
pub const LINELOCATIONOPTION_PULSEDIAL = @as(u32, 1);
pub const LINEMAPPER = @as(u32, 4294967295);
pub const LINEMEDIACONTROL_NONE = @as(u32, 1);
pub const LINEMEDIACONTROL_START = @as(u32, 2);
pub const LINEMEDIACONTROL_RESET = @as(u32, 4);
pub const LINEMEDIACONTROL_PAUSE = @as(u32, 8);
pub const LINEMEDIACONTROL_RESUME = @as(u32, 16);
pub const LINEMEDIACONTROL_RATEUP = @as(u32, 32);
pub const LINEMEDIACONTROL_RATEDOWN = @as(u32, 64);
pub const LINEMEDIACONTROL_RATENORMAL = @as(u32, 128);
pub const LINEMEDIACONTROL_VOLUMEUP = @as(u32, 256);
pub const LINEMEDIACONTROL_VOLUMEDOWN = @as(u32, 512);
pub const LINEMEDIACONTROL_VOLUMENORMAL = @as(u32, 1024);
pub const LINEMEDIAMODE_UNKNOWN = @as(u32, 2);
pub const LINEMEDIAMODE_INTERACTIVEVOICE = @as(u32, 4);
pub const LINEMEDIAMODE_AUTOMATEDVOICE = @as(u32, 8);
pub const LINEMEDIAMODE_DATAMODEM = @as(u32, 16);
pub const LINEMEDIAMODE_G3FAX = @as(u32, 32);
pub const LINEMEDIAMODE_TDD = @as(u32, 64);
pub const LINEMEDIAMODE_G4FAX = @as(u32, 128);
pub const LINEMEDIAMODE_DIGITALDATA = @as(u32, 256);
pub const LINEMEDIAMODE_TELETEX = @as(u32, 512);
pub const LINEMEDIAMODE_VIDEOTEX = @as(u32, 1024);
pub const LINEMEDIAMODE_TELEX = @as(u32, 2048);
pub const LINEMEDIAMODE_MIXED = @as(u32, 4096);
pub const LINEMEDIAMODE_ADSI = @as(u32, 8192);
pub const LINEMEDIAMODE_VOICEVIEW = @as(u32, 16384);
pub const LINEMEDIAMODE_VIDEO = @as(u32, 32768);
pub const LAST_LINEMEDIAMODE = @as(u32, 32768);
pub const LINEOFFERINGMODE_ACTIVE = @as(u32, 1);
pub const LINEOFFERINGMODE_INACTIVE = @as(u32, 2);
pub const LINEOPENOPTION_SINGLEADDRESS = @as(u32, 2147483648);
pub const LINEOPENOPTION_PROXY = @as(u32, 1073741824);
pub const LINEPARKMODE_DIRECTED = @as(u32, 1);
pub const LINEPARKMODE_NONDIRECTED = @as(u32, 2);
pub const LINEPROXYREQUEST_SETAGENTGROUP = @as(u32, 1);
pub const LINEPROXYREQUEST_SETAGENTSTATE = @as(u32, 2);
pub const LINEPROXYREQUEST_SETAGENTACTIVITY = @as(u32, 3);
pub const LINEPROXYREQUEST_GETAGENTCAPS = @as(u32, 4);
pub const LINEPROXYREQUEST_GETAGENTSTATUS = @as(u32, 5);
pub const LINEPROXYREQUEST_AGENTSPECIFIC = @as(u32, 6);
pub const LINEPROXYREQUEST_GETAGENTACTIVITYLIST = @as(u32, 7);
pub const LINEPROXYREQUEST_GETAGENTGROUPLIST = @as(u32, 8);
pub const LINEPROXYREQUEST_CREATEAGENT = @as(u32, 9);
pub const LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD = @as(u32, 10);
pub const LINEPROXYREQUEST_GETAGENTINFO = @as(u32, 11);
pub const LINEPROXYREQUEST_CREATEAGENTSESSION = @as(u32, 12);
pub const LINEPROXYREQUEST_GETAGENTSESSIONLIST = @as(u32, 13);
pub const LINEPROXYREQUEST_SETAGENTSESSIONSTATE = @as(u32, 14);
pub const LINEPROXYREQUEST_GETAGENTSESSIONINFO = @as(u32, 15);
pub const LINEPROXYREQUEST_GETQUEUELIST = @as(u32, 16);
pub const LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD = @as(u32, 17);
pub const LINEPROXYREQUEST_GETQUEUEINFO = @as(u32, 18);
pub const LINEPROXYREQUEST_GETGROUPLIST = @as(u32, 19);
pub const LINEPROXYREQUEST_SETAGENTSTATEEX = @as(u32, 20);
pub const LINEREMOVEFROMCONF_NONE = @as(u32, 1);
pub const LINEREMOVEFROMCONF_LAST = @as(u32, 2);
pub const LINEREMOVEFROMCONF_ANY = @as(u32, 3);
pub const LINEREQUESTMODE_MAKECALL = @as(u32, 1);
pub const LINEREQUESTMODE_MEDIACALL = @as(u32, 2);
pub const LINEREQUESTMODE_DROP = @as(u32, 4);
pub const LAST_LINEREQUESTMODE = @as(u32, 2);
pub const LINEROAMMODE_UNKNOWN = @as(u32, 1);
pub const LINEROAMMODE_UNAVAIL = @as(u32, 2);
pub const LINEROAMMODE_HOME = @as(u32, 4);
pub const LINEROAMMODE_ROAMA = @as(u32, 8);
pub const LINEROAMMODE_ROAMB = @as(u32, 16);
pub const LINESPECIALINFO_NOCIRCUIT = @as(u32, 1);
pub const LINESPECIALINFO_CUSTIRREG = @as(u32, 2);
pub const LINESPECIALINFO_REORDER = @as(u32, 4);
pub const LINESPECIALINFO_UNKNOWN = @as(u32, 8);
pub const LINESPECIALINFO_UNAVAIL = @as(u32, 16);
pub const LINETERMDEV_PHONE = @as(u32, 1);
pub const LINETERMDEV_HEADSET = @as(u32, 2);
pub const LINETERMDEV_SPEAKER = @as(u32, 4);
pub const LINETERMMODE_BUTTONS = @as(u32, 1);
pub const LINETERMMODE_LAMPS = @as(u32, 2);
pub const LINETERMMODE_DISPLAY = @as(u32, 4);
pub const LINETERMMODE_RINGER = @as(u32, 8);
pub const LINETERMMODE_HOOKSWITCH = @as(u32, 16);
pub const LINETERMMODE_MEDIATOLINE = @as(u32, 32);
pub const LINETERMMODE_MEDIAFROMLINE = @as(u32, 64);
pub const LINETERMMODE_MEDIABIDIRECT = @as(u32, 128);
pub const LINETERMSHARING_PRIVATE = @as(u32, 1);
pub const LINETERMSHARING_SHAREDEXCL = @as(u32, 2);
pub const LINETERMSHARING_SHAREDCONF = @as(u32, 4);
pub const LINETOLLLISTOPTION_ADD = @as(u32, 1);
pub const LINETOLLLISTOPTION_REMOVE = @as(u32, 2);
pub const LINETONEMODE_CUSTOM = @as(u32, 1);
pub const LINETONEMODE_RINGBACK = @as(u32, 2);
pub const LINETONEMODE_BUSY = @as(u32, 4);
pub const LINETONEMODE_BEEP = @as(u32, 8);
pub const LINETONEMODE_BILLING = @as(u32, 16);
pub const LINETRANSFERMODE_TRANSFER = @as(u32, 1);
pub const LINETRANSFERMODE_CONFERENCE = @as(u32, 2);
pub const LINETRANSLATEOPTION_CARDOVERRIDE = @as(u32, 1);
pub const LINETRANSLATEOPTION_CANCELCALLWAITING = @as(u32, 2);
pub const LINETRANSLATEOPTION_FORCELOCAL = @as(u32, 4);
pub const LINETRANSLATEOPTION_FORCELD = @as(u32, 8);
pub const LINETRANSLATERESULT_CANONICAL = @as(u32, 1);
pub const LINETRANSLATERESULT_INTERNATIONAL = @as(u32, 2);
pub const LINETRANSLATERESULT_LONGDISTANCE = @as(u32, 4);
pub const LINETRANSLATERESULT_LOCAL = @as(u32, 8);
pub const LINETRANSLATERESULT_INTOLLLIST = @as(u32, 16);
pub const LINETRANSLATERESULT_NOTINTOLLLIST = @as(u32, 32);
pub const LINETRANSLATERESULT_DIALBILLING = @as(u32, 64);
pub const LINETRANSLATERESULT_DIALQUIET = @as(u32, 128);
pub const LINETRANSLATERESULT_DIALDIALTONE = @as(u32, 256);
pub const LINETRANSLATERESULT_DIALPROMPT = @as(u32, 512);
pub const LINETRANSLATERESULT_VOICEDETECT = @as(u32, 1024);
pub const LINETRANSLATERESULT_NOTRANSLATION = @as(u32, 2048);
pub const PHONEBUTTONFUNCTION_UNKNOWN = @as(u32, 0);
pub const PHONEBUTTONFUNCTION_CONFERENCE = @as(u32, 1);
pub const PHONEBUTTONFUNCTION_TRANSFER = @as(u32, 2);
pub const PHONEBUTTONFUNCTION_DROP = @as(u32, 3);
pub const PHONEBUTTONFUNCTION_HOLD = @as(u32, 4);
pub const PHONEBUTTONFUNCTION_RECALL = @as(u32, 5);
pub const PHONEBUTTONFUNCTION_DISCONNECT = @as(u32, 6);
pub const PHONEBUTTONFUNCTION_CONNECT = @as(u32, 7);
pub const PHONEBUTTONFUNCTION_MSGWAITON = @as(u32, 8);
pub const PHONEBUTTONFUNCTION_MSGWAITOFF = @as(u32, 9);
pub const PHONEBUTTONFUNCTION_SELECTRING = @as(u32, 10);
pub const PHONEBUTTONFUNCTION_ABBREVDIAL = @as(u32, 11);
pub const PHONEBUTTONFUNCTION_FORWARD = @as(u32, 12);
pub const PHONEBUTTONFUNCTION_PICKUP = @as(u32, 13);
pub const PHONEBUTTONFUNCTION_RINGAGAIN = @as(u32, 14);
pub const PHONEBUTTONFUNCTION_PARK = @as(u32, 15);
pub const PHONEBUTTONFUNCTION_REJECT = @as(u32, 16);
pub const PHONEBUTTONFUNCTION_REDIRECT = @as(u32, 17);
pub const PHONEBUTTONFUNCTION_MUTE = @as(u32, 18);
pub const PHONEBUTTONFUNCTION_VOLUMEUP = @as(u32, 19);
pub const PHONEBUTTONFUNCTION_VOLUMEDOWN = @as(u32, 20);
pub const PHONEBUTTONFUNCTION_SPEAKERON = @as(u32, 21);
pub const PHONEBUTTONFUNCTION_SPEAKEROFF = @as(u32, 22);
pub const PHONEBUTTONFUNCTION_FLASH = @as(u32, 23);
pub const PHONEBUTTONFUNCTION_DATAON = @as(u32, 24);
pub const PHONEBUTTONFUNCTION_DATAOFF = @as(u32, 25);
pub const PHONEBUTTONFUNCTION_DONOTDISTURB = @as(u32, 26);
pub const PHONEBUTTONFUNCTION_INTERCOM = @as(u32, 27);
pub const PHONEBUTTONFUNCTION_BRIDGEDAPP = @as(u32, 28);
pub const PHONEBUTTONFUNCTION_BUSY = @as(u32, 29);
pub const PHONEBUTTONFUNCTION_CALLAPP = @as(u32, 30);
pub const PHONEBUTTONFUNCTION_DATETIME = @as(u32, 31);
pub const PHONEBUTTONFUNCTION_DIRECTORY = @as(u32, 32);
pub const PHONEBUTTONFUNCTION_COVER = @as(u32, 33);
pub const PHONEBUTTONFUNCTION_CALLID = @as(u32, 34);
pub const PHONEBUTTONFUNCTION_LASTNUM = @as(u32, 35);
pub const PHONEBUTTONFUNCTION_NIGHTSRV = @as(u32, 36);
pub const PHONEBUTTONFUNCTION_SENDCALLS = @as(u32, 37);
pub const PHONEBUTTONFUNCTION_MSGINDICATOR = @as(u32, 38);
pub const PHONEBUTTONFUNCTION_REPDIAL = @as(u32, 39);
pub const PHONEBUTTONFUNCTION_SETREPDIAL = @as(u32, 40);
pub const PHONEBUTTONFUNCTION_SYSTEMSPEED = @as(u32, 41);
pub const PHONEBUTTONFUNCTION_STATIONSPEED = @as(u32, 42);
pub const PHONEBUTTONFUNCTION_CAMPON = @as(u32, 43);
pub const PHONEBUTTONFUNCTION_SAVEREPEAT = @as(u32, 44);
pub const PHONEBUTTONFUNCTION_QUEUECALL = @as(u32, 45);
pub const PHONEBUTTONFUNCTION_NONE = @as(u32, 46);
pub const PHONEBUTTONFUNCTION_SEND = @as(u32, 47);
pub const PHONEBUTTONMODE_DUMMY = @as(u32, 1);
pub const PHONEBUTTONMODE_CALL = @as(u32, 2);
pub const PHONEBUTTONMODE_FEATURE = @as(u32, 4);
pub const PHONEBUTTONMODE_KEYPAD = @as(u32, 8);
pub const PHONEBUTTONMODE_LOCAL = @as(u32, 16);
pub const PHONEBUTTONMODE_DISPLAY = @as(u32, 32);
pub const PHONEBUTTONSTATE_UP = @as(u32, 1);
pub const PHONEBUTTONSTATE_DOWN = @as(u32, 2);
pub const PHONEBUTTONSTATE_UNKNOWN = @as(u32, 4);
pub const PHONEBUTTONSTATE_UNAVAIL = @as(u32, 8);
pub const PHONEERR_ALLOCATED = @as(u32, 2415919105);
pub const PHONEERR_BADDEVICEID = @as(u32, 2415919106);
pub const PHONEERR_INCOMPATIBLEAPIVERSION = @as(u32, 2415919107);
pub const PHONEERR_INCOMPATIBLEEXTVERSION = @as(u32, 2415919108);
pub const PHONEERR_INIFILECORRUPT = @as(u32, 2415919109);
pub const PHONEERR_INUSE = @as(u32, 2415919110);
pub const PHONEERR_INVALAPPHANDLE = @as(u32, 2415919111);
pub const PHONEERR_INVALAPPNAME = @as(u32, 2415919112);
pub const PHONEERR_INVALBUTTONLAMPID = @as(u32, 2415919113);
pub const PHONEERR_INVALBUTTONMODE = @as(u32, 2415919114);
pub const PHONEERR_INVALBUTTONSTATE = @as(u32, 2415919115);
pub const PHONEERR_INVALDATAID = @as(u32, 2415919116);
pub const PHONEERR_INVALDEVICECLASS = @as(u32, 2415919117);
pub const PHONEERR_INVALEXTVERSION = @as(u32, 2415919118);
pub const PHONEERR_INVALHOOKSWITCHDEV = @as(u32, 2415919119);
pub const PHONEERR_INVALHOOKSWITCHMODE = @as(u32, 2415919120);
pub const PHONEERR_INVALLAMPMODE = @as(u32, 2415919121);
pub const PHONEERR_INVALPARAM = @as(u32, 2415919122);
pub const PHONEERR_INVALPHONEHANDLE = @as(u32, 2415919123);
pub const PHONEERR_INVALPHONESTATE = @as(u32, 2415919124);
pub const PHONEERR_INVALPOINTER = @as(u32, 2415919125);
pub const PHONEERR_INVALPRIVILEGE = @as(u32, 2415919126);
pub const PHONEERR_INVALRINGMODE = @as(u32, 2415919127);
pub const PHONEERR_NODEVICE = @as(u32, 2415919128);
pub const PHONEERR_NODRIVER = @as(u32, 2415919129);
pub const PHONEERR_NOMEM = @as(u32, 2415919130);
pub const PHONEERR_NOTOWNER = @as(u32, 2415919131);
pub const PHONEERR_OPERATIONFAILED = @as(u32, 2415919132);
pub const PHONEERR_OPERATIONUNAVAIL = @as(u32, 2415919133);
pub const PHONEERR_RESOURCEUNAVAIL = @as(u32, 2415919135);
pub const PHONEERR_REQUESTOVERRUN = @as(u32, 2415919136);
pub const PHONEERR_STRUCTURETOOSMALL = @as(u32, 2415919137);
pub const PHONEERR_UNINITIALIZED = @as(u32, 2415919138);
pub const PHONEERR_REINIT = @as(u32, 2415919139);
pub const PHONEERR_DISCONNECTED = @as(u32, 2415919140);
pub const PHONEERR_SERVICE_NOT_RUNNING = @as(u32, 2415919141);
pub const PHONEFEATURE_GETBUTTONINFO = @as(u32, 1);
pub const PHONEFEATURE_GETDATA = @as(u32, 2);
pub const PHONEFEATURE_GETDISPLAY = @as(u32, 4);
pub const PHONEFEATURE_GETGAINHANDSET = @as(u32, 8);
pub const PHONEFEATURE_GETGAINSPEAKER = @as(u32, 16);
pub const PHONEFEATURE_GETGAINHEADSET = @as(u32, 32);
pub const PHONEFEATURE_GETHOOKSWITCHHANDSET = @as(u32, 64);
pub const PHONEFEATURE_GETHOOKSWITCHSPEAKER = @as(u32, 128);
pub const PHONEFEATURE_GETHOOKSWITCHHEADSET = @as(u32, 256);
pub const PHONEFEATURE_GETLAMP = @as(u32, 512);
pub const PHONEFEATURE_GETRING = @as(u32, 1024);
pub const PHONEFEATURE_GETVOLUMEHANDSET = @as(u32, 2048);
pub const PHONEFEATURE_GETVOLUMESPEAKER = @as(u32, 4096);
pub const PHONEFEATURE_GETVOLUMEHEADSET = @as(u32, 8192);
pub const PHONEFEATURE_SETBUTTONINFO = @as(u32, 16384);
pub const PHONEFEATURE_SETDATA = @as(u32, 32768);
pub const PHONEFEATURE_SETDISPLAY = @as(u32, 65536);
pub const PHONEFEATURE_SETGAINHANDSET = @as(u32, 131072);
pub const PHONEFEATURE_SETGAINSPEAKER = @as(u32, 262144);
pub const PHONEFEATURE_SETGAINHEADSET = @as(u32, 524288);
pub const PHONEFEATURE_SETHOOKSWITCHHANDSET = @as(u32, 1048576);
pub const PHONEFEATURE_SETHOOKSWITCHSPEAKER = @as(u32, 2097152);
pub const PHONEFEATURE_SETHOOKSWITCHHEADSET = @as(u32, 4194304);
pub const PHONEFEATURE_SETLAMP = @as(u32, 8388608);
pub const PHONEFEATURE_SETRING = @as(u32, 16777216);
pub const PHONEFEATURE_SETVOLUMEHANDSET = @as(u32, 33554432);
pub const PHONEFEATURE_SETVOLUMESPEAKER = @as(u32, 67108864);
pub const PHONEFEATURE_SETVOLUMEHEADSET = @as(u32, 134217728);
pub const PHONEFEATURE_GENERICPHONE = @as(u32, 268435456);
pub const PHONEHOOKSWITCHDEV_HANDSET = @as(u32, 1);
pub const PHONEHOOKSWITCHDEV_SPEAKER = @as(u32, 2);
pub const PHONEHOOKSWITCHDEV_HEADSET = @as(u32, 4);
pub const PHONEHOOKSWITCHMODE_ONHOOK = @as(u32, 1);
pub const PHONEHOOKSWITCHMODE_MIC = @as(u32, 2);
pub const PHONEHOOKSWITCHMODE_SPEAKER = @as(u32, 4);
pub const PHONEHOOKSWITCHMODE_MICSPEAKER = @as(u32, 8);
pub const PHONEHOOKSWITCHMODE_UNKNOWN = @as(u32, 16);
pub const PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW = @as(u32, 1);
pub const PHONEINITIALIZEEXOPTION_USEEVENT = @as(u32, 2);
pub const PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT = @as(u32, 3);
pub const PHONELAMPMODE_DUMMY = @as(u32, 1);
pub const PHONELAMPMODE_OFF = @as(u32, 2);
pub const PHONELAMPMODE_STEADY = @as(u32, 4);
pub const PHONELAMPMODE_WINK = @as(u32, 8);
pub const PHONELAMPMODE_FLASH = @as(u32, 16);
pub const PHONELAMPMODE_FLUTTER = @as(u32, 32);
pub const PHONELAMPMODE_BROKENFLUTTER = @as(u32, 64);
pub const PHONELAMPMODE_UNKNOWN = @as(u32, 128);
pub const PHONEPRIVILEGE_MONITOR = @as(u32, 1);
pub const PHONEPRIVILEGE_OWNER = @as(u32, 2);
pub const PHONESTATE_OTHER = @as(u32, 1);
pub const PHONESTATE_CONNECTED = @as(u32, 2);
pub const PHONESTATE_DISCONNECTED = @as(u32, 4);
pub const PHONESTATE_OWNER = @as(u32, 8);
pub const PHONESTATE_MONITORS = @as(u32, 16);
pub const PHONESTATE_DISPLAY = @as(u32, 32);
pub const PHONESTATE_LAMP = @as(u32, 64);
pub const PHONESTATE_RINGMODE = @as(u32, 128);
pub const PHONESTATE_RINGVOLUME = @as(u32, 256);
pub const PHONESTATE_HANDSETHOOKSWITCH = @as(u32, 512);
pub const PHONESTATE_HANDSETVOLUME = @as(u32, 1024);
pub const PHONESTATE_HANDSETGAIN = @as(u32, 2048);
pub const PHONESTATE_SPEAKERHOOKSWITCH = @as(u32, 4096);
pub const PHONESTATE_SPEAKERVOLUME = @as(u32, 8192);
pub const PHONESTATE_SPEAKERGAIN = @as(u32, 16384);
pub const PHONESTATE_HEADSETHOOKSWITCH = @as(u32, 32768);
pub const PHONESTATE_HEADSETVOLUME = @as(u32, 65536);
pub const PHONESTATE_HEADSETGAIN = @as(u32, 131072);
pub const PHONESTATE_SUSPEND = @as(u32, 262144);
pub const PHONESTATE_RESUME = @as(u32, 524288);
pub const PHONESTATE_DEVSPECIFIC = @as(u32, 1048576);
pub const PHONESTATE_REINIT = @as(u32, 2097152);
pub const PHONESTATE_CAPSCHANGE = @as(u32, 4194304);
pub const PHONESTATE_REMOVED = @as(u32, 8388608);
pub const PHONESTATUSFLAGS_CONNECTED = @as(u32, 1);
pub const PHONESTATUSFLAGS_SUSPENDED = @as(u32, 2);
pub const STRINGFORMAT_ASCII = @as(u32, 1);
pub const STRINGFORMAT_DBCS = @as(u32, 2);
pub const STRINGFORMAT_UNICODE = @as(u32, 3);
pub const STRINGFORMAT_BINARY = @as(u32, 4);
pub const TAPI_REPLY = @as(u32, 1123);
pub const TAPIERR_CONNECTED = @as(i32, 0);
pub const TAPIERR_DROPPED = @as(i32, -1);
pub const TAPIERR_NOREQUESTRECIPIENT = @as(i32, -2);
pub const TAPIERR_REQUESTQUEUEFULL = @as(i32, -3);
pub const TAPIERR_INVALDESTADDRESS = @as(i32, -4);
pub const TAPIERR_INVALWINDOWHANDLE = @as(i32, -5);
pub const TAPIERR_INVALDEVICECLASS = @as(i32, -6);
pub const TAPIERR_INVALDEVICEID = @as(i32, -7);
pub const TAPIERR_DEVICECLASSUNAVAIL = @as(i32, -8);
pub const TAPIERR_DEVICEIDUNAVAIL = @as(i32, -9);
pub const TAPIERR_DEVICEINUSE = @as(i32, -10);
pub const TAPIERR_DESTBUSY = @as(i32, -11);
pub const TAPIERR_DESTNOANSWER = @as(i32, -12);
pub const TAPIERR_DESTUNAVAIL = @as(i32, -13);
pub const TAPIERR_UNKNOWNWINHANDLE = @as(i32, -14);
pub const TAPIERR_UNKNOWNREQUESTID = @as(i32, -15);
pub const TAPIERR_REQUESTFAILED = @as(i32, -16);
pub const TAPIERR_REQUESTCANCELLED = @as(i32, -17);
pub const TAPIERR_INVALPOINTER = @as(i32, -18);
pub const TAPIERR_NOTADMIN = @as(i32, -19);
pub const TAPIERR_MMCWRITELOCKED = @as(i32, -20);
pub const TAPIERR_PROVIDERALREADYINSTALLED = @as(i32, -21);
pub const TAPIERR_SCP_ALREADY_EXISTS = @as(i32, -22);
pub const TAPIERR_SCP_DOES_NOT_EXIST = @as(i32, -23);
pub const TAPIMAXDESTADDRESSSIZE = @as(i32, 80);
pub const TAPIMAXAPPNAMESIZE = @as(i32, 40);
pub const TAPIMAXCALLEDPARTYSIZE = @as(i32, 40);
pub const TAPIMAXCOMMENTSIZE = @as(i32, 80);
pub const TAPIMAXDEVICECLASSSIZE = @as(i32, 40);
pub const TAPIMAXDEVICEIDSIZE = @as(i32, 40);
pub const INTERFACEMASK = @as(u32, 16711680);
pub const DISPIDMASK = @as(u32, 65535);
pub const IDISPTAPI = @as(u32, 65536);
pub const IDISPTAPICALLCENTER = @as(u32, 131072);
pub const IDISPCALLINFO = @as(u32, 65536);
pub const IDISPBASICCALLCONTROL = @as(u32, 131072);
pub const IDISPLEGACYCALLMEDIACONTROL = @as(u32, 196608);
pub const IDISPAGGREGATEDMSPCALLOBJ = @as(u32, 262144);
pub const IDISPADDRESS = @as(u32, 65536);
pub const IDISPADDRESSCAPABILITIES = @as(u32, 131072);
pub const IDISPMEDIASUPPORT = @as(u32, 196608);
pub const IDISPADDRESSTRANSLATION = @as(u32, 262144);
pub const IDISPLEGACYADDRESSMEDIACONTROL = @as(u32, 327680);
pub const IDISPAGGREGATEDMSPADDRESSOBJ = @as(u32, 393216);
pub const IDISPPHONE = @as(u32, 65536);
pub const IDISPAPC = @as(u32, 131072);
pub const IDISPMULTITRACK = @as(u32, 65536);
pub const IDISPMEDIACONTROL = @as(u32, 131072);
pub const IDISPMEDIARECORD = @as(u32, 196608);
pub const IDISPMEDIAPLAYBACK = @as(u32, 262144);
pub const IDISPFILETRACK = @as(u32, 65536);
pub const TAPIMEDIATYPE_AUDIO = @as(u32, 8);
pub const TAPIMEDIATYPE_VIDEO = @as(u32, 32768);
pub const TAPIMEDIATYPE_DATAMODEM = @as(u32, 16);
pub const TAPIMEDIATYPE_G3FAX = @as(u32, 32);
pub const TAPIMEDIATYPE_MULTITRACK = @as(u32, 65536);
pub const TSPI_MESSAGE_BASE = @as(u32, 500);
pub const LINETSPIOPTION_NONREENTRANT = @as(u32, 1);
pub const TUISPIDLL_OBJECT_LINEID = @as(i32, 1);
pub const TUISPIDLL_OBJECT_PHONEID = @as(i32, 2);
pub const TUISPIDLL_OBJECT_PROVIDERID = @as(i32, 3);
pub const TUISPIDLL_OBJECT_DIALOGINSTANCE = @as(i32, 4);
pub const PRIVATEOBJECT_NONE = @as(u32, 1);
pub const PRIVATEOBJECT_CALLID = @as(u32, 2);
pub const PRIVATEOBJECT_LINE = @as(u32, 3);
pub const PRIVATEOBJECT_CALL = @as(u32, 4);
pub const PRIVATEOBJECT_PHONE = @as(u32, 5);
pub const PRIVATEOBJECT_ADDRESS = @as(u32, 6);
pub const LINEQOSREQUESTTYPE_SERVICELEVEL = @as(u32, 1);
pub const LINEQOSSERVICELEVEL_NEEDED = @as(u32, 1);
pub const LINEQOSSERVICELEVEL_IFAVAILABLE = @as(u32, 2);
pub const LINEQOSSERVICELEVEL_BESTEFFORT = @as(u32, 3);
pub const LINEEQOSINFO_NOQOS = @as(u32, 1);
pub const LINEEQOSINFO_ADMISSIONFAILURE = @as(u32, 2);
pub const LINEEQOSINFO_POLICYFAILURE = @as(u32, 3);
pub const LINEEQOSINFO_GENERICERROR = @as(u32, 4);
pub const TSPI_PROC_BASE = @as(u32, 500);
pub const TSPI_LINEACCEPT = @as(u32, 500);
pub const TSPI_LINEADDTOCONFERENCE = @as(u32, 501);
pub const TSPI_LINEANSWER = @as(u32, 502);
pub const TSPI_LINEBLINDTRANSFER = @as(u32, 503);
pub const TSPI_LINECLOSE = @as(u32, 504);
pub const TSPI_LINECLOSECALL = @as(u32, 505);
pub const TSPI_LINECOMPLETECALL = @as(u32, 506);
pub const TSPI_LINECOMPLETETRANSFER = @as(u32, 507);
pub const TSPI_LINECONDITIONALMEDIADETECTION = @as(u32, 508);
pub const TSPI_LINECONFIGDIALOG = @as(u32, 509);
pub const TSPI_LINEDEVSPECIFIC = @as(u32, 510);
pub const TSPI_LINEDEVSPECIFICFEATURE = @as(u32, 511);
pub const TSPI_LINEDIAL = @as(u32, 512);
pub const TSPI_LINEDROP = @as(u32, 513);
pub const TSPI_LINEFORWARD = @as(u32, 514);
pub const TSPI_LINEGATHERDIGITS = @as(u32, 515);
pub const TSPI_LINEGENERATEDIGITS = @as(u32, 516);
pub const TSPI_LINEGENERATETONE = @as(u32, 517);
pub const TSPI_LINEGETADDRESSCAPS = @as(u32, 518);
pub const TSPI_LINEGETADDRESSID = @as(u32, 519);
pub const TSPI_LINEGETADDRESSSTATUS = @as(u32, 520);
pub const TSPI_LINEGETCALLADDRESSID = @as(u32, 521);
pub const TSPI_LINEGETCALLINFO = @as(u32, 522);
pub const TSPI_LINEGETCALLSTATUS = @as(u32, 523);
pub const TSPI_LINEGETDEVCAPS = @as(u32, 524);
pub const TSPI_LINEGETDEVCONFIG = @as(u32, 525);
pub const TSPI_LINEGETEXTENSIONID = @as(u32, 526);
pub const TSPI_LINEGETICON = @as(u32, 527);
pub const TSPI_LINEGETID = @as(u32, 528);
pub const TSPI_LINEGETLINEDEVSTATUS = @as(u32, 529);
pub const TSPI_LINEGETNUMADDRESSIDS = @as(u32, 530);
pub const TSPI_LINEHOLD = @as(u32, 531);
pub const TSPI_LINEMAKECALL = @as(u32, 532);
pub const TSPI_LINEMONITORDIGITS = @as(u32, 533);
pub const TSPI_LINEMONITORMEDIA = @as(u32, 534);
pub const TSPI_LINEMONITORTONES = @as(u32, 535);
pub const TSPI_LINENEGOTIATEEXTVERSION = @as(u32, 536);
pub const TSPI_LINENEGOTIATETSPIVERSION = @as(u32, 537);
pub const TSPI_LINEOPEN = @as(u32, 538);
pub const TSPI_LINEPARK = @as(u32, 539);
pub const TSPI_LINEPICKUP = @as(u32, 540);
pub const TSPI_LINEPREPAREADDTOCONFERENCE = @as(u32, 541);
pub const TSPI_LINEREDIRECT = @as(u32, 542);
pub const TSPI_LINEREMOVEFROMCONFERENCE = @as(u32, 543);
pub const TSPI_LINESECURECALL = @as(u32, 544);
pub const TSPI_LINESELECTEXTVERSION = @as(u32, 545);
pub const TSPI_LINESENDUSERUSERINFO = @as(u32, 546);
pub const TSPI_LINESETAPPSPECIFIC = @as(u32, 547);
pub const TSPI_LINESETCALLPARAMS = @as(u32, 548);
pub const TSPI_LINESETDEFAULTMEDIADETECTION = @as(u32, 549);
pub const TSPI_LINESETDEVCONFIG = @as(u32, 550);
pub const TSPI_LINESETMEDIACONTROL = @as(u32, 551);
pub const TSPI_LINESETMEDIAMODE = @as(u32, 552);
pub const TSPI_LINESETSTATUSMESSAGES = @as(u32, 553);
pub const TSPI_LINESETTERMINAL = @as(u32, 554);
pub const TSPI_LINESETUPCONFERENCE = @as(u32, 555);
pub const TSPI_LINESETUPTRANSFER = @as(u32, 556);
pub const TSPI_LINESWAPHOLD = @as(u32, 557);
pub const TSPI_LINEUNCOMPLETECALL = @as(u32, 558);
pub const TSPI_LINEUNHOLD = @as(u32, 559);
pub const TSPI_LINEUNPARK = @as(u32, 560);
pub const TSPI_PHONECLOSE = @as(u32, 561);
pub const TSPI_PHONECONFIGDIALOG = @as(u32, 562);
pub const TSPI_PHONEDEVSPECIFIC = @as(u32, 563);
pub const TSPI_PHONEGETBUTTONINFO = @as(u32, 564);
pub const TSPI_PHONEGETDATA = @as(u32, 565);
pub const TSPI_PHONEGETDEVCAPS = @as(u32, 566);
pub const TSPI_PHONEGETDISPLAY = @as(u32, 567);
pub const TSPI_PHONEGETEXTENSIONID = @as(u32, 568);
pub const TSPI_PHONEGETGAIN = @as(u32, 569);
pub const TSPI_PHONEGETHOOKSWITCH = @as(u32, 570);
pub const TSPI_PHONEGETICON = @as(u32, 571);
pub const TSPI_PHONEGETID = @as(u32, 572);
pub const TSPI_PHONEGETLAMP = @as(u32, 573);
pub const TSPI_PHONEGETRING = @as(u32, 574);
pub const TSPI_PHONEGETSTATUS = @as(u32, 575);
pub const TSPI_PHONEGETVOLUME = @as(u32, 576);
pub const TSPI_PHONENEGOTIATEEXTVERSION = @as(u32, 577);
pub const TSPI_PHONENEGOTIATETSPIVERSION = @as(u32, 578);
pub const TSPI_PHONEOPEN = @as(u32, 579);
pub const TSPI_PHONESELECTEXTVERSION = @as(u32, 580);
pub const TSPI_PHONESETBUTTONINFO = @as(u32, 581);
pub const TSPI_PHONESETDATA = @as(u32, 582);
pub const TSPI_PHONESETDISPLAY = @as(u32, 583);
pub const TSPI_PHONESETGAIN = @as(u32, 584);
pub const TSPI_PHONESETHOOKSWITCH = @as(u32, 585);
pub const TSPI_PHONESETLAMP = @as(u32, 586);
pub const TSPI_PHONESETRING = @as(u32, 587);
pub const TSPI_PHONESETSTATUSMESSAGES = @as(u32, 588);
pub const TSPI_PHONESETVOLUME = @as(u32, 589);
pub const TSPI_PROVIDERCONFIG = @as(u32, 590);
pub const TSPI_PROVIDERINIT = @as(u32, 591);
pub const TSPI_PROVIDERINSTALL = @as(u32, 592);
pub const TSPI_PROVIDERREMOVE = @as(u32, 593);
pub const TSPI_PROVIDERSHUTDOWN = @as(u32, 594);
pub const TSPI_PROVIDERENUMDEVICES = @as(u32, 595);
pub const TSPI_LINEDROPONCLOSE = @as(u32, 596);
pub const TSPI_LINEDROPNOOWNER = @as(u32, 597);
pub const TSPI_PROVIDERCREATELINEDEVICE = @as(u32, 598);
pub const TSPI_PROVIDERCREATEPHONEDEVICE = @as(u32, 599);
pub const TSPI_LINESETCURRENTLOCATION = @as(u32, 600);
pub const TSPI_LINECONFIGDIALOGEDIT = @as(u32, 601);
pub const TSPI_LINERELEASEUSERUSERINFO = @as(u32, 602);
pub const TSPI_LINEGETCALLID = @as(u32, 603);
pub const TSPI_LINEGETCALLHUBTRACKING = @as(u32, 604);
pub const TSPI_LINESETCALLHUBTRACKING = @as(u32, 605);
pub const TSPI_LINERECEIVEMSPDATA = @as(u32, 606);
pub const TSPI_LINEMSPIDENTIFY = @as(u32, 607);
pub const TSPI_LINECREATEMSPINSTANCE = @as(u32, 608);
pub const TSPI_LINECLOSEMSPINSTANCE = @as(u32, 609);
pub const IDISPDIROBJECT = @as(u32, 65536);
pub const IDISPDIROBJCONFERENCE = @as(u32, 131072);
pub const IDISPDIROBJUSER = @as(u32, 196608);
pub const IDISPDIRECTORY = @as(u32, 65536);
pub const IDISPILSCONFIG = @as(u32, 131072);
pub const RENDBIND_AUTHENTICATE = @as(u32, 1);
pub const RENDBIND_DEFAULTDOMAINNAME = @as(u32, 2);
pub const RENDBIND_DEFAULTUSERNAME = @as(u32, 4);
pub const RENDBIND_DEFAULTPASSWORD = @as(u32, 8);
pub const RENDBIND_DEFAULTCREDENTIALS = @as(u32, 14);
pub const STRM_INITIAL = @as(u32, 0);
pub const STRM_TERMINALSELECTED = @as(u32, 1);
pub const STRM_CONFIGURED = @as(u32, 2);
pub const STRM_RUNNING = @as(u32, 4);
pub const STRM_PAUSED = @as(u32, 8);
pub const STRM_STOPPED = @as(u32, 16);
pub const TAPI_E_NOTENOUGHMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221503));
pub const TAPI_E_NOITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221502));
pub const TAPI_E_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221501));
pub const TAPI_E_INVALIDMEDIATYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221500));
pub const TAPI_E_OPERATIONFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221499));
pub const TAPI_E_ALLOCATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221498));
pub const TAPI_E_CALLUNAVAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221497));
pub const TAPI_E_COMPLETIONOVERRUN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221496));
pub const TAPI_E_CONFERENCEFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221495));
pub const TAPI_E_DIALMODIFIERNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221494));
pub const TAPI_E_INUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221493));
pub const TAPI_E_INVALADDRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221492));
pub const TAPI_E_INVALADDRESSSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221491));
pub const TAPI_E_INVALCALLPARAMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221490));
pub const TAPI_E_INVALCALLPRIVILEGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221489));
pub const TAPI_E_INVALCALLSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221488));
pub const TAPI_E_INVALCARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221487));
pub const TAPI_E_INVALCOMPLETIONID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221486));
pub const TAPI_E_INVALCOUNTRYCODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221485));
pub const TAPI_E_INVALDEVICECLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221484));
pub const TAPI_E_INVALDIALPARAMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221483));
pub const TAPI_E_INVALDIGITS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221482));
pub const TAPI_E_INVALGROUPID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221481));
pub const TAPI_E_INVALLOCATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221480));
pub const TAPI_E_INVALMESSAGEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221479));
pub const TAPI_E_INVALPARKID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221478));
pub const TAPI_E_INVALRATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221477));
pub const TAPI_E_INVALTIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221476));
pub const TAPI_E_INVALTONE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221475));
pub const TAPI_E_INVALLIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221474));
pub const TAPI_E_INVALMODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221473));
pub const TAPI_E_NOCONFERENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221472));
pub const TAPI_E_NODEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221471));
pub const TAPI_E_NOREQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221470));
pub const TAPI_E_NOTOWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221469));
pub const TAPI_E_NOTREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221468));
pub const TAPI_E_REQUESTOVERRUN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221467));
pub const TAPI_E_TARGETNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221466));
pub const TAPI_E_TARGETSELF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221465));
pub const TAPI_E_USERUSERINFOTOOBIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221464));
pub const TAPI_E_REINIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221463));
pub const TAPI_E_ADDRESSBLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221462));
pub const TAPI_E_BILLINGREJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221461));
pub const TAPI_E_INVALFEATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221460));
pub const TAPI_E_INVALBUTTONLAMPID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221459));
pub const TAPI_E_INVALBUTTONSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221458));
pub const TAPI_E_INVALDATAID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221457));
pub const TAPI_E_INVALHOOKSWITCHDEV = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221456));
pub const TAPI_E_DROPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221455));
pub const TAPI_E_NOREQUESTRECIPIENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221454));
pub const TAPI_E_REQUESTQUEUEFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221453));
pub const TAPI_E_DESTBUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221452));
pub const TAPI_E_DESTNOANSWER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221451));
pub const TAPI_E_DESTUNAVAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221450));
pub const TAPI_E_REQUESTFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221449));
pub const TAPI_E_REQUESTCANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221448));
pub const TAPI_E_INVALPRIVILEGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221447));
pub const TAPI_E_INVALIDDIRECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221446));
pub const TAPI_E_INVALIDTERMINAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221445));
pub const TAPI_E_INVALIDTERMINALCLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221444));
pub const TAPI_E_NODRIVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221443));
pub const TAPI_E_MAXSTREAMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221442));
pub const TAPI_E_NOTERMINALSELECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221441));
pub const TAPI_E_TERMINALINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221440));
pub const TAPI_E_NOTSTOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221439));
pub const TAPI_E_MAXTERMINALS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221438));
pub const TAPI_E_INVALIDSTREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221437));
pub const TAPI_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221436));
pub const TAPI_E_CALLCENTER_GROUP_REMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221435));
pub const TAPI_E_CALLCENTER_QUEUE_REMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221434));
pub const TAPI_E_CALLCENTER_NO_AGENT_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221433));
pub const TAPI_E_CALLCENTER_INVALAGENTID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221432));
pub const TAPI_E_CALLCENTER_INVALAGENTGROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221431));
pub const TAPI_E_CALLCENTER_INVALPASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221430));
pub const TAPI_E_CALLCENTER_INVALAGENTSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221429));
pub const TAPI_E_CALLCENTER_INVALAGENTACTIVITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221428));
pub const TAPI_E_REGISTRY_SETTING_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221427));
pub const TAPI_E_TERMINAL_PEER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221426));
pub const TAPI_E_PEER_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221425));
pub const TAPI_E_NOEVENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221424));
pub const TAPI_E_INVALADDRESSTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221423));
pub const TAPI_E_RESOURCEUNAVAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221422));
pub const TAPI_E_PHONENOTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221421));
pub const TAPI_E_CALLNOTSELECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221420));
pub const TAPI_E_WRONGEVENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221419));
pub const TAPI_E_NOFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221418));
pub const TAPI_E_INVALIDSTREAMSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221417));
pub const TAPI_E_WRONG_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221416));
pub const TAPI_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221415));
pub const TAPI_E_SERVICE_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221414));
pub const atypNull = @as(i32, 0);
pub const atypFile = @as(i32, 1);
pub const atypOle = @as(i32, 2);
pub const atypPicture = @as(i32, 3);
pub const atypMax = @as(i32, 4);

//--------------------------------------------------------------------------------
// Section: Types (269)
//--------------------------------------------------------------------------------
pub const LINECALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: u32,
        dwMessage: u32,
        dwInstance: usize,
        dwParam1: usize,
        dwParam2: usize,
        dwParam3: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        hDevice: u32,
        dwMessage: u32,
        dwInstance: usize,
        dwParam1: usize,
        dwParam2: usize,
        dwParam3: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PHONECALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: u32,
        dwMessage: u32,
        dwInstance: usize,
        dwParam1: usize,
        dwParam2: usize,
        dwParam3: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        hDevice: u32,
        dwMessage: u32,
        dwInstance: usize,
        dwParam1: usize,
        dwParam2: usize,
        dwParam3: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const LINEADDRESSCAPS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwLineDeviceID: u32 align(1),
    dwAddressSize: u32 align(1),
    dwAddressOffset: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
    dwAddressSharing: u32 align(1),
    dwAddressStates: u32 align(1),
    dwCallInfoStates: u32 align(1),
    dwCallerIDFlags: u32 align(1),
    dwCalledIDFlags: u32 align(1),
    dwConnectedIDFlags: u32 align(1),
    dwRedirectionIDFlags: u32 align(1),
    dwRedirectingIDFlags: u32 align(1),
    dwCallStates: u32 align(1),
    dwDialToneModes: u32 align(1),
    dwBusyModes: u32 align(1),
    dwSpecialInfo: u32 align(1),
    dwDisconnectModes: u32 align(1),
    dwMaxNumActiveCalls: u32 align(1),
    dwMaxNumOnHoldCalls: u32 align(1),
    dwMaxNumOnHoldPendingCalls: u32 align(1),
    dwMaxNumConference: u32 align(1),
    dwMaxNumTransConf: u32 align(1),
    dwAddrCapFlags: u32 align(1),
    dwCallFeatures: u32 align(1),
    dwRemoveFromConfCaps: u32 align(1),
    dwRemoveFromConfState: u32 align(1),
    dwTransferModes: u32 align(1),
    dwParkModes: u32 align(1),
    dwForwardModes: u32 align(1),
    dwMaxForwardEntries: u32 align(1),
    dwMaxSpecificEntries: u32 align(1),
    dwMinFwdNumRings: u32 align(1),
    dwMaxFwdNumRings: u32 align(1),
    dwMaxCallCompletions: u32 align(1),
    dwCallCompletionConds: u32 align(1),
    dwCallCompletionModes: u32 align(1),
    dwNumCompletionMessages: u32 align(1),
    dwCompletionMsgTextEntrySize: u32 align(1),
    dwCompletionMsgTextSize: u32 align(1),
    dwCompletionMsgTextOffset: u32 align(1),
    dwAddressFeatures: u32 align(1),
    dwPredictiveAutoTransferStates: u32 align(1),
    dwNumCallTreatments: u32 align(1),
    dwCallTreatmentListSize: u32 align(1),
    dwCallTreatmentListOffset: u32 align(1),
    dwDeviceClassesSize: u32 align(1),
    dwDeviceClassesOffset: u32 align(1),
    dwMaxCallDataSize: u32 align(1),
    dwCallFeatures2: u32 align(1),
    dwMaxNoAnswerTimeout: u32 align(1),
    dwConnectedModes: u32 align(1),
    dwOfferingModes: u32 align(1),
    dwAvailableMediaModes: u32 align(1),
};

pub const LINEADDRESSSTATUS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumInUse: u32 align(1),
    dwNumActiveCalls: u32 align(1),
    dwNumOnHoldCalls: u32 align(1),
    dwNumOnHoldPendCalls: u32 align(1),
    dwAddressFeatures: u32 align(1),
    dwNumRingsNoAnswer: u32 align(1),
    dwForwardNumEntries: u32 align(1),
    dwForwardSize: u32 align(1),
    dwForwardOffset: u32 align(1),
    dwTerminalModesSize: u32 align(1),
    dwTerminalModesOffset: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
};

pub const LINEAGENTACTIVITYENTRY = extern struct {
    dwID: u32 align(1),
    dwNameSize: u32 align(1),
    dwNameOffset: u32 align(1),
};

pub const LINEAGENTACTIVITYLIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumEntries: u32 align(1),
    dwListSize: u32 align(1),
    dwListOffset: u32 align(1),
};

pub const LINEAGENTCAPS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwAgentHandlerInfoSize: u32 align(1),
    dwAgentHandlerInfoOffset: u32 align(1),
    dwCapsVersion: u32 align(1),
    dwFeatures: u32 align(1),
    dwStates: u32 align(1),
    dwNextStates: u32 align(1),
    dwMaxNumGroupEntries: u32 align(1),
    dwAgentStatusMessages: u32 align(1),
    dwNumAgentExtensionIDs: u32 align(1),
    dwAgentExtensionIDListSize: u32 align(1),
    dwAgentExtensionIDListOffset: u32 align(1),
    ProxyGUID: Guid align(1),
};

pub const LINEAGENTGROUPENTRY = extern struct {
    GroupID: extern struct {
        dwGroupID1: u32 align(1),
        dwGroupID2: u32 align(1),
        dwGroupID3: u32 align(1),
        dwGroupID4: u32 align(1),
    } align(1),
    dwNameSize: u32 align(1),
    dwNameOffset: u32 align(1),
};

pub const LINEAGENTGROUPLIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumEntries: u32 align(1),
    dwListSize: u32 align(1),
    dwListOffset: u32 align(1),
};

pub const LINEAGENTSTATUS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumEntries: u32 align(1),
    dwGroupListSize: u32 align(1),
    dwGroupListOffset: u32 align(1),
    dwState: u32 align(1),
    dwNextState: u32 align(1),
    dwActivityID: u32 align(1),
    dwActivitySize: u32 align(1),
    dwActivityOffset: u32 align(1),
    dwAgentFeatures: u32 align(1),
    dwValidStates: u32 align(1),
    dwValidNextStates: u32 align(1),
};

pub const LINEAPPINFO = extern struct {
    dwMachineNameSize: u32 align(1),
    dwMachineNameOffset: u32 align(1),
    dwUserNameSize: u32 align(1),
    dwUserNameOffset: u32 align(1),
    dwModuleFilenameSize: u32 align(1),
    dwModuleFilenameOffset: u32 align(1),
    dwFriendlyNameSize: u32 align(1),
    dwFriendlyNameOffset: u32 align(1),
    dwMediaModes: u32 align(1),
    dwAddressID: u32 align(1),
};

pub const LINEAGENTENTRY = extern struct {
    hAgent: u32 align(1),
    dwNameSize: u32 align(1),
    dwNameOffset: u32 align(1),
    dwIDSize: u32 align(1),
    dwIDOffset: u32 align(1),
    dwPINSize: u32 align(1),
    dwPINOffset: u32 align(1),
};

pub const LINEAGENTLIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumEntries: u32 align(1),
    dwListSize: u32 align(1),
    dwListOffset: u32 align(1),
};

pub const LINEAGENTINFO = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwAgentState: u32 align(1),
    dwNextAgentState: u32 align(1),
    dwMeasurementPeriod: u32 align(1),
    cyOverallCallRate: CY align(1),
    dwNumberOfACDCalls: u32 align(1),
    dwNumberOfIncomingCalls: u32 align(1),
    dwNumberOfOutgoingCalls: u32 align(1),
    dwTotalACDTalkTime: u32 align(1),
    dwTotalACDCallTime: u32 align(1),
    dwTotalACDWrapUpTime: u32 align(1),
};

pub const LINEAGENTSESSIONENTRY = extern struct {
    hAgentSession: u32 align(1),
    hAgent: u32 align(1),
    GroupID: Guid align(1),
    dwWorkingAddressID: u32 align(1),
};

pub const LINEAGENTSESSIONLIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumEntries: u32 align(1),
    dwListSize: u32 align(1),
    dwListOffset: u32 align(1),
};

pub const LINEAGENTSESSIONINFO = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwAgentSessionState: u32 align(1),
    dwNextAgentSessionState: u32 align(1),
    dateSessionStartTime: f64 align(1),
    dwSessionDuration: u32 align(1),
    dwNumberOfCalls: u32 align(1),
    dwTotalTalkTime: u32 align(1),
    dwAverageTalkTime: u32 align(1),
    dwTotalCallTime: u32 align(1),
    dwAverageCallTime: u32 align(1),
    dwTotalWrapUpTime: u32 align(1),
    dwAverageWrapUpTime: u32 align(1),
    cyACDCallRate: CY align(1),
    dwLongestTimeToAnswer: u32 align(1),
    dwAverageTimeToAnswer: u32 align(1),
};

pub const LINEQUEUEENTRY = extern struct {
    dwQueueID: u32 align(1),
    dwNameSize: u32 align(1),
    dwNameOffset: u32 align(1),
};

pub const LINEQUEUELIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumEntries: u32 align(1),
    dwListSize: u32 align(1),
    dwListOffset: u32 align(1),
};

pub const LINEQUEUEINFO = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwMeasurementPeriod: u32 align(1),
    dwTotalCallsQueued: u32 align(1),
    dwCurrentCallsQueued: u32 align(1),
    dwTotalCallsAbandoned: u32 align(1),
    dwTotalCallsFlowedIn: u32 align(1),
    dwTotalCallsFlowedOut: u32 align(1),
    dwLongestEverWaitTime: u32 align(1),
    dwCurrentLongestWaitTime: u32 align(1),
    dwAverageWaitTime: u32 align(1),
    dwFinalDisposition: u32 align(1),
};

pub const LINEPROXYREQUESTLIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumEntries: u32 align(1),
    dwListSize: u32 align(1),
    dwListOffset: u32 align(1),
};

pub const LINEDIALPARAMS = extern struct {
    dwDialPause: u32 align(1),
    dwDialSpeed: u32 align(1),
    dwDigitDuration: u32 align(1),
    dwWaitForDialtone: u32 align(1),
};

pub const LINECALLINFO = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    hLine: u32 align(1),
    dwLineDeviceID: u32 align(1),
    dwAddressID: u32 align(1),
    dwBearerMode: u32 align(1),
    dwRate: u32 align(1),
    dwMediaMode: u32 align(1),
    dwAppSpecific: u32 align(1),
    dwCallID: u32 align(1),
    dwRelatedCallID: u32 align(1),
    dwCallParamFlags: u32 align(1),
    dwCallStates: u32 align(1),
    dwMonitorDigitModes: u32 align(1),
    dwMonitorMediaModes: u32 align(1),
    DialParams: LINEDIALPARAMS align(1),
    dwOrigin: u32 align(1),
    dwReason: u32 align(1),
    dwCompletionID: u32 align(1),
    dwNumOwners: u32 align(1),
    dwNumMonitors: u32 align(1),
    dwCountryCode: u32 align(1),
    dwTrunk: u32 align(1),
    dwCallerIDFlags: u32 align(1),
    dwCallerIDSize: u32 align(1),
    dwCallerIDOffset: u32 align(1),
    dwCallerIDNameSize: u32 align(1),
    dwCallerIDNameOffset: u32 align(1),
    dwCalledIDFlags: u32 align(1),
    dwCalledIDSize: u32 align(1),
    dwCalledIDOffset: u32 align(1),
    dwCalledIDNameSize: u32 align(1),
    dwCalledIDNameOffset: u32 align(1),
    dwConnectedIDFlags: u32 align(1),
    dwConnectedIDSize: u32 align(1),
    dwConnectedIDOffset: u32 align(1),
    dwConnectedIDNameSize: u32 align(1),
    dwConnectedIDNameOffset: u32 align(1),
    dwRedirectionIDFlags: u32 align(1),
    dwRedirectionIDSize: u32 align(1),
    dwRedirectionIDOffset: u32 align(1),
    dwRedirectionIDNameSize: u32 align(1),
    dwRedirectionIDNameOffset: u32 align(1),
    dwRedirectingIDFlags: u32 align(1),
    dwRedirectingIDSize: u32 align(1),
    dwRedirectingIDOffset: u32 align(1),
    dwRedirectingIDNameSize: u32 align(1),
    dwRedirectingIDNameOffset: u32 align(1),
    dwAppNameSize: u32 align(1),
    dwAppNameOffset: u32 align(1),
    dwDisplayableAddressSize: u32 align(1),
    dwDisplayableAddressOffset: u32 align(1),
    dwCalledPartySize: u32 align(1),
    dwCalledPartyOffset: u32 align(1),
    dwCommentSize: u32 align(1),
    dwCommentOffset: u32 align(1),
    dwDisplaySize: u32 align(1),
    dwDisplayOffset: u32 align(1),
    dwUserUserInfoSize: u32 align(1),
    dwUserUserInfoOffset: u32 align(1),
    dwHighLevelCompSize: u32 align(1),
    dwHighLevelCompOffset: u32 align(1),
    dwLowLevelCompSize: u32 align(1),
    dwLowLevelCompOffset: u32 align(1),
    dwChargingInfoSize: u32 align(1),
    dwChargingInfoOffset: u32 align(1),
    dwTerminalModesSize: u32 align(1),
    dwTerminalModesOffset: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
    dwCallTreatment: u32 align(1),
    dwCallDataSize: u32 align(1),
    dwCallDataOffset: u32 align(1),
    dwSendingFlowspecSize: u32 align(1),
    dwSendingFlowspecOffset: u32 align(1),
    dwReceivingFlowspecSize: u32 align(1),
    dwReceivingFlowspecOffset: u32 align(1),
};

pub const LINECALLLIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwCallsNumEntries: u32 align(1),
    dwCallsSize: u32 align(1),
    dwCallsOffset: u32 align(1),
};

pub const LINECALLPARAMS = extern struct {
    dwTotalSize: u32 align(1),
    dwBearerMode: u32 align(1),
    dwMinRate: u32 align(1),
    dwMaxRate: u32 align(1),
    dwMediaMode: u32 align(1),
    dwCallParamFlags: u32 align(1),
    dwAddressMode: u32 align(1),
    dwAddressID: u32 align(1),
    DialParams: LINEDIALPARAMS align(1),
    dwOrigAddressSize: u32 align(1),
    dwOrigAddressOffset: u32 align(1),
    dwDisplayableAddressSize: u32 align(1),
    dwDisplayableAddressOffset: u32 align(1),
    dwCalledPartySize: u32 align(1),
    dwCalledPartyOffset: u32 align(1),
    dwCommentSize: u32 align(1),
    dwCommentOffset: u32 align(1),
    dwUserUserInfoSize: u32 align(1),
    dwUserUserInfoOffset: u32 align(1),
    dwHighLevelCompSize: u32 align(1),
    dwHighLevelCompOffset: u32 align(1),
    dwLowLevelCompSize: u32 align(1),
    dwLowLevelCompOffset: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
    dwPredictiveAutoTransferStates: u32 align(1),
    dwTargetAddressSize: u32 align(1),
    dwTargetAddressOffset: u32 align(1),
    dwSendingFlowspecSize: u32 align(1),
    dwSendingFlowspecOffset: u32 align(1),
    dwReceivingFlowspecSize: u32 align(1),
    dwReceivingFlowspecOffset: u32 align(1),
    dwDeviceClassSize: u32 align(1),
    dwDeviceClassOffset: u32 align(1),
    dwDeviceConfigSize: u32 align(1),
    dwDeviceConfigOffset: u32 align(1),
    dwCallDataSize: u32 align(1),
    dwCallDataOffset: u32 align(1),
    dwNoAnswerTimeout: u32 align(1),
    dwCallingPartyIDSize: u32 align(1),
    dwCallingPartyIDOffset: u32 align(1),
};

pub const LINECALLSTATUS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwCallState: u32 align(1),
    dwCallStateMode: u32 align(1),
    dwCallPrivilege: u32 align(1),
    dwCallFeatures: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
    dwCallFeatures2: u32 align(1),
    tStateEntryTime: SYSTEMTIME align(1),
};

pub const LINECALLTREATMENTENTRY = extern struct {
    dwCallTreatmentID: u32 align(1),
    dwCallTreatmentNameSize: u32 align(1),
    dwCallTreatmentNameOffset: u32 align(1),
};

pub const LINECARDENTRY = extern struct {
    dwPermanentCardID: u32 align(1),
    dwCardNameSize: u32 align(1),
    dwCardNameOffset: u32 align(1),
    dwCardNumberDigits: u32 align(1),
    dwSameAreaRuleSize: u32 align(1),
    dwSameAreaRuleOffset: u32 align(1),
    dwLongDistanceRuleSize: u32 align(1),
    dwLongDistanceRuleOffset: u32 align(1),
    dwInternationalRuleSize: u32 align(1),
    dwInternationalRuleOffset: u32 align(1),
    dwOptions: u32 align(1),
};

pub const LINECOUNTRYENTRY = extern struct {
    dwCountryID: u32 align(1),
    dwCountryCode: u32 align(1),
    dwNextCountryID: u32 align(1),
    dwCountryNameSize: u32 align(1),
    dwCountryNameOffset: u32 align(1),
    dwSameAreaRuleSize: u32 align(1),
    dwSameAreaRuleOffset: u32 align(1),
    dwLongDistanceRuleSize: u32 align(1),
    dwLongDistanceRuleOffset: u32 align(1),
    dwInternationalRuleSize: u32 align(1),
    dwInternationalRuleOffset: u32 align(1),
};

pub const LINECOUNTRYLIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumCountries: u32 align(1),
    dwCountryListSize: u32 align(1),
    dwCountryListOffset: u32 align(1),
};

pub const LINEDEVCAPS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwProviderInfoSize: u32 align(1),
    dwProviderInfoOffset: u32 align(1),
    dwSwitchInfoSize: u32 align(1),
    dwSwitchInfoOffset: u32 align(1),
    dwPermanentLineID: u32 align(1),
    dwLineNameSize: u32 align(1),
    dwLineNameOffset: u32 align(1),
    dwStringFormat: u32 align(1),
    dwAddressModes: u32 align(1),
    dwNumAddresses: u32 align(1),
    dwBearerModes: u32 align(1),
    dwMaxRate: u32 align(1),
    dwMediaModes: u32 align(1),
    dwGenerateToneModes: u32 align(1),
    dwGenerateToneMaxNumFreq: u32 align(1),
    dwGenerateDigitModes: u32 align(1),
    dwMonitorToneMaxNumFreq: u32 align(1),
    dwMonitorToneMaxNumEntries: u32 align(1),
    dwMonitorDigitModes: u32 align(1),
    dwGatherDigitsMinTimeout: u32 align(1),
    dwGatherDigitsMaxTimeout: u32 align(1),
    dwMedCtlDigitMaxListSize: u32 align(1),
    dwMedCtlMediaMaxListSize: u32 align(1),
    dwMedCtlToneMaxListSize: u32 align(1),
    dwMedCtlCallStateMaxListSize: u32 align(1),
    dwDevCapFlags: u32 align(1),
    dwMaxNumActiveCalls: u32 align(1),
    dwAnswerMode: u32 align(1),
    dwRingModes: u32 align(1),
    dwLineStates: u32 align(1),
    dwUUIAcceptSize: u32 align(1),
    dwUUIAnswerSize: u32 align(1),
    dwUUIMakeCallSize: u32 align(1),
    dwUUIDropSize: u32 align(1),
    dwUUISendUserUserInfoSize: u32 align(1),
    dwUUICallInfoSize: u32 align(1),
    MinDialParams: LINEDIALPARAMS align(1),
    MaxDialParams: LINEDIALPARAMS align(1),
    DefaultDialParams: LINEDIALPARAMS align(1),
    dwNumTerminals: u32 align(1),
    dwTerminalCapsSize: u32 align(1),
    dwTerminalCapsOffset: u32 align(1),
    dwTerminalTextEntrySize: u32 align(1),
    dwTerminalTextSize: u32 align(1),
    dwTerminalTextOffset: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
    dwLineFeatures: u32 align(1),
    dwSettableDevStatus: u32 align(1),
    dwDeviceClassesSize: u32 align(1),
    dwDeviceClassesOffset: u32 align(1),
    PermanentLineGuid: Guid align(1),
};

pub const LINEDEVSTATUS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumOpens: u32 align(1),
    dwOpenMediaModes: u32 align(1),
    dwNumActiveCalls: u32 align(1),
    dwNumOnHoldCalls: u32 align(1),
    dwNumOnHoldPendCalls: u32 align(1),
    dwLineFeatures: u32 align(1),
    dwNumCallCompletions: u32 align(1),
    dwRingMode: u32 align(1),
    dwSignalLevel: u32 align(1),
    dwBatteryLevel: u32 align(1),
    dwRoamMode: u32 align(1),
    dwDevStatusFlags: u32 align(1),
    dwTerminalModesSize: u32 align(1),
    dwTerminalModesOffset: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
    dwAvailableMediaModes: u32 align(1),
    dwAppInfoSize: u32 align(1),
    dwAppInfoOffset: u32 align(1),
};

pub const LINEEXTENSIONID = extern struct {
    dwExtensionID0: u32 align(1),
    dwExtensionID1: u32 align(1),
    dwExtensionID2: u32 align(1),
    dwExtensionID3: u32 align(1),
};

pub const LINEFORWARD = extern struct {
    dwForwardMode: u32 align(1),
    dwCallerAddressSize: u32 align(1),
    dwCallerAddressOffset: u32 align(1),
    dwDestCountryCode: u32 align(1),
    dwDestAddressSize: u32 align(1),
    dwDestAddressOffset: u32 align(1),
};

pub const LINEFORWARDLIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNumEntries: u32 align(1),
    ForwardList: [1]LINEFORWARD align(1),
};

pub const LINEGENERATETONE = extern struct {
    dwFrequency: u32 align(1),
    dwCadenceOn: u32 align(1),
    dwCadenceOff: u32 align(1),
    dwVolume: u32 align(1),
};

pub const LINEINITIALIZEEXPARAMS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwOptions: u32 align(1),
    Handles: extern union {
        hEvent: ?HANDLE align(1),
        hCompletionPort: ?HANDLE align(1),
    } align(1),
    dwCompletionKey: u32 align(1),
};

pub const LINELOCATIONENTRY = extern struct {
    dwPermanentLocationID: u32 align(1),
    dwLocationNameSize: u32 align(1),
    dwLocationNameOffset: u32 align(1),
    dwCountryCode: u32 align(1),
    dwCityCodeSize: u32 align(1),
    dwCityCodeOffset: u32 align(1),
    dwPreferredCardID: u32 align(1),
    dwLocalAccessCodeSize: u32 align(1),
    dwLocalAccessCodeOffset: u32 align(1),
    dwLongDistanceAccessCodeSize: u32 align(1),
    dwLongDistanceAccessCodeOffset: u32 align(1),
    dwTollPrefixListSize: u32 align(1),
    dwTollPrefixListOffset: u32 align(1),
    dwCountryID: u32 align(1),
    dwOptions: u32 align(1),
    dwCancelCallWaitingSize: u32 align(1),
    dwCancelCallWaitingOffset: u32 align(1),
};

pub const LINEMEDIACONTROLCALLSTATE = extern struct {
    dwCallStates: u32 align(1),
    dwMediaControl: u32 align(1),
};

pub const LINEMEDIACONTROLDIGIT = extern struct {
    dwDigit: u32 align(1),
    dwDigitModes: u32 align(1),
    dwMediaControl: u32 align(1),
};

pub const LINEMEDIACONTROLMEDIA = extern struct {
    dwMediaModes: u32 align(1),
    dwDuration: u32 align(1),
    dwMediaControl: u32 align(1),
};

pub const LINEMEDIACONTROLTONE = extern struct {
    dwAppSpecific: u32 align(1),
    dwDuration: u32 align(1),
    dwFrequency1: u32 align(1),
    dwFrequency2: u32 align(1),
    dwFrequency3: u32 align(1),
    dwMediaControl: u32 align(1),
};

pub const LINEMESSAGE = extern struct {
    hDevice: u32 align(1),
    dwMessageID: u32 align(1),
    dwCallbackInstance: usize align(1),
    dwParam1: usize align(1),
    dwParam2: usize align(1),
    dwParam3: usize align(1),
};

pub const LINEMONITORTONE = extern struct {
    dwAppSpecific: u32 align(1),
    dwDuration: u32 align(1),
    dwFrequency1: u32 align(1),
    dwFrequency2: u32 align(1),
    dwFrequency3: u32 align(1),
};

pub const LINEPROVIDERENTRY = extern struct {
    dwPermanentProviderID: u32 align(1),
    dwProviderFilenameSize: u32 align(1),
    dwProviderFilenameOffset: u32 align(1),
};

pub const LINEPROVIDERLIST = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumProviders: u32 align(1),
    dwProviderListSize: u32 align(1),
    dwProviderListOffset: u32 align(1),
};

pub const LINEPROXYREQUEST = extern struct {
    dwSize: u32 align(1),
    dwClientMachineNameSize: u32 align(1),
    dwClientMachineNameOffset: u32 align(1),
    dwClientUserNameSize: u32 align(1),
    dwClientUserNameOffset: u32 align(1),
    dwClientAppAPIVersion: u32 align(1),
    dwRequestType: u32 align(1),
    Anonymous: extern union {
        SetAgentGroup: extern struct {
            dwAddressID: u32 align(1),
            GroupList: LINEAGENTGROUPLIST align(1),
        },
        SetAgentState: extern struct {
            dwAddressID: u32 align(1),
            dwAgentState: u32 align(1),
            dwNextAgentState: u32 align(1),
        },
        SetAgentActivity: extern struct {
            dwAddressID: u32 align(1),
            dwActivityID: u32 align(1),
        },
        GetAgentCaps: extern struct {
            dwAddressID: u32 align(1),
            AgentCaps: LINEAGENTCAPS align(1),
        },
        GetAgentStatus: extern struct {
            dwAddressID: u32 align(1),
            AgentStatus: LINEAGENTSTATUS align(1),
        },
        AgentSpecific: extern struct {
            dwAddressID: u32 align(1),
            dwAgentExtensionIDIndex: u32 align(1),
            dwSize: u32 align(1),
            Params: [1]u8 align(1),
        },
        GetAgentActivityList: extern struct {
            dwAddressID: u32 align(1),
            ActivityList: LINEAGENTACTIVITYLIST align(1),
        },
        GetAgentGroupList: extern struct {
            dwAddressID: u32 align(1),
            GroupList: LINEAGENTGROUPLIST align(1),
        },
        CreateAgent: extern struct {
            hAgent: u32 align(1),
            dwAgentIDSize: u32 align(1),
            dwAgentIDOffset: u32 align(1),
            dwAgentPINSize: u32 align(1),
            dwAgentPINOffset: u32 align(1),
        },
        SetAgentStateEx: extern struct {
            hAgent: u32 align(1),
            dwAgentState: u32 align(1),
            dwNextAgentState: u32 align(1),
        },
        SetAgentMeasurementPeriod: extern struct {
            hAgent: u32 align(1),
            dwMeasurementPeriod: u32 align(1),
        },
        GetAgentInfo: extern struct {
            hAgent: u32 align(1),
            AgentInfo: LINEAGENTINFO align(1),
        },
        CreateAgentSession: extern struct {
            hAgentSession: u32 align(1),
            dwAgentPINSize: u32 align(1),
            dwAgentPINOffset: u32 align(1),
            hAgent: u32 align(1),
            GroupID: Guid align(1),
            dwWorkingAddressID: u32 align(1),
        },
        GetAgentSessionList: extern struct {
            hAgent: u32 align(1),
            SessionList: LINEAGENTSESSIONLIST align(1),
        },
        GetAgentSessionInfo: extern struct {
            hAgentSession: u32 align(1),
            SessionInfo: LINEAGENTSESSIONINFO align(1),
        },
        SetAgentSessionState: extern struct {
            hAgentSession: u32 align(1),
            dwAgentSessionState: u32 align(1),
            dwNextAgentSessionState: u32 align(1),
        },
        GetQueueList: extern struct {
            GroupID: Guid align(1),
            QueueList: LINEQUEUELIST align(1),
        },
        SetQueueMeasurementPeriod: extern struct {
            dwQueueID: u32 align(1),
            dwMeasurementPeriod: u32 align(1),
        },
        GetQueueInfo: extern struct {
            dwQueueID: u32 align(1),
            QueueInfo: LINEQUEUEINFO align(1),
        },
        GetGroupList: extern struct {
            GroupList: LINEAGENTGROUPLIST,
        },
    } align(1),
};

pub const LINEREQMAKECALL = extern struct {
    szDestAddress: [80]CHAR,
    szAppName: [40]CHAR,
    szCalledParty: [40]CHAR,
    szComment: [80]CHAR,
};

pub const linereqmakecallW_tag = extern struct {
    szDestAddress: [80]u16 align(1),
    szAppName: [40]u16 align(1),
    szCalledParty: [40]u16 align(1),
    szComment: [80]u16 align(1),
};

pub const LINEREQMEDIACALL = extern struct {
    hWnd: ?HWND align(1),
    wRequestID: WPARAM align(1),
    szDeviceClass: [40]CHAR align(1),
    ucDeviceID: [40]u8 align(1),
    dwSize: u32 align(1),
    dwSecure: u32 align(1),
    szDestAddress: [80]CHAR align(1),
    szAppName: [40]CHAR align(1),
    szCalledParty: [40]CHAR align(1),
    szComment: [80]CHAR align(1),
};

pub const linereqmediacallW_tag = extern struct {
    hWnd: ?HWND align(1),
    wRequestID: WPARAM align(1),
    szDeviceClass: [40]u16 align(1),
    ucDeviceID: [40]u8 align(1),
    dwSize: u32 align(1),
    dwSecure: u32 align(1),
    szDestAddress: [80]u16 align(1),
    szAppName: [40]u16 align(1),
    szCalledParty: [40]u16 align(1),
    szComment: [80]u16 align(1),
};

pub const LINETERMCAPS = extern struct {
    dwTermDev: u32 align(1),
    dwTermModes: u32 align(1),
    dwTermSharing: u32 align(1),
};

pub const LINETRANSLATECAPS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwNumLocations: u32 align(1),
    dwLocationListSize: u32 align(1),
    dwLocationListOffset: u32 align(1),
    dwCurrentLocationID: u32 align(1),
    dwNumCards: u32 align(1),
    dwCardListSize: u32 align(1),
    dwCardListOffset: u32 align(1),
    dwCurrentPreferredCardID: u32 align(1),
};

pub const LINETRANSLATEOUTPUT = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwDialableStringSize: u32 align(1),
    dwDialableStringOffset: u32 align(1),
    dwDisplayableStringSize: u32 align(1),
    dwDisplayableStringOffset: u32 align(1),
    dwCurrentCountry: u32 align(1),
    dwDestCountry: u32 align(1),
    dwTranslateResults: u32 align(1),
};

pub const PHONEBUTTONINFO = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwButtonMode: u32 align(1),
    dwButtonFunction: u32 align(1),
    dwButtonTextSize: u32 align(1),
    dwButtonTextOffset: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
    dwButtonState: u32 align(1),
};

pub const PHONECAPS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwProviderInfoSize: u32 align(1),
    dwProviderInfoOffset: u32 align(1),
    dwPhoneInfoSize: u32 align(1),
    dwPhoneInfoOffset: u32 align(1),
    dwPermanentPhoneID: u32 align(1),
    dwPhoneNameSize: u32 align(1),
    dwPhoneNameOffset: u32 align(1),
    dwStringFormat: u32 align(1),
    dwPhoneStates: u32 align(1),
    dwHookSwitchDevs: u32 align(1),
    dwHandsetHookSwitchModes: u32 align(1),
    dwSpeakerHookSwitchModes: u32 align(1),
    dwHeadsetHookSwitchModes: u32 align(1),
    dwVolumeFlags: u32 align(1),
    dwGainFlags: u32 align(1),
    dwDisplayNumRows: u32 align(1),
    dwDisplayNumColumns: u32 align(1),
    dwNumRingModes: u32 align(1),
    dwNumButtonLamps: u32 align(1),
    dwButtonModesSize: u32 align(1),
    dwButtonModesOffset: u32 align(1),
    dwButtonFunctionsSize: u32 align(1),
    dwButtonFunctionsOffset: u32 align(1),
    dwLampModesSize: u32 align(1),
    dwLampModesOffset: u32 align(1),
    dwNumSetData: u32 align(1),
    dwSetDataSize: u32 align(1),
    dwSetDataOffset: u32 align(1),
    dwNumGetData: u32 align(1),
    dwGetDataSize: u32 align(1),
    dwGetDataOffset: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
    dwDeviceClassesSize: u32 align(1),
    dwDeviceClassesOffset: u32 align(1),
    dwPhoneFeatures: u32 align(1),
    dwSettableHandsetHookSwitchModes: u32 align(1),
    dwSettableSpeakerHookSwitchModes: u32 align(1),
    dwSettableHeadsetHookSwitchModes: u32 align(1),
    dwMonitoredHandsetHookSwitchModes: u32 align(1),
    dwMonitoredSpeakerHookSwitchModes: u32 align(1),
    dwMonitoredHeadsetHookSwitchModes: u32 align(1),
    PermanentPhoneGuid: Guid align(1),
};

pub const PHONEEXTENSIONID = extern struct {
    dwExtensionID0: u32 align(1),
    dwExtensionID1: u32 align(1),
    dwExtensionID2: u32 align(1),
    dwExtensionID3: u32 align(1),
};

pub const PHONEINITIALIZEEXPARAMS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwOptions: u32 align(1),
    Handles: extern union {
        hEvent: ?HANDLE align(1),
        hCompletionPort: ?HANDLE align(1),
    } align(1),
    dwCompletionKey: u32 align(1),
};

pub const PHONEMESSAGE = extern struct {
    hDevice: u32 align(1),
    dwMessageID: u32 align(1),
    dwCallbackInstance: usize align(1),
    dwParam1: usize align(1),
    dwParam2: usize align(1),
    dwParam3: usize align(1),
};

pub const PHONESTATUS = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwStatusFlags: u32 align(1),
    dwNumOwners: u32 align(1),
    dwNumMonitors: u32 align(1),
    dwRingMode: u32 align(1),
    dwRingVolume: u32 align(1),
    dwHandsetHookSwitchMode: u32 align(1),
    dwHandsetVolume: u32 align(1),
    dwHandsetGain: u32 align(1),
    dwSpeakerHookSwitchMode: u32 align(1),
    dwSpeakerVolume: u32 align(1),
    dwSpeakerGain: u32 align(1),
    dwHeadsetHookSwitchMode: u32 align(1),
    dwHeadsetVolume: u32 align(1),
    dwHeadsetGain: u32 align(1),
    dwDisplaySize: u32 align(1),
    dwDisplayOffset: u32 align(1),
    dwLampModesSize: u32 align(1),
    dwLampModesOffset: u32 align(1),
    dwOwnerNameSize: u32 align(1),
    dwOwnerNameOffset: u32 align(1),
    dwDevSpecificSize: u32 align(1),
    dwDevSpecificOffset: u32 align(1),
    dwPhoneFeatures: u32 align(1),
};

pub const VARSTRING = extern struct {
    dwTotalSize: u32 align(1),
    dwNeededSize: u32 align(1),
    dwUsedSize: u32 align(1),
    dwStringFormat: u32 align(1),
    dwStringSize: u32 align(1),
    dwStringOffset: u32 align(1),
};

pub const HDRVCALL__ = extern struct {
    unused: i32,
};

pub const HDRVLINE__ = extern struct {
    unused: i32,
};

pub const HDRVPHONE__ = extern struct {
    unused: i32,
};

pub const HDRVMSPLINE__ = extern struct {
    unused: i32,
};

pub const HDRVDIALOGINSTANCE__ = extern struct {
    unused: i32,
};

pub const HTAPICALL__ = extern struct {
    unused: i32,
};

pub const HTAPILINE__ = extern struct {
    unused: i32,
};

pub const HTAPIPHONE__ = extern struct {
    unused: i32,
};

pub const HPROVIDER__ = extern struct {
    unused: i32,
};

pub const ASYNC_COMPLETION = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dwRequestID: u32,
        lResult: i32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        dwRequestID: u32,
        lResult: i32,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const LINEEVENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        htLine: ?*HTAPILINE__,
        htCall: ?*HTAPICALL__,
        dwMsg: u32,
        dwParam1: usize,
        dwParam2: usize,
        dwParam3: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        htLine: ?*HTAPILINE__,
        htCall: ?*HTAPICALL__,
        dwMsg: u32,
        dwParam1: usize,
        dwParam2: usize,
        dwParam3: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PHONEEVENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        htPhone: ?*HTAPIPHONE__,
        dwMsg: u32,
        dwParam1: usize,
        dwParam2: usize,
        dwParam3: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        htPhone: ?*HTAPIPHONE__,
        dwMsg: u32,
        dwParam1: usize,
        dwParam2: usize,
        dwParam3: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const TUISPIDLLCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dwObjectID: usize,
        dwObjectType: u32,
        lpParams: ?*anyopaque,
        dwSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        dwObjectID: usize,
        dwObjectType: u32,
        lpParams: ?*anyopaque,
        dwSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const TUISPICREATEDIALOGINSTANCEPARAMS = extern struct {
    dwRequestID: u32,
    hdDlgInst: ?*HDRVDIALOGINSTANCE__,
    htDlgInst: u32,
    lpszUIDLLName: ?[*:0]const u16,
    lpParams: ?*anyopaque,
    dwSize: u32,
};

const CLSID_TAPI_Value = Guid.initString("21d6d48e-a88b-11d0-83dd-00aa003ccabd");
pub const CLSID_TAPI = &CLSID_TAPI_Value;

const CLSID_DispatchMapper_Value = Guid.initString("e9225296-c759-11d1-a02b-00c04fb6809f");
pub const CLSID_DispatchMapper = &CLSID_DispatchMapper_Value;

const CLSID_RequestMakeCall_Value = Guid.initString("ac48ffe0-f8c4-11d1-a030-00c04fb6809f");
pub const CLSID_RequestMakeCall = &CLSID_RequestMakeCall_Value;

pub const TAPI_TONEMODE = enum(i32) {
    RINGBACK = 2,
    BUSY = 4,
    BEEP = 8,
    BILLING = 16,
};
pub const TTM_RINGBACK = TAPI_TONEMODE.RINGBACK;
pub const TTM_BUSY = TAPI_TONEMODE.BUSY;
pub const TTM_BEEP = TAPI_TONEMODE.BEEP;
pub const TTM_BILLING = TAPI_TONEMODE.BILLING;

pub const TAPI_GATHERTERM = enum(i32) {
    BUFFERFULL = 1,
    TERMDIGIT = 2,
    FIRSTTIMEOUT = 4,
    INTERTIMEOUT = 8,
    CANCEL = 16,
};
pub const TGT_BUFFERFULL = TAPI_GATHERTERM.BUFFERFULL;
pub const TGT_TERMDIGIT = TAPI_GATHERTERM.TERMDIGIT;
pub const TGT_FIRSTTIMEOUT = TAPI_GATHERTERM.FIRSTTIMEOUT;
pub const TGT_INTERTIMEOUT = TAPI_GATHERTERM.INTERTIMEOUT;
pub const TGT_CANCEL = TAPI_GATHERTERM.CANCEL;

pub const TAPI_CUSTOMTONE = extern struct {
    dwFrequency: u32,
    dwCadenceOn: u32,
    dwCadenceOff: u32,
    dwVolume: u32,
};

pub const TAPI_DETECTTONE = extern struct {
    dwAppSpecific: u32,
    dwDuration: u32,
    dwFrequency1: u32,
    dwFrequency2: u32,
    dwFrequency3: u32,
};

pub const ADDRESS_EVENT = enum(i32) {
    STATE = 0,
    CAPSCHANGE = 1,
    RINGING = 2,
    CONFIGCHANGE = 3,
    FORWARD = 4,
    NEWTERMINAL = 5,
    REMOVETERMINAL = 6,
    MSGWAITON = 7,
    MSGWAITOFF = 8,
    // LASTITEM = 8, this enum value conflicts with MSGWAITOFF
};
pub const AE_STATE = ADDRESS_EVENT.STATE;
pub const AE_CAPSCHANGE = ADDRESS_EVENT.CAPSCHANGE;
pub const AE_RINGING = ADDRESS_EVENT.RINGING;
pub const AE_CONFIGCHANGE = ADDRESS_EVENT.CONFIGCHANGE;
pub const AE_FORWARD = ADDRESS_EVENT.FORWARD;
pub const AE_NEWTERMINAL = ADDRESS_EVENT.NEWTERMINAL;
pub const AE_REMOVETERMINAL = ADDRESS_EVENT.REMOVETERMINAL;
pub const AE_MSGWAITON = ADDRESS_EVENT.MSGWAITON;
pub const AE_MSGWAITOFF = ADDRESS_EVENT.MSGWAITOFF;
pub const AE_LASTITEM = ADDRESS_EVENT.MSGWAITOFF;

pub const ADDRESS_STATE = enum(i32) {
    INSERVICE = 0,
    OUTOFSERVICE = 1,
};
pub const AS_INSERVICE = ADDRESS_STATE.INSERVICE;
pub const AS_OUTOFSERVICE = ADDRESS_STATE.OUTOFSERVICE;

pub const CALL_STATE = enum(i32) {
    IDLE = 0,
    INPROGRESS = 1,
    CONNECTED = 2,
    DISCONNECTED = 3,
    OFFERING = 4,
    HOLD = 5,
    QUEUED = 6,
    // LASTITEM = 6, this enum value conflicts with QUEUED
};
pub const CS_IDLE = CALL_STATE.IDLE;
pub const CS_INPROGRESS = CALL_STATE.INPROGRESS;
pub const CS_CONNECTED = CALL_STATE.CONNECTED;
pub const CS_DISCONNECTED = CALL_STATE.DISCONNECTED;
pub const CS_OFFERING = CALL_STATE.OFFERING;
pub const CS_HOLD = CALL_STATE.HOLD;
pub const CS_QUEUED = CALL_STATE.QUEUED;
pub const CS_LASTITEM = CALL_STATE.QUEUED;

pub const CALL_STATE_EVENT_CAUSE = enum(i32) {
    NONE = 0,
    DISCONNECT_NORMAL = 1,
    DISCONNECT_BUSY = 2,
    DISCONNECT_BADADDRESS = 3,
    DISCONNECT_NOANSWER = 4,
    DISCONNECT_CANCELLED = 5,
    DISCONNECT_REJECTED = 6,
    DISCONNECT_FAILED = 7,
    DISCONNECT_BLOCKED = 8,
};
pub const CEC_NONE = CALL_STATE_EVENT_CAUSE.NONE;
pub const CEC_DISCONNECT_NORMAL = CALL_STATE_EVENT_CAUSE.DISCONNECT_NORMAL;
pub const CEC_DISCONNECT_BUSY = CALL_STATE_EVENT_CAUSE.DISCONNECT_BUSY;
pub const CEC_DISCONNECT_BADADDRESS = CALL_STATE_EVENT_CAUSE.DISCONNECT_BADADDRESS;
pub const CEC_DISCONNECT_NOANSWER = CALL_STATE_EVENT_CAUSE.DISCONNECT_NOANSWER;
pub const CEC_DISCONNECT_CANCELLED = CALL_STATE_EVENT_CAUSE.DISCONNECT_CANCELLED;
pub const CEC_DISCONNECT_REJECTED = CALL_STATE_EVENT_CAUSE.DISCONNECT_REJECTED;
pub const CEC_DISCONNECT_FAILED = CALL_STATE_EVENT_CAUSE.DISCONNECT_FAILED;
pub const CEC_DISCONNECT_BLOCKED = CALL_STATE_EVENT_CAUSE.DISCONNECT_BLOCKED;

pub const CALL_MEDIA_EVENT = enum(i32) {
    NEW_STREAM = 0,
    STREAM_FAIL = 1,
    TERMINAL_FAIL = 2,
    STREAM_NOT_USED = 3,
    STREAM_ACTIVE = 4,
    STREAM_INACTIVE = 5,
    // LASTITEM = 5, this enum value conflicts with STREAM_INACTIVE
};
pub const CME_NEW_STREAM = CALL_MEDIA_EVENT.NEW_STREAM;
pub const CME_STREAM_FAIL = CALL_MEDIA_EVENT.STREAM_FAIL;
pub const CME_TERMINAL_FAIL = CALL_MEDIA_EVENT.TERMINAL_FAIL;
pub const CME_STREAM_NOT_USED = CALL_MEDIA_EVENT.STREAM_NOT_USED;
pub const CME_STREAM_ACTIVE = CALL_MEDIA_EVENT.STREAM_ACTIVE;
pub const CME_STREAM_INACTIVE = CALL_MEDIA_EVENT.STREAM_INACTIVE;
pub const CME_LASTITEM = CALL_MEDIA_EVENT.STREAM_INACTIVE;

pub const CALL_MEDIA_EVENT_CAUSE = enum(i32) {
    UNKNOWN = 0,
    BAD_DEVICE = 1,
    CONNECT_FAIL = 2,
    LOCAL_REQUEST = 3,
    REMOTE_REQUEST = 4,
    MEDIA_TIMEOUT = 5,
    MEDIA_RECOVERED = 6,
    QUALITY_OF_SERVICE = 7,
};
pub const CMC_UNKNOWN = CALL_MEDIA_EVENT_CAUSE.UNKNOWN;
pub const CMC_BAD_DEVICE = CALL_MEDIA_EVENT_CAUSE.BAD_DEVICE;
pub const CMC_CONNECT_FAIL = CALL_MEDIA_EVENT_CAUSE.CONNECT_FAIL;
pub const CMC_LOCAL_REQUEST = CALL_MEDIA_EVENT_CAUSE.LOCAL_REQUEST;
pub const CMC_REMOTE_REQUEST = CALL_MEDIA_EVENT_CAUSE.REMOTE_REQUEST;
pub const CMC_MEDIA_TIMEOUT = CALL_MEDIA_EVENT_CAUSE.MEDIA_TIMEOUT;
pub const CMC_MEDIA_RECOVERED = CALL_MEDIA_EVENT_CAUSE.MEDIA_RECOVERED;
pub const CMC_QUALITY_OF_SERVICE = CALL_MEDIA_EVENT_CAUSE.QUALITY_OF_SERVICE;

pub const DISCONNECT_CODE = enum(i32) {
    NORMAL = 0,
    NOANSWER = 1,
    REJECTED = 2,
};
pub const DC_NORMAL = DISCONNECT_CODE.NORMAL;
pub const DC_NOANSWER = DISCONNECT_CODE.NOANSWER;
pub const DC_REJECTED = DISCONNECT_CODE.REJECTED;

pub const TERMINAL_STATE = enum(i32) {
    INUSE = 0,
    NOTINUSE = 1,
};
pub const TS_INUSE = TERMINAL_STATE.INUSE;
pub const TS_NOTINUSE = TERMINAL_STATE.NOTINUSE;

pub const TERMINAL_DIRECTION = enum(i32) {
    CAPTURE = 0,
    RENDER = 1,
    BIDIRECTIONAL = 2,
    MULTITRACK_MIXED = 3,
    NONE = 4,
};
pub const TD_CAPTURE = TERMINAL_DIRECTION.CAPTURE;
pub const TD_RENDER = TERMINAL_DIRECTION.RENDER;
pub const TD_BIDIRECTIONAL = TERMINAL_DIRECTION.BIDIRECTIONAL;
pub const TD_MULTITRACK_MIXED = TERMINAL_DIRECTION.MULTITRACK_MIXED;
pub const TD_NONE = TERMINAL_DIRECTION.NONE;

pub const TERMINAL_TYPE = enum(i32) {
    STATIC = 0,
    DYNAMIC = 1,
};
pub const TT_STATIC = TERMINAL_TYPE.STATIC;
pub const TT_DYNAMIC = TERMINAL_TYPE.DYNAMIC;

pub const CALL_PRIVILEGE = enum(i32) {
    OWNER = 0,
    MONITOR = 1,
};
pub const CP_OWNER = CALL_PRIVILEGE.OWNER;
pub const CP_MONITOR = CALL_PRIVILEGE.MONITOR;

pub const TAPI_EVENT = enum(i32) {
    TAPIOBJECT = 1,
    ADDRESS = 2,
    CALLNOTIFICATION = 4,
    CALLSTATE = 8,
    CALLMEDIA = 16,
    CALLHUB = 32,
    CALLINFOCHANGE = 64,
    PRIVATE = 128,
    REQUEST = 256,
    AGENT = 512,
    AGENTSESSION = 1024,
    QOSEVENT = 2048,
    AGENTHANDLER = 4096,
    ACDGROUP = 8192,
    QUEUE = 16384,
    DIGITEVENT = 32768,
    GENERATEEVENT = 65536,
    ASRTERMINAL = 131072,
    TTSTERMINAL = 262144,
    FILETERMINAL = 524288,
    TONETERMINAL = 1048576,
    PHONEEVENT = 2097152,
    TONEEVENT = 4194304,
    GATHERDIGITS = 8388608,
    ADDRESSDEVSPECIFIC = 16777216,
    PHONEDEVSPECIFIC = 33554432,
};
pub const TE_TAPIOBJECT = TAPI_EVENT.TAPIOBJECT;
pub const TE_ADDRESS = TAPI_EVENT.ADDRESS;
pub const TE_CALLNOTIFICATION = TAPI_EVENT.CALLNOTIFICATION;
pub const TE_CALLSTATE = TAPI_EVENT.CALLSTATE;
pub const TE_CALLMEDIA = TAPI_EVENT.CALLMEDIA;
pub const TE_CALLHUB = TAPI_EVENT.CALLHUB;
pub const TE_CALLINFOCHANGE = TAPI_EVENT.CALLINFOCHANGE;
pub const TE_PRIVATE = TAPI_EVENT.PRIVATE;
pub const TE_REQUEST = TAPI_EVENT.REQUEST;
pub const TE_AGENT = TAPI_EVENT.AGENT;
pub const TE_AGENTSESSION = TAPI_EVENT.AGENTSESSION;
pub const TE_QOSEVENT = TAPI_EVENT.QOSEVENT;
pub const TE_AGENTHANDLER = TAPI_EVENT.AGENTHANDLER;
pub const TE_ACDGROUP = TAPI_EVENT.ACDGROUP;
pub const TE_QUEUE = TAPI_EVENT.QUEUE;
pub const TE_DIGITEVENT = TAPI_EVENT.DIGITEVENT;
pub const TE_GENERATEEVENT = TAPI_EVENT.GENERATEEVENT;
pub const TE_ASRTERMINAL = TAPI_EVENT.ASRTERMINAL;
pub const TE_TTSTERMINAL = TAPI_EVENT.TTSTERMINAL;
pub const TE_FILETERMINAL = TAPI_EVENT.FILETERMINAL;
pub const TE_TONETERMINAL = TAPI_EVENT.TONETERMINAL;
pub const TE_PHONEEVENT = TAPI_EVENT.PHONEEVENT;
pub const TE_TONEEVENT = TAPI_EVENT.TONEEVENT;
pub const TE_GATHERDIGITS = TAPI_EVENT.GATHERDIGITS;
pub const TE_ADDRESSDEVSPECIFIC = TAPI_EVENT.ADDRESSDEVSPECIFIC;
pub const TE_PHONEDEVSPECIFIC = TAPI_EVENT.PHONEDEVSPECIFIC;

pub const CALL_NOTIFICATION_EVENT = enum(i32) {
    OWNER = 0,
    MONITOR = 1,
    // LASTITEM = 1, this enum value conflicts with MONITOR
};
pub const CNE_OWNER = CALL_NOTIFICATION_EVENT.OWNER;
pub const CNE_MONITOR = CALL_NOTIFICATION_EVENT.MONITOR;
pub const CNE_LASTITEM = CALL_NOTIFICATION_EVENT.MONITOR;

pub const CALLHUB_EVENT = enum(i32) {
    CALLJOIN = 0,
    CALLLEAVE = 1,
    CALLHUBNEW = 2,
    CALLHUBIDLE = 3,
    // LASTITEM = 3, this enum value conflicts with CALLHUBIDLE
};
pub const CHE_CALLJOIN = CALLHUB_EVENT.CALLJOIN;
pub const CHE_CALLLEAVE = CALLHUB_EVENT.CALLLEAVE;
pub const CHE_CALLHUBNEW = CALLHUB_EVENT.CALLHUBNEW;
pub const CHE_CALLHUBIDLE = CALLHUB_EVENT.CALLHUBIDLE;
pub const CHE_LASTITEM = CALLHUB_EVENT.CALLHUBIDLE;

pub const CALLHUB_STATE = enum(i32) {
    ACTIVE = 0,
    IDLE = 1,
};
pub const CHS_ACTIVE = CALLHUB_STATE.ACTIVE;
pub const CHS_IDLE = CALLHUB_STATE.IDLE;

pub const TAPIOBJECT_EVENT = enum(i32) {
    ADDRESSCREATE = 0,
    ADDRESSREMOVE = 1,
    REINIT = 2,
    TRANSLATECHANGE = 3,
    ADDRESSCLOSE = 4,
    PHONECREATE = 5,
    PHONEREMOVE = 6,
};
pub const TE_ADDRESSCREATE = TAPIOBJECT_EVENT.ADDRESSCREATE;
pub const TE_ADDRESSREMOVE = TAPIOBJECT_EVENT.ADDRESSREMOVE;
pub const TE_REINIT = TAPIOBJECT_EVENT.REINIT;
pub const TE_TRANSLATECHANGE = TAPIOBJECT_EVENT.TRANSLATECHANGE;
pub const TE_ADDRESSCLOSE = TAPIOBJECT_EVENT.ADDRESSCLOSE;
pub const TE_PHONECREATE = TAPIOBJECT_EVENT.PHONECREATE;
pub const TE_PHONEREMOVE = TAPIOBJECT_EVENT.PHONEREMOVE;

pub const TAPI_OBJECT_TYPE = enum(i32) {
    NONE = 0,
    TAPI = 1,
    ADDRESS = 2,
    TERMINAL = 3,
    CALL = 4,
    CALLHUB = 5,
    PHONE = 6,
};
pub const TOT_NONE = TAPI_OBJECT_TYPE.NONE;
pub const TOT_TAPI = TAPI_OBJECT_TYPE.TAPI;
pub const TOT_ADDRESS = TAPI_OBJECT_TYPE.ADDRESS;
pub const TOT_TERMINAL = TAPI_OBJECT_TYPE.TERMINAL;
pub const TOT_CALL = TAPI_OBJECT_TYPE.CALL;
pub const TOT_CALLHUB = TAPI_OBJECT_TYPE.CALLHUB;
pub const TOT_PHONE = TAPI_OBJECT_TYPE.PHONE;

pub const QOS_SERVICE_LEVEL = enum(i32) {
    NEEDED = 1,
    IF_AVAILABLE = 2,
    BEST_EFFORT = 3,
};
pub const QSL_NEEDED = QOS_SERVICE_LEVEL.NEEDED;
pub const QSL_IF_AVAILABLE = QOS_SERVICE_LEVEL.IF_AVAILABLE;
pub const QSL_BEST_EFFORT = QOS_SERVICE_LEVEL.BEST_EFFORT;

pub const QOS_EVENT = enum(i32) {
    NOQOS = 1,
    ADMISSIONFAILURE = 2,
    POLICYFAILURE = 3,
    GENERICERROR = 4,
    // LASTITEM = 4, this enum value conflicts with GENERICERROR
};
pub const QE_NOQOS = QOS_EVENT.NOQOS;
pub const QE_ADMISSIONFAILURE = QOS_EVENT.ADMISSIONFAILURE;
pub const QE_POLICYFAILURE = QOS_EVENT.POLICYFAILURE;
pub const QE_GENERICERROR = QOS_EVENT.GENERICERROR;
pub const QE_LASTITEM = QOS_EVENT.GENERICERROR;

pub const CALLINFOCHANGE_CAUSE = enum(i32) {
    OTHER = 0,
    DEVSPECIFIC = 1,
    BEARERMODE = 2,
    RATE = 3,
    APPSPECIFIC = 4,
    CALLID = 5,
    RELATEDCALLID = 6,
    ORIGIN = 7,
    REASON = 8,
    COMPLETIONID = 9,
    NUMOWNERINCR = 10,
    NUMOWNERDECR = 11,
    NUMMONITORS = 12,
    TRUNK = 13,
    CALLERID = 14,
    CALLEDID = 15,
    CONNECTEDID = 16,
    REDIRECTIONID = 17,
    REDIRECTINGID = 18,
    USERUSERINFO = 19,
    HIGHLEVELCOMP = 20,
    LOWLEVELCOMP = 21,
    CHARGINGINFO = 22,
    TREATMENT = 23,
    CALLDATA = 24,
    PRIVILEGE = 25,
    MEDIATYPE = 26,
    // LASTITEM = 26, this enum value conflicts with MEDIATYPE
};
pub const CIC_OTHER = CALLINFOCHANGE_CAUSE.OTHER;
pub const CIC_DEVSPECIFIC = CALLINFOCHANGE_CAUSE.DEVSPECIFIC;
pub const CIC_BEARERMODE = CALLINFOCHANGE_CAUSE.BEARERMODE;
pub const CIC_RATE = CALLINFOCHANGE_CAUSE.RATE;
pub const CIC_APPSPECIFIC = CALLINFOCHANGE_CAUSE.APPSPECIFIC;
pub const CIC_CALLID = CALLINFOCHANGE_CAUSE.CALLID;
pub const CIC_RELATEDCALLID = CALLINFOCHANGE_CAUSE.RELATEDCALLID;
pub const CIC_ORIGIN = CALLINFOCHANGE_CAUSE.ORIGIN;
pub const CIC_REASON = CALLINFOCHANGE_CAUSE.REASON;
pub const CIC_COMPLETIONID = CALLINFOCHANGE_CAUSE.COMPLETIONID;
pub const CIC_NUMOWNERINCR = CALLINFOCHANGE_CAUSE.NUMOWNERINCR;
pub const CIC_NUMOWNERDECR = CALLINFOCHANGE_CAUSE.NUMOWNERDECR;
pub const CIC_NUMMONITORS = CALLINFOCHANGE_CAUSE.NUMMONITORS;
pub const CIC_TRUNK = CALLINFOCHANGE_CAUSE.TRUNK;
pub const CIC_CALLERID = CALLINFOCHANGE_CAUSE.CALLERID;
pub const CIC_CALLEDID = CALLINFOCHANGE_CAUSE.CALLEDID;
pub const CIC_CONNECTEDID = CALLINFOCHANGE_CAUSE.CONNECTEDID;
pub const CIC_REDIRECTIONID = CALLINFOCHANGE_CAUSE.REDIRECTIONID;
pub const CIC_REDIRECTINGID = CALLINFOCHANGE_CAUSE.REDIRECTINGID;
pub const CIC_USERUSERINFO = CALLINFOCHANGE_CAUSE.USERUSERINFO;
pub const CIC_HIGHLEVELCOMP = CALLINFOCHANGE_CAUSE.HIGHLEVELCOMP;
pub const CIC_LOWLEVELCOMP = CALLINFOCHANGE_CAUSE.LOWLEVELCOMP;
pub const CIC_CHARGINGINFO = CALLINFOCHANGE_CAUSE.CHARGINGINFO;
pub const CIC_TREATMENT = CALLINFOCHANGE_CAUSE.TREATMENT;
pub const CIC_CALLDATA = CALLINFOCHANGE_CAUSE.CALLDATA;
pub const CIC_PRIVILEGE = CALLINFOCHANGE_CAUSE.PRIVILEGE;
pub const CIC_MEDIATYPE = CALLINFOCHANGE_CAUSE.MEDIATYPE;
pub const CIC_LASTITEM = CALLINFOCHANGE_CAUSE.MEDIATYPE;

pub const CALLINFO_LONG = enum(i32) {
    MEDIATYPESAVAILABLE = 0,
    BEARERMODE = 1,
    CALLERIDADDRESSTYPE = 2,
    CALLEDIDADDRESSTYPE = 3,
    CONNECTEDIDADDRESSTYPE = 4,
    REDIRECTIONIDADDRESSTYPE = 5,
    REDIRECTINGIDADDRESSTYPE = 6,
    ORIGIN = 7,
    REASON = 8,
    APPSPECIFIC = 9,
    CALLPARAMSFLAGS = 10,
    CALLTREATMENT = 11,
    MINRATE = 12,
    MAXRATE = 13,
    COUNTRYCODE = 14,
    CALLID = 15,
    RELATEDCALLID = 16,
    COMPLETIONID = 17,
    NUMBEROFOWNERS = 18,
    NUMBEROFMONITORS = 19,
    TRUNK = 20,
    RATE = 21,
    GENERATEDIGITDURATION = 22,
    MONITORDIGITMODES = 23,
    MONITORMEDIAMODES = 24,
};
pub const CIL_MEDIATYPESAVAILABLE = CALLINFO_LONG.MEDIATYPESAVAILABLE;
pub const CIL_BEARERMODE = CALLINFO_LONG.BEARERMODE;
pub const CIL_CALLERIDADDRESSTYPE = CALLINFO_LONG.CALLERIDADDRESSTYPE;
pub const CIL_CALLEDIDADDRESSTYPE = CALLINFO_LONG.CALLEDIDADDRESSTYPE;
pub const CIL_CONNECTEDIDADDRESSTYPE = CALLINFO_LONG.CONNECTEDIDADDRESSTYPE;
pub const CIL_REDIRECTIONIDADDRESSTYPE = CALLINFO_LONG.REDIRECTIONIDADDRESSTYPE;
pub const CIL_REDIRECTINGIDADDRESSTYPE = CALLINFO_LONG.REDIRECTINGIDADDRESSTYPE;
pub const CIL_ORIGIN = CALLINFO_LONG.ORIGIN;
pub const CIL_REASON = CALLINFO_LONG.REASON;
pub const CIL_APPSPECIFIC = CALLINFO_LONG.APPSPECIFIC;
pub const CIL_CALLPARAMSFLAGS = CALLINFO_LONG.CALLPARAMSFLAGS;
pub const CIL_CALLTREATMENT = CALLINFO_LONG.CALLTREATMENT;
pub const CIL_MINRATE = CALLINFO_LONG.MINRATE;
pub const CIL_MAXRATE = CALLINFO_LONG.MAXRATE;
pub const CIL_COUNTRYCODE = CALLINFO_LONG.COUNTRYCODE;
pub const CIL_CALLID = CALLINFO_LONG.CALLID;
pub const CIL_RELATEDCALLID = CALLINFO_LONG.RELATEDCALLID;
pub const CIL_COMPLETIONID = CALLINFO_LONG.COMPLETIONID;
pub const CIL_NUMBEROFOWNERS = CALLINFO_LONG.NUMBEROFOWNERS;
pub const CIL_NUMBEROFMONITORS = CALLINFO_LONG.NUMBEROFMONITORS;
pub const CIL_TRUNK = CALLINFO_LONG.TRUNK;
pub const CIL_RATE = CALLINFO_LONG.RATE;
pub const CIL_GENERATEDIGITDURATION = CALLINFO_LONG.GENERATEDIGITDURATION;
pub const CIL_MONITORDIGITMODES = CALLINFO_LONG.MONITORDIGITMODES;
pub const CIL_MONITORMEDIAMODES = CALLINFO_LONG.MONITORMEDIAMODES;

pub const CALLINFO_STRING = enum(i32) {
    CALLERIDNAME = 0,
    CALLERIDNUMBER = 1,
    CALLEDIDNAME = 2,
    CALLEDIDNUMBER = 3,
    CONNECTEDIDNAME = 4,
    CONNECTEDIDNUMBER = 5,
    REDIRECTIONIDNAME = 6,
    REDIRECTIONIDNUMBER = 7,
    REDIRECTINGIDNAME = 8,
    REDIRECTINGIDNUMBER = 9,
    CALLEDPARTYFRIENDLYNAME = 10,
    COMMENT = 11,
    DISPLAYABLEADDRESS = 12,
    CALLINGPARTYID = 13,
};
pub const CIS_CALLERIDNAME = CALLINFO_STRING.CALLERIDNAME;
pub const CIS_CALLERIDNUMBER = CALLINFO_STRING.CALLERIDNUMBER;
pub const CIS_CALLEDIDNAME = CALLINFO_STRING.CALLEDIDNAME;
pub const CIS_CALLEDIDNUMBER = CALLINFO_STRING.CALLEDIDNUMBER;
pub const CIS_CONNECTEDIDNAME = CALLINFO_STRING.CONNECTEDIDNAME;
pub const CIS_CONNECTEDIDNUMBER = CALLINFO_STRING.CONNECTEDIDNUMBER;
pub const CIS_REDIRECTIONIDNAME = CALLINFO_STRING.REDIRECTIONIDNAME;
pub const CIS_REDIRECTIONIDNUMBER = CALLINFO_STRING.REDIRECTIONIDNUMBER;
pub const CIS_REDIRECTINGIDNAME = CALLINFO_STRING.REDIRECTINGIDNAME;
pub const CIS_REDIRECTINGIDNUMBER = CALLINFO_STRING.REDIRECTINGIDNUMBER;
pub const CIS_CALLEDPARTYFRIENDLYNAME = CALLINFO_STRING.CALLEDPARTYFRIENDLYNAME;
pub const CIS_COMMENT = CALLINFO_STRING.COMMENT;
pub const CIS_DISPLAYABLEADDRESS = CALLINFO_STRING.DISPLAYABLEADDRESS;
pub const CIS_CALLINGPARTYID = CALLINFO_STRING.CALLINGPARTYID;

pub const CALLINFO_BUFFER = enum(i32) {
    USERUSERINFO = 0,
    DEVSPECIFICBUFFER = 1,
    CALLDATABUFFER = 2,
    CHARGINGINFOBUFFER = 3,
    HIGHLEVELCOMPATIBILITYBUFFER = 4,
    LOWLEVELCOMPATIBILITYBUFFER = 5,
};
pub const CIB_USERUSERINFO = CALLINFO_BUFFER.USERUSERINFO;
pub const CIB_DEVSPECIFICBUFFER = CALLINFO_BUFFER.DEVSPECIFICBUFFER;
pub const CIB_CALLDATABUFFER = CALLINFO_BUFFER.CALLDATABUFFER;
pub const CIB_CHARGINGINFOBUFFER = CALLINFO_BUFFER.CHARGINGINFOBUFFER;
pub const CIB_HIGHLEVELCOMPATIBILITYBUFFER = CALLINFO_BUFFER.HIGHLEVELCOMPATIBILITYBUFFER;
pub const CIB_LOWLEVELCOMPATIBILITYBUFFER = CALLINFO_BUFFER.LOWLEVELCOMPATIBILITYBUFFER;

pub const ADDRESS_CAPABILITY = enum(i32) {
    ADDRESSTYPES = 0,
    BEARERMODES = 1,
    MAXACTIVECALLS = 2,
    MAXONHOLDCALLS = 3,
    MAXONHOLDPENDINGCALLS = 4,
    MAXNUMCONFERENCE = 5,
    MAXNUMTRANSCONF = 6,
    MONITORDIGITSUPPORT = 7,
    GENERATEDIGITSUPPORT = 8,
    GENERATETONEMODES = 9,
    GENERATETONEMAXNUMFREQ = 10,
    MONITORTONEMAXNUMFREQ = 11,
    MONITORTONEMAXNUMENTRIES = 12,
    DEVCAPFLAGS = 13,
    ANSWERMODES = 14,
    LINEFEATURES = 15,
    SETTABLEDEVSTATUS = 16,
    PARKSUPPORT = 17,
    CALLERIDSUPPORT = 18,
    CALLEDIDSUPPORT = 19,
    CONNECTEDIDSUPPORT = 20,
    REDIRECTIONIDSUPPORT = 21,
    REDIRECTINGIDSUPPORT = 22,
    ADDRESSCAPFLAGS = 23,
    CALLFEATURES1 = 24,
    CALLFEATURES2 = 25,
    REMOVEFROMCONFCAPS = 26,
    REMOVEFROMCONFSTATE = 27,
    TRANSFERMODES = 28,
    ADDRESSFEATURES = 29,
    PREDICTIVEAUTOTRANSFERSTATES = 30,
    MAXCALLDATASIZE = 31,
    LINEID = 32,
    ADDRESSID = 33,
    FORWARDMODES = 34,
    MAXFORWARDENTRIES = 35,
    MAXSPECIFICENTRIES = 36,
    MINFWDNUMRINGS = 37,
    MAXFWDNUMRINGS = 38,
    MAXCALLCOMPLETIONS = 39,
    CALLCOMPLETIONCONDITIONS = 40,
    CALLCOMPLETIONMODES = 41,
    PERMANENTDEVICEID = 42,
    GATHERDIGITSMINTIMEOUT = 43,
    GATHERDIGITSMAXTIMEOUT = 44,
    GENERATEDIGITMINDURATION = 45,
    GENERATEDIGITMAXDURATION = 46,
    GENERATEDIGITDEFAULTDURATION = 47,
};
pub const AC_ADDRESSTYPES = ADDRESS_CAPABILITY.ADDRESSTYPES;
pub const AC_BEARERMODES = ADDRESS_CAPABILITY.BEARERMODES;
pub const AC_MAXACTIVECALLS = ADDRESS_CAPABILITY.MAXACTIVECALLS;
pub const AC_MAXONHOLDCALLS = ADDRESS_CAPABILITY.MAXONHOLDCALLS;
pub const AC_MAXONHOLDPENDINGCALLS = ADDRESS_CAPABILITY.MAXONHOLDPENDINGCALLS;
pub const AC_MAXNUMCONFERENCE = ADDRESS_CAPABILITY.MAXNUMCONFERENCE;
pub const AC_MAXNUMTRANSCONF = ADDRESS_CAPABILITY.MAXNUMTRANSCONF;
pub const AC_MONITORDIGITSUPPORT = ADDRESS_CAPABILITY.MONITORDIGITSUPPORT;
pub const AC_GENERATEDIGITSUPPORT = ADDRESS_CAPABILITY.GENERATEDIGITSUPPORT;
pub const AC_GENERATETONEMODES = ADDRESS_CAPABILITY.GENERATETONEMODES;
pub const AC_GENERATETONEMAXNUMFREQ = ADDRESS_CAPABILITY.GENERATETONEMAXNUMFREQ;
pub const AC_MONITORTONEMAXNUMFREQ = ADDRESS_CAPABILITY.MONITORTONEMAXNUMFREQ;
pub const AC_MONITORTONEMAXNUMENTRIES = ADDRESS_CAPABILITY.MONITORTONEMAXNUMENTRIES;
pub const AC_DEVCAPFLAGS = ADDRESS_CAPABILITY.DEVCAPFLAGS;
pub const AC_ANSWERMODES = ADDRESS_CAPABILITY.ANSWERMODES;
pub const AC_LINEFEATURES = ADDRESS_CAPABILITY.LINEFEATURES;
pub const AC_SETTABLEDEVSTATUS = ADDRESS_CAPABILITY.SETTABLEDEVSTATUS;
pub const AC_PARKSUPPORT = ADDRESS_CAPABILITY.PARKSUPPORT;
pub const AC_CALLERIDSUPPORT = ADDRESS_CAPABILITY.CALLERIDSUPPORT;
pub const AC_CALLEDIDSUPPORT = ADDRESS_CAPABILITY.CALLEDIDSUPPORT;
pub const AC_CONNECTEDIDSUPPORT = ADDRESS_CAPABILITY.CONNECTEDIDSUPPORT;
pub const AC_REDIRECTIONIDSUPPORT = ADDRESS_CAPABILITY.REDIRECTIONIDSUPPORT;
pub const AC_REDIRECTINGIDSUPPORT = ADDRESS_CAPABILITY.REDIRECTINGIDSUPPORT;
pub const AC_ADDRESSCAPFLAGS = ADDRESS_CAPABILITY.ADDRESSCAPFLAGS;
pub const AC_CALLFEATURES1 = ADDRESS_CAPABILITY.CALLFEATURES1;
pub const AC_CALLFEATURES2 = ADDRESS_CAPABILITY.CALLFEATURES2;
pub const AC_REMOVEFROMCONFCAPS = ADDRESS_CAPABILITY.REMOVEFROMCONFCAPS;
pub const AC_REMOVEFROMCONFSTATE = ADDRESS_CAPABILITY.REMOVEFROMCONFSTATE;
pub const AC_TRANSFERMODES = ADDRESS_CAPABILITY.TRANSFERMODES;
pub const AC_ADDRESSFEATURES = ADDRESS_CAPABILITY.ADDRESSFEATURES;
pub const AC_PREDICTIVEAUTOTRANSFERSTATES = ADDRESS_CAPABILITY.PREDICTIVEAUTOTRANSFERSTATES;
pub const AC_MAXCALLDATASIZE = ADDRESS_CAPABILITY.MAXCALLDATASIZE;
pub const AC_LINEID = ADDRESS_CAPABILITY.LINEID;
pub const AC_ADDRESSID = ADDRESS_CAPABILITY.ADDRESSID;
pub const AC_FORWARDMODES = ADDRESS_CAPABILITY.FORWARDMODES;
pub const AC_MAXFORWARDENTRIES = ADDRESS_CAPABILITY.MAXFORWARDENTRIES;
pub const AC_MAXSPECIFICENTRIES = ADDRESS_CAPABILITY.MAXSPECIFICENTRIES;
pub const AC_MINFWDNUMRINGS = ADDRESS_CAPABILITY.MINFWDNUMRINGS;
pub const AC_MAXFWDNUMRINGS = ADDRESS_CAPABILITY.MAXFWDNUMRINGS;
pub const AC_MAXCALLCOMPLETIONS = ADDRESS_CAPABILITY.MAXCALLCOMPLETIONS;
pub const AC_CALLCOMPLETIONCONDITIONS = ADDRESS_CAPABILITY.CALLCOMPLETIONCONDITIONS;
pub const AC_CALLCOMPLETIONMODES = ADDRESS_CAPABILITY.CALLCOMPLETIONMODES;
pub const AC_PERMANENTDEVICEID = ADDRESS_CAPABILITY.PERMANENTDEVICEID;
pub const AC_GATHERDIGITSMINTIMEOUT = ADDRESS_CAPABILITY.GATHERDIGITSMINTIMEOUT;
pub const AC_GATHERDIGITSMAXTIMEOUT = ADDRESS_CAPABILITY.GATHERDIGITSMAXTIMEOUT;
pub const AC_GENERATEDIGITMINDURATION = ADDRESS_CAPABILITY.GENERATEDIGITMINDURATION;
pub const AC_GENERATEDIGITMAXDURATION = ADDRESS_CAPABILITY.GENERATEDIGITMAXDURATION;
pub const AC_GENERATEDIGITDEFAULTDURATION = ADDRESS_CAPABILITY.GENERATEDIGITDEFAULTDURATION;

pub const ADDRESS_CAPABILITY_STRING = enum(i32) {
    PROTOCOL = 0,
    ADDRESSDEVICESPECIFIC = 1,
    LINEDEVICESPECIFIC = 2,
    PROVIDERSPECIFIC = 3,
    SWITCHSPECIFIC = 4,
    PERMANENTDEVICEGUID = 5,
};
pub const ACS_PROTOCOL = ADDRESS_CAPABILITY_STRING.PROTOCOL;
pub const ACS_ADDRESSDEVICESPECIFIC = ADDRESS_CAPABILITY_STRING.ADDRESSDEVICESPECIFIC;
pub const ACS_LINEDEVICESPECIFIC = ADDRESS_CAPABILITY_STRING.LINEDEVICESPECIFIC;
pub const ACS_PROVIDERSPECIFIC = ADDRESS_CAPABILITY_STRING.PROVIDERSPECIFIC;
pub const ACS_SWITCHSPECIFIC = ADDRESS_CAPABILITY_STRING.SWITCHSPECIFIC;
pub const ACS_PERMANENTDEVICEGUID = ADDRESS_CAPABILITY_STRING.PERMANENTDEVICEGUID;

pub const FULLDUPLEX_SUPPORT = enum(i32) {
    SUPPORTED = 0,
    NOTSUPPORTED = 1,
    UNKNOWN = 2,
};
pub const FDS_SUPPORTED = FULLDUPLEX_SUPPORT.SUPPORTED;
pub const FDS_NOTSUPPORTED = FULLDUPLEX_SUPPORT.NOTSUPPORTED;
pub const FDS_UNKNOWN = FULLDUPLEX_SUPPORT.UNKNOWN;

pub const FINISH_MODE = enum(i32) {
    TRANSFER = 0,
    CONFERENCE = 1,
};
pub const FM_ASTRANSFER = FINISH_MODE.TRANSFER;
pub const FM_ASCONFERENCE = FINISH_MODE.CONFERENCE;

pub const PHONE_PRIVILEGE = enum(i32) {
    OWNER = 0,
    MONITOR = 1,
};
pub const PP_OWNER = PHONE_PRIVILEGE.OWNER;
pub const PP_MONITOR = PHONE_PRIVILEGE.MONITOR;

pub const PHONE_HOOK_SWITCH_DEVICE = enum(i32) {
    HANDSET = 1,
    SPEAKERPHONE = 2,
    HEADSET = 4,
};
pub const PHSD_HANDSET = PHONE_HOOK_SWITCH_DEVICE.HANDSET;
pub const PHSD_SPEAKERPHONE = PHONE_HOOK_SWITCH_DEVICE.SPEAKERPHONE;
pub const PHSD_HEADSET = PHONE_HOOK_SWITCH_DEVICE.HEADSET;

pub const PHONE_HOOK_SWITCH_STATE = enum(i32) {
    NHOOK = 1,
    FFHOOK_MIC_ONLY = 2,
    FFHOOK_SPEAKER_ONLY = 4,
    FFHOOK = 8,
};
pub const PHSS_ONHOOK = PHONE_HOOK_SWITCH_STATE.NHOOK;
pub const PHSS_OFFHOOK_MIC_ONLY = PHONE_HOOK_SWITCH_STATE.FFHOOK_MIC_ONLY;
pub const PHSS_OFFHOOK_SPEAKER_ONLY = PHONE_HOOK_SWITCH_STATE.FFHOOK_SPEAKER_ONLY;
pub const PHSS_OFFHOOK = PHONE_HOOK_SWITCH_STATE.FFHOOK;

pub const PHONE_LAMP_MODE = enum(i32) {
    DUMMY = 1,
    OFF = 2,
    STEADY = 4,
    WINK = 8,
    FLASH = 16,
    FLUTTER = 32,
    BROKENFLUTTER = 64,
    UNKNOWN = 128,
};
pub const LM_DUMMY = PHONE_LAMP_MODE.DUMMY;
pub const LM_OFF = PHONE_LAMP_MODE.OFF;
pub const LM_STEADY = PHONE_LAMP_MODE.STEADY;
pub const LM_WINK = PHONE_LAMP_MODE.WINK;
pub const LM_FLASH = PHONE_LAMP_MODE.FLASH;
pub const LM_FLUTTER = PHONE_LAMP_MODE.FLUTTER;
pub const LM_BROKENFLUTTER = PHONE_LAMP_MODE.BROKENFLUTTER;
pub const LM_UNKNOWN = PHONE_LAMP_MODE.UNKNOWN;

pub const PHONECAPS_LONG = enum(i32) {
    HOOKSWITCHES = 0,
    HANDSETHOOKSWITCHMODES = 1,
    HEADSETHOOKSWITCHMODES = 2,
    SPEAKERPHONEHOOKSWITCHMODES = 3,
    DISPLAYNUMROWS = 4,
    DISPLAYNUMCOLUMNS = 5,
    NUMRINGMODES = 6,
    NUMBUTTONLAMPS = 7,
    GENERICPHONE = 8,
};
pub const PCL_HOOKSWITCHES = PHONECAPS_LONG.HOOKSWITCHES;
pub const PCL_HANDSETHOOKSWITCHMODES = PHONECAPS_LONG.HANDSETHOOKSWITCHMODES;
pub const PCL_HEADSETHOOKSWITCHMODES = PHONECAPS_LONG.HEADSETHOOKSWITCHMODES;
pub const PCL_SPEAKERPHONEHOOKSWITCHMODES = PHONECAPS_LONG.SPEAKERPHONEHOOKSWITCHMODES;
pub const PCL_DISPLAYNUMROWS = PHONECAPS_LONG.DISPLAYNUMROWS;
pub const PCL_DISPLAYNUMCOLUMNS = PHONECAPS_LONG.DISPLAYNUMCOLUMNS;
pub const PCL_NUMRINGMODES = PHONECAPS_LONG.NUMRINGMODES;
pub const PCL_NUMBUTTONLAMPS = PHONECAPS_LONG.NUMBUTTONLAMPS;
pub const PCL_GENERICPHONE = PHONECAPS_LONG.GENERICPHONE;

pub const PHONECAPS_STRING = enum(i32) {
    HONENAME = 0,
    HONEINFO = 1,
    ROVIDERINFO = 2,
};
pub const PCS_PHONENAME = PHONECAPS_STRING.HONENAME;
pub const PCS_PHONEINFO = PHONECAPS_STRING.HONEINFO;
pub const PCS_PROVIDERINFO = PHONECAPS_STRING.ROVIDERINFO;

pub const PHONECAPS_BUFFER = enum(i32) {
    R = 0,
};
pub const PCB_DEVSPECIFICBUFFER = PHONECAPS_BUFFER.R;

pub const PHONE_BUTTON_STATE = enum(i32) {
    UP = 1,
    DOWN = 2,
    UNKNOWN = 4,
    UNAVAIL = 8,
};
pub const PBS_UP = PHONE_BUTTON_STATE.UP;
pub const PBS_DOWN = PHONE_BUTTON_STATE.DOWN;
pub const PBS_UNKNOWN = PHONE_BUTTON_STATE.UNKNOWN;
pub const PBS_UNAVAIL = PHONE_BUTTON_STATE.UNAVAIL;

pub const PHONE_BUTTON_MODE = enum(i32) {
    DUMMY = 0,
    CALL = 1,
    FEATURE = 2,
    KEYPAD = 3,
    LOCAL = 4,
    DISPLAY = 5,
};
pub const PBM_DUMMY = PHONE_BUTTON_MODE.DUMMY;
pub const PBM_CALL = PHONE_BUTTON_MODE.CALL;
pub const PBM_FEATURE = PHONE_BUTTON_MODE.FEATURE;
pub const PBM_KEYPAD = PHONE_BUTTON_MODE.KEYPAD;
pub const PBM_LOCAL = PHONE_BUTTON_MODE.LOCAL;
pub const PBM_DISPLAY = PHONE_BUTTON_MODE.DISPLAY;

pub const PHONE_BUTTON_FUNCTION = enum(i32) {
    UNKNOWN = 0,
    CONFERENCE = 1,
    TRANSFER = 2,
    DROP = 3,
    HOLD = 4,
    RECALL = 5,
    DISCONNECT = 6,
    CONNECT = 7,
    MSGWAITON = 8,
    MSGWAITOFF = 9,
    SELECTRING = 10,
    ABBREVDIAL = 11,
    FORWARD = 12,
    PICKUP = 13,
    RINGAGAIN = 14,
    PARK = 15,
    REJECT = 16,
    REDIRECT = 17,
    MUTE = 18,
    VOLUMEUP = 19,
    VOLUMEDOWN = 20,
    SPEAKERON = 21,
    SPEAKEROFF = 22,
    FLASH = 23,
    DATAON = 24,
    DATAOFF = 25,
    DONOTDISTURB = 26,
    INTERCOM = 27,
    BRIDGEDAPP = 28,
    BUSY = 29,
    CALLAPP = 30,
    DATETIME = 31,
    DIRECTORY = 32,
    COVER = 33,
    CALLID = 34,
    LASTNUM = 35,
    NIGHTSRV = 36,
    SENDCALLS = 37,
    MSGINDICATOR = 38,
    REPDIAL = 39,
    SETREPDIAL = 40,
    SYSTEMSPEED = 41,
    STATIONSPEED = 42,
    CAMPON = 43,
    SAVEREPEAT = 44,
    QUEUECALL = 45,
    NONE = 46,
    SEND = 47,
};
pub const PBF_UNKNOWN = PHONE_BUTTON_FUNCTION.UNKNOWN;
pub const PBF_CONFERENCE = PHONE_BUTTON_FUNCTION.CONFERENCE;
pub const PBF_TRANSFER = PHONE_BUTTON_FUNCTION.TRANSFER;
pub const PBF_DROP = PHONE_BUTTON_FUNCTION.DROP;
pub const PBF_HOLD = PHONE_BUTTON_FUNCTION.HOLD;
pub const PBF_RECALL = PHONE_BUTTON_FUNCTION.RECALL;
pub const PBF_DISCONNECT = PHONE_BUTTON_FUNCTION.DISCONNECT;
pub const PBF_CONNECT = PHONE_BUTTON_FUNCTION.CONNECT;
pub const PBF_MSGWAITON = PHONE_BUTTON_FUNCTION.MSGWAITON;
pub const PBF_MSGWAITOFF = PHONE_BUTTON_FUNCTION.MSGWAITOFF;
pub const PBF_SELECTRING = PHONE_BUTTON_FUNCTION.SELECTRING;
pub const PBF_ABBREVDIAL = PHONE_BUTTON_FUNCTION.ABBREVDIAL;
pub const PBF_FORWARD = PHONE_BUTTON_FUNCTION.FORWARD;
pub const PBF_PICKUP = PHONE_BUTTON_FUNCTION.PICKUP;
pub const PBF_RINGAGAIN = PHONE_BUTTON_FUNCTION.RINGAGAIN;
pub const PBF_PARK = PHONE_BUTTON_FUNCTION.PARK;
pub const PBF_REJECT = PHONE_BUTTON_FUNCTION.REJECT;
pub const PBF_REDIRECT = PHONE_BUTTON_FUNCTION.REDIRECT;
pub const PBF_MUTE = PHONE_BUTTON_FUNCTION.MUTE;
pub const PBF_VOLUMEUP = PHONE_BUTTON_FUNCTION.VOLUMEUP;
pub const PBF_VOLUMEDOWN = PHONE_BUTTON_FUNCTION.VOLUMEDOWN;
pub const PBF_SPEAKERON = PHONE_BUTTON_FUNCTION.SPEAKERON;
pub const PBF_SPEAKEROFF = PHONE_BUTTON_FUNCTION.SPEAKEROFF;
pub const PBF_FLASH = PHONE_BUTTON_FUNCTION.FLASH;
pub const PBF_DATAON = PHONE_BUTTON_FUNCTION.DATAON;
pub const PBF_DATAOFF = PHONE_BUTTON_FUNCTION.DATAOFF;
pub const PBF_DONOTDISTURB = PHONE_BUTTON_FUNCTION.DONOTDISTURB;
pub const PBF_INTERCOM = PHONE_BUTTON_FUNCTION.INTERCOM;
pub const PBF_BRIDGEDAPP = PHONE_BUTTON_FUNCTION.BRIDGEDAPP;
pub const PBF_BUSY = PHONE_BUTTON_FUNCTION.BUSY;
pub const PBF_CALLAPP = PHONE_BUTTON_FUNCTION.CALLAPP;
pub const PBF_DATETIME = PHONE_BUTTON_FUNCTION.DATETIME;
pub const PBF_DIRECTORY = PHONE_BUTTON_FUNCTION.DIRECTORY;
pub const PBF_COVER = PHONE_BUTTON_FUNCTION.COVER;
pub const PBF_CALLID = PHONE_BUTTON_FUNCTION.CALLID;
pub const PBF_LASTNUM = PHONE_BUTTON_FUNCTION.LASTNUM;
pub const PBF_NIGHTSRV = PHONE_BUTTON_FUNCTION.NIGHTSRV;
pub const PBF_SENDCALLS = PHONE_BUTTON_FUNCTION.SENDCALLS;
pub const PBF_MSGINDICATOR = PHONE_BUTTON_FUNCTION.MSGINDICATOR;
pub const PBF_REPDIAL = PHONE_BUTTON_FUNCTION.REPDIAL;
pub const PBF_SETREPDIAL = PHONE_BUTTON_FUNCTION.SETREPDIAL;
pub const PBF_SYSTEMSPEED = PHONE_BUTTON_FUNCTION.SYSTEMSPEED;
pub const PBF_STATIONSPEED = PHONE_BUTTON_FUNCTION.STATIONSPEED;
pub const PBF_CAMPON = PHONE_BUTTON_FUNCTION.CAMPON;
pub const PBF_SAVEREPEAT = PHONE_BUTTON_FUNCTION.SAVEREPEAT;
pub const PBF_QUEUECALL = PHONE_BUTTON_FUNCTION.QUEUECALL;
pub const PBF_NONE = PHONE_BUTTON_FUNCTION.NONE;
pub const PBF_SEND = PHONE_BUTTON_FUNCTION.SEND;

pub const PHONE_TONE = enum(i32) {
    KEYPADZERO = 0,
    KEYPADONE = 1,
    KEYPADTWO = 2,
    KEYPADTHREE = 3,
    KEYPADFOUR = 4,
    KEYPADFIVE = 5,
    KEYPADSIX = 6,
    KEYPADSEVEN = 7,
    KEYPADEIGHT = 8,
    KEYPADNINE = 9,
    KEYPADSTAR = 10,
    KEYPADPOUND = 11,
    KEYPADA = 12,
    KEYPADB = 13,
    KEYPADC = 14,
    KEYPADD = 15,
    NORMALDIALTONE = 16,
    EXTERNALDIALTONE = 17,
    BUSY = 18,
    RINGBACK = 19,
    ERRORTONE = 20,
    SILENCE = 21,
};
pub const PT_KEYPADZERO = PHONE_TONE.KEYPADZERO;
pub const PT_KEYPADONE = PHONE_TONE.KEYPADONE;
pub const PT_KEYPADTWO = PHONE_TONE.KEYPADTWO;
pub const PT_KEYPADTHREE = PHONE_TONE.KEYPADTHREE;
pub const PT_KEYPADFOUR = PHONE_TONE.KEYPADFOUR;
pub const PT_KEYPADFIVE = PHONE_TONE.KEYPADFIVE;
pub const PT_KEYPADSIX = PHONE_TONE.KEYPADSIX;
pub const PT_KEYPADSEVEN = PHONE_TONE.KEYPADSEVEN;
pub const PT_KEYPADEIGHT = PHONE_TONE.KEYPADEIGHT;
pub const PT_KEYPADNINE = PHONE_TONE.KEYPADNINE;
pub const PT_KEYPADSTAR = PHONE_TONE.KEYPADSTAR;
pub const PT_KEYPADPOUND = PHONE_TONE.KEYPADPOUND;
pub const PT_KEYPADA = PHONE_TONE.KEYPADA;
pub const PT_KEYPADB = PHONE_TONE.KEYPADB;
pub const PT_KEYPADC = PHONE_TONE.KEYPADC;
pub const PT_KEYPADD = PHONE_TONE.KEYPADD;
pub const PT_NORMALDIALTONE = PHONE_TONE.NORMALDIALTONE;
pub const PT_EXTERNALDIALTONE = PHONE_TONE.EXTERNALDIALTONE;
pub const PT_BUSY = PHONE_TONE.BUSY;
pub const PT_RINGBACK = PHONE_TONE.RINGBACK;
pub const PT_ERRORTONE = PHONE_TONE.ERRORTONE;
pub const PT_SILENCE = PHONE_TONE.SILENCE;

pub const PHONE_EVENT = enum(i32) {
    DISPLAY = 0,
    LAMPMODE = 1,
    RINGMODE = 2,
    RINGVOLUME = 3,
    HOOKSWITCH = 4,
    CAPSCHANGE = 5,
    BUTTON = 6,
    CLOSE = 7,
    NUMBERGATHERED = 8,
    DIALING = 9,
    ANSWER = 10,
    DISCONNECT = 11,
    // LASTITEM = 11, this enum value conflicts with DISCONNECT
};
pub const PE_DISPLAY = PHONE_EVENT.DISPLAY;
pub const PE_LAMPMODE = PHONE_EVENT.LAMPMODE;
pub const PE_RINGMODE = PHONE_EVENT.RINGMODE;
pub const PE_RINGVOLUME = PHONE_EVENT.RINGVOLUME;
pub const PE_HOOKSWITCH = PHONE_EVENT.HOOKSWITCH;
pub const PE_CAPSCHANGE = PHONE_EVENT.CAPSCHANGE;
pub const PE_BUTTON = PHONE_EVENT.BUTTON;
pub const PE_CLOSE = PHONE_EVENT.CLOSE;
pub const PE_NUMBERGATHERED = PHONE_EVENT.NUMBERGATHERED;
pub const PE_DIALING = PHONE_EVENT.DIALING;
pub const PE_ANSWER = PHONE_EVENT.ANSWER;
pub const PE_DISCONNECT = PHONE_EVENT.DISCONNECT;
pub const PE_LASTITEM = PHONE_EVENT.DISCONNECT;

const IID_ITTAPI_Value = Guid.initString("b1efc382-9355-11d0-835c-00aa003ccabd");
pub const IID_ITTAPI = &IID_ITTAPI_Value;
pub const ITTAPI = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Addresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPI,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPI,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateAddresses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
                ppEnumAddress: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
                ppEnumAddress: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterCallNotifications: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
                pAddress: ?*ITAddress,
                fMonitor: i16,
                fOwner: i16,
                lMediaTypes: i32,
                lCallbackInstance: i32,
                plRegister: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
                pAddress: ?*ITAddress,
                fMonitor: i16,
                fOwner: i16,
                lMediaTypes: i32,
                lCallbackInstance: i32,
                plRegister: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterNotifications: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
                lRegister: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
                lRegister: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallHubs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPI,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPI,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateCallHubs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
                ppEnumCallHub: ?*?*IEnumCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
                ppEnumCallHub: ?*?*IEnumCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCallHubTracking: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
                pAddresses: VARIANT,
                bTracking: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
                pAddresses: VARIANT,
                bTracking: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumeratePrivateTAPIObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
                ppEnumUnknown: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
                ppEnumUnknown: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrivateTAPIObjects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPI,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPI,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterRequestRecipient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
                lRegistrationInstance: i32,
                lRequestMode: i32,
                fEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
                lRegistrationInstance: i32,
                lRequestMode: i32,
                fEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssistedTelephonyPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
                pAppFilename: ?BSTR,
                fPriority: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
                pAppFilename: ?BSTR,
                fPriority: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetApplicationPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI,
                pAppFilename: ?BSTR,
                lMediaType: i32,
                fPriority: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI,
                pAppFilename: ?BSTR,
                lMediaType: i32,
                fPriority: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPI,
                lFilterMask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPI,
                lFilterMask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPI,
                plFilterMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPI,
                plFilterMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_Initialize(self: *const T) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ITTAPI, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_Shutdown(self: *const T) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const ITTAPI, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_get_Addresses(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).get_Addresses(@as(*const ITTAPI, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_EnumerateAddresses(self: *const T, ppEnumAddress: ?*?*IEnumAddress) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).EnumerateAddresses(@as(*const ITTAPI, @ptrCast(self)), ppEnumAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_RegisterCallNotifications(self: *const T, pAddress: ?*ITAddress, fMonitor: i16, fOwner: i16, lMediaTypes: i32, lCallbackInstance: i32, plRegister: ?*i32) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).RegisterCallNotifications(@as(*const ITTAPI, @ptrCast(self)), pAddress, fMonitor, fOwner, lMediaTypes, lCallbackInstance, plRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_UnregisterNotifications(self: *const T, lRegister: i32) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).UnregisterNotifications(@as(*const ITTAPI, @ptrCast(self)), lRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_get_CallHubs(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).get_CallHubs(@as(*const ITTAPI, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_EnumerateCallHubs(self: *const T, ppEnumCallHub: ?*?*IEnumCallHub) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).EnumerateCallHubs(@as(*const ITTAPI, @ptrCast(self)), ppEnumCallHub);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_SetCallHubTracking(self: *const T, pAddresses: VARIANT, bTracking: i16) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).SetCallHubTracking(@as(*const ITTAPI, @ptrCast(self)), pAddresses, bTracking);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_EnumeratePrivateTAPIObjects(self: *const T, ppEnumUnknown: ?*?*IEnumUnknown) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).EnumeratePrivateTAPIObjects(@as(*const ITTAPI, @ptrCast(self)), ppEnumUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_get_PrivateTAPIObjects(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).get_PrivateTAPIObjects(@as(*const ITTAPI, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_RegisterRequestRecipient(self: *const T, lRegistrationInstance: i32, lRequestMode: i32, fEnable: i16) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).RegisterRequestRecipient(@as(*const ITTAPI, @ptrCast(self)), lRegistrationInstance, lRequestMode, fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_SetAssistedTelephonyPriority(self: *const T, pAppFilename: ?BSTR, fPriority: i16) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).SetAssistedTelephonyPriority(@as(*const ITTAPI, @ptrCast(self)), pAppFilename, fPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_SetApplicationPriority(self: *const T, pAppFilename: ?BSTR, lMediaType: i32, fPriority: i16) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).SetApplicationPriority(@as(*const ITTAPI, @ptrCast(self)), pAppFilename, lMediaType, fPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_put_EventFilter(self: *const T, lFilterMask: i32) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).put_EventFilter(@as(*const ITTAPI, @ptrCast(self)), lFilterMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI_get_EventFilter(self: *const T, plFilterMask: ?*i32) HRESULT {
                return @as(*const ITTAPI.VTable, @ptrCast(self.vtable)).get_EventFilter(@as(*const ITTAPI, @ptrCast(self)), plFilterMask);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTAPI2_Value = Guid.initString("54fbdc8c-d90f-4dad-9695-b373097f094b");
pub const IID_ITTAPI2 = &IID_ITTAPI2_Value;
pub const ITTAPI2 = extern struct {
    pub const VTable = extern struct {
        base: ITTAPI.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Phones: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPI2,
                pPhones: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPI2,
                pPhones: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumeratePhones: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI2,
                ppEnumPhone: ?*?*IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI2,
                ppEnumPhone: ?*?*IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateEmptyCollectionObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPI2,
                ppCollection: ?*?*ITCollection2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPI2,
                ppCollection: ?*?*ITCollection2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITTAPI.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI2_get_Phones(self: *const T, pPhones: ?*VARIANT) HRESULT {
                return @as(*const ITTAPI2.VTable, @ptrCast(self.vtable)).get_Phones(@as(*const ITTAPI2, @ptrCast(self)), pPhones);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI2_EnumeratePhones(self: *const T, ppEnumPhone: ?*?*IEnumPhone) HRESULT {
                return @as(*const ITTAPI2.VTable, @ptrCast(self.vtable)).EnumeratePhones(@as(*const ITTAPI2, @ptrCast(self)), ppEnumPhone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPI2_CreateEmptyCollectionObject(self: *const T, ppCollection: ?*?*ITCollection2) HRESULT {
                return @as(*const ITTAPI2.VTable, @ptrCast(self.vtable)).CreateEmptyCollectionObject(@as(*const ITTAPI2, @ptrCast(self)), ppCollection);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITMediaSupport_Value = Guid.initString("b1efc384-9355-11d0-835c-00aa003ccabd");
pub const IID_ITMediaSupport = &IID_ITMediaSupport_Value;
pub const ITMediaSupport = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITMediaSupport,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITMediaSupport,
                plMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMediaSupport,
                lMediaType: i32,
                pfSupport: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMediaSupport,
                lMediaType: i32,
                pfSupport: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaSupport_get_MediaTypes(self: *const T, plMediaTypes: ?*i32) HRESULT {
                return @as(*const ITMediaSupport.VTable, @ptrCast(self.vtable)).get_MediaTypes(@as(*const ITMediaSupport, @ptrCast(self)), plMediaTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaSupport_QueryMediaType(self: *const T, lMediaType: i32, pfSupport: ?*i16) HRESULT {
                return @as(*const ITMediaSupport.VTable, @ptrCast(self.vtable)).QueryMediaType(@as(*const ITMediaSupport, @ptrCast(self)), lMediaType, pfSupport);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITPluggableTerminalClassInfo_Value = Guid.initString("41757f4a-cf09-4b34-bc96-0a79d2390076");
pub const IID_ITPluggableTerminalClassInfo = &IID_ITPluggableTerminalClassInfo_Value;
pub const ITPluggableTerminalClassInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPluggableTerminalClassInfo,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPluggableTerminalClassInfo,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Company: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPluggableTerminalClassInfo,
                pCompany: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPluggableTerminalClassInfo,
                pCompany: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPluggableTerminalClassInfo,
                pVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPluggableTerminalClassInfo,
                pVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TerminalClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPluggableTerminalClassInfo,
                pTerminalClass: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPluggableTerminalClassInfo,
                pTerminalClass: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CLSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPluggableTerminalClassInfo,
                pCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPluggableTerminalClassInfo,
                pCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Direction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPluggableTerminalClassInfo,
                pDirection: ?*TERMINAL_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPluggableTerminalClassInfo,
                pDirection: ?*TERMINAL_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPluggableTerminalClassInfo,
                pMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPluggableTerminalClassInfo,
                pMediaTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalClassInfo_get_Name(self: *const T, pName: ?*?BSTR) HRESULT {
                return @as(*const ITPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ITPluggableTerminalClassInfo, @ptrCast(self)), pName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalClassInfo_get_Company(self: *const T, pCompany: ?*?BSTR) HRESULT {
                return @as(*const ITPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).get_Company(@as(*const ITPluggableTerminalClassInfo, @ptrCast(self)), pCompany);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalClassInfo_get_Version(self: *const T, pVersion: ?*?BSTR) HRESULT {
                return @as(*const ITPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).get_Version(@as(*const ITPluggableTerminalClassInfo, @ptrCast(self)), pVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalClassInfo_get_TerminalClass(self: *const T, pTerminalClass: ?*?BSTR) HRESULT {
                return @as(*const ITPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).get_TerminalClass(@as(*const ITPluggableTerminalClassInfo, @ptrCast(self)), pTerminalClass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalClassInfo_get_CLSID(self: *const T, pCLSID: ?*?BSTR) HRESULT {
                return @as(*const ITPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).get_CLSID(@as(*const ITPluggableTerminalClassInfo, @ptrCast(self)), pCLSID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalClassInfo_get_Direction(self: *const T, pDirection: ?*TERMINAL_DIRECTION) HRESULT {
                return @as(*const ITPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).get_Direction(@as(*const ITPluggableTerminalClassInfo, @ptrCast(self)), pDirection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalClassInfo_get_MediaTypes(self: *const T, pMediaTypes: ?*i32) HRESULT {
                return @as(*const ITPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).get_MediaTypes(@as(*const ITPluggableTerminalClassInfo, @ptrCast(self)), pMediaTypes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITPluggableTerminalSuperclassInfo_Value = Guid.initString("6d54e42c-4625-4359-a6f7-631999107e05");
pub const IID_ITPluggableTerminalSuperclassInfo = &IID_ITPluggableTerminalSuperclassInfo_Value;
pub const ITPluggableTerminalSuperclassInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPluggableTerminalSuperclassInfo,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPluggableTerminalSuperclassInfo,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CLSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPluggableTerminalSuperclassInfo,
                pCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPluggableTerminalSuperclassInfo,
                pCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalSuperclassInfo_get_Name(self: *const T, pName: ?*?BSTR) HRESULT {
                return @as(*const ITPluggableTerminalSuperclassInfo.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ITPluggableTerminalSuperclassInfo, @ptrCast(self)), pName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalSuperclassInfo_get_CLSID(self: *const T, pCLSID: ?*?BSTR) HRESULT {
                return @as(*const ITPluggableTerminalSuperclassInfo.VTable, @ptrCast(self.vtable)).get_CLSID(@as(*const ITPluggableTerminalSuperclassInfo, @ptrCast(self)), pCLSID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTerminalSupport_Value = Guid.initString("b1efc385-9355-11d0-835c-00aa003ccabd");
pub const IID_ITTerminalSupport = &IID_ITTerminalSupport_Value;
pub const ITTerminalSupport = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StaticTerminals: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminalSupport,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminalSupport,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateStaticTerminals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTerminalSupport,
                ppTerminalEnumerator: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTerminalSupport,
                ppTerminalEnumerator: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DynamicTerminalClasses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminalSupport,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminalSupport,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateDynamicTerminalClasses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTerminalSupport,
                ppTerminalClassEnumerator: ?*?*IEnumTerminalClass,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTerminalSupport,
                ppTerminalClassEnumerator: ?*?*IEnumTerminalClass,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTerminalSupport,
                pTerminalClass: ?BSTR,
                lMediaType: i32,
                Direction: TERMINAL_DIRECTION,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTerminalSupport,
                pTerminalClass: ?BSTR,
                lMediaType: i32,
                Direction: TERMINAL_DIRECTION,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultStaticTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTerminalSupport,
                lMediaType: i32,
                Direction: TERMINAL_DIRECTION,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTerminalSupport,
                lMediaType: i32,
                Direction: TERMINAL_DIRECTION,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport_get_StaticTerminals(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITTerminalSupport.VTable, @ptrCast(self.vtable)).get_StaticTerminals(@as(*const ITTerminalSupport, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport_EnumerateStaticTerminals(self: *const T, ppTerminalEnumerator: ?*?*IEnumTerminal) HRESULT {
                return @as(*const ITTerminalSupport.VTable, @ptrCast(self.vtable)).EnumerateStaticTerminals(@as(*const ITTerminalSupport, @ptrCast(self)), ppTerminalEnumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport_get_DynamicTerminalClasses(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITTerminalSupport.VTable, @ptrCast(self.vtable)).get_DynamicTerminalClasses(@as(*const ITTerminalSupport, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport_EnumerateDynamicTerminalClasses(self: *const T, ppTerminalClassEnumerator: ?*?*IEnumTerminalClass) HRESULT {
                return @as(*const ITTerminalSupport.VTable, @ptrCast(self.vtable)).EnumerateDynamicTerminalClasses(@as(*const ITTerminalSupport, @ptrCast(self)), ppTerminalClassEnumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport_CreateTerminal(self: *const T, pTerminalClass: ?BSTR, lMediaType: i32, Direction: TERMINAL_DIRECTION, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITTerminalSupport.VTable, @ptrCast(self.vtable)).CreateTerminal(@as(*const ITTerminalSupport, @ptrCast(self)), pTerminalClass, lMediaType, Direction, ppTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport_GetDefaultStaticTerminal(self: *const T, lMediaType: i32, Direction: TERMINAL_DIRECTION, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITTerminalSupport.VTable, @ptrCast(self.vtable)).GetDefaultStaticTerminal(@as(*const ITTerminalSupport, @ptrCast(self)), lMediaType, Direction, ppTerminal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTerminalSupport2_Value = Guid.initString("f3eb39bc-1b1f-4e99-a0c0-56305c4dd591");
pub const IID_ITTerminalSupport2 = &IID_ITTerminalSupport2_Value;
pub const ITTerminalSupport2 = extern struct {
    pub const VTable = extern struct {
        base: ITTerminalSupport.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PluggableSuperclasses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminalSupport2,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminalSupport2,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumeratePluggableSuperclasses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTerminalSupport2,
                ppSuperclassEnumerator: ?*?*IEnumPluggableSuperclassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTerminalSupport2,
                ppSuperclassEnumerator: ?*?*IEnumPluggableSuperclassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PluggableTerminalClasses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminalSupport2,
                bstrTerminalSuperclass: ?BSTR,
                lMediaType: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminalSupport2,
                bstrTerminalSuperclass: ?BSTR,
                lMediaType: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumeratePluggableTerminalClasses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTerminalSupport2,
                iidTerminalSuperclass: Guid,
                lMediaType: i32,
                ppClassEnumerator: ?*?*IEnumPluggableTerminalClassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTerminalSupport2,
                iidTerminalSuperclass: Guid,
                lMediaType: i32,
                ppClassEnumerator: ?*?*IEnumPluggableTerminalClassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITTerminalSupport.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport2_get_PluggableSuperclasses(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITTerminalSupport2.VTable, @ptrCast(self.vtable)).get_PluggableSuperclasses(@as(*const ITTerminalSupport2, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport2_EnumeratePluggableSuperclasses(self: *const T, ppSuperclassEnumerator: ?*?*IEnumPluggableSuperclassInfo) HRESULT {
                return @as(*const ITTerminalSupport2.VTable, @ptrCast(self.vtable)).EnumeratePluggableSuperclasses(@as(*const ITTerminalSupport2, @ptrCast(self)), ppSuperclassEnumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport2_get_PluggableTerminalClasses(self: *const T, bstrTerminalSuperclass: ?BSTR, lMediaType: i32, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITTerminalSupport2.VTable, @ptrCast(self.vtable)).get_PluggableTerminalClasses(@as(*const ITTerminalSupport2, @ptrCast(self)), bstrTerminalSuperclass, lMediaType, pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminalSupport2_EnumeratePluggableTerminalClasses(self: *const T, iidTerminalSuperclass: Guid, lMediaType: i32, ppClassEnumerator: ?*?*IEnumPluggableTerminalClassInfo) HRESULT {
                return @as(*const ITTerminalSupport2.VTable, @ptrCast(self.vtable)).EnumeratePluggableTerminalClasses(@as(*const ITTerminalSupport2, @ptrCast(self)), iidTerminalSuperclass, lMediaType, ppClassEnumerator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAddress_Value = Guid.initString("b1efc386-9355-11d0-835c-00aa003ccabd");
pub const IID_ITAddress = &IID_ITAddress_Value;
pub const ITAddress = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                pAddressState: ?*ADDRESS_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                pAddressState: ?*ADDRESS_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AddressName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceProviderName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TAPIObject: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                ppTapiObject: ?*?*ITTAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                ppTapiObject: ?*?*ITTAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress,
                pDestAddress: ?BSTR,
                lAddressType: i32,
                lMediaTypes: i32,
                ppCall: ?*?*ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress,
                pDestAddress: ?BSTR,
                lAddressType: i32,
                lMediaTypes: i32,
                ppCall: ?*?*ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Calls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateCalls: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress,
                ppCallEnum: ?*?*IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress,
                ppCallEnum: ?*?*IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DialableAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                pDialableAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                pDialableAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateForwardInfoObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress,
                ppForwardInfo: ?*?*ITForwardInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress,
                ppForwardInfo: ?*?*ITForwardInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Forward: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress,
                pForwardInfo: ?*ITForwardInformation,
                pCall: ?*ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress,
                pForwardInfo: ?*ITForwardInformation,
                pCall: ?*ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentForwardInfo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                ppForwardInfo: ?*?*ITForwardInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                ppForwardInfo: ?*?*ITForwardInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MessageWaiting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                fMessageWaiting: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                fMessageWaiting: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MessageWaiting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                pfMessageWaiting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                pfMessageWaiting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DoNotDisturb: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                fDoNotDisturb: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                fDoNotDisturb: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DoNotDisturb: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress,
                pfDoNotDisturb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress,
                pfDoNotDisturb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_get_State(self: *const T, pAddressState: ?*ADDRESS_STATE) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).get_State(@as(*const ITAddress, @ptrCast(self)), pAddressState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_get_AddressName(self: *const T, ppName: ?*?BSTR) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).get_AddressName(@as(*const ITAddress, @ptrCast(self)), ppName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_get_ServiceProviderName(self: *const T, ppName: ?*?BSTR) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).get_ServiceProviderName(@as(*const ITAddress, @ptrCast(self)), ppName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_get_TAPIObject(self: *const T, ppTapiObject: ?*?*ITTAPI) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).get_TAPIObject(@as(*const ITAddress, @ptrCast(self)), ppTapiObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_CreateCall(self: *const T, pDestAddress: ?BSTR, lAddressType: i32, lMediaTypes: i32, ppCall: ?*?*ITBasicCallControl) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).CreateCall(@as(*const ITAddress, @ptrCast(self)), pDestAddress, lAddressType, lMediaTypes, ppCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_get_Calls(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).get_Calls(@as(*const ITAddress, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_EnumerateCalls(self: *const T, ppCallEnum: ?*?*IEnumCall) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).EnumerateCalls(@as(*const ITAddress, @ptrCast(self)), ppCallEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_get_DialableAddress(self: *const T, pDialableAddress: ?*?BSTR) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).get_DialableAddress(@as(*const ITAddress, @ptrCast(self)), pDialableAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_CreateForwardInfoObject(self: *const T, ppForwardInfo: ?*?*ITForwardInformation) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).CreateForwardInfoObject(@as(*const ITAddress, @ptrCast(self)), ppForwardInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_Forward(self: *const T, pForwardInfo: ?*ITForwardInformation, pCall: ?*ITBasicCallControl) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).Forward(@as(*const ITAddress, @ptrCast(self)), pForwardInfo, pCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_get_CurrentForwardInfo(self: *const T, ppForwardInfo: ?*?*ITForwardInformation) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).get_CurrentForwardInfo(@as(*const ITAddress, @ptrCast(self)), ppForwardInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_put_MessageWaiting(self: *const T, fMessageWaiting: i16) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).put_MessageWaiting(@as(*const ITAddress, @ptrCast(self)), fMessageWaiting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_get_MessageWaiting(self: *const T, pfMessageWaiting: ?*i16) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).get_MessageWaiting(@as(*const ITAddress, @ptrCast(self)), pfMessageWaiting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_put_DoNotDisturb(self: *const T, fDoNotDisturb: i16) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).put_DoNotDisturb(@as(*const ITAddress, @ptrCast(self)), fDoNotDisturb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress_get_DoNotDisturb(self: *const T, pfDoNotDisturb: ?*i16) HRESULT {
                return @as(*const ITAddress.VTable, @ptrCast(self.vtable)).get_DoNotDisturb(@as(*const ITAddress, @ptrCast(self)), pfDoNotDisturb);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAddress2_Value = Guid.initString("b0ae5d9b-be51-46c9-b0f7-dfa8a22a8bc4");
pub const IID_ITAddress2 = &IID_ITAddress2_Value;
pub const ITAddress2 = extern struct {
    pub const VTable = extern struct {
        base: ITAddress.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Phones: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress2,
                pPhones: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress2,
                pPhones: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumeratePhones: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress2,
                ppEnumPhone: ?*?*IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress2,
                ppEnumPhone: ?*?*IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPhoneFromTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress2,
                pTerminal: ?*ITTerminal,
                ppPhone: ?*?*ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress2,
                pTerminal: ?*ITTerminal,
                ppPhone: ?*?*ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredPhones: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress2,
                pPhones: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress2,
                pPhones: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumeratePreferredPhones: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress2,
                ppEnumPhone: ?*?*IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress2,
                ppEnumPhone: ?*?*IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress2,
                TapiEvent: TAPI_EVENT,
                lSubEvent: i32,
                pEnable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress2,
                TapiEvent: TAPI_EVENT,
                lSubEvent: i32,
                pEnable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddress2,
                TapiEvent: TAPI_EVENT,
                lSubEvent: i32,
                bEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddress2,
                TapiEvent: TAPI_EVENT,
                lSubEvent: i32,
                bEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeviceSpecific: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress2,
                pCall: ?*ITCallInfo,
                pParams: ?*u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress2,
                pCall: ?*ITCallInfo,
                pParams: ?*u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeviceSpecificVariant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress2,
                pCall: ?*ITCallInfo,
                varDevSpecificByteArray: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress2,
                pCall: ?*ITCallInfo,
                varDevSpecificByteArray: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NegotiateExtVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddress2,
                lLowVersion: i32,
                lHighVersion: i32,
                plExtVersion: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddress2,
                lLowVersion: i32,
                lHighVersion: i32,
                plExtVersion: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITAddress.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_get_Phones(self: *const T, pPhones: ?*VARIANT) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).get_Phones(@as(*const ITAddress2, @ptrCast(self)), pPhones);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_EnumeratePhones(self: *const T, ppEnumPhone: ?*?*IEnumPhone) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).EnumeratePhones(@as(*const ITAddress2, @ptrCast(self)), ppEnumPhone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_GetPhoneFromTerminal(self: *const T, pTerminal: ?*ITTerminal, ppPhone: ?*?*ITPhone) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).GetPhoneFromTerminal(@as(*const ITAddress2, @ptrCast(self)), pTerminal, ppPhone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_get_PreferredPhones(self: *const T, pPhones: ?*VARIANT) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).get_PreferredPhones(@as(*const ITAddress2, @ptrCast(self)), pPhones);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_EnumeratePreferredPhones(self: *const T, ppEnumPhone: ?*?*IEnumPhone) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).EnumeratePreferredPhones(@as(*const ITAddress2, @ptrCast(self)), ppEnumPhone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_get_EventFilter(self: *const T, TapiEvent: TAPI_EVENT, lSubEvent: i32, pEnable: ?*i16) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).get_EventFilter(@as(*const ITAddress2, @ptrCast(self)), TapiEvent, lSubEvent, pEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_put_EventFilter(self: *const T, TapiEvent: TAPI_EVENT, lSubEvent: i32, bEnable: i16) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).put_EventFilter(@as(*const ITAddress2, @ptrCast(self)), TapiEvent, lSubEvent, bEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_DeviceSpecific(self: *const T, pCall: ?*ITCallInfo, pParams: ?*u8, dwSize: u32) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).DeviceSpecific(@as(*const ITAddress2, @ptrCast(self)), pCall, pParams, dwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_DeviceSpecificVariant(self: *const T, pCall: ?*ITCallInfo, varDevSpecificByteArray: VARIANT) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).DeviceSpecificVariant(@as(*const ITAddress2, @ptrCast(self)), pCall, varDevSpecificByteArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddress2_NegotiateExtVersion(self: *const T, lLowVersion: i32, lHighVersion: i32, plExtVersion: ?*i32) HRESULT {
                return @as(*const ITAddress2.VTable, @ptrCast(self.vtable)).NegotiateExtVersion(@as(*const ITAddress2, @ptrCast(self)), lLowVersion, lHighVersion, plExtVersion);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAddressCapabilities_Value = Guid.initString("8df232f5-821b-11d1-bb5c-00c04fb6809f");
pub const IID_ITAddressCapabilities = &IID_ITAddressCapabilities_Value;
pub const ITAddressCapabilities = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AddressCapability: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressCapabilities,
                AddressCap: ADDRESS_CAPABILITY,
                plCapability: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressCapabilities,
                AddressCap: ADDRESS_CAPABILITY,
                plCapability: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AddressCapabilityString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressCapabilities,
                AddressCapString: ADDRESS_CAPABILITY_STRING,
                ppCapabilityString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressCapabilities,
                AddressCapString: ADDRESS_CAPABILITY_STRING,
                ppCapabilityString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallTreatments: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressCapabilities,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressCapabilities,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateCallTreatments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddressCapabilities,
                ppEnumCallTreatment: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddressCapabilities,
                ppEnumCallTreatment: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CompletionMessages: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressCapabilities,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressCapabilities,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateCompletionMessages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddressCapabilities,
                ppEnumCompletionMessage: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddressCapabilities,
                ppEnumCompletionMessage: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceClasses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressCapabilities,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressCapabilities,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateDeviceClasses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddressCapabilities,
                ppEnumDeviceClass: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddressCapabilities,
                ppEnumDeviceClass: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressCapabilities_get_AddressCapability(self: *const T, AddressCap: ADDRESS_CAPABILITY, plCapability: ?*i32) HRESULT {
                return @as(*const ITAddressCapabilities.VTable, @ptrCast(self.vtable)).get_AddressCapability(@as(*const ITAddressCapabilities, @ptrCast(self)), AddressCap, plCapability);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressCapabilities_get_AddressCapabilityString(self: *const T, AddressCapString: ADDRESS_CAPABILITY_STRING, ppCapabilityString: ?*?BSTR) HRESULT {
                return @as(*const ITAddressCapabilities.VTable, @ptrCast(self.vtable)).get_AddressCapabilityString(@as(*const ITAddressCapabilities, @ptrCast(self)), AddressCapString, ppCapabilityString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressCapabilities_get_CallTreatments(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAddressCapabilities.VTable, @ptrCast(self.vtable)).get_CallTreatments(@as(*const ITAddressCapabilities, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressCapabilities_EnumerateCallTreatments(self: *const T, ppEnumCallTreatment: ?*?*IEnumBstr) HRESULT {
                return @as(*const ITAddressCapabilities.VTable, @ptrCast(self.vtable)).EnumerateCallTreatments(@as(*const ITAddressCapabilities, @ptrCast(self)), ppEnumCallTreatment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressCapabilities_get_CompletionMessages(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAddressCapabilities.VTable, @ptrCast(self.vtable)).get_CompletionMessages(@as(*const ITAddressCapabilities, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressCapabilities_EnumerateCompletionMessages(self: *const T, ppEnumCompletionMessage: ?*?*IEnumBstr) HRESULT {
                return @as(*const ITAddressCapabilities.VTable, @ptrCast(self.vtable)).EnumerateCompletionMessages(@as(*const ITAddressCapabilities, @ptrCast(self)), ppEnumCompletionMessage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressCapabilities_get_DeviceClasses(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAddressCapabilities.VTable, @ptrCast(self.vtable)).get_DeviceClasses(@as(*const ITAddressCapabilities, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressCapabilities_EnumerateDeviceClasses(self: *const T, ppEnumDeviceClass: ?*?*IEnumBstr) HRESULT {
                return @as(*const ITAddressCapabilities.VTable, @ptrCast(self.vtable)).EnumerateDeviceClasses(@as(*const ITAddressCapabilities, @ptrCast(self)), ppEnumDeviceClass);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITPhone_Value = Guid.initString("09d48db4-10cc-4388-9de7-a8465618975a");
pub const IID_ITPhone = &IID_ITPhone_Value;
pub const ITPhone = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
                Privilege: PHONE_PRIVILEGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
                Privilege: PHONE_PRIVILEGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Addresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                pAddresses: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                pAddresses: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateAddresses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
                ppEnumAddress: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
                ppEnumAddress: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhoneCapsLong: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                pclCap: PHONECAPS_LONG,
                plCapability: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                pclCap: PHONECAPS_LONG,
                plCapability: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhoneCapsString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                pcsCap: PHONECAPS_STRING,
                ppCapability: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                pcsCap: PHONECAPS_STRING,
                ppCapability: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Terminals: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                pAddress: ?*ITAddress,
                pTerminals: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                pAddress: ?*ITAddress,
                pTerminals: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateTerminals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
                pAddress: ?*ITAddress,
                ppEnumTerminal: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
                pAddress: ?*ITAddress,
                ppEnumTerminal: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lButtonID: i32,
                pButtonMode: ?*PHONE_BUTTON_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lButtonID: i32,
                pButtonMode: ?*PHONE_BUTTON_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ButtonMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lButtonID: i32,
                ButtonMode: PHONE_BUTTON_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lButtonID: i32,
                ButtonMode: PHONE_BUTTON_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonFunction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lButtonID: i32,
                pButtonFunction: ?*PHONE_BUTTON_FUNCTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lButtonID: i32,
                pButtonFunction: ?*PHONE_BUTTON_FUNCTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ButtonFunction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lButtonID: i32,
                ButtonFunction: PHONE_BUTTON_FUNCTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lButtonID: i32,
                ButtonFunction: PHONE_BUTTON_FUNCTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lButtonID: i32,
                ppButtonText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lButtonID: i32,
                ppButtonText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ButtonText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lButtonID: i32,
                bstrButtonText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lButtonID: i32,
                bstrButtonText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lButtonID: i32,
                pButtonState: ?*PHONE_BUTTON_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lButtonID: i32,
                pButtonState: ?*PHONE_BUTTON_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HookSwitchState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                HookSwitchDevice: PHONE_HOOK_SWITCH_DEVICE,
                pHookSwitchState: ?*PHONE_HOOK_SWITCH_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                HookSwitchDevice: PHONE_HOOK_SWITCH_DEVICE,
                pHookSwitchState: ?*PHONE_HOOK_SWITCH_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HookSwitchState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                HookSwitchDevice: PHONE_HOOK_SWITCH_DEVICE,
                HookSwitchState: PHONE_HOOK_SWITCH_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                HookSwitchDevice: PHONE_HOOK_SWITCH_DEVICE,
                HookSwitchState: PHONE_HOOK_SWITCH_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RingMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lRingMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lRingMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RingMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                plRingMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                plRingMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RingVolume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lRingVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lRingVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RingVolume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                plRingVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                plRingVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Privilege: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                pPrivilege: ?*PHONE_PRIVILEGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                pPrivilege: ?*PHONE_PRIVILEGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPhoneCapsBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
                pcbCaps: PHONECAPS_BUFFER,
                pdwSize: ?*u32,
                ppPhoneCapsBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
                pcbCaps: PHONECAPS_BUFFER,
                pdwSize: ?*u32,
                ppPhoneCapsBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhoneCapsBuffer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                pcbCaps: PHONECAPS_BUFFER,
                pVarBuffer: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                pcbCaps: PHONECAPS_BUFFER,
                pVarBuffer: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LampMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lLampID: i32,
                pLampMode: ?*PHONE_LAMP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lLampID: i32,
                pLampMode: ?*PHONE_LAMP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LampMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                lLampID: i32,
                LampMode: PHONE_LAMP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                lLampID: i32,
                LampMode: PHONE_LAMP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Display: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                pbstrDisplay: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                pbstrDisplay: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDisplay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
                lRow: i32,
                lColumn: i32,
                bstrDisplay: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
                lRow: i32,
                lColumn: i32,
                bstrDisplay: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhone,
                pAddresses: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhone,
                pAddresses: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumeratePreferredAddresses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
                ppEnumAddress: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
                ppEnumAddress: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeviceSpecific: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
                pParams: ?*u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
                pParams: ?*u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeviceSpecificVariant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
                varDevSpecificByteArray: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
                varDevSpecificByteArray: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NegotiateExtVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPhone,
                lLowVersion: i32,
                lHighVersion: i32,
                plExtVersion: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPhone,
                lLowVersion: i32,
                lHighVersion: i32,
                plExtVersion: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_Open(self: *const T, Privilege: PHONE_PRIVILEGE) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).Open(@as(*const ITPhone, @ptrCast(self)), Privilege);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_Close(self: *const T) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).Close(@as(*const ITPhone, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_Addresses(self: *const T, pAddresses: ?*VARIANT) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_Addresses(@as(*const ITPhone, @ptrCast(self)), pAddresses);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_EnumerateAddresses(self: *const T, ppEnumAddress: ?*?*IEnumAddress) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).EnumerateAddresses(@as(*const ITPhone, @ptrCast(self)), ppEnumAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_PhoneCapsLong(self: *const T, pclCap: PHONECAPS_LONG, plCapability: ?*i32) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_PhoneCapsLong(@as(*const ITPhone, @ptrCast(self)), pclCap, plCapability);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_PhoneCapsString(self: *const T, pcsCap: PHONECAPS_STRING, ppCapability: ?*?BSTR) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_PhoneCapsString(@as(*const ITPhone, @ptrCast(self)), pcsCap, ppCapability);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_Terminals(self: *const T, pAddress: ?*ITAddress, pTerminals: ?*VARIANT) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_Terminals(@as(*const ITPhone, @ptrCast(self)), pAddress, pTerminals);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_EnumerateTerminals(self: *const T, pAddress: ?*ITAddress, ppEnumTerminal: ?*?*IEnumTerminal) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).EnumerateTerminals(@as(*const ITPhone, @ptrCast(self)), pAddress, ppEnumTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_ButtonMode(self: *const T, lButtonID: i32, pButtonMode: ?*PHONE_BUTTON_MODE) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_ButtonMode(@as(*const ITPhone, @ptrCast(self)), lButtonID, pButtonMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_put_ButtonMode(self: *const T, lButtonID: i32, ButtonMode: PHONE_BUTTON_MODE) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).put_ButtonMode(@as(*const ITPhone, @ptrCast(self)), lButtonID, ButtonMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_ButtonFunction(self: *const T, lButtonID: i32, pButtonFunction: ?*PHONE_BUTTON_FUNCTION) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_ButtonFunction(@as(*const ITPhone, @ptrCast(self)), lButtonID, pButtonFunction);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_put_ButtonFunction(self: *const T, lButtonID: i32, ButtonFunction: PHONE_BUTTON_FUNCTION) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).put_ButtonFunction(@as(*const ITPhone, @ptrCast(self)), lButtonID, ButtonFunction);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_ButtonText(self: *const T, lButtonID: i32, ppButtonText: ?*?BSTR) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_ButtonText(@as(*const ITPhone, @ptrCast(self)), lButtonID, ppButtonText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_put_ButtonText(self: *const T, lButtonID: i32, bstrButtonText: ?BSTR) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).put_ButtonText(@as(*const ITPhone, @ptrCast(self)), lButtonID, bstrButtonText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_ButtonState(self: *const T, lButtonID: i32, pButtonState: ?*PHONE_BUTTON_STATE) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_ButtonState(@as(*const ITPhone, @ptrCast(self)), lButtonID, pButtonState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_HookSwitchState(self: *const T, HookSwitchDevice: PHONE_HOOK_SWITCH_DEVICE, pHookSwitchState: ?*PHONE_HOOK_SWITCH_STATE) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_HookSwitchState(@as(*const ITPhone, @ptrCast(self)), HookSwitchDevice, pHookSwitchState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_put_HookSwitchState(self: *const T, HookSwitchDevice: PHONE_HOOK_SWITCH_DEVICE, HookSwitchState: PHONE_HOOK_SWITCH_STATE) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).put_HookSwitchState(@as(*const ITPhone, @ptrCast(self)), HookSwitchDevice, HookSwitchState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_put_RingMode(self: *const T, lRingMode: i32) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).put_RingMode(@as(*const ITPhone, @ptrCast(self)), lRingMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_RingMode(self: *const T, plRingMode: ?*i32) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_RingMode(@as(*const ITPhone, @ptrCast(self)), plRingMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_put_RingVolume(self: *const T, lRingVolume: i32) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).put_RingVolume(@as(*const ITPhone, @ptrCast(self)), lRingVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_RingVolume(self: *const T, plRingVolume: ?*i32) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_RingVolume(@as(*const ITPhone, @ptrCast(self)), plRingVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_Privilege(self: *const T, pPrivilege: ?*PHONE_PRIVILEGE) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_Privilege(@as(*const ITPhone, @ptrCast(self)), pPrivilege);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_GetPhoneCapsBuffer(self: *const T, pcbCaps: PHONECAPS_BUFFER, pdwSize: ?*u32, ppPhoneCapsBuffer: ?*?*u8) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).GetPhoneCapsBuffer(@as(*const ITPhone, @ptrCast(self)), pcbCaps, pdwSize, ppPhoneCapsBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_PhoneCapsBuffer(self: *const T, pcbCaps: PHONECAPS_BUFFER, pVarBuffer: ?*VARIANT) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_PhoneCapsBuffer(@as(*const ITPhone, @ptrCast(self)), pcbCaps, pVarBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_LampMode(self: *const T, lLampID: i32, pLampMode: ?*PHONE_LAMP_MODE) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_LampMode(@as(*const ITPhone, @ptrCast(self)), lLampID, pLampMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_put_LampMode(self: *const T, lLampID: i32, LampMode: PHONE_LAMP_MODE) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).put_LampMode(@as(*const ITPhone, @ptrCast(self)), lLampID, LampMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_Display(self: *const T, pbstrDisplay: ?*?BSTR) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_Display(@as(*const ITPhone, @ptrCast(self)), pbstrDisplay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_SetDisplay(self: *const T, lRow: i32, lColumn: i32, bstrDisplay: ?BSTR) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).SetDisplay(@as(*const ITPhone, @ptrCast(self)), lRow, lColumn, bstrDisplay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_get_PreferredAddresses(self: *const T, pAddresses: ?*VARIANT) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).get_PreferredAddresses(@as(*const ITPhone, @ptrCast(self)), pAddresses);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_EnumeratePreferredAddresses(self: *const T, ppEnumAddress: ?*?*IEnumAddress) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).EnumeratePreferredAddresses(@as(*const ITPhone, @ptrCast(self)), ppEnumAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_DeviceSpecific(self: *const T, pParams: ?*u8, dwSize: u32) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).DeviceSpecific(@as(*const ITPhone, @ptrCast(self)), pParams, dwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_DeviceSpecificVariant(self: *const T, varDevSpecificByteArray: VARIANT) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).DeviceSpecificVariant(@as(*const ITPhone, @ptrCast(self)), varDevSpecificByteArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhone_NegotiateExtVersion(self: *const T, lLowVersion: i32, lHighVersion: i32, plExtVersion: ?*i32) HRESULT {
                return @as(*const ITPhone.VTable, @ptrCast(self.vtable)).NegotiateExtVersion(@as(*const ITPhone, @ptrCast(self)), lLowVersion, lHighVersion, plExtVersion);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAutomatedPhoneControl_Value = Guid.initString("1ee1af0e-6159-4a61-b79b-6a4ba3fc9dfc");
pub const IID_ITAutomatedPhoneControl = &IID_ITAutomatedPhoneControl_Value;
pub const ITAutomatedPhoneControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        StartTone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                Tone: PHONE_TONE,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                Tone: PHONE_TONE,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopTone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tone: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pTone: ?*PHONE_TONE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pTone: ?*PHONE_TONE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartRinger: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                lRingMode: i32,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                lRingMode: i32,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopRinger: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ringer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pfRinging: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pfRinging: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PhoneHandlingEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhoneHandlingEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoEndOfNumberTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                lTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                lTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoEndOfNumberTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                plTimeout: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                plTimeout: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoDialtone: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoDialtone: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoStopTonesOnOnHook: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoStopTonesOnOnHook: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoStopRingOnOffHook: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoStopRingOnOffHook: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoKeypadTones: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoKeypadTones: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoKeypadTonesMinimumDuration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoKeypadTonesMinimumDuration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                plDuration: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                plDuration: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoVolumeControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoVolumeControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                fEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoVolumeControlStep: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                lStepSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                lStepSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoVolumeControlStep: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                plStepSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                plStepSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoVolumeControlRepeatDelay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                lDelay: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                lDelay: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoVolumeControlRepeatDelay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                plDelay: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                plDelay: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoVolumeControlRepeatPeriod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                lPeriod: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                lPeriod: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoVolumeControlRepeatPeriod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                plPeriod: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                plPeriod: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pCall: ?*ITCallInfo,
                fSelectDefaultTerminals: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pCall: ?*ITCallInfo,
                fSelectDefaultTerminals: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnselectCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pCall: ?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pCall: ?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateSelectedCalls: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                ppCallEnum: ?*?*IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                ppCallEnum: ?*?*IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectedCalls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAutomatedPhoneControl,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAutomatedPhoneControl,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_StartTone(self: *const T, Tone: PHONE_TONE, lDuration: i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).StartTone(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), Tone, lDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_StopTone(self: *const T) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).StopTone(@as(*const ITAutomatedPhoneControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_Tone(self: *const T, pTone: ?*PHONE_TONE) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_Tone(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pTone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_StartRinger(self: *const T, lRingMode: i32, lDuration: i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).StartRinger(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), lRingMode, lDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_StopRinger(self: *const T) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).StopRinger(@as(*const ITAutomatedPhoneControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_Ringer(self: *const T, pfRinging: ?*i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_Ringer(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pfRinging);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_PhoneHandlingEnabled(self: *const T, fEnabled: i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_PhoneHandlingEnabled(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_PhoneHandlingEnabled(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_PhoneHandlingEnabled(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoEndOfNumberTimeout(self: *const T, lTimeout: i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoEndOfNumberTimeout(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), lTimeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoEndOfNumberTimeout(self: *const T, plTimeout: ?*i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoEndOfNumberTimeout(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), plTimeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoDialtone(self: *const T, fEnabled: i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoDialtone(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoDialtone(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoDialtone(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoStopTonesOnOnHook(self: *const T, fEnabled: i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoStopTonesOnOnHook(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoStopTonesOnOnHook(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoStopTonesOnOnHook(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoStopRingOnOffHook(self: *const T, fEnabled: i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoStopRingOnOffHook(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoStopRingOnOffHook(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoStopRingOnOffHook(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoKeypadTones(self: *const T, fEnabled: i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoKeypadTones(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoKeypadTones(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoKeypadTones(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoKeypadTonesMinimumDuration(self: *const T, lDuration: i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoKeypadTonesMinimumDuration(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), lDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoKeypadTonesMinimumDuration(self: *const T, plDuration: ?*i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoKeypadTonesMinimumDuration(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), plDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoVolumeControl(self: *const T, fEnabled: i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoVolumeControl(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoVolumeControl(self: *const T, fEnabled: ?*i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoVolumeControl(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoVolumeControlStep(self: *const T, lStepSize: i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoVolumeControlStep(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), lStepSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoVolumeControlStep(self: *const T, plStepSize: ?*i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoVolumeControlStep(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), plStepSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoVolumeControlRepeatDelay(self: *const T, lDelay: i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoVolumeControlRepeatDelay(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), lDelay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoVolumeControlRepeatDelay(self: *const T, plDelay: ?*i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoVolumeControlRepeatDelay(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), plDelay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_put_AutoVolumeControlRepeatPeriod(self: *const T, lPeriod: i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).put_AutoVolumeControlRepeatPeriod(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), lPeriod);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_AutoVolumeControlRepeatPeriod(self: *const T, plPeriod: ?*i32) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_AutoVolumeControlRepeatPeriod(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), plPeriod);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_SelectCall(self: *const T, pCall: ?*ITCallInfo, fSelectDefaultTerminals: i16) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).SelectCall(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pCall, fSelectDefaultTerminals);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_UnselectCall(self: *const T, pCall: ?*ITCallInfo) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).UnselectCall(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_EnumerateSelectedCalls(self: *const T, ppCallEnum: ?*?*IEnumCall) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).EnumerateSelectedCalls(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), ppCallEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAutomatedPhoneControl_get_SelectedCalls(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAutomatedPhoneControl.VTable, @ptrCast(self.vtable)).get_SelectedCalls(@as(*const ITAutomatedPhoneControl, @ptrCast(self)), pVariant);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITBasicCallControl_Value = Guid.initString("b1efc389-9355-11d0-835c-00aa003ccabd");
pub const IID_ITBasicCallControl = &IID_ITBasicCallControl_Value;
pub const ITBasicCallControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                fSync: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                fSync: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Answer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                code: DISCONNECT_CODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                code: DISCONNECT_CODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Hold: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                fHold: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                fHold: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandoffDirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                pApplicationName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                pApplicationName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandoffIndirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                lMediaType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                lMediaType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Conference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                pCall: ?*ITBasicCallControl,
                fSync: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                pCall: ?*ITBasicCallControl,
                fSync: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Transfer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                pCall: ?*ITBasicCallControl,
                fSync: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                pCall: ?*ITBasicCallControl,
                fSync: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BlindTransfer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                pDestAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                pDestAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SwapHold: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                pCall: ?*ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                pCall: ?*ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParkDirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                pParkAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                pParkAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParkIndirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                ppNonDirAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                ppNonDirAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unpark: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQOS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                lMediaType: i32,
                ServiceLevel: QOS_SERVICE_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                lMediaType: i32,
                ServiceLevel: QOS_SERVICE_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pickup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                pGroupID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                pGroupID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Dial: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                pDestAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                pDestAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
                finishMode: FINISH_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
                finishMode: FINISH_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFromConference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Connect(self: *const T, fSync: i16) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Connect(@as(*const ITBasicCallControl, @ptrCast(self)), fSync);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Answer(self: *const T) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Answer(@as(*const ITBasicCallControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Disconnect(self: *const T, code: DISCONNECT_CODE) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const ITBasicCallControl, @ptrCast(self)), code);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Hold(self: *const T, fHold: i16) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Hold(@as(*const ITBasicCallControl, @ptrCast(self)), fHold);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_HandoffDirect(self: *const T, pApplicationName: ?BSTR) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).HandoffDirect(@as(*const ITBasicCallControl, @ptrCast(self)), pApplicationName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_HandoffIndirect(self: *const T, lMediaType: i32) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).HandoffIndirect(@as(*const ITBasicCallControl, @ptrCast(self)), lMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Conference(self: *const T, pCall: ?*ITBasicCallControl, fSync: i16) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Conference(@as(*const ITBasicCallControl, @ptrCast(self)), pCall, fSync);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Transfer(self: *const T, pCall: ?*ITBasicCallControl, fSync: i16) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Transfer(@as(*const ITBasicCallControl, @ptrCast(self)), pCall, fSync);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_BlindTransfer(self: *const T, pDestAddress: ?BSTR) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).BlindTransfer(@as(*const ITBasicCallControl, @ptrCast(self)), pDestAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_SwapHold(self: *const T, pCall: ?*ITBasicCallControl) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).SwapHold(@as(*const ITBasicCallControl, @ptrCast(self)), pCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_ParkDirect(self: *const T, pParkAddress: ?BSTR) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).ParkDirect(@as(*const ITBasicCallControl, @ptrCast(self)), pParkAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_ParkIndirect(self: *const T, ppNonDirAddress: ?*?BSTR) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).ParkIndirect(@as(*const ITBasicCallControl, @ptrCast(self)), ppNonDirAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Unpark(self: *const T) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Unpark(@as(*const ITBasicCallControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_SetQOS(self: *const T, lMediaType: i32, ServiceLevel: QOS_SERVICE_LEVEL) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).SetQOS(@as(*const ITBasicCallControl, @ptrCast(self)), lMediaType, ServiceLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Pickup(self: *const T, pGroupID: ?BSTR) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Pickup(@as(*const ITBasicCallControl, @ptrCast(self)), pGroupID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Dial(self: *const T, pDestAddress: ?BSTR) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Dial(@as(*const ITBasicCallControl, @ptrCast(self)), pDestAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_Finish(self: *const T, finishMode: FINISH_MODE) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).Finish(@as(*const ITBasicCallControl, @ptrCast(self)), finishMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl_RemoveFromConference(self: *const T) HRESULT {
                return @as(*const ITBasicCallControl.VTable, @ptrCast(self.vtable)).RemoveFromConference(@as(*const ITBasicCallControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCallInfo_Value = Guid.initString("350f85d1-1227-11d3-83d4-00c04fb6809f");
pub const IID_ITCallInfo = &IID_ITCallInfo_Value;
pub const ITCallInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Address: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                pCallState: ?*CALL_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                pCallState: ?*CALL_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Privilege: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                pPrivilege: ?*CALL_PRIVILEGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                pPrivilege: ?*CALL_PRIVILEGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallHub: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                ppCallHub: ?*?*ITCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                ppCallHub: ?*?*ITCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallInfoLong: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                CallInfoLong: CALLINFO_LONG,
                plCallInfoLongVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                CallInfoLong: CALLINFO_LONG,
                plCallInfoLongVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CallInfoLong: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                CallInfoLong: CALLINFO_LONG,
                lCallInfoLongVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                CallInfoLong: CALLINFO_LONG,
                lCallInfoLongVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallInfoString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                CallInfoString: CALLINFO_STRING,
                ppCallInfoString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                CallInfoString: CALLINFO_STRING,
                ppCallInfoString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CallInfoString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                CallInfoString: CALLINFO_STRING,
                pCallInfoString: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                CallInfoString: CALLINFO_STRING,
                pCallInfoString: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallInfoBuffer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                CallInfoBuffer: CALLINFO_BUFFER,
                ppCallInfoBuffer: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                CallInfoBuffer: CALLINFO_BUFFER,
                ppCallInfoBuffer: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CallInfoBuffer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo,
                CallInfoBuffer: CALLINFO_BUFFER,
                pCallInfoBuffer: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo,
                CallInfoBuffer: CALLINFO_BUFFER,
                pCallInfoBuffer: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCallInfoBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITCallInfo,
                CallInfoBuffer: CALLINFO_BUFFER,
                pdwSize: ?*u32,
                ppCallInfoBuffer: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITCallInfo,
                CallInfoBuffer: CALLINFO_BUFFER,
                pdwSize: ?*u32,
                ppCallInfoBuffer: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCallInfoBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITCallInfo,
                CallInfoBuffer: CALLINFO_BUFFER,
                dwSize: u32,
                pCallInfoBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITCallInfo,
                CallInfoBuffer: CALLINFO_BUFFER,
                dwSize: u32,
                pCallInfoBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseUserUserInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_get_Address(self: *const T, ppAddress: ?*?*ITAddress) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).get_Address(@as(*const ITCallInfo, @ptrCast(self)), ppAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_get_CallState(self: *const T, pCallState: ?*CALL_STATE) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).get_CallState(@as(*const ITCallInfo, @ptrCast(self)), pCallState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_get_Privilege(self: *const T, pPrivilege: ?*CALL_PRIVILEGE) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).get_Privilege(@as(*const ITCallInfo, @ptrCast(self)), pPrivilege);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_get_CallHub(self: *const T, ppCallHub: ?*?*ITCallHub) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).get_CallHub(@as(*const ITCallInfo, @ptrCast(self)), ppCallHub);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_get_CallInfoLong(self: *const T, CallInfoLong: CALLINFO_LONG, plCallInfoLongVal: ?*i32) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).get_CallInfoLong(@as(*const ITCallInfo, @ptrCast(self)), CallInfoLong, plCallInfoLongVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_put_CallInfoLong(self: *const T, CallInfoLong: CALLINFO_LONG, lCallInfoLongVal: i32) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).put_CallInfoLong(@as(*const ITCallInfo, @ptrCast(self)), CallInfoLong, lCallInfoLongVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_get_CallInfoString(self: *const T, CallInfoString: CALLINFO_STRING, ppCallInfoString: ?*?BSTR) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).get_CallInfoString(@as(*const ITCallInfo, @ptrCast(self)), CallInfoString, ppCallInfoString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_put_CallInfoString(self: *const T, CallInfoString: CALLINFO_STRING, pCallInfoString: ?BSTR) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).put_CallInfoString(@as(*const ITCallInfo, @ptrCast(self)), CallInfoString, pCallInfoString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_get_CallInfoBuffer(self: *const T, CallInfoBuffer: CALLINFO_BUFFER, ppCallInfoBuffer: ?*VARIANT) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).get_CallInfoBuffer(@as(*const ITCallInfo, @ptrCast(self)), CallInfoBuffer, ppCallInfoBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_put_CallInfoBuffer(self: *const T, CallInfoBuffer: CALLINFO_BUFFER, pCallInfoBuffer: VARIANT) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).put_CallInfoBuffer(@as(*const ITCallInfo, @ptrCast(self)), CallInfoBuffer, pCallInfoBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_GetCallInfoBuffer(self: *const T, CallInfoBuffer: CALLINFO_BUFFER, pdwSize: ?*u32, ppCallInfoBuffer: [*]?*u8) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).GetCallInfoBuffer(@as(*const ITCallInfo, @ptrCast(self)), CallInfoBuffer, pdwSize, ppCallInfoBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_SetCallInfoBuffer(self: *const T, CallInfoBuffer: CALLINFO_BUFFER, dwSize: u32, pCallInfoBuffer: [*:0]u8) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).SetCallInfoBuffer(@as(*const ITCallInfo, @ptrCast(self)), CallInfoBuffer, dwSize, pCallInfoBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo_ReleaseUserUserInfo(self: *const T) HRESULT {
                return @as(*const ITCallInfo.VTable, @ptrCast(self.vtable)).ReleaseUserUserInfo(@as(*const ITCallInfo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCallInfo2_Value = Guid.initString("94d70ca6-7ab0-4daa-81ca-b8f8643faec1");
pub const IID_ITCallInfo2 = &IID_ITCallInfo2_Value;
pub const ITCallInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ITCallInfo.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo2,
                TapiEvent: TAPI_EVENT,
                lSubEvent: i32,
                pEnable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo2,
                TapiEvent: TAPI_EVENT,
                lSubEvent: i32,
                pEnable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfo2,
                TapiEvent: TAPI_EVENT,
                lSubEvent: i32,
                bEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfo2,
                TapiEvent: TAPI_EVENT,
                lSubEvent: i32,
                bEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITCallInfo.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo2_get_EventFilter(self: *const T, TapiEvent: TAPI_EVENT, lSubEvent: i32, pEnable: ?*i16) HRESULT {
                return @as(*const ITCallInfo2.VTable, @ptrCast(self.vtable)).get_EventFilter(@as(*const ITCallInfo2, @ptrCast(self)), TapiEvent, lSubEvent, pEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfo2_put_EventFilter(self: *const T, TapiEvent: TAPI_EVENT, lSubEvent: i32, bEnable: i16) HRESULT {
                return @as(*const ITCallInfo2.VTable, @ptrCast(self.vtable)).put_EventFilter(@as(*const ITCallInfo2, @ptrCast(self)), TapiEvent, lSubEvent, bEnable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTerminal_Value = Guid.initString("b1efc38a-9355-11d0-835c-00aa003ccabd");
pub const IID_ITTerminal = &IID_ITTerminal_Value;
pub const ITTerminal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminal,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminal,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminal,
                pTerminalState: ?*TERMINAL_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminal,
                pTerminalState: ?*TERMINAL_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TerminalType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminal,
                pType: ?*TERMINAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminal,
                pType: ?*TERMINAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TerminalClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminal,
                ppTerminalClass: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminal,
                ppTerminalClass: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminal,
                plMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminal,
                plMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Direction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTerminal,
                pDirection: ?*TERMINAL_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTerminal,
                pDirection: ?*TERMINAL_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminal_get_Name(self: *const T, ppName: ?*?BSTR) HRESULT {
                return @as(*const ITTerminal.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ITTerminal, @ptrCast(self)), ppName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminal_get_State(self: *const T, pTerminalState: ?*TERMINAL_STATE) HRESULT {
                return @as(*const ITTerminal.VTable, @ptrCast(self.vtable)).get_State(@as(*const ITTerminal, @ptrCast(self)), pTerminalState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminal_get_TerminalType(self: *const T, pType: ?*TERMINAL_TYPE) HRESULT {
                return @as(*const ITTerminal.VTable, @ptrCast(self.vtable)).get_TerminalType(@as(*const ITTerminal, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminal_get_TerminalClass(self: *const T, ppTerminalClass: ?*?BSTR) HRESULT {
                return @as(*const ITTerminal.VTable, @ptrCast(self.vtable)).get_TerminalClass(@as(*const ITTerminal, @ptrCast(self)), ppTerminalClass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminal_get_MediaType(self: *const T, plMediaType: ?*i32) HRESULT {
                return @as(*const ITTerminal.VTable, @ptrCast(self.vtable)).get_MediaType(@as(*const ITTerminal, @ptrCast(self)), plMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTerminal_get_Direction(self: *const T, pDirection: ?*TERMINAL_DIRECTION) HRESULT {
                return @as(*const ITTerminal.VTable, @ptrCast(self.vtable)).get_Direction(@as(*const ITTerminal, @ptrCast(self)), pDirection);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITMultiTrackTerminal_Value = Guid.initString("fe040091-ade8-4072-95c9-bf7de8c54b44");
pub const IID_ITMultiTrackTerminal = &IID_ITMultiTrackTerminal_Value;
pub const ITMultiTrackTerminal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackTerminals: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITMultiTrackTerminal,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITMultiTrackTerminal,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateTrackTerminals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMultiTrackTerminal,
                ppEnumTerminal: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMultiTrackTerminal,
                ppEnumTerminal: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTrackTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMultiTrackTerminal,
                MediaType: i32,
                TerminalDirection: TERMINAL_DIRECTION,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMultiTrackTerminal,
                MediaType: i32,
                TerminalDirection: TERMINAL_DIRECTION,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaTypesInUse: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITMultiTrackTerminal,
                plMediaTypesInUse: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITMultiTrackTerminal,
                plMediaTypesInUse: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DirectionsInUse: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITMultiTrackTerminal,
                plDirectionsInUsed: ?*TERMINAL_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITMultiTrackTerminal,
                plDirectionsInUsed: ?*TERMINAL_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTrackTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMultiTrackTerminal,
                pTrackTerminalToRemove: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMultiTrackTerminal,
                pTrackTerminalToRemove: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMultiTrackTerminal_get_TrackTerminals(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITMultiTrackTerminal.VTable, @ptrCast(self.vtable)).get_TrackTerminals(@as(*const ITMultiTrackTerminal, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMultiTrackTerminal_EnumerateTrackTerminals(self: *const T, ppEnumTerminal: ?*?*IEnumTerminal) HRESULT {
                return @as(*const ITMultiTrackTerminal.VTable, @ptrCast(self.vtable)).EnumerateTrackTerminals(@as(*const ITMultiTrackTerminal, @ptrCast(self)), ppEnumTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMultiTrackTerminal_CreateTrackTerminal(self: *const T, MediaType: i32, TerminalDirection: TERMINAL_DIRECTION, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITMultiTrackTerminal.VTable, @ptrCast(self.vtable)).CreateTrackTerminal(@as(*const ITMultiTrackTerminal, @ptrCast(self)), MediaType, TerminalDirection, ppTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMultiTrackTerminal_get_MediaTypesInUse(self: *const T, plMediaTypesInUse: ?*i32) HRESULT {
                return @as(*const ITMultiTrackTerminal.VTable, @ptrCast(self.vtable)).get_MediaTypesInUse(@as(*const ITMultiTrackTerminal, @ptrCast(self)), plMediaTypesInUse);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMultiTrackTerminal_get_DirectionsInUse(self: *const T, plDirectionsInUsed: ?*TERMINAL_DIRECTION) HRESULT {
                return @as(*const ITMultiTrackTerminal.VTable, @ptrCast(self.vtable)).get_DirectionsInUse(@as(*const ITMultiTrackTerminal, @ptrCast(self)), plDirectionsInUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMultiTrackTerminal_RemoveTrackTerminal(self: *const T, pTrackTerminalToRemove: ?*ITTerminal) HRESULT {
                return @as(*const ITMultiTrackTerminal.VTable, @ptrCast(self.vtable)).RemoveTrackTerminal(@as(*const ITMultiTrackTerminal, @ptrCast(self)), pTrackTerminalToRemove);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TERMINAL_MEDIA_STATE = enum(i32) {
    IDLE = 0,
    ACTIVE = 1,
    PAUSED = 2,
    // LASTITEM = 2, this enum value conflicts with PAUSED
};
pub const TMS_IDLE = TERMINAL_MEDIA_STATE.IDLE;
pub const TMS_ACTIVE = TERMINAL_MEDIA_STATE.ACTIVE;
pub const TMS_PAUSED = TERMINAL_MEDIA_STATE.PAUSED;
pub const TMS_LASTITEM = TERMINAL_MEDIA_STATE.PAUSED;

pub const FT_STATE_EVENT_CAUSE = enum(i32) {
    NORMAL = 0,
    END_OF_FILE = 1,
    READ_ERROR = 2,
    WRITE_ERROR = 3,
};
pub const FTEC_NORMAL = FT_STATE_EVENT_CAUSE.NORMAL;
pub const FTEC_END_OF_FILE = FT_STATE_EVENT_CAUSE.END_OF_FILE;
pub const FTEC_READ_ERROR = FT_STATE_EVENT_CAUSE.READ_ERROR;
pub const FTEC_WRITE_ERROR = FT_STATE_EVENT_CAUSE.WRITE_ERROR;

const IID_ITFileTrack_Value = Guid.initString("31ca6ea9-c08a-4bea-8811-8e9c1ba3ea3a");
pub const IID_ITFileTrack = &IID_ITFileTrack_Value;
pub const ITFileTrack = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Format: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTrack,
                ppmt: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTrack,
                ppmt: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Format: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTrack,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTrack,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ControllingTerminal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTrack,
                ppControllingTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTrack,
                ppControllingTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFormatForScripting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTrack,
                ppAudioFormat: ?*?*ITScriptableAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTrack,
                ppAudioFormat: ?*?*ITScriptableAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioFormatForScripting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTrack,
                pAudioFormat: ?*ITScriptableAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTrack,
                pAudioFormat: ?*ITScriptableAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EmptyAudioFormatForScripting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTrack,
                ppAudioFormat: ?*?*ITScriptableAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTrack,
                ppAudioFormat: ?*?*ITScriptableAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTrack_get_Format(self: *const T, ppmt: ?*?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const ITFileTrack.VTable, @ptrCast(self.vtable)).get_Format(@as(*const ITFileTrack, @ptrCast(self)), ppmt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTrack_put_Format(self: *const T, pmt: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const ITFileTrack.VTable, @ptrCast(self.vtable)).put_Format(@as(*const ITFileTrack, @ptrCast(self)), pmt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTrack_get_ControllingTerminal(self: *const T, ppControllingTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITFileTrack.VTable, @ptrCast(self.vtable)).get_ControllingTerminal(@as(*const ITFileTrack, @ptrCast(self)), ppControllingTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTrack_get_AudioFormatForScripting(self: *const T, ppAudioFormat: ?*?*ITScriptableAudioFormat) HRESULT {
                return @as(*const ITFileTrack.VTable, @ptrCast(self.vtable)).get_AudioFormatForScripting(@as(*const ITFileTrack, @ptrCast(self)), ppAudioFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTrack_put_AudioFormatForScripting(self: *const T, pAudioFormat: ?*ITScriptableAudioFormat) HRESULT {
                return @as(*const ITFileTrack.VTable, @ptrCast(self.vtable)).put_AudioFormatForScripting(@as(*const ITFileTrack, @ptrCast(self)), pAudioFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTrack_get_EmptyAudioFormatForScripting(self: *const T, ppAudioFormat: ?*?*ITScriptableAudioFormat) HRESULT {
                return @as(*const ITFileTrack.VTable, @ptrCast(self.vtable)).get_EmptyAudioFormatForScripting(@as(*const ITFileTrack, @ptrCast(self)), ppAudioFormat);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITMediaPlayback_Value = Guid.initString("627e8ae6-ae4c-4a69-bb63-2ad625404b77");
pub const IID_ITMediaPlayback = &IID_ITMediaPlayback_Value;
pub const ITMediaPlayback = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PlayList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITMediaPlayback,
                PlayListVariant: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITMediaPlayback,
                PlayListVariant: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlayList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITMediaPlayback,
                pPlayListVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITMediaPlayback,
                pPlayListVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaPlayback_put_PlayList(self: *const T, PlayListVariant: VARIANT) HRESULT {
                return @as(*const ITMediaPlayback.VTable, @ptrCast(self.vtable)).put_PlayList(@as(*const ITMediaPlayback, @ptrCast(self)), PlayListVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaPlayback_get_PlayList(self: *const T, pPlayListVariant: ?*VARIANT) HRESULT {
                return @as(*const ITMediaPlayback.VTable, @ptrCast(self.vtable)).get_PlayList(@as(*const ITMediaPlayback, @ptrCast(self)), pPlayListVariant);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITMediaRecord_Value = Guid.initString("f5dd4592-5476-4cc1-9d4d-fad3eefe7db2");
pub const IID_ITMediaRecord = &IID_ITMediaRecord_Value;
pub const ITMediaRecord = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITMediaRecord,
                bstrFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITMediaRecord,
                bstrFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITMediaRecord,
                pbstrFileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITMediaRecord,
                pbstrFileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaRecord_put_FileName(self: *const T, bstrFileName: ?BSTR) HRESULT {
                return @as(*const ITMediaRecord.VTable, @ptrCast(self.vtable)).put_FileName(@as(*const ITMediaRecord, @ptrCast(self)), bstrFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaRecord_get_FileName(self: *const T, pbstrFileName: ?*?BSTR) HRESULT {
                return @as(*const ITMediaRecord.VTable, @ptrCast(self.vtable)).get_FileName(@as(*const ITMediaRecord, @ptrCast(self)), pbstrFileName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITMediaControl_Value = Guid.initString("c445dde8-5199-4bc7-9807-5ffb92e42e09");
pub const IID_ITMediaControl = &IID_ITMediaControl_Value;
pub const ITMediaControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITMediaControl,
                pTerminalMediaState: ?*TERMINAL_MEDIA_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITMediaControl,
                pTerminalMediaState: ?*TERMINAL_MEDIA_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaControl_Start(self: *const T) HRESULT {
                return @as(*const ITMediaControl.VTable, @ptrCast(self.vtable)).Start(@as(*const ITMediaControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaControl_Stop(self: *const T) HRESULT {
                return @as(*const ITMediaControl.VTable, @ptrCast(self.vtable)).Stop(@as(*const ITMediaControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaControl_Pause(self: *const T) HRESULT {
                return @as(*const ITMediaControl.VTable, @ptrCast(self.vtable)).Pause(@as(*const ITMediaControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMediaControl_get_MediaState(self: *const T, pTerminalMediaState: ?*TERMINAL_MEDIA_STATE) HRESULT {
                return @as(*const ITMediaControl.VTable, @ptrCast(self.vtable)).get_MediaState(@as(*const ITMediaControl, @ptrCast(self)), pTerminalMediaState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITBasicAudioTerminal_Value = Guid.initString("b1efc38d-9355-11d0-835c-00aa003ccabd");
pub const IID_ITBasicAudioTerminal = &IID_ITBasicAudioTerminal_Value;
pub const ITBasicAudioTerminal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITBasicAudioTerminal,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITBasicAudioTerminal,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITBasicAudioTerminal,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITBasicAudioTerminal,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Balance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITBasicAudioTerminal,
                lBalance: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITBasicAudioTerminal,
                lBalance: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Balance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITBasicAudioTerminal,
                plBalance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITBasicAudioTerminal,
                plBalance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicAudioTerminal_put_Volume(self: *const T, lVolume: i32) HRESULT {
                return @as(*const ITBasicAudioTerminal.VTable, @ptrCast(self.vtable)).put_Volume(@as(*const ITBasicAudioTerminal, @ptrCast(self)), lVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicAudioTerminal_get_Volume(self: *const T, plVolume: ?*i32) HRESULT {
                return @as(*const ITBasicAudioTerminal.VTable, @ptrCast(self.vtable)).get_Volume(@as(*const ITBasicAudioTerminal, @ptrCast(self)), plVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicAudioTerminal_put_Balance(self: *const T, lBalance: i32) HRESULT {
                return @as(*const ITBasicAudioTerminal.VTable, @ptrCast(self.vtable)).put_Balance(@as(*const ITBasicAudioTerminal, @ptrCast(self)), lBalance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicAudioTerminal_get_Balance(self: *const T, plBalance: ?*i32) HRESULT {
                return @as(*const ITBasicAudioTerminal.VTable, @ptrCast(self.vtable)).get_Balance(@as(*const ITBasicAudioTerminal, @ptrCast(self)), plBalance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITStaticAudioTerminal_Value = Guid.initString("a86b7871-d14c-48e6-922e-a8d15f984800");
pub const IID_ITStaticAudioTerminal = &IID_ITStaticAudioTerminal_Value;
pub const ITStaticAudioTerminal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WaveId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITStaticAudioTerminal,
                plWaveId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITStaticAudioTerminal,
                plWaveId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStaticAudioTerminal_get_WaveId(self: *const T, plWaveId: ?*i32) HRESULT {
                return @as(*const ITStaticAudioTerminal.VTable, @ptrCast(self.vtable)).get_WaveId(@as(*const ITStaticAudioTerminal, @ptrCast(self)), plWaveId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCallHub_Value = Guid.initString("a3c1544e-5b92-11d1-8f4e-00c04fb6809f");
pub const IID_ITCallHub = &IID_ITCallHub_Value;
pub const ITCallHub = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateCalls: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITCallHub,
                ppEnumCall: ?*?*IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITCallHub,
                ppEnumCall: ?*?*IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Calls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallHub,
                pCalls: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallHub,
                pCalls: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumCalls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallHub,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallHub,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallHub,
                pState: ?*CALLHUB_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallHub,
                pState: ?*CALLHUB_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallHub_Clear(self: *const T) HRESULT {
                return @as(*const ITCallHub.VTable, @ptrCast(self.vtable)).Clear(@as(*const ITCallHub, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallHub_EnumerateCalls(self: *const T, ppEnumCall: ?*?*IEnumCall) HRESULT {
                return @as(*const ITCallHub.VTable, @ptrCast(self.vtable)).EnumerateCalls(@as(*const ITCallHub, @ptrCast(self)), ppEnumCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallHub_get_Calls(self: *const T, pCalls: ?*VARIANT) HRESULT {
                return @as(*const ITCallHub.VTable, @ptrCast(self.vtable)).get_Calls(@as(*const ITCallHub, @ptrCast(self)), pCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallHub_get_NumCalls(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITCallHub.VTable, @ptrCast(self.vtable)).get_NumCalls(@as(*const ITCallHub, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallHub_get_State(self: *const T, pState: ?*CALLHUB_STATE) HRESULT {
                return @as(*const ITCallHub.VTable, @ptrCast(self.vtable)).get_State(@as(*const ITCallHub, @ptrCast(self)), pState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITLegacyAddressMediaControl_Value = Guid.initString("ab493640-4c0b-11d2-a046-00c04fb6809f");
pub const IID_ITLegacyAddressMediaControl = &IID_ITLegacyAddressMediaControl_Value;
pub const ITLegacyAddressMediaControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyAddressMediaControl,
                pDeviceClass: ?BSTR,
                pdwSize: ?*u32,
                ppDeviceID: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyAddressMediaControl,
                pDeviceClass: ?BSTR,
                pdwSize: ?*u32,
                ppDeviceID: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDevConfig: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyAddressMediaControl,
                pDeviceClass: ?BSTR,
                pdwSize: ?*u32,
                ppDeviceConfig: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyAddressMediaControl,
                pDeviceClass: ?BSTR,
                pdwSize: ?*u32,
                ppDeviceConfig: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDevConfig: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyAddressMediaControl,
                pDeviceClass: ?BSTR,
                dwSize: u32,
                pDeviceConfig: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyAddressMediaControl,
                pDeviceClass: ?BSTR,
                dwSize: u32,
                pDeviceConfig: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyAddressMediaControl_GetID(self: *const T, pDeviceClass: ?BSTR, pdwSize: ?*u32, ppDeviceID: [*]?*u8) HRESULT {
                return @as(*const ITLegacyAddressMediaControl.VTable, @ptrCast(self.vtable)).GetID(@as(*const ITLegacyAddressMediaControl, @ptrCast(self)), pDeviceClass, pdwSize, ppDeviceID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyAddressMediaControl_GetDevConfig(self: *const T, pDeviceClass: ?BSTR, pdwSize: ?*u32, ppDeviceConfig: [*]?*u8) HRESULT {
                return @as(*const ITLegacyAddressMediaControl.VTable, @ptrCast(self.vtable)).GetDevConfig(@as(*const ITLegacyAddressMediaControl, @ptrCast(self)), pDeviceClass, pdwSize, ppDeviceConfig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyAddressMediaControl_SetDevConfig(self: *const T, pDeviceClass: ?BSTR, dwSize: u32, pDeviceConfig: [*:0]u8) HRESULT {
                return @as(*const ITLegacyAddressMediaControl.VTable, @ptrCast(self.vtable)).SetDevConfig(@as(*const ITLegacyAddressMediaControl, @ptrCast(self)), pDeviceClass, dwSize, pDeviceConfig);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITPrivateEvent_Value = Guid.initString("0e269cd0-10d4-4121-9c22-9c85d625650d");
pub const IID_ITPrivateEvent = &IID_ITPrivateEvent_Value;
pub const ITPrivateEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Address: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPrivateEvent,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPrivateEvent,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPrivateEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPrivateEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallHub: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPrivateEvent,
                ppCallHub: ?*?*ITCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPrivateEvent,
                ppCallHub: ?*?*ITCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPrivateEvent,
                plEventCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPrivateEvent,
                plEventCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventInterface: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPrivateEvent,
                pEventInterface: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPrivateEvent,
                pEventInterface: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPrivateEvent_get_Address(self: *const T, ppAddress: ?*?*ITAddress) HRESULT {
                return @as(*const ITPrivateEvent.VTable, @ptrCast(self.vtable)).get_Address(@as(*const ITPrivateEvent, @ptrCast(self)), ppAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPrivateEvent_get_Call(self: *const T, ppCallInfo: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITPrivateEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITPrivateEvent, @ptrCast(self)), ppCallInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPrivateEvent_get_CallHub(self: *const T, ppCallHub: ?*?*ITCallHub) HRESULT {
                return @as(*const ITPrivateEvent.VTable, @ptrCast(self.vtable)).get_CallHub(@as(*const ITPrivateEvent, @ptrCast(self)), ppCallHub);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPrivateEvent_get_EventCode(self: *const T, plEventCode: ?*i32) HRESULT {
                return @as(*const ITPrivateEvent.VTable, @ptrCast(self.vtable)).get_EventCode(@as(*const ITPrivateEvent, @ptrCast(self)), plEventCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPrivateEvent_get_EventInterface(self: *const T, pEventInterface: ?*?*IDispatch) HRESULT {
                return @as(*const ITPrivateEvent.VTable, @ptrCast(self.vtable)).get_EventInterface(@as(*const ITPrivateEvent, @ptrCast(self)), pEventInterface);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITLegacyAddressMediaControl2_Value = Guid.initString("b0ee512b-a531-409e-9dd9-4099fe86c738");
pub const IID_ITLegacyAddressMediaControl2 = &IID_ITLegacyAddressMediaControl2_Value;
pub const ITLegacyAddressMediaControl2 = extern struct {
    pub const VTable = extern struct {
        base: ITLegacyAddressMediaControl.VTable,
        ConfigDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyAddressMediaControl2,
                hwndOwner: ?HWND,
                pDeviceClass: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyAddressMediaControl2,
                hwndOwner: ?HWND,
                pDeviceClass: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfigDialogEdit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyAddressMediaControl2,
                hwndOwner: ?HWND,
                pDeviceClass: ?BSTR,
                dwSizeIn: u32,
                pDeviceConfigIn: [*:0]u8,
                pdwSizeOut: ?*u32,
                ppDeviceConfigOut: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyAddressMediaControl2,
                hwndOwner: ?HWND,
                pDeviceClass: ?BSTR,
                dwSizeIn: u32,
                pDeviceConfigIn: [*:0]u8,
                pdwSizeOut: ?*u32,
                ppDeviceConfigOut: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITLegacyAddressMediaControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyAddressMediaControl2_ConfigDialog(self: *const T, hwndOwner: ?HWND, pDeviceClass: ?BSTR) HRESULT {
                return @as(*const ITLegacyAddressMediaControl2.VTable, @ptrCast(self.vtable)).ConfigDialog(@as(*const ITLegacyAddressMediaControl2, @ptrCast(self)), hwndOwner, pDeviceClass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyAddressMediaControl2_ConfigDialogEdit(self: *const T, hwndOwner: ?HWND, pDeviceClass: ?BSTR, dwSizeIn: u32, pDeviceConfigIn: [*:0]u8, pdwSizeOut: ?*u32, ppDeviceConfigOut: [*]?*u8) HRESULT {
                return @as(*const ITLegacyAddressMediaControl2.VTable, @ptrCast(self.vtable)).ConfigDialogEdit(@as(*const ITLegacyAddressMediaControl2, @ptrCast(self)), hwndOwner, pDeviceClass, dwSizeIn, pDeviceConfigIn, pdwSizeOut, ppDeviceConfigOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITLegacyCallMediaControl_Value = Guid.initString("d624582f-cc23-4436-b8a5-47c625c8045d");
pub const IID_ITLegacyCallMediaControl = &IID_ITLegacyCallMediaControl_Value;
pub const ITLegacyCallMediaControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        DetectDigits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl,
                DigitMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl,
                DigitMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateDigits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl,
                pDigits: ?BSTR,
                DigitMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl,
                pDigits: ?BSTR,
                DigitMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl,
                pDeviceClass: ?BSTR,
                pdwSize: ?*u32,
                ppDeviceID: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl,
                pDeviceClass: ?BSTR,
                pdwSize: ?*u32,
                ppDeviceID: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl,
                lMediaType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl,
                lMediaType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MonitorMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl,
                lMediaType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl,
                lMediaType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl_DetectDigits(self: *const T, DigitMode: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl.VTable, @ptrCast(self.vtable)).DetectDigits(@as(*const ITLegacyCallMediaControl, @ptrCast(self)), DigitMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl_GenerateDigits(self: *const T, pDigits: ?BSTR, DigitMode: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl.VTable, @ptrCast(self.vtable)).GenerateDigits(@as(*const ITLegacyCallMediaControl, @ptrCast(self)), pDigits, DigitMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl_GetID(self: *const T, pDeviceClass: ?BSTR, pdwSize: ?*u32, ppDeviceID: [*]?*u8) HRESULT {
                return @as(*const ITLegacyCallMediaControl.VTable, @ptrCast(self.vtable)).GetID(@as(*const ITLegacyCallMediaControl, @ptrCast(self)), pDeviceClass, pdwSize, ppDeviceID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl_SetMediaType(self: *const T, lMediaType: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const ITLegacyCallMediaControl, @ptrCast(self)), lMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl_MonitorMedia(self: *const T, lMediaType: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl.VTable, @ptrCast(self.vtable)).MonitorMedia(@as(*const ITLegacyCallMediaControl, @ptrCast(self)), lMediaType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITLegacyCallMediaControl2_Value = Guid.initString("57ca332d-7bc2-44f1-a60c-936fe8d7ce73");
pub const IID_ITLegacyCallMediaControl2 = &IID_ITLegacyCallMediaControl2_Value;
pub const ITLegacyCallMediaControl2 = extern struct {
    pub const VTable = extern struct {
        base: ITLegacyCallMediaControl.VTable,
        GenerateDigits2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                pDigits: ?BSTR,
                DigitMode: i32,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                pDigits: ?BSTR,
                DigitMode: i32,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GatherDigits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                DigitMode: i32,
                lNumDigits: i32,
                pTerminationDigits: ?BSTR,
                lFirstDigitTimeout: i32,
                lInterDigitTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                DigitMode: i32,
                lNumDigits: i32,
                pTerminationDigits: ?BSTR,
                lFirstDigitTimeout: i32,
                lInterDigitTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetectTones: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                pToneList: ?*TAPI_DETECTTONE,
                lNumTones: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                pToneList: ?*TAPI_DETECTTONE,
                lNumTones: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetectTonesByCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                pDetectToneCollection: ?*ITCollection2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                pDetectToneCollection: ?*ITCollection2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateTone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                ToneMode: TAPI_TONEMODE,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                ToneMode: TAPI_TONEMODE,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateCustomTones: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                pToneList: ?*TAPI_CUSTOMTONE,
                lNumTones: i32,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                pToneList: ?*TAPI_CUSTOMTONE,
                lNumTones: i32,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateCustomTonesByCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                pCustomToneCollection: ?*ITCollection2,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                pCustomToneCollection: ?*ITCollection2,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDetectToneObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                ppDetectTone: ?*?*ITDetectTone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                ppDetectTone: ?*?*ITDetectTone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCustomToneObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                ppCustomTone: ?*?*ITCustomTone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                ppCustomTone: ?*?*ITCustomTone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDAsVariant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyCallMediaControl2,
                bstrDeviceClass: ?BSTR,
                pVarDeviceID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyCallMediaControl2,
                bstrDeviceClass: ?BSTR,
                pVarDeviceID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITLegacyCallMediaControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_GenerateDigits2(self: *const T, pDigits: ?BSTR, DigitMode: i32, lDuration: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).GenerateDigits2(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), pDigits, DigitMode, lDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_GatherDigits(self: *const T, DigitMode: i32, lNumDigits: i32, pTerminationDigits: ?BSTR, lFirstDigitTimeout: i32, lInterDigitTimeout: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).GatherDigits(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), DigitMode, lNumDigits, pTerminationDigits, lFirstDigitTimeout, lInterDigitTimeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_DetectTones(self: *const T, pToneList: ?*TAPI_DETECTTONE, lNumTones: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).DetectTones(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), pToneList, lNumTones);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_DetectTonesByCollection(self: *const T, pDetectToneCollection: ?*ITCollection2) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).DetectTonesByCollection(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), pDetectToneCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_GenerateTone(self: *const T, ToneMode: TAPI_TONEMODE, lDuration: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).GenerateTone(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), ToneMode, lDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_GenerateCustomTones(self: *const T, pToneList: ?*TAPI_CUSTOMTONE, lNumTones: i32, lDuration: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).GenerateCustomTones(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), pToneList, lNumTones, lDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_GenerateCustomTonesByCollection(self: *const T, pCustomToneCollection: ?*ITCollection2, lDuration: i32) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).GenerateCustomTonesByCollection(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), pCustomToneCollection, lDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_CreateDetectToneObject(self: *const T, ppDetectTone: ?*?*ITDetectTone) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).CreateDetectToneObject(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), ppDetectTone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_CreateCustomToneObject(self: *const T, ppCustomTone: ?*?*ITCustomTone) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).CreateCustomToneObject(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), ppCustomTone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyCallMediaControl2_GetIDAsVariant(self: *const T, bstrDeviceClass: ?BSTR, pVarDeviceID: ?*VARIANT) HRESULT {
                return @as(*const ITLegacyCallMediaControl2.VTable, @ptrCast(self.vtable)).GetIDAsVariant(@as(*const ITLegacyCallMediaControl2, @ptrCast(self)), bstrDeviceClass, pVarDeviceID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITDetectTone_Value = Guid.initString("961f79bd-3097-49df-a1d6-909b77e89ca0");
pub const IID_ITDetectTone = &IID_ITDetectTone_Value;
pub const ITDetectTone = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppSpecific: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDetectTone,
                plAppSpecific: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDetectTone,
                plAppSpecific: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AppSpecific: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDetectTone,
                lAppSpecific: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDetectTone,
                lAppSpecific: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Duration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDetectTone,
                plDuration: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDetectTone,
                plDuration: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Duration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDetectTone,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDetectTone,
                lDuration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Frequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDetectTone,
                Index: i32,
                plFrequency: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDetectTone,
                Index: i32,
                plFrequency: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Frequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDetectTone,
                Index: i32,
                lFrequency: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDetectTone,
                Index: i32,
                lFrequency: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDetectTone_get_AppSpecific(self: *const T, plAppSpecific: ?*i32) HRESULT {
                return @as(*const ITDetectTone.VTable, @ptrCast(self.vtable)).get_AppSpecific(@as(*const ITDetectTone, @ptrCast(self)), plAppSpecific);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDetectTone_put_AppSpecific(self: *const T, lAppSpecific: i32) HRESULT {
                return @as(*const ITDetectTone.VTable, @ptrCast(self.vtable)).put_AppSpecific(@as(*const ITDetectTone, @ptrCast(self)), lAppSpecific);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDetectTone_get_Duration(self: *const T, plDuration: ?*i32) HRESULT {
                return @as(*const ITDetectTone.VTable, @ptrCast(self.vtable)).get_Duration(@as(*const ITDetectTone, @ptrCast(self)), plDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDetectTone_put_Duration(self: *const T, lDuration: i32) HRESULT {
                return @as(*const ITDetectTone.VTable, @ptrCast(self.vtable)).put_Duration(@as(*const ITDetectTone, @ptrCast(self)), lDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDetectTone_get_Frequency(self: *const T, Index: i32, plFrequency: ?*i32) HRESULT {
                return @as(*const ITDetectTone.VTable, @ptrCast(self.vtable)).get_Frequency(@as(*const ITDetectTone, @ptrCast(self)), Index, plFrequency);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDetectTone_put_Frequency(self: *const T, Index: i32, lFrequency: i32) HRESULT {
                return @as(*const ITDetectTone.VTable, @ptrCast(self.vtable)).put_Frequency(@as(*const ITDetectTone, @ptrCast(self)), Index, lFrequency);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCustomTone_Value = Guid.initString("357ad764-b3c6-4b2a-8fa5-0722827a9254");
pub const IID_ITCustomTone = &IID_ITCustomTone_Value;
pub const ITCustomTone = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Frequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCustomTone,
                plFrequency: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCustomTone,
                plFrequency: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Frequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCustomTone,
                lFrequency: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCustomTone,
                lFrequency: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CadenceOn: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCustomTone,
                plCadenceOn: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCustomTone,
                plCadenceOn: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CadenceOn: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCustomTone,
                CadenceOn: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCustomTone,
                CadenceOn: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CadenceOff: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCustomTone,
                plCadenceOff: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCustomTone,
                plCadenceOff: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CadenceOff: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCustomTone,
                lCadenceOff: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCustomTone,
                lCadenceOff: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCustomTone,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCustomTone,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCustomTone,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCustomTone,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCustomTone_get_Frequency(self: *const T, plFrequency: ?*i32) HRESULT {
                return @as(*const ITCustomTone.VTable, @ptrCast(self.vtable)).get_Frequency(@as(*const ITCustomTone, @ptrCast(self)), plFrequency);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCustomTone_put_Frequency(self: *const T, lFrequency: i32) HRESULT {
                return @as(*const ITCustomTone.VTable, @ptrCast(self.vtable)).put_Frequency(@as(*const ITCustomTone, @ptrCast(self)), lFrequency);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCustomTone_get_CadenceOn(self: *const T, plCadenceOn: ?*i32) HRESULT {
                return @as(*const ITCustomTone.VTable, @ptrCast(self.vtable)).get_CadenceOn(@as(*const ITCustomTone, @ptrCast(self)), plCadenceOn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCustomTone_put_CadenceOn(self: *const T, CadenceOn: i32) HRESULT {
                return @as(*const ITCustomTone.VTable, @ptrCast(self.vtable)).put_CadenceOn(@as(*const ITCustomTone, @ptrCast(self)), CadenceOn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCustomTone_get_CadenceOff(self: *const T, plCadenceOff: ?*i32) HRESULT {
                return @as(*const ITCustomTone.VTable, @ptrCast(self.vtable)).get_CadenceOff(@as(*const ITCustomTone, @ptrCast(self)), plCadenceOff);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCustomTone_put_CadenceOff(self: *const T, lCadenceOff: i32) HRESULT {
                return @as(*const ITCustomTone.VTable, @ptrCast(self.vtable)).put_CadenceOff(@as(*const ITCustomTone, @ptrCast(self)), lCadenceOff);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCustomTone_get_Volume(self: *const T, plVolume: ?*i32) HRESULT {
                return @as(*const ITCustomTone.VTable, @ptrCast(self.vtable)).get_Volume(@as(*const ITCustomTone, @ptrCast(self)), plVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCustomTone_put_Volume(self: *const T, lVolume: i32) HRESULT {
                return @as(*const ITCustomTone.VTable, @ptrCast(self.vtable)).put_Volume(@as(*const ITCustomTone, @ptrCast(self)), lVolume);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumPhone_Value = Guid.initString("f15b7669-4780-4595-8c89-fb369c8cf7aa");
pub const IID_IEnumPhone = &IID_IEnumPhone_Value;
pub const IEnumPhone = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPhone,
                celt: u32,
                ppElements: [*]?*ITPhone,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPhone,
                celt: u32,
                ppElements: [*]?*ITPhone,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPhone,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPhone,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPhone,
                ppEnum: ?*?*IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPhone,
                ppEnum: ?*?*IEnumPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPhone_Next(self: *const T, celt: u32, ppElements: [*]?*ITPhone, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumPhone.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumPhone, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPhone_Reset(self: *const T) HRESULT {
                return @as(*const IEnumPhone.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumPhone, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPhone_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumPhone.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumPhone, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPhone_Clone(self: *const T, ppEnum: ?*?*IEnumPhone) HRESULT {
                return @as(*const IEnumPhone.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumPhone, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTerminal_Value = Guid.initString("ae269cf4-935e-11d0-835c-00aa003ccabd");
pub const IID_IEnumTerminal = &IID_IEnumTerminal_Value;
pub const IEnumTerminal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTerminal,
                celt: u32,
                ppElements: ?*?*ITTerminal,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTerminal,
                celt: u32,
                ppElements: ?*?*ITTerminal,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTerminal,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTerminal,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTerminal,
                ppEnum: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTerminal,
                ppEnum: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTerminal_Next(self: *const T, celt: u32, ppElements: ?*?*ITTerminal, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumTerminal.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTerminal, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTerminal_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTerminal.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTerminal, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTerminal_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumTerminal.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTerminal, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTerminal_Clone(self: *const T, ppEnum: ?*?*IEnumTerminal) HRESULT {
                return @as(*const IEnumTerminal.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTerminal, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTerminalClass_Value = Guid.initString("ae269cf5-935e-11d0-835c-00aa003ccabd");
pub const IID_IEnumTerminalClass = &IID_IEnumTerminalClass_Value;
pub const IEnumTerminalClass = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTerminalClass,
                celt: u32,
                pElements: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTerminalClass,
                celt: u32,
                pElements: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTerminalClass,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTerminalClass,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTerminalClass,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTerminalClass,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTerminalClass,
                ppEnum: ?*?*IEnumTerminalClass,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTerminalClass,
                ppEnum: ?*?*IEnumTerminalClass,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTerminalClass_Next(self: *const T, celt: u32, pElements: [*]Guid, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumTerminalClass.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTerminalClass, @ptrCast(self)), celt, pElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTerminalClass_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTerminalClass.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTerminalClass, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTerminalClass_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumTerminalClass.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTerminalClass, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTerminalClass_Clone(self: *const T, ppEnum: ?*?*IEnumTerminalClass) HRESULT {
                return @as(*const IEnumTerminalClass.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTerminalClass, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumCall_Value = Guid.initString("ae269cf6-935e-11d0-835c-00aa003ccabd");
pub const IID_IEnumCall = &IID_IEnumCall_Value;
pub const IEnumCall = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCall,
                celt: u32,
                ppElements: ?*?*ITCallInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCall,
                celt: u32,
                ppElements: ?*?*ITCallInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCall,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCall,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCall,
                ppEnum: ?*?*IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCall,
                ppEnum: ?*?*IEnumCall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCall_Next(self: *const T, celt: u32, ppElements: ?*?*ITCallInfo, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumCall.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumCall, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCall_Reset(self: *const T) HRESULT {
                return @as(*const IEnumCall.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumCall, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCall_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumCall.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumCall, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCall_Clone(self: *const T, ppEnum: ?*?*IEnumCall) HRESULT {
                return @as(*const IEnumCall.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumCall, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumAddress_Value = Guid.initString("1666fca1-9363-11d0-835c-00aa003ccabd");
pub const IID_IEnumAddress = &IID_IEnumAddress_Value;
pub const IEnumAddress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAddress,
                celt: u32,
                ppElements: [*]?*ITAddress,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAddress,
                celt: u32,
                ppElements: [*]?*ITAddress,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAddress,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAddress,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAddress,
                ppEnum: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAddress,
                ppEnum: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAddress_Next(self: *const T, celt: u32, ppElements: [*]?*ITAddress, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumAddress.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumAddress, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAddress_Reset(self: *const T) HRESULT {
                return @as(*const IEnumAddress.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumAddress, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAddress_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumAddress.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumAddress, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAddress_Clone(self: *const T, ppEnum: ?*?*IEnumAddress) HRESULT {
                return @as(*const IEnumAddress.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumAddress, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumCallHub_Value = Guid.initString("a3c15450-5b92-11d1-8f4e-00c04fb6809f");
pub const IID_IEnumCallHub = &IID_IEnumCallHub_Value;
pub const IEnumCallHub = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCallHub,
                celt: u32,
                ppElements: [*]?*ITCallHub,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCallHub,
                celt: u32,
                ppElements: [*]?*ITCallHub,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCallHub,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCallHub,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCallHub,
                ppEnum: ?*?*IEnumCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCallHub,
                ppEnum: ?*?*IEnumCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCallHub_Next(self: *const T, celt: u32, ppElements: [*]?*ITCallHub, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumCallHub.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumCallHub, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCallHub_Reset(self: *const T) HRESULT {
                return @as(*const IEnumCallHub.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumCallHub, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCallHub_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumCallHub.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumCallHub, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCallHub_Clone(self: *const T, ppEnum: ?*?*IEnumCallHub) HRESULT {
                return @as(*const IEnumCallHub.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumCallHub, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumBstr_Value = Guid.initString("35372049-0bc6-11d2-a033-00c04fb6809f");
pub const IID_IEnumBstr = &IID_IEnumBstr_Value;
pub const IEnumBstr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumBstr,
                celt: u32,
                ppStrings: [*]?BSTR,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumBstr,
                celt: u32,
                ppStrings: [*]?BSTR,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumBstr,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumBstr,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumBstr,
                ppEnum: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumBstr,
                ppEnum: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumBstr_Next(self: *const T, celt: u32, ppStrings: [*]?BSTR, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumBstr.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumBstr, @ptrCast(self)), celt, ppStrings, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumBstr_Reset(self: *const T) HRESULT {
                return @as(*const IEnumBstr.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumBstr, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumBstr_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumBstr.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumBstr, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumBstr_Clone(self: *const T, ppEnum: ?*?*IEnumBstr) HRESULT {
                return @as(*const IEnumBstr.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumBstr, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumPluggableTerminalClassInfo_Value = Guid.initString("4567450c-dbee-4e3f-aaf5-37bf9ebf5e29");
pub const IID_IEnumPluggableTerminalClassInfo = &IID_IEnumPluggableTerminalClassInfo_Value;
pub const IEnumPluggableTerminalClassInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPluggableTerminalClassInfo,
                celt: u32,
                ppElements: [*]?*ITPluggableTerminalClassInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPluggableTerminalClassInfo,
                celt: u32,
                ppElements: [*]?*ITPluggableTerminalClassInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPluggableTerminalClassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPluggableTerminalClassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPluggableTerminalClassInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPluggableTerminalClassInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPluggableTerminalClassInfo,
                ppEnum: ?*?*IEnumPluggableTerminalClassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPluggableTerminalClassInfo,
                ppEnum: ?*?*IEnumPluggableTerminalClassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPluggableTerminalClassInfo_Next(self: *const T, celt: u32, ppElements: [*]?*ITPluggableTerminalClassInfo, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumPluggableTerminalClassInfo, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPluggableTerminalClassInfo_Reset(self: *const T) HRESULT {
                return @as(*const IEnumPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumPluggableTerminalClassInfo, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPluggableTerminalClassInfo_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumPluggableTerminalClassInfo, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPluggableTerminalClassInfo_Clone(self: *const T, ppEnum: ?*?*IEnumPluggableTerminalClassInfo) HRESULT {
                return @as(*const IEnumPluggableTerminalClassInfo.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumPluggableTerminalClassInfo, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumPluggableSuperclassInfo_Value = Guid.initString("e9586a80-89e6-4cff-931d-478d5751f4c0");
pub const IID_IEnumPluggableSuperclassInfo = &IID_IEnumPluggableSuperclassInfo_Value;
pub const IEnumPluggableSuperclassInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPluggableSuperclassInfo,
                celt: u32,
                ppElements: [*]?*ITPluggableTerminalSuperclassInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPluggableSuperclassInfo,
                celt: u32,
                ppElements: [*]?*ITPluggableTerminalSuperclassInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPluggableSuperclassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPluggableSuperclassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPluggableSuperclassInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPluggableSuperclassInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPluggableSuperclassInfo,
                ppEnum: ?*?*IEnumPluggableSuperclassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPluggableSuperclassInfo,
                ppEnum: ?*?*IEnumPluggableSuperclassInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPluggableSuperclassInfo_Next(self: *const T, celt: u32, ppElements: [*]?*ITPluggableTerminalSuperclassInfo, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumPluggableSuperclassInfo.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumPluggableSuperclassInfo, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPluggableSuperclassInfo_Reset(self: *const T) HRESULT {
                return @as(*const IEnumPluggableSuperclassInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumPluggableSuperclassInfo, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPluggableSuperclassInfo_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumPluggableSuperclassInfo.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumPluggableSuperclassInfo, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPluggableSuperclassInfo_Clone(self: *const T, ppEnum: ?*?*IEnumPluggableSuperclassInfo) HRESULT {
                return @as(*const IEnumPluggableSuperclassInfo.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumPluggableSuperclassInfo, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITPhoneEvent_Value = Guid.initString("8f942dd8-64ed-4aaf-a77d-b23db0837ead");
pub const IID_ITPhoneEvent = &IID_ITPhoneEvent_Value;
pub const ITPhoneEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Phone: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneEvent,
                ppPhone: ?*?*ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneEvent,
                ppPhone: ?*?*ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneEvent,
                pEvent: ?*PHONE_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneEvent,
                pEvent: ?*PHONE_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneEvent,
                pState: ?*PHONE_BUTTON_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneEvent,
                pState: ?*PHONE_BUTTON_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HookSwitchState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneEvent,
                pState: ?*PHONE_HOOK_SWITCH_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneEvent,
                pState: ?*PHONE_HOOK_SWITCH_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HookSwitchDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneEvent,
                pDevice: ?*PHONE_HOOK_SWITCH_DEVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneEvent,
                pDevice: ?*PHONE_HOOK_SWITCH_DEVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RingMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneEvent,
                plRingMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneEvent,
                plRingMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonLampId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneEvent,
                plButtonLampId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneEvent,
                plButtonLampId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberGathered: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneEvent,
                ppNumber: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneEvent,
                ppNumber: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneEvent_get_Phone(self: *const T, ppPhone: ?*?*ITPhone) HRESULT {
                return @as(*const ITPhoneEvent.VTable, @ptrCast(self.vtable)).get_Phone(@as(*const ITPhoneEvent, @ptrCast(self)), ppPhone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneEvent_get_Event(self: *const T, pEvent: ?*PHONE_EVENT) HRESULT {
                return @as(*const ITPhoneEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITPhoneEvent, @ptrCast(self)), pEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneEvent_get_ButtonState(self: *const T, pState: ?*PHONE_BUTTON_STATE) HRESULT {
                return @as(*const ITPhoneEvent.VTable, @ptrCast(self.vtable)).get_ButtonState(@as(*const ITPhoneEvent, @ptrCast(self)), pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneEvent_get_HookSwitchState(self: *const T, pState: ?*PHONE_HOOK_SWITCH_STATE) HRESULT {
                return @as(*const ITPhoneEvent.VTable, @ptrCast(self.vtable)).get_HookSwitchState(@as(*const ITPhoneEvent, @ptrCast(self)), pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneEvent_get_HookSwitchDevice(self: *const T, pDevice: ?*PHONE_HOOK_SWITCH_DEVICE) HRESULT {
                return @as(*const ITPhoneEvent.VTable, @ptrCast(self.vtable)).get_HookSwitchDevice(@as(*const ITPhoneEvent, @ptrCast(self)), pDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneEvent_get_RingMode(self: *const T, plRingMode: ?*i32) HRESULT {
                return @as(*const ITPhoneEvent.VTable, @ptrCast(self.vtable)).get_RingMode(@as(*const ITPhoneEvent, @ptrCast(self)), plRingMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneEvent_get_ButtonLampId(self: *const T, plButtonLampId: ?*i32) HRESULT {
                return @as(*const ITPhoneEvent.VTable, @ptrCast(self.vtable)).get_ButtonLampId(@as(*const ITPhoneEvent, @ptrCast(self)), plButtonLampId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneEvent_get_NumberGathered(self: *const T, ppNumber: ?*?BSTR) HRESULT {
                return @as(*const ITPhoneEvent.VTable, @ptrCast(self.vtable)).get_NumberGathered(@as(*const ITPhoneEvent, @ptrCast(self)), ppNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneEvent_get_Call(self: *const T, ppCallInfo: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITPhoneEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITPhoneEvent, @ptrCast(self)), ppCallInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCallStateEvent_Value = Guid.initString("62f47097-95c9-11d0-835d-00aa003ccabd");
pub const IID_ITCallStateEvent = &IID_ITCallStateEvent_Value;
pub const ITCallStateEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallStateEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallStateEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallStateEvent,
                pCallState: ?*CALL_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallStateEvent,
                pCallState: ?*CALL_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cause: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallStateEvent,
                pCEC: ?*CALL_STATE_EVENT_CAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallStateEvent,
                pCEC: ?*CALL_STATE_EVENT_CAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallbackInstance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallStateEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallStateEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallStateEvent_get_Call(self: *const T, ppCallInfo: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITCallStateEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITCallStateEvent, @ptrCast(self)), ppCallInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallStateEvent_get_State(self: *const T, pCallState: ?*CALL_STATE) HRESULT {
                return @as(*const ITCallStateEvent.VTable, @ptrCast(self.vtable)).get_State(@as(*const ITCallStateEvent, @ptrCast(self)), pCallState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallStateEvent_get_Cause(self: *const T, pCEC: ?*CALL_STATE_EVENT_CAUSE) HRESULT {
                return @as(*const ITCallStateEvent.VTable, @ptrCast(self.vtable)).get_Cause(@as(*const ITCallStateEvent, @ptrCast(self)), pCEC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallStateEvent_get_CallbackInstance(self: *const T, plCallbackInstance: ?*i32) HRESULT {
                return @as(*const ITCallStateEvent.VTable, @ptrCast(self.vtable)).get_CallbackInstance(@as(*const ITCallStateEvent, @ptrCast(self)), plCallbackInstance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITPhoneDeviceSpecificEvent_Value = Guid.initString("63ffb2a6-872b-4cd3-a501-326e8fb40af7");
pub const IID_ITPhoneDeviceSpecificEvent = &IID_ITPhoneDeviceSpecificEvent_Value;
pub const ITPhoneDeviceSpecificEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Phone: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneDeviceSpecificEvent,
                ppPhone: ?*?*ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneDeviceSpecificEvent,
                ppPhone: ?*?*ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lParam1: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneDeviceSpecificEvent,
                pParam1: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneDeviceSpecificEvent,
                pParam1: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lParam2: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneDeviceSpecificEvent,
                pParam2: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneDeviceSpecificEvent,
                pParam2: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lParam3: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITPhoneDeviceSpecificEvent,
                pParam3: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITPhoneDeviceSpecificEvent,
                pParam3: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneDeviceSpecificEvent_get_Phone(self: *const T, ppPhone: ?*?*ITPhone) HRESULT {
                return @as(*const ITPhoneDeviceSpecificEvent.VTable, @ptrCast(self.vtable)).get_Phone(@as(*const ITPhoneDeviceSpecificEvent, @ptrCast(self)), ppPhone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneDeviceSpecificEvent_get_lParam1(self: *const T, pParam1: ?*i32) HRESULT {
                return @as(*const ITPhoneDeviceSpecificEvent.VTable, @ptrCast(self.vtable)).get_lParam1(@as(*const ITPhoneDeviceSpecificEvent, @ptrCast(self)), pParam1);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneDeviceSpecificEvent_get_lParam2(self: *const T, pParam2: ?*i32) HRESULT {
                return @as(*const ITPhoneDeviceSpecificEvent.VTable, @ptrCast(self.vtable)).get_lParam2(@as(*const ITPhoneDeviceSpecificEvent, @ptrCast(self)), pParam2);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPhoneDeviceSpecificEvent_get_lParam3(self: *const T, pParam3: ?*i32) HRESULT {
                return @as(*const ITPhoneDeviceSpecificEvent.VTable, @ptrCast(self.vtable)).get_lParam3(@as(*const ITPhoneDeviceSpecificEvent, @ptrCast(self)), pParam3);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCallMediaEvent_Value = Guid.initString("ff36b87f-ec3a-11d0-8ee4-00c04fb6809f");
pub const IID_ITCallMediaEvent = &IID_ITCallMediaEvent_Value;
pub const ITCallMediaEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallMediaEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallMediaEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallMediaEvent,
                pCallMediaEvent: ?*CALL_MEDIA_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallMediaEvent,
                pCallMediaEvent: ?*CALL_MEDIA_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallMediaEvent,
                phrError: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallMediaEvent,
                phrError: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Terminal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallMediaEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallMediaEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Stream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallMediaEvent,
                ppStream: ?*?*ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallMediaEvent,
                ppStream: ?*?*ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cause: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallMediaEvent,
                pCause: ?*CALL_MEDIA_EVENT_CAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallMediaEvent,
                pCause: ?*CALL_MEDIA_EVENT_CAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallMediaEvent_get_Call(self: *const T, ppCallInfo: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITCallMediaEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITCallMediaEvent, @ptrCast(self)), ppCallInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallMediaEvent_get_Event(self: *const T, pCallMediaEvent: ?*CALL_MEDIA_EVENT) HRESULT {
                return @as(*const ITCallMediaEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITCallMediaEvent, @ptrCast(self)), pCallMediaEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallMediaEvent_get_Error(self: *const T, phrError: ?*HRESULT) HRESULT {
                return @as(*const ITCallMediaEvent.VTable, @ptrCast(self.vtable)).get_Error(@as(*const ITCallMediaEvent, @ptrCast(self)), phrError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallMediaEvent_get_Terminal(self: *const T, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITCallMediaEvent.VTable, @ptrCast(self.vtable)).get_Terminal(@as(*const ITCallMediaEvent, @ptrCast(self)), ppTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallMediaEvent_get_Stream(self: *const T, ppStream: ?*?*ITStream) HRESULT {
                return @as(*const ITCallMediaEvent.VTable, @ptrCast(self.vtable)).get_Stream(@as(*const ITCallMediaEvent, @ptrCast(self)), ppStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallMediaEvent_get_Cause(self: *const T, pCause: ?*CALL_MEDIA_EVENT_CAUSE) HRESULT {
                return @as(*const ITCallMediaEvent.VTable, @ptrCast(self.vtable)).get_Cause(@as(*const ITCallMediaEvent, @ptrCast(self)), pCause);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITDigitDetectionEvent_Value = Guid.initString("80d3bfac-57d9-11d2-a04a-00c04fb6809f");
pub const IID_ITDigitDetectionEvent = &IID_ITDigitDetectionEvent_Value;
pub const ITDigitDetectionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitDetectionEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitDetectionEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Digit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitDetectionEvent,
                pucDigit: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitDetectionEvent,
                pucDigit: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DigitMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitDetectionEvent,
                pDigitMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitDetectionEvent,
                pDigitMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TickCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitDetectionEvent,
                plTickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitDetectionEvent,
                plTickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallbackInstance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitDetectionEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitDetectionEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitDetectionEvent_get_Call(self: *const T, ppCallInfo: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITDigitDetectionEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITDigitDetectionEvent, @ptrCast(self)), ppCallInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitDetectionEvent_get_Digit(self: *const T, pucDigit: ?*u8) HRESULT {
                return @as(*const ITDigitDetectionEvent.VTable, @ptrCast(self.vtable)).get_Digit(@as(*const ITDigitDetectionEvent, @ptrCast(self)), pucDigit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitDetectionEvent_get_DigitMode(self: *const T, pDigitMode: ?*i32) HRESULT {
                return @as(*const ITDigitDetectionEvent.VTable, @ptrCast(self.vtable)).get_DigitMode(@as(*const ITDigitDetectionEvent, @ptrCast(self)), pDigitMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitDetectionEvent_get_TickCount(self: *const T, plTickCount: ?*i32) HRESULT {
                return @as(*const ITDigitDetectionEvent.VTable, @ptrCast(self.vtable)).get_TickCount(@as(*const ITDigitDetectionEvent, @ptrCast(self)), plTickCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitDetectionEvent_get_CallbackInstance(self: *const T, plCallbackInstance: ?*i32) HRESULT {
                return @as(*const ITDigitDetectionEvent.VTable, @ptrCast(self.vtable)).get_CallbackInstance(@as(*const ITDigitDetectionEvent, @ptrCast(self)), plCallbackInstance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITDigitGenerationEvent_Value = Guid.initString("80d3bfad-57d9-11d2-a04a-00c04fb6809f");
pub const IID_ITDigitGenerationEvent = &IID_ITDigitGenerationEvent_Value;
pub const ITDigitGenerationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitGenerationEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitGenerationEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GenerationTermination: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitGenerationEvent,
                plGenerationTermination: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitGenerationEvent,
                plGenerationTermination: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TickCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitGenerationEvent,
                plTickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitGenerationEvent,
                plTickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallbackInstance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitGenerationEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitGenerationEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitGenerationEvent_get_Call(self: *const T, ppCallInfo: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITDigitGenerationEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITDigitGenerationEvent, @ptrCast(self)), ppCallInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitGenerationEvent_get_GenerationTermination(self: *const T, plGenerationTermination: ?*i32) HRESULT {
                return @as(*const ITDigitGenerationEvent.VTable, @ptrCast(self.vtable)).get_GenerationTermination(@as(*const ITDigitGenerationEvent, @ptrCast(self)), plGenerationTermination);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitGenerationEvent_get_TickCount(self: *const T, plTickCount: ?*i32) HRESULT {
                return @as(*const ITDigitGenerationEvent.VTable, @ptrCast(self.vtable)).get_TickCount(@as(*const ITDigitGenerationEvent, @ptrCast(self)), plTickCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitGenerationEvent_get_CallbackInstance(self: *const T, plCallbackInstance: ?*i32) HRESULT {
                return @as(*const ITDigitGenerationEvent.VTable, @ptrCast(self.vtable)).get_CallbackInstance(@as(*const ITDigitGenerationEvent, @ptrCast(self)), plCallbackInstance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITDigitsGatheredEvent_Value = Guid.initString("e52ec4c1-cba3-441a-9e6a-93cb909e9724");
pub const IID_ITDigitsGatheredEvent = &IID_ITDigitsGatheredEvent_Value;
pub const ITDigitsGatheredEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitsGatheredEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitsGatheredEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Digits: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitsGatheredEvent,
                ppDigits: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitsGatheredEvent,
                ppDigits: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GatherTermination: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitsGatheredEvent,
                pGatherTermination: ?*TAPI_GATHERTERM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitsGatheredEvent,
                pGatherTermination: ?*TAPI_GATHERTERM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TickCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitsGatheredEvent,
                plTickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitsGatheredEvent,
                plTickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallbackInstance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDigitsGatheredEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDigitsGatheredEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitsGatheredEvent_get_Call(self: *const T, ppCallInfo: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITDigitsGatheredEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITDigitsGatheredEvent, @ptrCast(self)), ppCallInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitsGatheredEvent_get_Digits(self: *const T, ppDigits: ?*?BSTR) HRESULT {
                return @as(*const ITDigitsGatheredEvent.VTable, @ptrCast(self.vtable)).get_Digits(@as(*const ITDigitsGatheredEvent, @ptrCast(self)), ppDigits);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitsGatheredEvent_get_GatherTermination(self: *const T, pGatherTermination: ?*TAPI_GATHERTERM) HRESULT {
                return @as(*const ITDigitsGatheredEvent.VTable, @ptrCast(self.vtable)).get_GatherTermination(@as(*const ITDigitsGatheredEvent, @ptrCast(self)), pGatherTermination);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitsGatheredEvent_get_TickCount(self: *const T, plTickCount: ?*i32) HRESULT {
                return @as(*const ITDigitsGatheredEvent.VTable, @ptrCast(self.vtable)).get_TickCount(@as(*const ITDigitsGatheredEvent, @ptrCast(self)), plTickCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDigitsGatheredEvent_get_CallbackInstance(self: *const T, plCallbackInstance: ?*i32) HRESULT {
                return @as(*const ITDigitsGatheredEvent.VTable, @ptrCast(self.vtable)).get_CallbackInstance(@as(*const ITDigitsGatheredEvent, @ptrCast(self)), plCallbackInstance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITToneDetectionEvent_Value = Guid.initString("407e0faf-d047-4753-b0c6-8e060373fecd");
pub const IID_ITToneDetectionEvent = &IID_ITToneDetectionEvent_Value;
pub const ITToneDetectionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITToneDetectionEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITToneDetectionEvent,
                ppCallInfo: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppSpecific: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITToneDetectionEvent,
                plAppSpecific: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITToneDetectionEvent,
                plAppSpecific: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TickCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITToneDetectionEvent,
                plTickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITToneDetectionEvent,
                plTickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallbackInstance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITToneDetectionEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITToneDetectionEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITToneDetectionEvent_get_Call(self: *const T, ppCallInfo: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITToneDetectionEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITToneDetectionEvent, @ptrCast(self)), ppCallInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITToneDetectionEvent_get_AppSpecific(self: *const T, plAppSpecific: ?*i32) HRESULT {
                return @as(*const ITToneDetectionEvent.VTable, @ptrCast(self.vtable)).get_AppSpecific(@as(*const ITToneDetectionEvent, @ptrCast(self)), plAppSpecific);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITToneDetectionEvent_get_TickCount(self: *const T, plTickCount: ?*i32) HRESULT {
                return @as(*const ITToneDetectionEvent.VTable, @ptrCast(self.vtable)).get_TickCount(@as(*const ITToneDetectionEvent, @ptrCast(self)), plTickCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITToneDetectionEvent_get_CallbackInstance(self: *const T, plCallbackInstance: ?*i32) HRESULT {
                return @as(*const ITToneDetectionEvent.VTable, @ptrCast(self.vtable)).get_CallbackInstance(@as(*const ITToneDetectionEvent, @ptrCast(self)), plCallbackInstance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTAPIObjectEvent_Value = Guid.initString("f4854d48-937a-11d1-bb58-00c04fb6809f");
pub const IID_ITTAPIObjectEvent = &IID_ITTAPIObjectEvent_Value;
pub const ITTAPIObjectEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TAPIObject: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPIObjectEvent,
                ppTAPIObject: ?*?*ITTAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPIObjectEvent,
                ppTAPIObject: ?*?*ITTAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPIObjectEvent,
                pEvent: ?*TAPIOBJECT_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPIObjectEvent,
                pEvent: ?*TAPIOBJECT_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Address: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPIObjectEvent,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPIObjectEvent,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallbackInstance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPIObjectEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPIObjectEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPIObjectEvent_get_TAPIObject(self: *const T, ppTAPIObject: ?*?*ITTAPI) HRESULT {
                return @as(*const ITTAPIObjectEvent.VTable, @ptrCast(self.vtable)).get_TAPIObject(@as(*const ITTAPIObjectEvent, @ptrCast(self)), ppTAPIObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPIObjectEvent_get_Event(self: *const T, pEvent: ?*TAPIOBJECT_EVENT) HRESULT {
                return @as(*const ITTAPIObjectEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITTAPIObjectEvent, @ptrCast(self)), pEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPIObjectEvent_get_Address(self: *const T, ppAddress: ?*?*ITAddress) HRESULT {
                return @as(*const ITTAPIObjectEvent.VTable, @ptrCast(self.vtable)).get_Address(@as(*const ITTAPIObjectEvent, @ptrCast(self)), ppAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPIObjectEvent_get_CallbackInstance(self: *const T, plCallbackInstance: ?*i32) HRESULT {
                return @as(*const ITTAPIObjectEvent.VTable, @ptrCast(self.vtable)).get_CallbackInstance(@as(*const ITTAPIObjectEvent, @ptrCast(self)), plCallbackInstance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTAPIObjectEvent2_Value = Guid.initString("359dda6e-68ce-4383-bf0b-169133c41b46");
pub const IID_ITTAPIObjectEvent2 = &IID_ITTAPIObjectEvent2_Value;
pub const ITTAPIObjectEvent2 = extern struct {
    pub const VTable = extern struct {
        base: ITTAPIObjectEvent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Phone: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPIObjectEvent2,
                ppPhone: ?*?*ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPIObjectEvent2,
                ppPhone: ?*?*ITPhone,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITTAPIObjectEvent.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPIObjectEvent2_get_Phone(self: *const T, ppPhone: ?*?*ITPhone) HRESULT {
                return @as(*const ITTAPIObjectEvent2.VTable, @ptrCast(self.vtable)).get_Phone(@as(*const ITTAPIObjectEvent2, @ptrCast(self)), ppPhone);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTAPIEventNotification_Value = Guid.initString("eddb9426-3b91-11d1-8f30-00c04fb6809f");
pub const IID_ITTAPIEventNotification = &IID_ITTAPIEventNotification_Value;
pub const ITTAPIEventNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Event: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPIEventNotification,
                TapiEvent: TAPI_EVENT,
                pEvent: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPIEventNotification,
                TapiEvent: TAPI_EVENT,
                pEvent: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPIEventNotification_Event(self: *const T, TapiEvent: TAPI_EVENT, pEvent: ?*IDispatch) HRESULT {
                return @as(*const ITTAPIEventNotification.VTable, @ptrCast(self.vtable)).Event(@as(*const ITTAPIEventNotification, @ptrCast(self)), TapiEvent, pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCallHubEvent_Value = Guid.initString("a3c15451-5b92-11d1-8f4e-00c04fb6809f");
pub const IID_ITCallHubEvent = &IID_ITCallHubEvent_Value;
pub const ITCallHubEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallHubEvent,
                pEvent: ?*CALLHUB_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallHubEvent,
                pEvent: ?*CALLHUB_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallHub: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallHubEvent,
                ppCallHub: ?*?*ITCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallHubEvent,
                ppCallHub: ?*?*ITCallHub,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallHubEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallHubEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallHubEvent_get_Event(self: *const T, pEvent: ?*CALLHUB_EVENT) HRESULT {
                return @as(*const ITCallHubEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITCallHubEvent, @ptrCast(self)), pEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallHubEvent_get_CallHub(self: *const T, ppCallHub: ?*?*ITCallHub) HRESULT {
                return @as(*const ITCallHubEvent.VTable, @ptrCast(self.vtable)).get_CallHub(@as(*const ITCallHubEvent, @ptrCast(self)), ppCallHub);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallHubEvent_get_Call(self: *const T, ppCall: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITCallHubEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITCallHubEvent, @ptrCast(self)), ppCall);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAddressEvent_Value = Guid.initString("831ce2d1-83b5-11d1-bb5c-00c04fb6809f");
pub const IID_ITAddressEvent = &IID_ITAddressEvent_Value;
pub const ITAddressEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Address: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressEvent,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressEvent,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressEvent,
                pEvent: ?*ADDRESS_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressEvent,
                pEvent: ?*ADDRESS_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Terminal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressEvent_get_Address(self: *const T, ppAddress: ?*?*ITAddress) HRESULT {
                return @as(*const ITAddressEvent.VTable, @ptrCast(self.vtable)).get_Address(@as(*const ITAddressEvent, @ptrCast(self)), ppAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressEvent_get_Event(self: *const T, pEvent: ?*ADDRESS_EVENT) HRESULT {
                return @as(*const ITAddressEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITAddressEvent, @ptrCast(self)), pEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressEvent_get_Terminal(self: *const T, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITAddressEvent.VTable, @ptrCast(self.vtable)).get_Terminal(@as(*const ITAddressEvent, @ptrCast(self)), ppTerminal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAddressDeviceSpecificEvent_Value = Guid.initString("3acb216b-40bd-487a-8672-5ce77bd7e3a3");
pub const IID_ITAddressDeviceSpecificEvent = &IID_ITAddressDeviceSpecificEvent_Value;
pub const ITAddressDeviceSpecificEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Address: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressDeviceSpecificEvent,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressDeviceSpecificEvent,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressDeviceSpecificEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressDeviceSpecificEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lParam1: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressDeviceSpecificEvent,
                pParam1: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressDeviceSpecificEvent,
                pParam1: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lParam2: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressDeviceSpecificEvent,
                pParam2: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressDeviceSpecificEvent,
                pParam2: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lParam3: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressDeviceSpecificEvent,
                pParam3: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressDeviceSpecificEvent,
                pParam3: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressDeviceSpecificEvent_get_Address(self: *const T, ppAddress: ?*?*ITAddress) HRESULT {
                return @as(*const ITAddressDeviceSpecificEvent.VTable, @ptrCast(self.vtable)).get_Address(@as(*const ITAddressDeviceSpecificEvent, @ptrCast(self)), ppAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressDeviceSpecificEvent_get_Call(self: *const T, ppCall: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITAddressDeviceSpecificEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITAddressDeviceSpecificEvent, @ptrCast(self)), ppCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressDeviceSpecificEvent_get_lParam1(self: *const T, pParam1: ?*i32) HRESULT {
                return @as(*const ITAddressDeviceSpecificEvent.VTable, @ptrCast(self.vtable)).get_lParam1(@as(*const ITAddressDeviceSpecificEvent, @ptrCast(self)), pParam1);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressDeviceSpecificEvent_get_lParam2(self: *const T, pParam2: ?*i32) HRESULT {
                return @as(*const ITAddressDeviceSpecificEvent.VTable, @ptrCast(self.vtable)).get_lParam2(@as(*const ITAddressDeviceSpecificEvent, @ptrCast(self)), pParam2);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressDeviceSpecificEvent_get_lParam3(self: *const T, pParam3: ?*i32) HRESULT {
                return @as(*const ITAddressDeviceSpecificEvent.VTable, @ptrCast(self.vtable)).get_lParam3(@as(*const ITAddressDeviceSpecificEvent, @ptrCast(self)), pParam3);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITFileTerminalEvent_Value = Guid.initString("e4a7fbac-8c17-4427-9f55-9f589ac8af00");
pub const IID_ITFileTerminalEvent = &IID_ITFileTerminalEvent_Value;
pub const ITFileTerminalEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Terminal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTerminalEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTerminalEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Track: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTerminalEvent,
                ppTrackTerminal: ?*?*ITFileTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTerminalEvent,
                ppTrackTerminal: ?*?*ITFileTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTerminalEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTerminalEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTerminalEvent,
                pState: ?*TERMINAL_MEDIA_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTerminalEvent,
                pState: ?*TERMINAL_MEDIA_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cause: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTerminalEvent,
                pCause: ?*FT_STATE_EVENT_CAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTerminalEvent,
                pCause: ?*FT_STATE_EVENT_CAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITFileTerminalEvent,
                phrErrorCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITFileTerminalEvent,
                phrErrorCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTerminalEvent_get_Terminal(self: *const T, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITFileTerminalEvent.VTable, @ptrCast(self.vtable)).get_Terminal(@as(*const ITFileTerminalEvent, @ptrCast(self)), ppTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTerminalEvent_get_Track(self: *const T, ppTrackTerminal: ?*?*ITFileTrack) HRESULT {
                return @as(*const ITFileTerminalEvent.VTable, @ptrCast(self.vtable)).get_Track(@as(*const ITFileTerminalEvent, @ptrCast(self)), ppTrackTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTerminalEvent_get_Call(self: *const T, ppCall: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITFileTerminalEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITFileTerminalEvent, @ptrCast(self)), ppCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTerminalEvent_get_State(self: *const T, pState: ?*TERMINAL_MEDIA_STATE) HRESULT {
                return @as(*const ITFileTerminalEvent.VTable, @ptrCast(self.vtable)).get_State(@as(*const ITFileTerminalEvent, @ptrCast(self)), pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTerminalEvent_get_Cause(self: *const T, pCause: ?*FT_STATE_EVENT_CAUSE) HRESULT {
                return @as(*const ITFileTerminalEvent.VTable, @ptrCast(self.vtable)).get_Cause(@as(*const ITFileTerminalEvent, @ptrCast(self)), pCause);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITFileTerminalEvent_get_Error(self: *const T, phrErrorCode: ?*HRESULT) HRESULT {
                return @as(*const ITFileTerminalEvent.VTable, @ptrCast(self.vtable)).get_Error(@as(*const ITFileTerminalEvent, @ptrCast(self)), phrErrorCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTTSTerminalEvent_Value = Guid.initString("d964788f-95a5-461d-ab0c-b9900a6c2713");
pub const IID_ITTTSTerminalEvent = &IID_ITTTSTerminalEvent_Value;
pub const ITTTSTerminalEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Terminal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTTSTerminalEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTTSTerminalEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTTSTerminalEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTTSTerminalEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTTSTerminalEvent,
                phrErrorCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTTSTerminalEvent,
                phrErrorCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTTSTerminalEvent_get_Terminal(self: *const T, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITTTSTerminalEvent.VTable, @ptrCast(self.vtable)).get_Terminal(@as(*const ITTTSTerminalEvent, @ptrCast(self)), ppTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTTSTerminalEvent_get_Call(self: *const T, ppCall: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITTTSTerminalEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITTTSTerminalEvent, @ptrCast(self)), ppCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTTSTerminalEvent_get_Error(self: *const T, phrErrorCode: ?*HRESULT) HRESULT {
                return @as(*const ITTTSTerminalEvent.VTable, @ptrCast(self.vtable)).get_Error(@as(*const ITTTSTerminalEvent, @ptrCast(self)), phrErrorCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITASRTerminalEvent_Value = Guid.initString("ee016a02-4fa9-467c-933f-5a15b12377d7");
pub const IID_ITASRTerminalEvent = &IID_ITASRTerminalEvent_Value;
pub const ITASRTerminalEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Terminal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITASRTerminalEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITASRTerminalEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITASRTerminalEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITASRTerminalEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITASRTerminalEvent,
                phrErrorCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITASRTerminalEvent,
                phrErrorCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITASRTerminalEvent_get_Terminal(self: *const T, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITASRTerminalEvent.VTable, @ptrCast(self.vtable)).get_Terminal(@as(*const ITASRTerminalEvent, @ptrCast(self)), ppTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITASRTerminalEvent_get_Call(self: *const T, ppCall: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITASRTerminalEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITASRTerminalEvent, @ptrCast(self)), ppCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITASRTerminalEvent_get_Error(self: *const T, phrErrorCode: ?*HRESULT) HRESULT {
                return @as(*const ITASRTerminalEvent.VTable, @ptrCast(self.vtable)).get_Error(@as(*const ITASRTerminalEvent, @ptrCast(self)), phrErrorCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITToneTerminalEvent_Value = Guid.initString("e6f56009-611f-4945-bbd2-2d0ce5612056");
pub const IID_ITToneTerminalEvent = &IID_ITToneTerminalEvent_Value;
pub const ITToneTerminalEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Terminal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITToneTerminalEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITToneTerminalEvent,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITToneTerminalEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITToneTerminalEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITToneTerminalEvent,
                phrErrorCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITToneTerminalEvent,
                phrErrorCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITToneTerminalEvent_get_Terminal(self: *const T, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITToneTerminalEvent.VTable, @ptrCast(self.vtable)).get_Terminal(@as(*const ITToneTerminalEvent, @ptrCast(self)), ppTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITToneTerminalEvent_get_Call(self: *const T, ppCall: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITToneTerminalEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITToneTerminalEvent, @ptrCast(self)), ppCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITToneTerminalEvent_get_Error(self: *const T, phrErrorCode: ?*HRESULT) HRESULT {
                return @as(*const ITToneTerminalEvent.VTable, @ptrCast(self.vtable)).get_Error(@as(*const ITToneTerminalEvent, @ptrCast(self)), phrErrorCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITQOSEvent_Value = Guid.initString("cfa3357c-ad77-11d1-bb68-00c04fb6809f");
pub const IID_ITQOSEvent = &IID_ITQOSEvent_Value;
pub const ITQOSEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQOSEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQOSEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQOSEvent,
                pQosEvent: ?*QOS_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQOSEvent,
                pQosEvent: ?*QOS_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQOSEvent,
                plMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQOSEvent,
                plMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQOSEvent_get_Call(self: *const T, ppCall: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITQOSEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITQOSEvent, @ptrCast(self)), ppCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQOSEvent_get_Event(self: *const T, pQosEvent: ?*QOS_EVENT) HRESULT {
                return @as(*const ITQOSEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITQOSEvent, @ptrCast(self)), pQosEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQOSEvent_get_MediaType(self: *const T, plMediaType: ?*i32) HRESULT {
                return @as(*const ITQOSEvent.VTable, @ptrCast(self.vtable)).get_MediaType(@as(*const ITQOSEvent, @ptrCast(self)), plMediaType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCallInfoChangeEvent_Value = Guid.initString("5d4b65f9-e51c-11d1-a02f-00c04fb6809f");
pub const IID_ITCallInfoChangeEvent = &IID_ITCallInfoChangeEvent_Value;
pub const ITCallInfoChangeEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfoChangeEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfoChangeEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cause: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfoChangeEvent,
                pCIC: ?*CALLINFOCHANGE_CAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfoChangeEvent,
                pCIC: ?*CALLINFOCHANGE_CAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallbackInstance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallInfoChangeEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallInfoChangeEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfoChangeEvent_get_Call(self: *const T, ppCall: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITCallInfoChangeEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITCallInfoChangeEvent, @ptrCast(self)), ppCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfoChangeEvent_get_Cause(self: *const T, pCIC: ?*CALLINFOCHANGE_CAUSE) HRESULT {
                return @as(*const ITCallInfoChangeEvent.VTable, @ptrCast(self.vtable)).get_Cause(@as(*const ITCallInfoChangeEvent, @ptrCast(self)), pCIC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallInfoChangeEvent_get_CallbackInstance(self: *const T, plCallbackInstance: ?*i32) HRESULT {
                return @as(*const ITCallInfoChangeEvent.VTable, @ptrCast(self.vtable)).get_CallbackInstance(@as(*const ITCallInfoChangeEvent, @ptrCast(self)), plCallbackInstance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITRequest_Value = Guid.initString("ac48ffdf-f8c4-11d1-a030-00c04fb6809f");
pub const IID_ITRequest = &IID_ITRequest_Value;
pub const ITRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        MakeCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITRequest,
                pDestAddress: ?BSTR,
                pAppName: ?BSTR,
                pCalledParty: ?BSTR,
                pComment: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITRequest,
                pDestAddress: ?BSTR,
                pAppName: ?BSTR,
                pCalledParty: ?BSTR,
                pComment: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRequest_MakeCall(self: *const T, pDestAddress: ?BSTR, pAppName: ?BSTR, pCalledParty: ?BSTR, pComment: ?BSTR) HRESULT {
                return @as(*const ITRequest.VTable, @ptrCast(self.vtable)).MakeCall(@as(*const ITRequest, @ptrCast(self)), pDestAddress, pAppName, pCalledParty, pComment);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITRequestEvent_Value = Guid.initString("ac48ffde-f8c4-11d1-a030-00c04fb6809f");
pub const IID_ITRequestEvent = &IID_ITRequestEvent_Value;
pub const ITRequestEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegistrationInstance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITRequestEvent,
                plRegistrationInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITRequestEvent,
                plRegistrationInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITRequestEvent,
                plRequestMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITRequestEvent,
                plRequestMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITRequestEvent,
                ppDestAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITRequestEvent,
                ppDestAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITRequestEvent,
                ppAppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITRequestEvent,
                ppAppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CalledParty: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITRequestEvent,
                ppCalledParty: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITRequestEvent,
                ppCalledParty: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Comment: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITRequestEvent,
                ppComment: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITRequestEvent,
                ppComment: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRequestEvent_get_RegistrationInstance(self: *const T, plRegistrationInstance: ?*i32) HRESULT {
                return @as(*const ITRequestEvent.VTable, @ptrCast(self.vtable)).get_RegistrationInstance(@as(*const ITRequestEvent, @ptrCast(self)), plRegistrationInstance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRequestEvent_get_RequestMode(self: *const T, plRequestMode: ?*i32) HRESULT {
                return @as(*const ITRequestEvent.VTable, @ptrCast(self.vtable)).get_RequestMode(@as(*const ITRequestEvent, @ptrCast(self)), plRequestMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRequestEvent_get_DestAddress(self: *const T, ppDestAddress: ?*?BSTR) HRESULT {
                return @as(*const ITRequestEvent.VTable, @ptrCast(self.vtable)).get_DestAddress(@as(*const ITRequestEvent, @ptrCast(self)), ppDestAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRequestEvent_get_AppName(self: *const T, ppAppName: ?*?BSTR) HRESULT {
                return @as(*const ITRequestEvent.VTable, @ptrCast(self.vtable)).get_AppName(@as(*const ITRequestEvent, @ptrCast(self)), ppAppName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRequestEvent_get_CalledParty(self: *const T, ppCalledParty: ?*?BSTR) HRESULT {
                return @as(*const ITRequestEvent.VTable, @ptrCast(self.vtable)).get_CalledParty(@as(*const ITRequestEvent, @ptrCast(self)), ppCalledParty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRequestEvent_get_Comment(self: *const T, ppComment: ?*?BSTR) HRESULT {
                return @as(*const ITRequestEvent.VTable, @ptrCast(self.vtable)).get_Comment(@as(*const ITRequestEvent, @ptrCast(self)), ppComment);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCollection_Value = Guid.initString("5ec5acf2-9c02-11d0-8362-00aa003ccabd");
pub const IID_ITCollection = &IID_ITCollection_Value;
pub const ITCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCollection,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCollection,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCollection,
                Index: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCollection,
                Index: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCollection,
                ppNewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCollection,
                ppNewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCollection_get_Count(self: *const T, lCount: ?*i32) HRESULT {
                return @as(*const ITCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ITCollection, @ptrCast(self)), lCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCollection_get_Item(self: *const T, Index: i32, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const ITCollection, @ptrCast(self)), Index, pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCollection_get__NewEnum(self: *const T, ppNewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const ITCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ITCollection, @ptrCast(self)), ppNewEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCollection2_Value = Guid.initString("e6dddda5-a6d3-48ff-8737-d32fc4d95477");
pub const IID_ITCollection2 = &IID_ITCollection2_Value;
pub const ITCollection2 = extern struct {
    pub const VTable = extern struct {
        base: ITCollection.VTable,
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITCollection2,
                Index: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITCollection2,
                Index: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITCollection2,
                Index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITCollection2,
                Index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITCollection.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCollection2_Add(self: *const T, Index: i32, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITCollection2.VTable, @ptrCast(self.vtable)).Add(@as(*const ITCollection2, @ptrCast(self)), Index, pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCollection2_Remove(self: *const T, Index: i32) HRESULT {
                return @as(*const ITCollection2.VTable, @ptrCast(self.vtable)).Remove(@as(*const ITCollection2, @ptrCast(self)), Index);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITForwardInformation_Value = Guid.initString("449f659e-88a3-11d1-bb5d-00c04fb6809f");
pub const IID_ITForwardInformation = &IID_ITForwardInformation_Value;
pub const ITForwardInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NumRingsNoAnswer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITForwardInformation,
                lNumRings: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITForwardInformation,
                lNumRings: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumRingsNoAnswer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITForwardInformation,
                plNumRings: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITForwardInformation,
                plNumRings: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetForwardType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITForwardInformation,
                ForwardType: i32,
                pDestAddress: ?BSTR,
                pCallerAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITForwardInformation,
                ForwardType: i32,
                pDestAddress: ?BSTR,
                pCallerAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForwardTypeDestination: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITForwardInformation,
                ForwardType: i32,
                ppDestAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITForwardInformation,
                ForwardType: i32,
                ppDestAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForwardTypeCaller: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITForwardInformation,
                Forwardtype: i32,
                ppCallerAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITForwardInformation,
                Forwardtype: i32,
                ppCallerAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetForwardType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITForwardInformation,
                ForwardType: i32,
                ppDestinationAddress: ?*?BSTR,
                ppCallerAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITForwardInformation,
                ForwardType: i32,
                ppDestinationAddress: ?*?BSTR,
                ppCallerAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITForwardInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITForwardInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation_put_NumRingsNoAnswer(self: *const T, lNumRings: i32) HRESULT {
                return @as(*const ITForwardInformation.VTable, @ptrCast(self.vtable)).put_NumRingsNoAnswer(@as(*const ITForwardInformation, @ptrCast(self)), lNumRings);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation_get_NumRingsNoAnswer(self: *const T, plNumRings: ?*i32) HRESULT {
                return @as(*const ITForwardInformation.VTable, @ptrCast(self.vtable)).get_NumRingsNoAnswer(@as(*const ITForwardInformation, @ptrCast(self)), plNumRings);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation_SetForwardType(self: *const T, ForwardType: i32, pDestAddress: ?BSTR, pCallerAddress: ?BSTR) HRESULT {
                return @as(*const ITForwardInformation.VTable, @ptrCast(self.vtable)).SetForwardType(@as(*const ITForwardInformation, @ptrCast(self)), ForwardType, pDestAddress, pCallerAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation_get_ForwardTypeDestination(self: *const T, ForwardType: i32, ppDestAddress: ?*?BSTR) HRESULT {
                return @as(*const ITForwardInformation.VTable, @ptrCast(self.vtable)).get_ForwardTypeDestination(@as(*const ITForwardInformation, @ptrCast(self)), ForwardType, ppDestAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation_get_ForwardTypeCaller(self: *const T, Forwardtype: i32, ppCallerAddress: ?*?BSTR) HRESULT {
                return @as(*const ITForwardInformation.VTable, @ptrCast(self.vtable)).get_ForwardTypeCaller(@as(*const ITForwardInformation, @ptrCast(self)), Forwardtype, ppCallerAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation_GetForwardType(self: *const T, ForwardType: i32, ppDestinationAddress: ?*?BSTR, ppCallerAddress: ?*?BSTR) HRESULT {
                return @as(*const ITForwardInformation.VTable, @ptrCast(self.vtable)).GetForwardType(@as(*const ITForwardInformation, @ptrCast(self)), ForwardType, ppDestinationAddress, ppCallerAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation_Clear(self: *const T) HRESULT {
                return @as(*const ITForwardInformation.VTable, @ptrCast(self.vtable)).Clear(@as(*const ITForwardInformation, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITForwardInformation2_Value = Guid.initString("5229b4ed-b260-4382-8e1a-5df3a8a4ccc0");
pub const IID_ITForwardInformation2 = &IID_ITForwardInformation2_Value;
pub const ITForwardInformation2 = extern struct {
    pub const VTable = extern struct {
        base: ITForwardInformation.VTable,
        SetForwardType2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITForwardInformation2,
                ForwardType: i32,
                pDestAddress: ?BSTR,
                DestAddressType: i32,
                pCallerAddress: ?BSTR,
                CallerAddressType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITForwardInformation2,
                ForwardType: i32,
                pDestAddress: ?BSTR,
                DestAddressType: i32,
                pCallerAddress: ?BSTR,
                CallerAddressType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetForwardType2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITForwardInformation2,
                ForwardType: i32,
                ppDestinationAddress: ?*?BSTR,
                pDestAddressType: ?*i32,
                ppCallerAddress: ?*?BSTR,
                pCallerAddressType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITForwardInformation2,
                ForwardType: i32,
                ppDestinationAddress: ?*?BSTR,
                pDestAddressType: ?*i32,
                ppCallerAddress: ?*?BSTR,
                pCallerAddressType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForwardTypeDestinationAddressType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITForwardInformation2,
                ForwardType: i32,
                pDestAddressType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITForwardInformation2,
                ForwardType: i32,
                pDestAddressType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForwardTypeCallerAddressType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITForwardInformation2,
                Forwardtype: i32,
                pCallerAddressType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITForwardInformation2,
                Forwardtype: i32,
                pCallerAddressType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITForwardInformation.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation2_SetForwardType2(self: *const T, ForwardType: i32, pDestAddress: ?BSTR, DestAddressType: i32, pCallerAddress: ?BSTR, CallerAddressType: i32) HRESULT {
                return @as(*const ITForwardInformation2.VTable, @ptrCast(self.vtable)).SetForwardType2(@as(*const ITForwardInformation2, @ptrCast(self)), ForwardType, pDestAddress, DestAddressType, pCallerAddress, CallerAddressType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation2_GetForwardType2(self: *const T, ForwardType: i32, ppDestinationAddress: ?*?BSTR, pDestAddressType: ?*i32, ppCallerAddress: ?*?BSTR, pCallerAddressType: ?*i32) HRESULT {
                return @as(*const ITForwardInformation2.VTable, @ptrCast(self.vtable)).GetForwardType2(@as(*const ITForwardInformation2, @ptrCast(self)), ForwardType, ppDestinationAddress, pDestAddressType, ppCallerAddress, pCallerAddressType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation2_get_ForwardTypeDestinationAddressType(self: *const T, ForwardType: i32, pDestAddressType: ?*i32) HRESULT {
                return @as(*const ITForwardInformation2.VTable, @ptrCast(self.vtable)).get_ForwardTypeDestinationAddressType(@as(*const ITForwardInformation2, @ptrCast(self)), ForwardType, pDestAddressType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITForwardInformation2_get_ForwardTypeCallerAddressType(self: *const T, Forwardtype: i32, pCallerAddressType: ?*i32) HRESULT {
                return @as(*const ITForwardInformation2.VTable, @ptrCast(self.vtable)).get_ForwardTypeCallerAddressType(@as(*const ITForwardInformation2, @ptrCast(self)), Forwardtype, pCallerAddressType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAddressTranslation_Value = Guid.initString("0c4d8f03-8ddb-11d1-a09e-00805fc147d3");
pub const IID_ITAddressTranslation = &IID_ITAddressTranslation_Value;
pub const ITAddressTranslation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        TranslateAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddressTranslation,
                pAddressToTranslate: ?BSTR,
                lCard: i32,
                lTranslateOptions: i32,
                ppTranslated: ?*?*ITAddressTranslationInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddressTranslation,
                pAddressToTranslate: ?BSTR,
                lCard: i32,
                lTranslateOptions: i32,
                ppTranslated: ?*?*ITAddressTranslationInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddressTranslation,
                hwndOwner: isize,
                pAddressIn: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddressTranslation,
                hwndOwner: isize,
                pAddressIn: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateLocations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddressTranslation,
                ppEnumLocation: ?*?*IEnumLocation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddressTranslation,
                ppEnumLocation: ?*?*IEnumLocation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Locations: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressTranslation,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressTranslation,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateCallingCards: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAddressTranslation,
                ppEnumCallingCard: ?*?*IEnumCallingCard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAddressTranslation,
                ppEnumCallingCard: ?*?*IEnumCallingCard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallingCards: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressTranslation,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressTranslation,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslation_TranslateAddress(self: *const T, pAddressToTranslate: ?BSTR, lCard: i32, lTranslateOptions: i32, ppTranslated: ?*?*ITAddressTranslationInfo) HRESULT {
                return @as(*const ITAddressTranslation.VTable, @ptrCast(self.vtable)).TranslateAddress(@as(*const ITAddressTranslation, @ptrCast(self)), pAddressToTranslate, lCard, lTranslateOptions, ppTranslated);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslation_TranslateDialog(self: *const T, hwndOwner: isize, pAddressIn: ?BSTR) HRESULT {
                return @as(*const ITAddressTranslation.VTable, @ptrCast(self.vtable)).TranslateDialog(@as(*const ITAddressTranslation, @ptrCast(self)), hwndOwner, pAddressIn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslation_EnumerateLocations(self: *const T, ppEnumLocation: ?*?*IEnumLocation) HRESULT {
                return @as(*const ITAddressTranslation.VTable, @ptrCast(self.vtable)).EnumerateLocations(@as(*const ITAddressTranslation, @ptrCast(self)), ppEnumLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslation_get_Locations(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAddressTranslation.VTable, @ptrCast(self.vtable)).get_Locations(@as(*const ITAddressTranslation, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslation_EnumerateCallingCards(self: *const T, ppEnumCallingCard: ?*?*IEnumCallingCard) HRESULT {
                return @as(*const ITAddressTranslation.VTable, @ptrCast(self.vtable)).EnumerateCallingCards(@as(*const ITAddressTranslation, @ptrCast(self)), ppEnumCallingCard);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslation_get_CallingCards(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAddressTranslation.VTable, @ptrCast(self.vtable)).get_CallingCards(@as(*const ITAddressTranslation, @ptrCast(self)), pVariant);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAddressTranslationInfo_Value = Guid.initString("afc15945-8d40-11d1-a09e-00805fc147d3");
pub const IID_ITAddressTranslationInfo = &IID_ITAddressTranslationInfo_Value;
pub const ITAddressTranslationInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DialableString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressTranslationInfo,
                ppDialableString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressTranslationInfo,
                ppDialableString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayableString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressTranslationInfo,
                ppDisplayableString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressTranslationInfo,
                ppDisplayableString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressTranslationInfo,
                CountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressTranslationInfo,
                CountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationCountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressTranslationInfo,
                CountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressTranslationInfo,
                CountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TranslationResults: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAddressTranslationInfo,
                plResults: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAddressTranslationInfo,
                plResults: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslationInfo_get_DialableString(self: *const T, ppDialableString: ?*?BSTR) HRESULT {
                return @as(*const ITAddressTranslationInfo.VTable, @ptrCast(self.vtable)).get_DialableString(@as(*const ITAddressTranslationInfo, @ptrCast(self)), ppDialableString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslationInfo_get_DisplayableString(self: *const T, ppDisplayableString: ?*?BSTR) HRESULT {
                return @as(*const ITAddressTranslationInfo.VTable, @ptrCast(self.vtable)).get_DisplayableString(@as(*const ITAddressTranslationInfo, @ptrCast(self)), ppDisplayableString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslationInfo_get_CurrentCountryCode(self: *const T, CountryCode: ?*i32) HRESULT {
                return @as(*const ITAddressTranslationInfo.VTable, @ptrCast(self.vtable)).get_CurrentCountryCode(@as(*const ITAddressTranslationInfo, @ptrCast(self)), CountryCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslationInfo_get_DestinationCountryCode(self: *const T, CountryCode: ?*i32) HRESULT {
                return @as(*const ITAddressTranslationInfo.VTable, @ptrCast(self.vtable)).get_DestinationCountryCode(@as(*const ITAddressTranslationInfo, @ptrCast(self)), CountryCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAddressTranslationInfo_get_TranslationResults(self: *const T, plResults: ?*i32) HRESULT {
                return @as(*const ITAddressTranslationInfo.VTable, @ptrCast(self.vtable)).get_TranslationResults(@as(*const ITAddressTranslationInfo, @ptrCast(self)), plResults);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITLocationInfo_Value = Guid.initString("0c4d8eff-8ddb-11d1-a09e-00805fc147d3");
pub const IID_ITLocationInfo = &IID_ITLocationInfo_Value;
pub const ITLocationInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PermanentLocationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                plLocationID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                plLocationID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                plCountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                plCountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                plCountryID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                plCountryID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Options: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                plOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                plOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredCardID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                plCardID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                plCardID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocationName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                ppLocationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                ppLocationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CityCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                ppCode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                ppCode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalAccessCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                ppCode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                ppCode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LongDistanceAccessCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                ppCode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                ppCode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TollPrefixList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                ppTollList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                ppTollList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CancelCallWaitingCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITLocationInfo,
                ppCode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITLocationInfo,
                ppCode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_PermanentLocationID(self: *const T, plLocationID: ?*i32) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_PermanentLocationID(@as(*const ITLocationInfo, @ptrCast(self)), plLocationID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_CountryCode(self: *const T, plCountryCode: ?*i32) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const ITLocationInfo, @ptrCast(self)), plCountryCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_CountryID(self: *const T, plCountryID: ?*i32) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_CountryID(@as(*const ITLocationInfo, @ptrCast(self)), plCountryID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_Options(self: *const T, plOptions: ?*i32) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_Options(@as(*const ITLocationInfo, @ptrCast(self)), plOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_PreferredCardID(self: *const T, plCardID: ?*i32) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_PreferredCardID(@as(*const ITLocationInfo, @ptrCast(self)), plCardID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_LocationName(self: *const T, ppLocationName: ?*?BSTR) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_LocationName(@as(*const ITLocationInfo, @ptrCast(self)), ppLocationName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_CityCode(self: *const T, ppCode: ?*?BSTR) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_CityCode(@as(*const ITLocationInfo, @ptrCast(self)), ppCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_LocalAccessCode(self: *const T, ppCode: ?*?BSTR) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_LocalAccessCode(@as(*const ITLocationInfo, @ptrCast(self)), ppCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_LongDistanceAccessCode(self: *const T, ppCode: ?*?BSTR) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_LongDistanceAccessCode(@as(*const ITLocationInfo, @ptrCast(self)), ppCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_TollPrefixList(self: *const T, ppTollList: ?*?BSTR) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_TollPrefixList(@as(*const ITLocationInfo, @ptrCast(self)), ppTollList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLocationInfo_get_CancelCallWaitingCode(self: *const T, ppCode: ?*?BSTR) HRESULT {
                return @as(*const ITLocationInfo.VTable, @ptrCast(self.vtable)).get_CancelCallWaitingCode(@as(*const ITLocationInfo, @ptrCast(self)), ppCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumLocation_Value = Guid.initString("0c4d8f01-8ddb-11d1-a09e-00805fc147d3");
pub const IID_IEnumLocation = &IID_IEnumLocation_Value;
pub const IEnumLocation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumLocation,
                celt: u32,
                ppElements: ?*?*ITLocationInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumLocation,
                celt: u32,
                ppElements: ?*?*ITLocationInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumLocation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumLocation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumLocation,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumLocation,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumLocation,
                ppEnum: ?*?*IEnumLocation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumLocation,
                ppEnum: ?*?*IEnumLocation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumLocation_Next(self: *const T, celt: u32, ppElements: ?*?*ITLocationInfo, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumLocation.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumLocation, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumLocation_Reset(self: *const T) HRESULT {
                return @as(*const IEnumLocation.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumLocation, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumLocation_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumLocation.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumLocation, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumLocation_Clone(self: *const T, ppEnum: ?*?*IEnumLocation) HRESULT {
                return @as(*const IEnumLocation.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumLocation, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCallingCard_Value = Guid.initString("0c4d8f00-8ddb-11d1-a09e-00805fc147d3");
pub const IID_ITCallingCard = &IID_ITCallingCard_Value;
pub const ITCallingCard = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PermanentCardID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallingCard,
                plCardID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallingCard,
                plCardID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfDigits: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallingCard,
                plDigits: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallingCard,
                plDigits: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Options: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallingCard,
                plOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallingCard,
                plOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CardName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallingCard,
                ppCardName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallingCard,
                ppCardName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SameAreaDialingRule: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallingCard,
                ppRule: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallingCard,
                ppRule: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LongDistanceDialingRule: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallingCard,
                ppRule: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallingCard,
                ppRule: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternationalDialingRule: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallingCard,
                ppRule: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallingCard,
                ppRule: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallingCard_get_PermanentCardID(self: *const T, plCardID: ?*i32) HRESULT {
                return @as(*const ITCallingCard.VTable, @ptrCast(self.vtable)).get_PermanentCardID(@as(*const ITCallingCard, @ptrCast(self)), plCardID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallingCard_get_NumberOfDigits(self: *const T, plDigits: ?*i32) HRESULT {
                return @as(*const ITCallingCard.VTable, @ptrCast(self.vtable)).get_NumberOfDigits(@as(*const ITCallingCard, @ptrCast(self)), plDigits);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallingCard_get_Options(self: *const T, plOptions: ?*i32) HRESULT {
                return @as(*const ITCallingCard.VTable, @ptrCast(self.vtable)).get_Options(@as(*const ITCallingCard, @ptrCast(self)), plOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallingCard_get_CardName(self: *const T, ppCardName: ?*?BSTR) HRESULT {
                return @as(*const ITCallingCard.VTable, @ptrCast(self.vtable)).get_CardName(@as(*const ITCallingCard, @ptrCast(self)), ppCardName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallingCard_get_SameAreaDialingRule(self: *const T, ppRule: ?*?BSTR) HRESULT {
                return @as(*const ITCallingCard.VTable, @ptrCast(self.vtable)).get_SameAreaDialingRule(@as(*const ITCallingCard, @ptrCast(self)), ppRule);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallingCard_get_LongDistanceDialingRule(self: *const T, ppRule: ?*?BSTR) HRESULT {
                return @as(*const ITCallingCard.VTable, @ptrCast(self.vtable)).get_LongDistanceDialingRule(@as(*const ITCallingCard, @ptrCast(self)), ppRule);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallingCard_get_InternationalDialingRule(self: *const T, ppRule: ?*?BSTR) HRESULT {
                return @as(*const ITCallingCard.VTable, @ptrCast(self.vtable)).get_InternationalDialingRule(@as(*const ITCallingCard, @ptrCast(self)), ppRule);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumCallingCard_Value = Guid.initString("0c4d8f02-8ddb-11d1-a09e-00805fc147d3");
pub const IID_IEnumCallingCard = &IID_IEnumCallingCard_Value;
pub const IEnumCallingCard = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCallingCard,
                celt: u32,
                ppElements: ?*?*ITCallingCard,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCallingCard,
                celt: u32,
                ppElements: ?*?*ITCallingCard,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCallingCard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCallingCard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCallingCard,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCallingCard,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCallingCard,
                ppEnum: ?*?*IEnumCallingCard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCallingCard,
                ppEnum: ?*?*IEnumCallingCard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCallingCard_Next(self: *const T, celt: u32, ppElements: ?*?*ITCallingCard, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumCallingCard.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumCallingCard, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCallingCard_Reset(self: *const T) HRESULT {
                return @as(*const IEnumCallingCard.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumCallingCard, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCallingCard_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumCallingCard.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumCallingCard, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCallingCard_Clone(self: *const T, ppEnum: ?*?*IEnumCallingCard) HRESULT {
                return @as(*const IEnumCallingCard.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumCallingCard, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITCallNotificationEvent_Value = Guid.initString("895801df-3dd6-11d1-8f30-00c04fb6809f");
pub const IID_ITCallNotificationEvent = &IID_ITCallNotificationEvent_Value;
pub const ITCallNotificationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Call: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallNotificationEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallNotificationEvent,
                ppCall: ?*?*ITCallInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallNotificationEvent,
                pCallNotificationEvent: ?*CALL_NOTIFICATION_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallNotificationEvent,
                pCallNotificationEvent: ?*CALL_NOTIFICATION_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CallbackInstance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITCallNotificationEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITCallNotificationEvent,
                plCallbackInstance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallNotificationEvent_get_Call(self: *const T, ppCall: ?*?*ITCallInfo) HRESULT {
                return @as(*const ITCallNotificationEvent.VTable, @ptrCast(self.vtable)).get_Call(@as(*const ITCallNotificationEvent, @ptrCast(self)), ppCall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallNotificationEvent_get_Event(self: *const T, pCallNotificationEvent: ?*CALL_NOTIFICATION_EVENT) HRESULT {
                return @as(*const ITCallNotificationEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITCallNotificationEvent, @ptrCast(self)), pCallNotificationEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITCallNotificationEvent_get_CallbackInstance(self: *const T, plCallbackInstance: ?*i32) HRESULT {
                return @as(*const ITCallNotificationEvent.VTable, @ptrCast(self.vtable)).get_CallbackInstance(@as(*const ITCallNotificationEvent, @ptrCast(self)), plCallbackInstance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITDispatchMapper_Value = Guid.initString("e9225295-c759-11d1-a02b-00c04fb6809f");
pub const IID_ITDispatchMapper = &IID_ITDispatchMapper_Value;
pub const ITDispatchMapper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        QueryDispatchInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDispatchMapper,
                pIID: ?BSTR,
                pInterfaceToMap: ?*IDispatch,
                ppReturnedInterface: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDispatchMapper,
                pIID: ?BSTR,
                pInterfaceToMap: ?*IDispatch,
                ppReturnedInterface: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDispatchMapper_QueryDispatchInterface(self: *const T, pIID: ?BSTR, pInterfaceToMap: ?*IDispatch, ppReturnedInterface: ?*?*IDispatch) HRESULT {
                return @as(*const ITDispatchMapper.VTable, @ptrCast(self.vtable)).QueryDispatchInterface(@as(*const ITDispatchMapper, @ptrCast(self)), pIID, pInterfaceToMap, ppReturnedInterface);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITStreamControl_Value = Guid.initString("ee3bd604-3868-11d2-a045-00c04fb6809f");
pub const IID_ITStreamControl = &IID_ITStreamControl_Value;
pub const ITStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITStreamControl,
                lMediaType: i32,
                td: TERMINAL_DIRECTION,
                ppStream: ?*?*ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITStreamControl,
                lMediaType: i32,
                td: TERMINAL_DIRECTION,
                ppStream: ?*?*ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITStreamControl,
                pStream: ?*ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITStreamControl,
                pStream: ?*ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITStreamControl,
                ppEnumStream: ?*?*IEnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITStreamControl,
                ppEnumStream: ?*?*IEnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Streams: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITStreamControl,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITStreamControl,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStreamControl_CreateStream(self: *const T, lMediaType: i32, td: TERMINAL_DIRECTION, ppStream: ?*?*ITStream) HRESULT {
                return @as(*const ITStreamControl.VTable, @ptrCast(self.vtable)).CreateStream(@as(*const ITStreamControl, @ptrCast(self)), lMediaType, td, ppStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStreamControl_RemoveStream(self: *const T, pStream: ?*ITStream) HRESULT {
                return @as(*const ITStreamControl.VTable, @ptrCast(self.vtable)).RemoveStream(@as(*const ITStreamControl, @ptrCast(self)), pStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStreamControl_EnumerateStreams(self: *const T, ppEnumStream: ?*?*IEnumStream) HRESULT {
                return @as(*const ITStreamControl.VTable, @ptrCast(self.vtable)).EnumerateStreams(@as(*const ITStreamControl, @ptrCast(self)), ppEnumStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStreamControl_get_Streams(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITStreamControl.VTable, @ptrCast(self.vtable)).get_Streams(@as(*const ITStreamControl, @ptrCast(self)), pVariant);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITStream_Value = Guid.initString("ee3bd605-3868-11d2-a045-00c04fb6809f");
pub const IID_ITStream = &IID_ITStream_Value;
pub const ITStream = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITStream,
                plMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITStream,
                plMediaType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Direction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITStream,
                pTD: ?*TERMINAL_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITStream,
                pTD: ?*TERMINAL_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITStream,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITStream,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PauseStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITStream,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITStream,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnselectTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITStream,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITStream,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateTerminals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITStream,
                ppEnumTerminal: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITStream,
                ppEnumTerminal: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Terminals: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITStream,
                pTerminals: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITStream,
                pTerminals: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_get_MediaType(self: *const T, plMediaType: ?*i32) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).get_MediaType(@as(*const ITStream, @ptrCast(self)), plMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_get_Direction(self: *const T, pTD: ?*TERMINAL_DIRECTION) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).get_Direction(@as(*const ITStream, @ptrCast(self)), pTD);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_get_Name(self: *const T, ppName: ?*?BSTR) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ITStream, @ptrCast(self)), ppName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_StartStream(self: *const T) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).StartStream(@as(*const ITStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_PauseStream(self: *const T) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).PauseStream(@as(*const ITStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_StopStream(self: *const T) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).StopStream(@as(*const ITStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_SelectTerminal(self: *const T, pTerminal: ?*ITTerminal) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).SelectTerminal(@as(*const ITStream, @ptrCast(self)), pTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_UnselectTerminal(self: *const T, pTerminal: ?*ITTerminal) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).UnselectTerminal(@as(*const ITStream, @ptrCast(self)), pTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_EnumerateTerminals(self: *const T, ppEnumTerminal: ?*?*IEnumTerminal) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).EnumerateTerminals(@as(*const ITStream, @ptrCast(self)), ppEnumTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITStream_get_Terminals(self: *const T, pTerminals: ?*VARIANT) HRESULT {
                return @as(*const ITStream.VTable, @ptrCast(self.vtable)).get_Terminals(@as(*const ITStream, @ptrCast(self)), pTerminals);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumStream_Value = Guid.initString("ee3bd606-3868-11d2-a045-00c04fb6809f");
pub const IID_IEnumStream = &IID_IEnumStream_Value;
pub const IEnumStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumStream,
                celt: u32,
                ppElements: ?*?*ITStream,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumStream,
                celt: u32,
                ppElements: ?*?*ITStream,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumStream,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumStream,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumStream,
                ppEnum: ?*?*IEnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumStream,
                ppEnum: ?*?*IEnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumStream_Next(self: *const T, celt: u32, ppElements: ?*?*ITStream, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumStream.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumStream, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumStream_Reset(self: *const T) HRESULT {
                return @as(*const IEnumStream.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumStream_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumStream.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumStream, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumStream_Clone(self: *const T, ppEnum: ?*?*IEnumStream) HRESULT {
                return @as(*const IEnumStream.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumStream, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITSubStreamControl_Value = Guid.initString("ee3bd607-3868-11d2-a045-00c04fb6809f");
pub const IID_ITSubStreamControl = &IID_ITSubStreamControl_Value;
pub const ITSubStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateSubStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITSubStreamControl,
                ppSubStream: ?*?*ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITSubStreamControl,
                ppSubStream: ?*?*ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSubStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITSubStreamControl,
                pSubStream: ?*ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITSubStreamControl,
                pSubStream: ?*ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateSubStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITSubStreamControl,
                ppEnumSubStream: ?*?*IEnumSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITSubStreamControl,
                ppEnumSubStream: ?*?*IEnumSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubStreams: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITSubStreamControl,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITSubStreamControl,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStreamControl_CreateSubStream(self: *const T, ppSubStream: ?*?*ITSubStream) HRESULT {
                return @as(*const ITSubStreamControl.VTable, @ptrCast(self.vtable)).CreateSubStream(@as(*const ITSubStreamControl, @ptrCast(self)), ppSubStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStreamControl_RemoveSubStream(self: *const T, pSubStream: ?*ITSubStream) HRESULT {
                return @as(*const ITSubStreamControl.VTable, @ptrCast(self.vtable)).RemoveSubStream(@as(*const ITSubStreamControl, @ptrCast(self)), pSubStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStreamControl_EnumerateSubStreams(self: *const T, ppEnumSubStream: ?*?*IEnumSubStream) HRESULT {
                return @as(*const ITSubStreamControl.VTable, @ptrCast(self.vtable)).EnumerateSubStreams(@as(*const ITSubStreamControl, @ptrCast(self)), ppEnumSubStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStreamControl_get_SubStreams(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITSubStreamControl.VTable, @ptrCast(self.vtable)).get_SubStreams(@as(*const ITSubStreamControl, @ptrCast(self)), pVariant);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITSubStream_Value = Guid.initString("ee3bd608-3868-11d2-a045-00c04fb6809f");
pub const IID_ITSubStream = &IID_ITSubStream_Value;
pub const ITSubStream = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        StartSubStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PauseSubStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopSubStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITSubStream,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITSubStream,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnselectTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITSubStream,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITSubStream,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateTerminals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITSubStream,
                ppEnumTerminal: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITSubStream,
                ppEnumTerminal: ?*?*IEnumTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Terminals: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITSubStream,
                pTerminals: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITSubStream,
                pTerminals: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Stream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITSubStream,
                ppITStream: ?*?*ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITSubStream,
                ppITStream: ?*?*ITStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStream_StartSubStream(self: *const T) HRESULT {
                return @as(*const ITSubStream.VTable, @ptrCast(self.vtable)).StartSubStream(@as(*const ITSubStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStream_PauseSubStream(self: *const T) HRESULT {
                return @as(*const ITSubStream.VTable, @ptrCast(self.vtable)).PauseSubStream(@as(*const ITSubStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStream_StopSubStream(self: *const T) HRESULT {
                return @as(*const ITSubStream.VTable, @ptrCast(self.vtable)).StopSubStream(@as(*const ITSubStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStream_SelectTerminal(self: *const T, pTerminal: ?*ITTerminal) HRESULT {
                return @as(*const ITSubStream.VTable, @ptrCast(self.vtable)).SelectTerminal(@as(*const ITSubStream, @ptrCast(self)), pTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStream_UnselectTerminal(self: *const T, pTerminal: ?*ITTerminal) HRESULT {
                return @as(*const ITSubStream.VTable, @ptrCast(self.vtable)).UnselectTerminal(@as(*const ITSubStream, @ptrCast(self)), pTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStream_EnumerateTerminals(self: *const T, ppEnumTerminal: ?*?*IEnumTerminal) HRESULT {
                return @as(*const ITSubStream.VTable, @ptrCast(self.vtable)).EnumerateTerminals(@as(*const ITSubStream, @ptrCast(self)), ppEnumTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStream_get_Terminals(self: *const T, pTerminals: ?*VARIANT) HRESULT {
                return @as(*const ITSubStream.VTable, @ptrCast(self.vtable)).get_Terminals(@as(*const ITSubStream, @ptrCast(self)), pTerminals);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITSubStream_get_Stream(self: *const T, ppITStream: ?*?*ITStream) HRESULT {
                return @as(*const ITSubStream.VTable, @ptrCast(self.vtable)).get_Stream(@as(*const ITSubStream, @ptrCast(self)), ppITStream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSubStream_Value = Guid.initString("ee3bd609-3868-11d2-a045-00c04fb6809f");
pub const IID_IEnumSubStream = &IID_IEnumSubStream_Value;
pub const IEnumSubStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSubStream,
                celt: u32,
                ppElements: ?*?*ITSubStream,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSubStream,
                celt: u32,
                ppElements: ?*?*ITSubStream,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSubStream,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSubStream,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSubStream,
                ppEnum: ?*?*IEnumSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSubStream,
                ppEnum: ?*?*IEnumSubStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSubStream_Next(self: *const T, celt: u32, ppElements: ?*?*ITSubStream, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumSubStream.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSubStream, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSubStream_Reset(self: *const T) HRESULT {
                return @as(*const IEnumSubStream.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSubStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSubStream_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumSubStream.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSubStream, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSubStream_Clone(self: *const T, ppEnum: ?*?*IEnumSubStream) HRESULT {
                return @as(*const IEnumSubStream.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSubStream, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITLegacyWaveSupport_Value = Guid.initString("207823ea-e252-11d2-b77e-0080c7135381");
pub const IID_ITLegacyWaveSupport = &IID_ITLegacyWaveSupport_Value;
pub const ITLegacyWaveSupport = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        IsFullDuplex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITLegacyWaveSupport,
                pSupport: ?*FULLDUPLEX_SUPPORT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITLegacyWaveSupport,
                pSupport: ?*FULLDUPLEX_SUPPORT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITLegacyWaveSupport_IsFullDuplex(self: *const T, pSupport: ?*FULLDUPLEX_SUPPORT) HRESULT {
                return @as(*const ITLegacyWaveSupport.VTable, @ptrCast(self.vtable)).IsFullDuplex(@as(*const ITLegacyWaveSupport, @ptrCast(self)), pSupport);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITBasicCallControl2_Value = Guid.initString("161a4a56-1e99-4b3f-a46a-168f38a5ee4c");
pub const IID_ITBasicCallControl2 = &IID_ITBasicCallControl2_Value;
pub const ITBasicCallControl2 = extern struct {
    pub const VTable = extern struct {
        base: ITBasicCallControl.VTable,
        RequestTerminal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl2,
                bstrTerminalClassGUID: ?BSTR,
                lMediaType: i32,
                Direction: TERMINAL_DIRECTION,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl2,
                bstrTerminalClassGUID: ?BSTR,
                lMediaType: i32,
                Direction: TERMINAL_DIRECTION,
                ppTerminal: ?*?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectTerminalOnCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl2,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl2,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnselectTerminalOnCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITBasicCallControl2,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITBasicCallControl2,
                pTerminal: ?*ITTerminal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITBasicCallControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl2_RequestTerminal(self: *const T, bstrTerminalClassGUID: ?BSTR, lMediaType: i32, Direction: TERMINAL_DIRECTION, ppTerminal: ?*?*ITTerminal) HRESULT {
                return @as(*const ITBasicCallControl2.VTable, @ptrCast(self.vtable)).RequestTerminal(@as(*const ITBasicCallControl2, @ptrCast(self)), bstrTerminalClassGUID, lMediaType, Direction, ppTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl2_SelectTerminalOnCall(self: *const T, pTerminal: ?*ITTerminal) HRESULT {
                return @as(*const ITBasicCallControl2.VTable, @ptrCast(self.vtable)).SelectTerminalOnCall(@as(*const ITBasicCallControl2, @ptrCast(self)), pTerminal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITBasicCallControl2_UnselectTerminalOnCall(self: *const T, pTerminal: ?*ITTerminal) HRESULT {
                return @as(*const ITBasicCallControl2.VTable, @ptrCast(self.vtable)).UnselectTerminalOnCall(@as(*const ITBasicCallControl2, @ptrCast(self)), pTerminal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITScriptableAudioFormat_Value = Guid.initString("b87658bd-3c59-4f64-be74-aede3e86a81e");
pub const IID_ITScriptableAudioFormat = &IID_ITScriptableAudioFormat_Value;
pub const ITScriptableAudioFormat = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channels: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channels: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SamplesPerSec: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SamplesPerSec: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgBytesPerSec: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AvgBytesPerSec: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockAlign: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockAlign: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitsPerSample: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BitsPerSample: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FormatTag: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FormatTag: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITScriptableAudioFormat,
                nNewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_get_Channels(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).get_Channels(@as(*const ITScriptableAudioFormat, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_put_Channels(self: *const T, nNewVal: i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).put_Channels(@as(*const ITScriptableAudioFormat, @ptrCast(self)), nNewVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_get_SamplesPerSec(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).get_SamplesPerSec(@as(*const ITScriptableAudioFormat, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_put_SamplesPerSec(self: *const T, nNewVal: i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).put_SamplesPerSec(@as(*const ITScriptableAudioFormat, @ptrCast(self)), nNewVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_get_AvgBytesPerSec(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).get_AvgBytesPerSec(@as(*const ITScriptableAudioFormat, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_put_AvgBytesPerSec(self: *const T, nNewVal: i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).put_AvgBytesPerSec(@as(*const ITScriptableAudioFormat, @ptrCast(self)), nNewVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_get_BlockAlign(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).get_BlockAlign(@as(*const ITScriptableAudioFormat, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_put_BlockAlign(self: *const T, nNewVal: i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).put_BlockAlign(@as(*const ITScriptableAudioFormat, @ptrCast(self)), nNewVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_get_BitsPerSample(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).get_BitsPerSample(@as(*const ITScriptableAudioFormat, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_put_BitsPerSample(self: *const T, nNewVal: i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).put_BitsPerSample(@as(*const ITScriptableAudioFormat, @ptrCast(self)), nNewVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_get_FormatTag(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).get_FormatTag(@as(*const ITScriptableAudioFormat, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITScriptableAudioFormat_put_FormatTag(self: *const T, nNewVal: i32) HRESULT {
                return @as(*const ITScriptableAudioFormat.VTable, @ptrCast(self.vtable)).put_FormatTag(@as(*const ITScriptableAudioFormat, @ptrCast(self)), nNewVal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AGENT_EVENT = enum(i32) {
    NOT_READY = 0,
    READY = 1,
    BUSY_ACD = 2,
    BUSY_INCOMING = 3,
    BUSY_OUTGOING = 4,
    UNKNOWN = 5,
};
pub const AE_NOT_READY = AGENT_EVENT.NOT_READY;
pub const AE_READY = AGENT_EVENT.READY;
pub const AE_BUSY_ACD = AGENT_EVENT.BUSY_ACD;
pub const AE_BUSY_INCOMING = AGENT_EVENT.BUSY_INCOMING;
pub const AE_BUSY_OUTGOING = AGENT_EVENT.BUSY_OUTGOING;
pub const AE_UNKNOWN = AGENT_EVENT.UNKNOWN;

pub const AGENT_STATE = enum(i32) {
    NOT_READY = 0,
    READY = 1,
    BUSY_ACD = 2,
    BUSY_INCOMING = 3,
    BUSY_OUTGOING = 4,
    UNKNOWN = 5,
};
pub const AS_NOT_READY = AGENT_STATE.NOT_READY;
pub const AS_READY = AGENT_STATE.READY;
pub const AS_BUSY_ACD = AGENT_STATE.BUSY_ACD;
pub const AS_BUSY_INCOMING = AGENT_STATE.BUSY_INCOMING;
pub const AS_BUSY_OUTGOING = AGENT_STATE.BUSY_OUTGOING;
pub const AS_UNKNOWN = AGENT_STATE.UNKNOWN;

pub const AGENT_SESSION_EVENT = enum(i32) {
    NEW_SESSION = 0,
    NOT_READY = 1,
    READY = 2,
    BUSY = 3,
    WRAPUP = 4,
    END = 5,
};
pub const ASE_NEW_SESSION = AGENT_SESSION_EVENT.NEW_SESSION;
pub const ASE_NOT_READY = AGENT_SESSION_EVENT.NOT_READY;
pub const ASE_READY = AGENT_SESSION_EVENT.READY;
pub const ASE_BUSY = AGENT_SESSION_EVENT.BUSY;
pub const ASE_WRAPUP = AGENT_SESSION_EVENT.WRAPUP;
pub const ASE_END = AGENT_SESSION_EVENT.END;

pub const AGENT_SESSION_STATE = enum(i32) {
    NOT_READY = 0,
    READY = 1,
    BUSY_ON_CALL = 2,
    BUSY_WRAPUP = 3,
    SESSION_ENDED = 4,
};
pub const ASST_NOT_READY = AGENT_SESSION_STATE.NOT_READY;
pub const ASST_READY = AGENT_SESSION_STATE.READY;
pub const ASST_BUSY_ON_CALL = AGENT_SESSION_STATE.BUSY_ON_CALL;
pub const ASST_BUSY_WRAPUP = AGENT_SESSION_STATE.BUSY_WRAPUP;
pub const ASST_SESSION_ENDED = AGENT_SESSION_STATE.SESSION_ENDED;

pub const AGENTHANDLER_EVENT = enum(i32) {
    NEW_AGENTHANDLER = 0,
    AGENTHANDLER_REMOVED = 1,
};
pub const AHE_NEW_AGENTHANDLER = AGENTHANDLER_EVENT.NEW_AGENTHANDLER;
pub const AHE_AGENTHANDLER_REMOVED = AGENTHANDLER_EVENT.AGENTHANDLER_REMOVED;

pub const ACDGROUP_EVENT = enum(i32) {
    NEW_GROUP = 0,
    GROUP_REMOVED = 1,
};
pub const ACDGE_NEW_GROUP = ACDGROUP_EVENT.NEW_GROUP;
pub const ACDGE_GROUP_REMOVED = ACDGROUP_EVENT.GROUP_REMOVED;

pub const ACDQUEUE_EVENT = enum(i32) {
    NEW_QUEUE = 0,
    QUEUE_REMOVED = 1,
};
pub const ACDQE_NEW_QUEUE = ACDQUEUE_EVENT.NEW_QUEUE;
pub const ACDQE_QUEUE_REMOVED = ACDQUEUE_EVENT.QUEUE_REMOVED;

const IID_ITAgent_Value = Guid.initString("5770ece5-4b27-11d1-bf80-00805fc147d3");
pub const IID_ITAgent = &IID_ITAgent_Value;
pub const ITAgent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        EnumerateAgentSessions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAgent,
                ppEnumAgentSession: ?*?*IEnumAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAgent,
                ppEnumAgentSession: ?*?*IEnumAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAgent,
                pACDGroup: ?*ITACDGroup,
                pAddress: ?*ITAddress,
                ppAgentSession: ?*?*ITAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAgent,
                pACDGroup: ?*ITACDGroup,
                pAddress: ?*ITAddress,
                ppAgentSession: ?*?*ITAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSessionWithPIN: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAgent,
                pACDGroup: ?*ITACDGroup,
                pAddress: ?*ITAddress,
                pPIN: ?BSTR,
                ppAgentSession: ?*?*ITAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAgent,
                pACDGroup: ?*ITACDGroup,
                pAddress: ?*ITAddress,
                pPIN: ?BSTR,
                ppAgentSession: ?*?*ITAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                ppID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                ppID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_User: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                ppUser: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                ppUser: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                AgentState: AGENT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                AgentState: AGENT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                pAgentState: ?*AGENT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                pAgentState: ?*AGENT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MeasurementPeriod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                lPeriod: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                lPeriod: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MeasurementPeriod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                plPeriod: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                plPeriod: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OverallCallRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                pcyCallrate: ?*CY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                pcyCallrate: ?*CY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfACDCalls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfIncomingCalls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfOutgoingCalls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalACDTalkTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                plTalkTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                plTalkTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalACDCallTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                plCallTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                plCallTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalWrapUpTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                plWrapUpTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                plWrapUpTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AgentSessions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgent,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgent,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_EnumerateAgentSessions(self: *const T, ppEnumAgentSession: ?*?*IEnumAgentSession) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).EnumerateAgentSessions(@as(*const ITAgent, @ptrCast(self)), ppEnumAgentSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_CreateSession(self: *const T, pACDGroup: ?*ITACDGroup, pAddress: ?*ITAddress, ppAgentSession: ?*?*ITAgentSession) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).CreateSession(@as(*const ITAgent, @ptrCast(self)), pACDGroup, pAddress, ppAgentSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_CreateSessionWithPIN(self: *const T, pACDGroup: ?*ITACDGroup, pAddress: ?*ITAddress, pPIN: ?BSTR, ppAgentSession: ?*?*ITAgentSession) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).CreateSessionWithPIN(@as(*const ITAgent, @ptrCast(self)), pACDGroup, pAddress, pPIN, ppAgentSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_ID(self: *const T, ppID: ?*?BSTR) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_ID(@as(*const ITAgent, @ptrCast(self)), ppID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_User(self: *const T, ppUser: ?*?BSTR) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_User(@as(*const ITAgent, @ptrCast(self)), ppUser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_put_State(self: *const T, AgentState: AGENT_STATE) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).put_State(@as(*const ITAgent, @ptrCast(self)), AgentState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_State(self: *const T, pAgentState: ?*AGENT_STATE) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_State(@as(*const ITAgent, @ptrCast(self)), pAgentState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_put_MeasurementPeriod(self: *const T, lPeriod: i32) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).put_MeasurementPeriod(@as(*const ITAgent, @ptrCast(self)), lPeriod);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_MeasurementPeriod(self: *const T, plPeriod: ?*i32) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_MeasurementPeriod(@as(*const ITAgent, @ptrCast(self)), plPeriod);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_OverallCallRate(self: *const T, pcyCallrate: ?*CY) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_OverallCallRate(@as(*const ITAgent, @ptrCast(self)), pcyCallrate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_NumberOfACDCalls(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_NumberOfACDCalls(@as(*const ITAgent, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_NumberOfIncomingCalls(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_NumberOfIncomingCalls(@as(*const ITAgent, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_NumberOfOutgoingCalls(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_NumberOfOutgoingCalls(@as(*const ITAgent, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_TotalACDTalkTime(self: *const T, plTalkTime: ?*i32) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_TotalACDTalkTime(@as(*const ITAgent, @ptrCast(self)), plTalkTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_TotalACDCallTime(self: *const T, plCallTime: ?*i32) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_TotalACDCallTime(@as(*const ITAgent, @ptrCast(self)), plCallTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_TotalWrapUpTime(self: *const T, plWrapUpTime: ?*i32) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_TotalWrapUpTime(@as(*const ITAgent, @ptrCast(self)), plWrapUpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgent_get_AgentSessions(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAgent.VTable, @ptrCast(self.vtable)).get_AgentSessions(@as(*const ITAgent, @ptrCast(self)), pVariant);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAgentSession_Value = Guid.initString("5afc3147-4bcc-11d1-bf80-00805fc147d3");
pub const IID_ITAgentSession = &IID_ITAgentSession_Value;
pub const ITAgentSession = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Agent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                ppAgent: ?*?*ITAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                ppAgent: ?*?*ITAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Address: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                ppAddress: ?*?*ITAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ACDGroup: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                ppACDGroup: ?*?*ITACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                ppACDGroup: ?*?*ITACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                SessionState: AGENT_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                SessionState: AGENT_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                pSessionState: ?*AGENT_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                pSessionState: ?*AGENT_SESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionStartTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                pdateSessionStart: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                pdateSessionStart: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionDuration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plDuration: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plDuration: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfCalls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalTalkTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plTalkTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plTalkTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AverageTalkTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plTalkTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plTalkTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalCallTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plCallTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plCallTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AverageCallTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plCallTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plCallTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalWrapUpTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plWrapUpTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plWrapUpTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AverageWrapUpTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plWrapUpTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plWrapUpTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ACDCallRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                pcyCallrate: ?*CY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                pcyCallrate: ?*CY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LongestTimeToAnswer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plAnswerTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plAnswerTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AverageTimeToAnswer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSession,
                plAnswerTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSession,
                plAnswerTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_Agent(self: *const T, ppAgent: ?*?*ITAgent) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_Agent(@as(*const ITAgentSession, @ptrCast(self)), ppAgent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_Address(self: *const T, ppAddress: ?*?*ITAddress) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_Address(@as(*const ITAgentSession, @ptrCast(self)), ppAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_ACDGroup(self: *const T, ppACDGroup: ?*?*ITACDGroup) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_ACDGroup(@as(*const ITAgentSession, @ptrCast(self)), ppACDGroup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_put_State(self: *const T, SessionState: AGENT_SESSION_STATE) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).put_State(@as(*const ITAgentSession, @ptrCast(self)), SessionState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_State(self: *const T, pSessionState: ?*AGENT_SESSION_STATE) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_State(@as(*const ITAgentSession, @ptrCast(self)), pSessionState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_SessionStartTime(self: *const T, pdateSessionStart: ?*f64) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_SessionStartTime(@as(*const ITAgentSession, @ptrCast(self)), pdateSessionStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_SessionDuration(self: *const T, plDuration: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_SessionDuration(@as(*const ITAgentSession, @ptrCast(self)), plDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_NumberOfCalls(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_NumberOfCalls(@as(*const ITAgentSession, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_TotalTalkTime(self: *const T, plTalkTime: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_TotalTalkTime(@as(*const ITAgentSession, @ptrCast(self)), plTalkTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_AverageTalkTime(self: *const T, plTalkTime: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_AverageTalkTime(@as(*const ITAgentSession, @ptrCast(self)), plTalkTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_TotalCallTime(self: *const T, plCallTime: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_TotalCallTime(@as(*const ITAgentSession, @ptrCast(self)), plCallTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_AverageCallTime(self: *const T, plCallTime: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_AverageCallTime(@as(*const ITAgentSession, @ptrCast(self)), plCallTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_TotalWrapUpTime(self: *const T, plWrapUpTime: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_TotalWrapUpTime(@as(*const ITAgentSession, @ptrCast(self)), plWrapUpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_AverageWrapUpTime(self: *const T, plWrapUpTime: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_AverageWrapUpTime(@as(*const ITAgentSession, @ptrCast(self)), plWrapUpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_ACDCallRate(self: *const T, pcyCallrate: ?*CY) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_ACDCallRate(@as(*const ITAgentSession, @ptrCast(self)), pcyCallrate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_LongestTimeToAnswer(self: *const T, plAnswerTime: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_LongestTimeToAnswer(@as(*const ITAgentSession, @ptrCast(self)), plAnswerTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSession_get_AverageTimeToAnswer(self: *const T, plAnswerTime: ?*i32) HRESULT {
                return @as(*const ITAgentSession.VTable, @ptrCast(self.vtable)).get_AverageTimeToAnswer(@as(*const ITAgentSession, @ptrCast(self)), plAnswerTime);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITACDGroup_Value = Guid.initString("5afc3148-4bcc-11d1-bf80-00805fc147d3");
pub const IID_ITACDGroup = &IID_ITACDGroup_Value;
pub const ITACDGroup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITACDGroup,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITACDGroup,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateQueues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITACDGroup,
                ppEnumQueue: ?*?*IEnumQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITACDGroup,
                ppEnumQueue: ?*?*IEnumQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Queues: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITACDGroup,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITACDGroup,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITACDGroup_get_Name(self: *const T, ppName: ?*?BSTR) HRESULT {
                return @as(*const ITACDGroup.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ITACDGroup, @ptrCast(self)), ppName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITACDGroup_EnumerateQueues(self: *const T, ppEnumQueue: ?*?*IEnumQueue) HRESULT {
                return @as(*const ITACDGroup.VTable, @ptrCast(self.vtable)).EnumerateQueues(@as(*const ITACDGroup, @ptrCast(self)), ppEnumQueue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITACDGroup_get_Queues(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITACDGroup.VTable, @ptrCast(self.vtable)).get_Queues(@as(*const ITACDGroup, @ptrCast(self)), pVariant);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITQueue_Value = Guid.initString("5afc3149-4bcc-11d1-bf80-00805fc147d3");
pub const IID_ITQueue = &IID_ITQueue_Value;
pub const ITQueue = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MeasurementPeriod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                lPeriod: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                lPeriod: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MeasurementPeriod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plPeriod: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plPeriod: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalCallsQueued: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCallsQueued: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalCallsAbandoned: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalCallsFlowedIn: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalCallsFlowedOut: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LongestEverWaitTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plWaitTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plWaitTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentLongestWaitTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plWaitTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plWaitTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AverageWaitTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plWaitTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plWaitTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FinalDisposition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                plCalls: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueue,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueue,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_put_MeasurementPeriod(self: *const T, lPeriod: i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).put_MeasurementPeriod(@as(*const ITQueue, @ptrCast(self)), lPeriod);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_MeasurementPeriod(self: *const T, plPeriod: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_MeasurementPeriod(@as(*const ITQueue, @ptrCast(self)), plPeriod);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_TotalCallsQueued(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_TotalCallsQueued(@as(*const ITQueue, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_CurrentCallsQueued(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_CurrentCallsQueued(@as(*const ITQueue, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_TotalCallsAbandoned(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_TotalCallsAbandoned(@as(*const ITQueue, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_TotalCallsFlowedIn(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_TotalCallsFlowedIn(@as(*const ITQueue, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_TotalCallsFlowedOut(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_TotalCallsFlowedOut(@as(*const ITQueue, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_LongestEverWaitTime(self: *const T, plWaitTime: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_LongestEverWaitTime(@as(*const ITQueue, @ptrCast(self)), plWaitTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_CurrentLongestWaitTime(self: *const T, plWaitTime: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_CurrentLongestWaitTime(@as(*const ITQueue, @ptrCast(self)), plWaitTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_AverageWaitTime(self: *const T, plWaitTime: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_AverageWaitTime(@as(*const ITQueue, @ptrCast(self)), plWaitTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_FinalDisposition(self: *const T, plCalls: ?*i32) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_FinalDisposition(@as(*const ITQueue, @ptrCast(self)), plCalls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueue_get_Name(self: *const T, ppName: ?*?BSTR) HRESULT {
                return @as(*const ITQueue.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ITQueue, @ptrCast(self)), ppName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAgentEvent_Value = Guid.initString("5afc314a-4bcc-11d1-bf80-00805fc147d3");
pub const IID_ITAgentEvent = &IID_ITAgentEvent_Value;
pub const ITAgentEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Agent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentEvent,
                ppAgent: ?*?*ITAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentEvent,
                ppAgent: ?*?*ITAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentEvent,
                pEvent: ?*AGENT_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentEvent,
                pEvent: ?*AGENT_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentEvent_get_Agent(self: *const T, ppAgent: ?*?*ITAgent) HRESULT {
                return @as(*const ITAgentEvent.VTable, @ptrCast(self.vtable)).get_Agent(@as(*const ITAgentEvent, @ptrCast(self)), ppAgent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentEvent_get_Event(self: *const T, pEvent: ?*AGENT_EVENT) HRESULT {
                return @as(*const ITAgentEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITAgentEvent, @ptrCast(self)), pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAgentSessionEvent_Value = Guid.initString("5afc314b-4bcc-11d1-bf80-00805fc147d3");
pub const IID_ITAgentSessionEvent = &IID_ITAgentSessionEvent_Value;
pub const ITAgentSessionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Session: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSessionEvent,
                ppSession: ?*?*ITAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSessionEvent,
                ppSession: ?*?*ITAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentSessionEvent,
                pEvent: ?*AGENT_SESSION_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentSessionEvent,
                pEvent: ?*AGENT_SESSION_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSessionEvent_get_Session(self: *const T, ppSession: ?*?*ITAgentSession) HRESULT {
                return @as(*const ITAgentSessionEvent.VTable, @ptrCast(self.vtable)).get_Session(@as(*const ITAgentSessionEvent, @ptrCast(self)), ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentSessionEvent_get_Event(self: *const T, pEvent: ?*AGENT_SESSION_EVENT) HRESULT {
                return @as(*const ITAgentSessionEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITAgentSessionEvent, @ptrCast(self)), pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITACDGroupEvent_Value = Guid.initString("297f3032-bd11-11d1-a0a7-00805fc147d3");
pub const IID_ITACDGroupEvent = &IID_ITACDGroupEvent_Value;
pub const ITACDGroupEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Group: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITACDGroupEvent,
                ppGroup: ?*?*ITACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITACDGroupEvent,
                ppGroup: ?*?*ITACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITACDGroupEvent,
                pEvent: ?*ACDGROUP_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITACDGroupEvent,
                pEvent: ?*ACDGROUP_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITACDGroupEvent_get_Group(self: *const T, ppGroup: ?*?*ITACDGroup) HRESULT {
                return @as(*const ITACDGroupEvent.VTable, @ptrCast(self.vtable)).get_Group(@as(*const ITACDGroupEvent, @ptrCast(self)), ppGroup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITACDGroupEvent_get_Event(self: *const T, pEvent: ?*ACDGROUP_EVENT) HRESULT {
                return @as(*const ITACDGroupEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITACDGroupEvent, @ptrCast(self)), pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITQueueEvent_Value = Guid.initString("297f3033-bd11-11d1-a0a7-00805fc147d3");
pub const IID_ITQueueEvent = &IID_ITQueueEvent_Value;
pub const ITQueueEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Queue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueueEvent,
                ppQueue: ?*?*ITQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueueEvent,
                ppQueue: ?*?*ITQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITQueueEvent,
                pEvent: ?*ACDQUEUE_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITQueueEvent,
                pEvent: ?*ACDQUEUE_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueueEvent_get_Queue(self: *const T, ppQueue: ?*?*ITQueue) HRESULT {
                return @as(*const ITQueueEvent.VTable, @ptrCast(self.vtable)).get_Queue(@as(*const ITQueueEvent, @ptrCast(self)), ppQueue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITQueueEvent_get_Event(self: *const T, pEvent: ?*ACDQUEUE_EVENT) HRESULT {
                return @as(*const ITQueueEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITQueueEvent, @ptrCast(self)), pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAgentHandlerEvent_Value = Guid.initString("297f3034-bd11-11d1-a0a7-00805fc147d3");
pub const IID_ITAgentHandlerEvent = &IID_ITAgentHandlerEvent_Value;
pub const ITAgentHandlerEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AgentHandler: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentHandlerEvent,
                ppAgentHandler: ?*?*ITAgentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentHandlerEvent,
                ppAgentHandler: ?*?*ITAgentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentHandlerEvent,
                pEvent: ?*AGENTHANDLER_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentHandlerEvent,
                pEvent: ?*AGENTHANDLER_EVENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentHandlerEvent_get_AgentHandler(self: *const T, ppAgentHandler: ?*?*ITAgentHandler) HRESULT {
                return @as(*const ITAgentHandlerEvent.VTable, @ptrCast(self.vtable)).get_AgentHandler(@as(*const ITAgentHandlerEvent, @ptrCast(self)), ppAgentHandler);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentHandlerEvent_get_Event(self: *const T, pEvent: ?*AGENTHANDLER_EVENT) HRESULT {
                return @as(*const ITAgentHandlerEvent.VTable, @ptrCast(self.vtable)).get_Event(@as(*const ITAgentHandlerEvent, @ptrCast(self)), pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTAPICallCenter_Value = Guid.initString("5afc3154-4bcc-11d1-bf80-00805fc147d3");
pub const IID_ITTAPICallCenter = &IID_ITTAPICallCenter_Value;
pub const ITTAPICallCenter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        EnumerateAgentHandlers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITTAPICallCenter,
                ppEnumHandler: ?*?*IEnumAgentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITTAPICallCenter,
                ppEnumHandler: ?*?*IEnumAgentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AgentHandlers: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITTAPICallCenter,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITTAPICallCenter,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPICallCenter_EnumerateAgentHandlers(self: *const T, ppEnumHandler: ?*?*IEnumAgentHandler) HRESULT {
                return @as(*const ITTAPICallCenter.VTable, @ptrCast(self.vtable)).EnumerateAgentHandlers(@as(*const ITTAPICallCenter, @ptrCast(self)), ppEnumHandler);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITTAPICallCenter_get_AgentHandlers(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITTAPICallCenter.VTable, @ptrCast(self.vtable)).get_AgentHandlers(@as(*const ITTAPICallCenter, @ptrCast(self)), pVariant);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAgentHandler_Value = Guid.initString("587e8c22-9802-11d1-a0a4-00805fc147d3");
pub const IID_ITAgentHandler = &IID_ITAgentHandler_Value;
pub const ITAgentHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentHandler,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentHandler,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAgent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAgentHandler,
                ppAgent: ?*?*ITAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAgentHandler,
                ppAgent: ?*?*ITAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAgentWithID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAgentHandler,
                pID: ?BSTR,
                pPIN: ?BSTR,
                ppAgent: ?*?*ITAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAgentHandler,
                pID: ?BSTR,
                pPIN: ?BSTR,
                ppAgent: ?*?*ITAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateACDGroups: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAgentHandler,
                ppEnumACDGroup: ?*?*IEnumACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAgentHandler,
                ppEnumACDGroup: ?*?*IEnumACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateUsableAddresses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAgentHandler,
                ppEnumAddress: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAgentHandler,
                ppEnumAddress: ?*?*IEnumAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ACDGroups: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentHandler,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentHandler,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsableAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAgentHandler,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAgentHandler,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentHandler_get_Name(self: *const T, ppName: ?*?BSTR) HRESULT {
                return @as(*const ITAgentHandler.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ITAgentHandler, @ptrCast(self)), ppName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentHandler_CreateAgent(self: *const T, ppAgent: ?*?*ITAgent) HRESULT {
                return @as(*const ITAgentHandler.VTable, @ptrCast(self.vtable)).CreateAgent(@as(*const ITAgentHandler, @ptrCast(self)), ppAgent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentHandler_CreateAgentWithID(self: *const T, pID: ?BSTR, pPIN: ?BSTR, ppAgent: ?*?*ITAgent) HRESULT {
                return @as(*const ITAgentHandler.VTable, @ptrCast(self.vtable)).CreateAgentWithID(@as(*const ITAgentHandler, @ptrCast(self)), pID, pPIN, ppAgent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentHandler_EnumerateACDGroups(self: *const T, ppEnumACDGroup: ?*?*IEnumACDGroup) HRESULT {
                return @as(*const ITAgentHandler.VTable, @ptrCast(self.vtable)).EnumerateACDGroups(@as(*const ITAgentHandler, @ptrCast(self)), ppEnumACDGroup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentHandler_EnumerateUsableAddresses(self: *const T, ppEnumAddress: ?*?*IEnumAddress) HRESULT {
                return @as(*const ITAgentHandler.VTable, @ptrCast(self.vtable)).EnumerateUsableAddresses(@as(*const ITAgentHandler, @ptrCast(self)), ppEnumAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentHandler_get_ACDGroups(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAgentHandler.VTable, @ptrCast(self.vtable)).get_ACDGroups(@as(*const ITAgentHandler, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAgentHandler_get_UsableAddresses(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITAgentHandler.VTable, @ptrCast(self.vtable)).get_UsableAddresses(@as(*const ITAgentHandler, @ptrCast(self)), pVariant);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumAgent_Value = Guid.initString("5afc314d-4bcc-11d1-bf80-00805fc147d3");
pub const IID_IEnumAgent = &IID_IEnumAgent_Value;
pub const IEnumAgent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgent,
                celt: u32,
                ppElements: ?*?*ITAgent,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgent,
                celt: u32,
                ppElements: ?*?*ITAgent,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgent,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgent,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgent,
                ppEnum: ?*?*IEnumAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgent,
                ppEnum: ?*?*IEnumAgent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgent_Next(self: *const T, celt: u32, ppElements: ?*?*ITAgent, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumAgent.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumAgent, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgent_Reset(self: *const T) HRESULT {
                return @as(*const IEnumAgent.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumAgent, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgent_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumAgent.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumAgent, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgent_Clone(self: *const T, ppEnum: ?*?*IEnumAgent) HRESULT {
                return @as(*const IEnumAgent.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumAgent, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumAgentSession_Value = Guid.initString("5afc314e-4bcc-11d1-bf80-00805fc147d3");
pub const IID_IEnumAgentSession = &IID_IEnumAgentSession_Value;
pub const IEnumAgentSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgentSession,
                celt: u32,
                ppElements: ?*?*ITAgentSession,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgentSession,
                celt: u32,
                ppElements: ?*?*ITAgentSession,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgentSession,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgentSession,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgentSession,
                ppEnum: ?*?*IEnumAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgentSession,
                ppEnum: ?*?*IEnumAgentSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgentSession_Next(self: *const T, celt: u32, ppElements: ?*?*ITAgentSession, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumAgentSession.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumAgentSession, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgentSession_Reset(self: *const T) HRESULT {
                return @as(*const IEnumAgentSession.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumAgentSession, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgentSession_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumAgentSession.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumAgentSession, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgentSession_Clone(self: *const T, ppEnum: ?*?*IEnumAgentSession) HRESULT {
                return @as(*const IEnumAgentSession.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumAgentSession, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumQueue_Value = Guid.initString("5afc3158-4bcc-11d1-bf80-00805fc147d3");
pub const IID_IEnumQueue = &IID_IEnumQueue_Value;
pub const IEnumQueue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumQueue,
                celt: u32,
                ppElements: ?*?*ITQueue,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumQueue,
                celt: u32,
                ppElements: ?*?*ITQueue,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumQueue,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumQueue,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumQueue,
                ppEnum: ?*?*IEnumQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumQueue,
                ppEnum: ?*?*IEnumQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumQueue_Next(self: *const T, celt: u32, ppElements: ?*?*ITQueue, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumQueue.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumQueue, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumQueue_Reset(self: *const T) HRESULT {
                return @as(*const IEnumQueue.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumQueue, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumQueue_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumQueue.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumQueue, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumQueue_Clone(self: *const T, ppEnum: ?*?*IEnumQueue) HRESULT {
                return @as(*const IEnumQueue.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumQueue, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumACDGroup_Value = Guid.initString("5afc3157-4bcc-11d1-bf80-00805fc147d3");
pub const IID_IEnumACDGroup = &IID_IEnumACDGroup_Value;
pub const IEnumACDGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumACDGroup,
                celt: u32,
                ppElements: ?*?*ITACDGroup,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumACDGroup,
                celt: u32,
                ppElements: ?*?*ITACDGroup,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumACDGroup,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumACDGroup,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumACDGroup,
                ppEnum: ?*?*IEnumACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumACDGroup,
                ppEnum: ?*?*IEnumACDGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumACDGroup_Next(self: *const T, celt: u32, ppElements: ?*?*ITACDGroup, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumACDGroup.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumACDGroup, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumACDGroup_Reset(self: *const T) HRESULT {
                return @as(*const IEnumACDGroup.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumACDGroup, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumACDGroup_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumACDGroup.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumACDGroup, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumACDGroup_Clone(self: *const T, ppEnum: ?*?*IEnumACDGroup) HRESULT {
                return @as(*const IEnumACDGroup.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumACDGroup, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumAgentHandler_Value = Guid.initString("587e8c28-9802-11d1-a0a4-00805fc147d3");
pub const IID_IEnumAgentHandler = &IID_IEnumAgentHandler_Value;
pub const IEnumAgentHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgentHandler,
                celt: u32,
                ppElements: ?*?*ITAgentHandler,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgentHandler,
                celt: u32,
                ppElements: ?*?*ITAgentHandler,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgentHandler,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgentHandler,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAgentHandler,
                ppEnum: ?*?*IEnumAgentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAgentHandler,
                ppEnum: ?*?*IEnumAgentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgentHandler_Next(self: *const T, celt: u32, ppElements: ?*?*ITAgentHandler, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumAgentHandler.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumAgentHandler, @ptrCast(self)), celt, ppElements, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgentHandler_Reset(self: *const T) HRESULT {
                return @as(*const IEnumAgentHandler.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumAgentHandler, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgentHandler_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumAgentHandler.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumAgentHandler, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAgentHandler_Clone(self: *const T, ppEnum: ?*?*IEnumAgentHandler) HRESULT {
                return @as(*const IEnumAgentHandler.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumAgentHandler, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAMMediaFormat_Value = Guid.initString("0364eb00-4a77-11d1-a671-006097c9a2e8");
pub const IID_ITAMMediaFormat = &IID_ITAMMediaFormat_Value;
pub const ITAMMediaFormat = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAMMediaFormat,
                ppmt: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAMMediaFormat,
                ppmt: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITAMMediaFormat,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITAMMediaFormat,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAMMediaFormat_get_MediaFormat(self: *const T, ppmt: ?*?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const ITAMMediaFormat.VTable, @ptrCast(self.vtable)).get_MediaFormat(@as(*const ITAMMediaFormat, @ptrCast(self)), ppmt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAMMediaFormat_put_MediaFormat(self: *const T, pmt: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const ITAMMediaFormat.VTable, @ptrCast(self.vtable)).put_MediaFormat(@as(*const ITAMMediaFormat, @ptrCast(self)), pmt);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITAllocatorProperties_Value = Guid.initString("c1bc3c90-bcfe-11d1-9745-00c04fd91ac0");
pub const IID_ITAllocatorProperties = &IID_ITAllocatorProperties_Value;
pub const ITAllocatorProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAllocatorProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAllocatorProperties,
                pAllocProperties: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAllocatorProperties,
                pAllocProperties: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocatorProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAllocatorProperties,
                pAllocProperties: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAllocatorProperties,
                pAllocProperties: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllocateBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAllocatorProperties,
                bAllocBuffers: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAllocatorProperties,
                bAllocBuffers: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocateBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAllocatorProperties,
                pbAllocBuffers: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAllocatorProperties,
                pbAllocBuffers: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBufferSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAllocatorProperties,
                BufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAllocatorProperties,
                BufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITAllocatorProperties,
                pBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITAllocatorProperties,
                pBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAllocatorProperties_SetAllocatorProperties(self: *const T, pAllocProperties: ?*ALLOCATOR_PROPERTIES) HRESULT {
                return @as(*const ITAllocatorProperties.VTable, @ptrCast(self.vtable)).SetAllocatorProperties(@as(*const ITAllocatorProperties, @ptrCast(self)), pAllocProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAllocatorProperties_GetAllocatorProperties(self: *const T, pAllocProperties: ?*ALLOCATOR_PROPERTIES) HRESULT {
                return @as(*const ITAllocatorProperties.VTable, @ptrCast(self.vtable)).GetAllocatorProperties(@as(*const ITAllocatorProperties, @ptrCast(self)), pAllocProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAllocatorProperties_SetAllocateBuffers(self: *const T, bAllocBuffers: BOOL) HRESULT {
                return @as(*const ITAllocatorProperties.VTable, @ptrCast(self.vtable)).SetAllocateBuffers(@as(*const ITAllocatorProperties, @ptrCast(self)), bAllocBuffers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAllocatorProperties_GetAllocateBuffers(self: *const T, pbAllocBuffers: ?*BOOL) HRESULT {
                return @as(*const ITAllocatorProperties.VTable, @ptrCast(self.vtable)).GetAllocateBuffers(@as(*const ITAllocatorProperties, @ptrCast(self)), pbAllocBuffers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAllocatorProperties_SetBufferSize(self: *const T, BufferSize: u32) HRESULT {
                return @as(*const ITAllocatorProperties.VTable, @ptrCast(self.vtable)).SetBufferSize(@as(*const ITAllocatorProperties, @ptrCast(self)), BufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITAllocatorProperties_GetBufferSize(self: *const T, pBufferSize: ?*u32) HRESULT {
                return @as(*const ITAllocatorProperties.VTable, @ptrCast(self.vtable)).GetBufferSize(@as(*const ITAllocatorProperties, @ptrCast(self)), pBufferSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MSP_ADDRESS_EVENT = enum(i32) {
    AVAILABLE = 0,
    UNAVAILABLE = 1,
};
pub const ADDRESS_TERMINAL_AVAILABLE = MSP_ADDRESS_EVENT.AVAILABLE;
pub const ADDRESS_TERMINAL_UNAVAILABLE = MSP_ADDRESS_EVENT.UNAVAILABLE;

pub const MSP_CALL_EVENT = enum(i32) {
    NEW_STREAM = 0,
    STREAM_FAIL = 1,
    TERMINAL_FAIL = 2,
    STREAM_NOT_USED = 3,
    STREAM_ACTIVE = 4,
    STREAM_INACTIVE = 5,
};
pub const CALL_NEW_STREAM = MSP_CALL_EVENT.NEW_STREAM;
pub const CALL_STREAM_FAIL = MSP_CALL_EVENT.STREAM_FAIL;
pub const CALL_TERMINAL_FAIL = MSP_CALL_EVENT.TERMINAL_FAIL;
pub const CALL_STREAM_NOT_USED = MSP_CALL_EVENT.STREAM_NOT_USED;
pub const CALL_STREAM_ACTIVE = MSP_CALL_EVENT.STREAM_ACTIVE;
pub const CALL_STREAM_INACTIVE = MSP_CALL_EVENT.STREAM_INACTIVE;

pub const MSP_CALL_EVENT_CAUSE = enum(i32) {
    UNKNOWN = 0,
    BAD_DEVICE = 1,
    CONNECT_FAIL = 2,
    LOCAL_REQUEST = 3,
    REMOTE_REQUEST = 4,
    MEDIA_TIMEOUT = 5,
    MEDIA_RECOVERED = 6,
    QUALITY_OF_SERVICE = 7,
};
pub const CALL_CAUSE_UNKNOWN = MSP_CALL_EVENT_CAUSE.UNKNOWN;
pub const CALL_CAUSE_BAD_DEVICE = MSP_CALL_EVENT_CAUSE.BAD_DEVICE;
pub const CALL_CAUSE_CONNECT_FAIL = MSP_CALL_EVENT_CAUSE.CONNECT_FAIL;
pub const CALL_CAUSE_LOCAL_REQUEST = MSP_CALL_EVENT_CAUSE.LOCAL_REQUEST;
pub const CALL_CAUSE_REMOTE_REQUEST = MSP_CALL_EVENT_CAUSE.REMOTE_REQUEST;
pub const CALL_CAUSE_MEDIA_TIMEOUT = MSP_CALL_EVENT_CAUSE.MEDIA_TIMEOUT;
pub const CALL_CAUSE_MEDIA_RECOVERED = MSP_CALL_EVENT_CAUSE.MEDIA_RECOVERED;
pub const CALL_CAUSE_QUALITY_OF_SERVICE = MSP_CALL_EVENT_CAUSE.QUALITY_OF_SERVICE;

pub const MSP_EVENT = enum(i32) {
    ADDRESS_EVENT = 0,
    CALL_EVENT = 1,
    TSP_DATA = 2,
    PRIVATE_EVENT = 3,
    ASR_TERMINAL_EVENT = 4,
    TTS_TERMINAL_EVENT = 5,
    FILE_TERMINAL_EVENT = 6,
    TONE_TERMINAL_EVENT = 7,
};
pub const ME_ADDRESS_EVENT = MSP_EVENT.ADDRESS_EVENT;
pub const ME_CALL_EVENT = MSP_EVENT.CALL_EVENT;
pub const ME_TSP_DATA = MSP_EVENT.TSP_DATA;
pub const ME_PRIVATE_EVENT = MSP_EVENT.PRIVATE_EVENT;
pub const ME_ASR_TERMINAL_EVENT = MSP_EVENT.ASR_TERMINAL_EVENT;
pub const ME_TTS_TERMINAL_EVENT = MSP_EVENT.TTS_TERMINAL_EVENT;
pub const ME_FILE_TERMINAL_EVENT = MSP_EVENT.FILE_TERMINAL_EVENT;
pub const ME_TONE_TERMINAL_EVENT = MSP_EVENT.TONE_TERMINAL_EVENT;

pub const MSP_EVENT_INFO = extern struct {
    dwSize: u32,
    Event: MSP_EVENT,
    hCall: ?*i32,
    Anonymous: extern union {
        MSP_ADDRESS_EVENT_INFO: extern struct {
            Type: MSP_ADDRESS_EVENT,
            pTerminal: ?*ITTerminal,
        },
        MSP_CALL_EVENT_INFO: extern struct {
            Type: MSP_CALL_EVENT,
            Cause: MSP_CALL_EVENT_CAUSE,
            pStream: ?*ITStream,
            pTerminal: ?*ITTerminal,
            hrError: HRESULT,
        },
        MSP_TSP_DATA: extern struct {
            dwBufferSize: u32,
            pBuffer: [1]u8,
        },
        MSP_PRIVATE_EVENT_INFO: extern struct {
            pEvent: ?*IDispatch,
            lEventCode: i32,
        },
        MSP_FILE_TERMINAL_EVENT_INFO: extern struct {
            pParentFileTerminal: ?*ITTerminal,
            pFileTrack: ?*ITFileTrack,
            TerminalMediaState: TERMINAL_MEDIA_STATE,
            ftecEventCause: FT_STATE_EVENT_CAUSE,
            hrErrorCode: HRESULT,
        },
        MSP_ASR_TERMINAL_EVENT_INFO: extern struct {
            pASRTerminal: ?*ITTerminal,
            hrErrorCode: HRESULT,
        },
        MSP_TTS_TERMINAL_EVENT_INFO: extern struct {
            pTTSTerminal: ?*ITTerminal,
            hrErrorCode: HRESULT,
        },
        MSP_TONE_TERMINAL_EVENT_INFO: extern struct {
            pToneTerminal: ?*ITTerminal,
            hrErrorCode: HRESULT,
        },
    },
};

const IID_ITPluggableTerminalEventSink_Value = Guid.initString("6e0887be-ba1a-492e-bd10-4020ec5e33e0");
pub const IID_ITPluggableTerminalEventSink = &IID_ITPluggableTerminalEventSink_Value;
pub const ITPluggableTerminalEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPluggableTerminalEventSink,
                pMspEventInfo: ?*const MSP_EVENT_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPluggableTerminalEventSink,
                pMspEventInfo: ?*const MSP_EVENT_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalEventSink_FireEvent(self: *const T, pMspEventInfo: ?*const MSP_EVENT_INFO) HRESULT {
                return @as(*const ITPluggableTerminalEventSink.VTable, @ptrCast(self.vtable)).FireEvent(@as(*const ITPluggableTerminalEventSink, @ptrCast(self)), pMspEventInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITPluggableTerminalEventSinkRegistration_Value = Guid.initString("f7115709-a216-4957-a759-060ab32a90d1");
pub const IID_ITPluggableTerminalEventSinkRegistration = &IID_ITPluggableTerminalEventSinkRegistration_Value;
pub const ITPluggableTerminalEventSinkRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPluggableTerminalEventSinkRegistration,
                pEventSink: ?*ITPluggableTerminalEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPluggableTerminalEventSinkRegistration,
                pEventSink: ?*ITPluggableTerminalEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITPluggableTerminalEventSinkRegistration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITPluggableTerminalEventSinkRegistration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalEventSinkRegistration_RegisterSink(self: *const T, pEventSink: ?*ITPluggableTerminalEventSink) HRESULT {
                return @as(*const ITPluggableTerminalEventSinkRegistration.VTable, @ptrCast(self.vtable)).RegisterSink(@as(*const ITPluggableTerminalEventSinkRegistration, @ptrCast(self)), pEventSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITPluggableTerminalEventSinkRegistration_UnregisterSink(self: *const T) HRESULT {
                return @as(*const ITPluggableTerminalEventSinkRegistration.VTable, @ptrCast(self.vtable)).UnregisterSink(@as(*const ITPluggableTerminalEventSinkRegistration, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITMSPAddress_Value = Guid.initString("ee3bd600-3868-11d2-a045-00c04fb6809f");
pub const IID_ITMSPAddress = &IID_ITMSPAddress_Value;
pub const ITMSPAddress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMSPAddress,
                hEvent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMSPAddress,
                hEvent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMSPAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMSPAddress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMSPCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMSPAddress,
                hCall: ?*i32,
                dwReserved: u32,
                dwMediaType: u32,
                pOuterUnknown: ?*IUnknown,
                ppStreamControl: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMSPAddress,
                hCall: ?*i32,
                dwReserved: u32,
                dwMediaType: u32,
                pOuterUnknown: ?*IUnknown,
                ppStreamControl: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShutdownMSPCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMSPAddress,
                pStreamControl: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMSPAddress,
                pStreamControl: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReceiveTSPData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMSPAddress,
                pMSPCall: ?*IUnknown,
                pBuffer: [*:0]u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMSPAddress,
                pMSPCall: ?*IUnknown,
                pBuffer: [*:0]u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITMSPAddress,
                pdwSize: ?*u32,
                pEventBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITMSPAddress,
                pdwSize: ?*u32,
                pEventBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMSPAddress_Initialize(self: *const T, hEvent: ?*i32) HRESULT {
                return @as(*const ITMSPAddress.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ITMSPAddress, @ptrCast(self)), hEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMSPAddress_Shutdown(self: *const T) HRESULT {
                return @as(*const ITMSPAddress.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const ITMSPAddress, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMSPAddress_CreateMSPCall(self: *const T, hCall: ?*i32, dwReserved: u32, dwMediaType: u32, pOuterUnknown: ?*IUnknown, ppStreamControl: ?*?*IUnknown) HRESULT {
                return @as(*const ITMSPAddress.VTable, @ptrCast(self.vtable)).CreateMSPCall(@as(*const ITMSPAddress, @ptrCast(self)), hCall, dwReserved, dwMediaType, pOuterUnknown, ppStreamControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMSPAddress_ShutdownMSPCall(self: *const T, pStreamControl: ?*IUnknown) HRESULT {
                return @as(*const ITMSPAddress.VTable, @ptrCast(self.vtable)).ShutdownMSPCall(@as(*const ITMSPAddress, @ptrCast(self)), pStreamControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMSPAddress_ReceiveTSPData(self: *const T, pMSPCall: ?*IUnknown, pBuffer: [*:0]u8, dwSize: u32) HRESULT {
                return @as(*const ITMSPAddress.VTable, @ptrCast(self.vtable)).ReceiveTSPData(@as(*const ITMSPAddress, @ptrCast(self)), pMSPCall, pBuffer, dwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITMSPAddress_GetEvent(self: *const T, pdwSize: ?*u32, pEventBuffer: [*:0]u8) HRESULT {
                return @as(*const ITMSPAddress.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const ITMSPAddress, @ptrCast(self)), pdwSize, pEventBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITTAPIDispatchEventNotification_Value = Guid.initString("9f34325b-7e62-11d2-9457-00c04f8ec888");
pub const IID_ITTAPIDispatchEventNotification = &IID_ITTAPIDispatchEventNotification_Value;
pub const ITTAPIDispatchEventNotification = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_Rendezvous_Value = Guid.initString("f1029e5b-cb5b-11d0-8d59-00c04fd91ac0");
pub const CLSID_Rendezvous = &CLSID_Rendezvous_Value;

pub const DIRECTORY_TYPE = enum(i32) {
    NTDS = 1,
    ILS = 2,
};
pub const DT_NTDS = DIRECTORY_TYPE.NTDS;
pub const DT_ILS = DIRECTORY_TYPE.ILS;

pub const DIRECTORY_OBJECT_TYPE = enum(i32) {
    CONFERENCE = 1,
    USER = 2,
};
pub const OT_CONFERENCE = DIRECTORY_OBJECT_TYPE.CONFERENCE;
pub const OT_USER = DIRECTORY_OBJECT_TYPE.USER;

pub const RND_ADVERTISING_SCOPE = enum(i32) {
    LOCAL = 1,
    SITE = 2,
    REGION = 3,
    WORLD = 4,
};
pub const RAS_LOCAL = RND_ADVERTISING_SCOPE.LOCAL;
pub const RAS_SITE = RND_ADVERTISING_SCOPE.SITE;
pub const RAS_REGION = RND_ADVERTISING_SCOPE.REGION;
pub const RAS_WORLD = RND_ADVERTISING_SCOPE.WORLD;

const IID_ITDirectoryObjectConference_Value = Guid.initString("f1029e5d-cb5b-11d0-8d59-00c04fd91ac0");
pub const IID_ITDirectoryObjectConference = &IID_ITDirectoryObjectConference_Value;
pub const ITDirectoryObjectConference = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                ppProtocol: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                ppProtocol: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Originator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                ppOriginator: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                ppOriginator: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Originator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                pOriginator: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                pOriginator: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AdvertisingScope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                pAdvertisingScope: ?*RND_ADVERTISING_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                pAdvertisingScope: ?*RND_ADVERTISING_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AdvertisingScope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                AdvertisingScope: RND_ADVERTISING_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                AdvertisingScope: RND_ADVERTISING_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Url: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                ppUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                ppUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Url: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                pUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                pUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                ppDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                ppDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                pDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                pDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsEncrypted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                pfEncrypted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                pfEncrypted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsEncrypted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                fEncrypted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                fEncrypted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                pDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                pDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                Date: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                Date: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                pDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                pDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectConference,
                Date: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectConference,
                Date: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_get_Protocol(self: *const T, ppProtocol: ?*?BSTR) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).get_Protocol(@as(*const ITDirectoryObjectConference, @ptrCast(self)), ppProtocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_get_Originator(self: *const T, ppOriginator: ?*?BSTR) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).get_Originator(@as(*const ITDirectoryObjectConference, @ptrCast(self)), ppOriginator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_put_Originator(self: *const T, pOriginator: ?BSTR) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).put_Originator(@as(*const ITDirectoryObjectConference, @ptrCast(self)), pOriginator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_get_AdvertisingScope(self: *const T, pAdvertisingScope: ?*RND_ADVERTISING_SCOPE) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).get_AdvertisingScope(@as(*const ITDirectoryObjectConference, @ptrCast(self)), pAdvertisingScope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_put_AdvertisingScope(self: *const T, AdvertisingScope: RND_ADVERTISING_SCOPE) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).put_AdvertisingScope(@as(*const ITDirectoryObjectConference, @ptrCast(self)), AdvertisingScope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_get_Url(self: *const T, ppUrl: ?*?BSTR) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).get_Url(@as(*const ITDirectoryObjectConference, @ptrCast(self)), ppUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_put_Url(self: *const T, pUrl: ?BSTR) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).put_Url(@as(*const ITDirectoryObjectConference, @ptrCast(self)), pUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_get_Description(self: *const T, ppDescription: ?*?BSTR) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).get_Description(@as(*const ITDirectoryObjectConference, @ptrCast(self)), ppDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_put_Description(self: *const T, pDescription: ?BSTR) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).put_Description(@as(*const ITDirectoryObjectConference, @ptrCast(self)), pDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_get_IsEncrypted(self: *const T, pfEncrypted: ?*i16) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).get_IsEncrypted(@as(*const ITDirectoryObjectConference, @ptrCast(self)), pfEncrypted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_put_IsEncrypted(self: *const T, fEncrypted: i16) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).put_IsEncrypted(@as(*const ITDirectoryObjectConference, @ptrCast(self)), fEncrypted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_get_StartTime(self: *const T, pDate: ?*f64) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).get_StartTime(@as(*const ITDirectoryObjectConference, @ptrCast(self)), pDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_put_StartTime(self: *const T, Date: f64) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).put_StartTime(@as(*const ITDirectoryObjectConference, @ptrCast(self)), Date);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_get_StopTime(self: *const T, pDate: ?*f64) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).get_StopTime(@as(*const ITDirectoryObjectConference, @ptrCast(self)), pDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectConference_put_StopTime(self: *const T, Date: f64) HRESULT {
                return @as(*const ITDirectoryObjectConference.VTable, @ptrCast(self.vtable)).put_StopTime(@as(*const ITDirectoryObjectConference, @ptrCast(self)), Date);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITDirectoryObjectUser_Value = Guid.initString("34621d6f-6cff-11d1-aff7-00c04fc31fee");
pub const IID_ITDirectoryObjectUser = &IID_ITDirectoryObjectUser_Value;
pub const ITDirectoryObjectUser = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IPPhonePrimary: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectUser,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectUser,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IPPhonePrimary: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObjectUser,
                pName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObjectUser,
                pName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectUser_get_IPPhonePrimary(self: *const T, ppName: ?*?BSTR) HRESULT {
                return @as(*const ITDirectoryObjectUser.VTable, @ptrCast(self.vtable)).get_IPPhonePrimary(@as(*const ITDirectoryObjectUser, @ptrCast(self)), ppName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObjectUser_put_IPPhonePrimary(self: *const T, pName: ?BSTR) HRESULT {
                return @as(*const ITDirectoryObjectUser.VTable, @ptrCast(self.vtable)).put_IPPhonePrimary(@as(*const ITDirectoryObjectUser, @ptrCast(self)), pName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDialableAddrs_Value = Guid.initString("34621d70-6cff-11d1-aff7-00c04fc31fee");
pub const IID_IEnumDialableAddrs = &IID_IEnumDialableAddrs_Value;
pub const IEnumDialableAddrs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDialableAddrs,
                celt: u32,
                ppElements: [*]?BSTR,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDialableAddrs,
                celt: u32,
                ppElements: [*]?BSTR,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDialableAddrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDialableAddrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDialableAddrs,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDialableAddrs,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDialableAddrs,
                ppEnum: ?*?*IEnumDialableAddrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDialableAddrs,
                ppEnum: ?*?*IEnumDialableAddrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDialableAddrs_Next(self: *const T, celt: u32, ppElements: [*]?BSTR, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumDialableAddrs.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDialableAddrs, @ptrCast(self)), celt, ppElements, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDialableAddrs_Reset(self: *const T) HRESULT {
                return @as(*const IEnumDialableAddrs.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDialableAddrs, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDialableAddrs_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumDialableAddrs.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDialableAddrs, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDialableAddrs_Clone(self: *const T, ppEnum: ?*?*IEnumDialableAddrs) HRESULT {
                return @as(*const IEnumDialableAddrs.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDialableAddrs, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITDirectoryObject_Value = Guid.initString("34621d6e-6cff-11d1-aff7-00c04fc31fee");
pub const IID_ITDirectoryObject = &IID_ITDirectoryObject_Value;
pub const ITDirectoryObject = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ObjectType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObject,
                pObjectType: ?*DIRECTORY_OBJECT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObject,
                pObjectType: ?*DIRECTORY_OBJECT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObject,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObject,
                ppName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObject,
                pName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObject,
                pName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DialableAddrs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObject,
                dwAddressType: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObject,
                dwAddressType: i32,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateDialableAddrs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDirectoryObject,
                dwAddressType: u32,
                ppEnumDialableAddrs: ?*?*IEnumDialableAddrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDirectoryObject,
                dwAddressType: u32,
                ppEnumDialableAddrs: ?*?*IEnumDialableAddrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SecurityDescriptor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObject,
                ppSecDes: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObject,
                ppSecDes: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SecurityDescriptor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectoryObject,
                pSecDes: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectoryObject,
                pSecDes: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObject_get_ObjectType(self: *const T, pObjectType: ?*DIRECTORY_OBJECT_TYPE) HRESULT {
                return @as(*const ITDirectoryObject.VTable, @ptrCast(self.vtable)).get_ObjectType(@as(*const ITDirectoryObject, @ptrCast(self)), pObjectType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObject_get_Name(self: *const T, ppName: ?*?BSTR) HRESULT {
                return @as(*const ITDirectoryObject.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ITDirectoryObject, @ptrCast(self)), ppName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObject_put_Name(self: *const T, pName: ?BSTR) HRESULT {
                return @as(*const ITDirectoryObject.VTable, @ptrCast(self.vtable)).put_Name(@as(*const ITDirectoryObject, @ptrCast(self)), pName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObject_get_DialableAddrs(self: *const T, dwAddressType: i32, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITDirectoryObject.VTable, @ptrCast(self.vtable)).get_DialableAddrs(@as(*const ITDirectoryObject, @ptrCast(self)), dwAddressType, pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObject_EnumerateDialableAddrs(self: *const T, dwAddressType: u32, ppEnumDialableAddrs: ?*?*IEnumDialableAddrs) HRESULT {
                return @as(*const ITDirectoryObject.VTable, @ptrCast(self.vtable)).EnumerateDialableAddrs(@as(*const ITDirectoryObject, @ptrCast(self)), dwAddressType, ppEnumDialableAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObject_get_SecurityDescriptor(self: *const T, ppSecDes: ?*?*IDispatch) HRESULT {
                return @as(*const ITDirectoryObject.VTable, @ptrCast(self.vtable)).get_SecurityDescriptor(@as(*const ITDirectoryObject, @ptrCast(self)), ppSecDes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectoryObject_put_SecurityDescriptor(self: *const T, pSecDes: ?*IDispatch) HRESULT {
                return @as(*const ITDirectoryObject.VTable, @ptrCast(self.vtable)).put_SecurityDescriptor(@as(*const ITDirectoryObject, @ptrCast(self)), pSecDes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDirectoryObject_Value = Guid.initString("06c9b64a-306d-11d1-9774-00c04fd91ac0");
pub const IID_IEnumDirectoryObject = &IID_IEnumDirectoryObject_Value;
pub const IEnumDirectoryObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDirectoryObject,
                celt: u32,
                pVal: [*]?*ITDirectoryObject,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDirectoryObject,
                celt: u32,
                pVal: [*]?*ITDirectoryObject,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDirectoryObject,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDirectoryObject,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDirectoryObject,
                ppEnum: ?*?*IEnumDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDirectoryObject,
                ppEnum: ?*?*IEnumDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDirectoryObject_Next(self: *const T, celt: u32, pVal: [*]?*ITDirectoryObject, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumDirectoryObject.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDirectoryObject, @ptrCast(self)), celt, pVal, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDirectoryObject_Reset(self: *const T) HRESULT {
                return @as(*const IEnumDirectoryObject.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDirectoryObject, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDirectoryObject_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumDirectoryObject.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDirectoryObject, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDirectoryObject_Clone(self: *const T, ppEnum: ?*?*IEnumDirectoryObject) HRESULT {
                return @as(*const IEnumDirectoryObject.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDirectoryObject, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITILSConfig_Value = Guid.initString("34621d72-6cff-11d1-aff7-00c04fc31fee");
pub const IID_ITILSConfig = &IID_ITILSConfig_Value;
pub const ITILSConfig = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Port: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITILSConfig,
                pPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITILSConfig,
                pPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Port: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITILSConfig,
                Port: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITILSConfig,
                Port: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITILSConfig_get_Port(self: *const T, pPort: ?*i32) HRESULT {
                return @as(*const ITILSConfig.VTable, @ptrCast(self.vtable)).get_Port(@as(*const ITILSConfig, @ptrCast(self)), pPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITILSConfig_put_Port(self: *const T, Port: i32) HRESULT {
                return @as(*const ITILSConfig.VTable, @ptrCast(self.vtable)).put_Port(@as(*const ITILSConfig, @ptrCast(self)), Port);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITDirectory_Value = Guid.initString("34621d6c-6cff-11d1-aff7-00c04fc31fee");
pub const IID_ITDirectory = &IID_ITDirectory_Value;
pub const ITDirectory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DirectoryType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectory,
                pDirectoryType: ?*DIRECTORY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectory,
                pDirectoryType: ?*DIRECTORY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectory,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectory,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDynamic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectory,
                pfDynamic: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectory,
                pfDynamic: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultObjectTTL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectory,
                pTTL: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectory,
                pTTL: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultObjectTTL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectory,
                TTL: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectory,
                TTL: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableAutoRefresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDirectory,
                fEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDirectory,
                fEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDirectory,
                fSecure: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDirectory,
                fSecure: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Bind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDirectory,
                pDomainName: ?BSTR,
                pUserName: ?BSTR,
                pPassword: ?BSTR,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDirectory,
                pDomainName: ?BSTR,
                pUserName: ?BSTR,
                pPassword: ?BSTR,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDirectoryObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDirectory,
                pDirectoryObject: ?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDirectory,
                pDirectoryObject: ?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifyDirectoryObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDirectory,
                pDirectoryObject: ?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDirectory,
                pDirectoryObject: ?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefreshDirectoryObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDirectory,
                pDirectoryObject: ?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDirectory,
                pDirectoryObject: ?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteDirectoryObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDirectory,
                pDirectoryObject: ?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDirectory,
                pDirectoryObject: ?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DirectoryObjects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITDirectory,
                DirectoryObjectType: DIRECTORY_OBJECT_TYPE,
                pName: ?BSTR,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITDirectory,
                DirectoryObjectType: DIRECTORY_OBJECT_TYPE,
                pName: ?BSTR,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateDirectoryObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITDirectory,
                DirectoryObjectType: DIRECTORY_OBJECT_TYPE,
                pName: ?BSTR,
                ppEnumObject: ?*?*IEnumDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITDirectory,
                DirectoryObjectType: DIRECTORY_OBJECT_TYPE,
                pName: ?BSTR,
                ppEnumObject: ?*?*IEnumDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_get_DirectoryType(self: *const T, pDirectoryType: ?*DIRECTORY_TYPE) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).get_DirectoryType(@as(*const ITDirectory, @ptrCast(self)), pDirectoryType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_get_DisplayName(self: *const T, pName: ?*?BSTR) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).get_DisplayName(@as(*const ITDirectory, @ptrCast(self)), pName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_get_IsDynamic(self: *const T, pfDynamic: ?*i16) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).get_IsDynamic(@as(*const ITDirectory, @ptrCast(self)), pfDynamic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_get_DefaultObjectTTL(self: *const T, pTTL: ?*i32) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).get_DefaultObjectTTL(@as(*const ITDirectory, @ptrCast(self)), pTTL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_put_DefaultObjectTTL(self: *const T, TTL: i32) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).put_DefaultObjectTTL(@as(*const ITDirectory, @ptrCast(self)), TTL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_EnableAutoRefresh(self: *const T, fEnable: i16) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).EnableAutoRefresh(@as(*const ITDirectory, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_Connect(self: *const T, fSecure: i16) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).Connect(@as(*const ITDirectory, @ptrCast(self)), fSecure);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_Bind(self: *const T, pDomainName: ?BSTR, pUserName: ?BSTR, pPassword: ?BSTR, lFlags: i32) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).Bind(@as(*const ITDirectory, @ptrCast(self)), pDomainName, pUserName, pPassword, lFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_AddDirectoryObject(self: *const T, pDirectoryObject: ?*ITDirectoryObject) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).AddDirectoryObject(@as(*const ITDirectory, @ptrCast(self)), pDirectoryObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_ModifyDirectoryObject(self: *const T, pDirectoryObject: ?*ITDirectoryObject) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).ModifyDirectoryObject(@as(*const ITDirectory, @ptrCast(self)), pDirectoryObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_RefreshDirectoryObject(self: *const T, pDirectoryObject: ?*ITDirectoryObject) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).RefreshDirectoryObject(@as(*const ITDirectory, @ptrCast(self)), pDirectoryObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_DeleteDirectoryObject(self: *const T, pDirectoryObject: ?*ITDirectoryObject) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).DeleteDirectoryObject(@as(*const ITDirectory, @ptrCast(self)), pDirectoryObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_get_DirectoryObjects(self: *const T, DirectoryObjectType: DIRECTORY_OBJECT_TYPE, pName: ?BSTR, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).get_DirectoryObjects(@as(*const ITDirectory, @ptrCast(self)), DirectoryObjectType, pName, pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITDirectory_EnumerateDirectoryObjects(self: *const T, DirectoryObjectType: DIRECTORY_OBJECT_TYPE, pName: ?BSTR, ppEnumObject: ?*?*IEnumDirectoryObject) HRESULT {
                return @as(*const ITDirectory.VTable, @ptrCast(self.vtable)).EnumerateDirectoryObjects(@as(*const ITDirectory, @ptrCast(self)), DirectoryObjectType, pName, ppEnumObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDirectory_Value = Guid.initString("34621d6d-6cff-11d1-aff7-00c04fc31fee");
pub const IID_IEnumDirectory = &IID_IEnumDirectory_Value;
pub const IEnumDirectory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDirectory,
                celt: u32,
                ppElements: [*]?*ITDirectory,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDirectory,
                celt: u32,
                ppElements: [*]?*ITDirectory,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDirectory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDirectory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDirectory,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDirectory,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDirectory,
                ppEnum: ?*?*IEnumDirectory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDirectory,
                ppEnum: ?*?*IEnumDirectory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDirectory_Next(self: *const T, celt: u32, ppElements: [*]?*ITDirectory, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumDirectory.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDirectory, @ptrCast(self)), celt, ppElements, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDirectory_Reset(self: *const T) HRESULT {
                return @as(*const IEnumDirectory.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDirectory, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDirectory_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumDirectory.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDirectory, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDirectory_Clone(self: *const T, ppEnum: ?*?*IEnumDirectory) HRESULT {
                return @as(*const IEnumDirectory.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDirectory, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITRendezvous_Value = Guid.initString("34621d6b-6cff-11d1-aff7-00c04fc31fee");
pub const IID_ITRendezvous = &IID_ITRendezvous_Value;
pub const ITRendezvous = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultDirectories: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITRendezvous,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITRendezvous,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateDefaultDirectories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITRendezvous,
                ppEnumDirectory: ?*?*IEnumDirectory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITRendezvous,
                ppEnumDirectory: ?*?*IEnumDirectory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITRendezvous,
                DirectoryType: DIRECTORY_TYPE,
                pName: ?BSTR,
                ppDir: ?*?*ITDirectory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITRendezvous,
                DirectoryType: DIRECTORY_TYPE,
                pName: ?BSTR,
                ppDir: ?*?*ITDirectory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDirectoryObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITRendezvous,
                DirectoryObjectType: DIRECTORY_OBJECT_TYPE,
                pName: ?BSTR,
                ppDirectoryObject: ?*?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITRendezvous,
                DirectoryObjectType: DIRECTORY_OBJECT_TYPE,
                pName: ?BSTR,
                ppDirectoryObject: ?*?*ITDirectoryObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRendezvous_get_DefaultDirectories(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const ITRendezvous.VTable, @ptrCast(self.vtable)).get_DefaultDirectories(@as(*const ITRendezvous, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRendezvous_EnumerateDefaultDirectories(self: *const T, ppEnumDirectory: ?*?*IEnumDirectory) HRESULT {
                return @as(*const ITRendezvous.VTable, @ptrCast(self.vtable)).EnumerateDefaultDirectories(@as(*const ITRendezvous, @ptrCast(self)), ppEnumDirectory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRendezvous_CreateDirectory(self: *const T, DirectoryType: DIRECTORY_TYPE, pName: ?BSTR, ppDir: ?*?*ITDirectory) HRESULT {
                return @as(*const ITRendezvous.VTable, @ptrCast(self.vtable)).CreateDirectory(@as(*const ITRendezvous, @ptrCast(self)), DirectoryType, pName, ppDir);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITRendezvous_CreateDirectoryObject(self: *const T, DirectoryObjectType: DIRECTORY_OBJECT_TYPE, pName: ?BSTR, ppDirectoryObject: ?*?*ITDirectoryObject) HRESULT {
                return @as(*const ITRendezvous.VTable, @ptrCast(self.vtable)).CreateDirectoryObject(@as(*const ITRendezvous, @ptrCast(self)), DirectoryObjectType, pName, ppDirectoryObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_McastAddressAllocation_Value = Guid.initString("df0daef2-a289-11d1-8697-006008b0e5d2");
pub const CLSID_McastAddressAllocation = &CLSID_McastAddressAllocation_Value;

const IID_IMcastScope_Value = Guid.initString("df0daef4-a289-11d1-8697-006008b0e5d2");
pub const IID_IMcastScope = &IID_IMcastScope_Value;
pub const IMcastScope = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScopeID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastScope,
                pID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastScope,
                pID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServerID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastScope,
                pID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastScope,
                pID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InterfaceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastScope,
                pID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastScope,
                pID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScopeDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastScope,
                ppDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastScope,
                ppDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TTL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastScope,
                pTTL: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastScope,
                pTTL: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastScope_get_ScopeID(self: *const T, pID: ?*i32) HRESULT {
                return @as(*const IMcastScope.VTable, @ptrCast(self.vtable)).get_ScopeID(@as(*const IMcastScope, @ptrCast(self)), pID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastScope_get_ServerID(self: *const T, pID: ?*i32) HRESULT {
                return @as(*const IMcastScope.VTable, @ptrCast(self.vtable)).get_ServerID(@as(*const IMcastScope, @ptrCast(self)), pID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastScope_get_InterfaceID(self: *const T, pID: ?*i32) HRESULT {
                return @as(*const IMcastScope.VTable, @ptrCast(self.vtable)).get_InterfaceID(@as(*const IMcastScope, @ptrCast(self)), pID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastScope_get_ScopeDescription(self: *const T, ppDescription: ?*?BSTR) HRESULT {
                return @as(*const IMcastScope.VTable, @ptrCast(self.vtable)).get_ScopeDescription(@as(*const IMcastScope, @ptrCast(self)), ppDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastScope_get_TTL(self: *const T, pTTL: ?*i32) HRESULT {
                return @as(*const IMcastScope.VTable, @ptrCast(self.vtable)).get_TTL(@as(*const IMcastScope, @ptrCast(self)), pTTL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMcastLeaseInfo_Value = Guid.initString("df0daefd-a289-11d1-8697-006008b0e5d2");
pub const IID_IMcastLeaseInfo = &IID_IMcastLeaseInfo_Value;
pub const IMcastLeaseInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                ppRequestID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastLeaseInfo,
                ppRequestID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LeaseStartTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                pTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastLeaseInfo,
                pTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LeaseStartTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastLeaseInfo,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LeaseStopTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                pTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastLeaseInfo,
                pTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LeaseStopTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastLeaseInfo,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AddressCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastLeaseInfo,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServerAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                ppAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastLeaseInfo,
                ppAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TTL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                pTTL: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastLeaseInfo,
                pTTL: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Addresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastLeaseInfo,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateAddresses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMcastLeaseInfo,
                ppEnumAddresses: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMcastLeaseInfo,
                ppEnumAddresses: ?*?*IEnumBstr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_get_RequestID(self: *const T, ppRequestID: ?*?BSTR) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).get_RequestID(@as(*const IMcastLeaseInfo, @ptrCast(self)), ppRequestID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_get_LeaseStartTime(self: *const T, pTime: ?*f64) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).get_LeaseStartTime(@as(*const IMcastLeaseInfo, @ptrCast(self)), pTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_put_LeaseStartTime(self: *const T, time: f64) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).put_LeaseStartTime(@as(*const IMcastLeaseInfo, @ptrCast(self)), time);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_get_LeaseStopTime(self: *const T, pTime: ?*f64) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).get_LeaseStopTime(@as(*const IMcastLeaseInfo, @ptrCast(self)), pTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_put_LeaseStopTime(self: *const T, time: f64) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).put_LeaseStopTime(@as(*const IMcastLeaseInfo, @ptrCast(self)), time);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_get_AddressCount(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).get_AddressCount(@as(*const IMcastLeaseInfo, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_get_ServerAddress(self: *const T, ppAddress: ?*?BSTR) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).get_ServerAddress(@as(*const IMcastLeaseInfo, @ptrCast(self)), ppAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_get_TTL(self: *const T, pTTL: ?*i32) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).get_TTL(@as(*const IMcastLeaseInfo, @ptrCast(self)), pTTL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_get_Addresses(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).get_Addresses(@as(*const IMcastLeaseInfo, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastLeaseInfo_EnumerateAddresses(self: *const T, ppEnumAddresses: ?*?*IEnumBstr) HRESULT {
                return @as(*const IMcastLeaseInfo.VTable, @ptrCast(self.vtable)).EnumerateAddresses(@as(*const IMcastLeaseInfo, @ptrCast(self)), ppEnumAddresses);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMcastScope_Value = Guid.initString("df0daf09-a289-11d1-8697-006008b0e5d2");
pub const IID_IEnumMcastScope = &IID_IEnumMcastScope_Value;
pub const IEnumMcastScope = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumMcastScope,
                celt: u32,
                ppScopes: ?*?*IMcastScope,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumMcastScope,
                celt: u32,
                ppScopes: ?*?*IMcastScope,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumMcastScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumMcastScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumMcastScope,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumMcastScope,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumMcastScope,
                ppEnum: ?*?*IEnumMcastScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumMcastScope,
                ppEnum: ?*?*IEnumMcastScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumMcastScope_Next(self: *const T, celt: u32, ppScopes: ?*?*IMcastScope, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumMcastScope.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMcastScope, @ptrCast(self)), celt, ppScopes, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumMcastScope_Reset(self: *const T) HRESULT {
                return @as(*const IEnumMcastScope.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMcastScope, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumMcastScope_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumMcastScope.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMcastScope, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumMcastScope_Clone(self: *const T, ppEnum: ?*?*IEnumMcastScope) HRESULT {
                return @as(*const IEnumMcastScope.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMcastScope, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMcastAddressAllocation_Value = Guid.initString("df0daef1-a289-11d1-8697-006008b0e5d2");
pub const IID_IMcastAddressAllocation = &IID_IMcastAddressAllocation_Value;
pub const IMcastAddressAllocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scopes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMcastAddressAllocation,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMcastAddressAllocation,
                pVariant: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateScopes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMcastAddressAllocation,
                ppEnumMcastScope: ?*?*IEnumMcastScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMcastAddressAllocation,
                ppEnumMcastScope: ?*?*IEnumMcastScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMcastAddressAllocation,
                pScope: ?*IMcastScope,
                LeaseStartTime: f64,
                LeaseStopTime: f64,
                NumAddresses: i32,
                ppLeaseResponse: ?*?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMcastAddressAllocation,
                pScope: ?*IMcastScope,
                LeaseStartTime: f64,
                LeaseStopTime: f64,
                NumAddresses: i32,
                ppLeaseResponse: ?*?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenewAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMcastAddressAllocation,
                lReserved: i32,
                pRenewRequest: ?*IMcastLeaseInfo,
                ppRenewResponse: ?*?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMcastAddressAllocation,
                lReserved: i32,
                pRenewRequest: ?*IMcastLeaseInfo,
                ppRenewResponse: ?*?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMcastAddressAllocation,
                pReleaseRequest: ?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMcastAddressAllocation,
                pReleaseRequest: ?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLeaseInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMcastAddressAllocation,
                LeaseStartTime: f64,
                LeaseStopTime: f64,
                dwNumAddresses: u32,
                ppAddresses: ?*?PWSTR,
                pRequestID: ?PWSTR,
                pServerAddress: ?PWSTR,
                ppReleaseRequest: ?*?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMcastAddressAllocation,
                LeaseStartTime: f64,
                LeaseStopTime: f64,
                dwNumAddresses: u32,
                ppAddresses: ?*?PWSTR,
                pRequestID: ?PWSTR,
                pServerAddress: ?PWSTR,
                ppReleaseRequest: ?*?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLeaseInfoFromVariant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMcastAddressAllocation,
                LeaseStartTime: f64,
                LeaseStopTime: f64,
                vAddresses: VARIANT,
                pRequestID: ?BSTR,
                pServerAddress: ?BSTR,
                ppReleaseRequest: ?*?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMcastAddressAllocation,
                LeaseStartTime: f64,
                LeaseStopTime: f64,
                vAddresses: VARIANT,
                pRequestID: ?BSTR,
                pServerAddress: ?BSTR,
                ppReleaseRequest: ?*?*IMcastLeaseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastAddressAllocation_get_Scopes(self: *const T, pVariant: ?*VARIANT) HRESULT {
                return @as(*const IMcastAddressAllocation.VTable, @ptrCast(self.vtable)).get_Scopes(@as(*const IMcastAddressAllocation, @ptrCast(self)), pVariant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastAddressAllocation_EnumerateScopes(self: *const T, ppEnumMcastScope: ?*?*IEnumMcastScope) HRESULT {
                return @as(*const IMcastAddressAllocation.VTable, @ptrCast(self.vtable)).EnumerateScopes(@as(*const IMcastAddressAllocation, @ptrCast(self)), ppEnumMcastScope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastAddressAllocation_RequestAddress(self: *const T, pScope: ?*IMcastScope, LeaseStartTime: f64, LeaseStopTime: f64, NumAddresses: i32, ppLeaseResponse: ?*?*IMcastLeaseInfo) HRESULT {
                return @as(*const IMcastAddressAllocation.VTable, @ptrCast(self.vtable)).RequestAddress(@as(*const IMcastAddressAllocation, @ptrCast(self)), pScope, LeaseStartTime, LeaseStopTime, NumAddresses, ppLeaseResponse);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastAddressAllocation_RenewAddress(self: *const T, lReserved: i32, pRenewRequest: ?*IMcastLeaseInfo, ppRenewResponse: ?*?*IMcastLeaseInfo) HRESULT {
                return @as(*const IMcastAddressAllocation.VTable, @ptrCast(self.vtable)).RenewAddress(@as(*const IMcastAddressAllocation, @ptrCast(self)), lReserved, pRenewRequest, ppRenewResponse);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastAddressAllocation_ReleaseAddress(self: *const T, pReleaseRequest: ?*IMcastLeaseInfo) HRESULT {
                return @as(*const IMcastAddressAllocation.VTable, @ptrCast(self.vtable)).ReleaseAddress(@as(*const IMcastAddressAllocation, @ptrCast(self)), pReleaseRequest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastAddressAllocation_CreateLeaseInfo(self: *const T, LeaseStartTime: f64, LeaseStopTime: f64, dwNumAddresses: u32, ppAddresses: ?*?PWSTR, pRequestID: ?PWSTR, pServerAddress: ?PWSTR, ppReleaseRequest: ?*?*IMcastLeaseInfo) HRESULT {
                return @as(*const IMcastAddressAllocation.VTable, @ptrCast(self.vtable)).CreateLeaseInfo(@as(*const IMcastAddressAllocation, @ptrCast(self)), LeaseStartTime, LeaseStopTime, dwNumAddresses, ppAddresses, pRequestID, pServerAddress, ppReleaseRequest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMcastAddressAllocation_CreateLeaseInfoFromVariant(self: *const T, LeaseStartTime: f64, LeaseStopTime: f64, vAddresses: VARIANT, pRequestID: ?BSTR, pServerAddress: ?BSTR, ppReleaseRequest: ?*?*IMcastLeaseInfo) HRESULT {
                return @as(*const IMcastAddressAllocation.VTable, @ptrCast(self.vtable)).CreateLeaseInfoFromVariant(@as(*const IMcastAddressAllocation, @ptrCast(self)), LeaseStartTime, LeaseStopTime, vAddresses, pRequestID, pServerAddress, ppReleaseRequest);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STnefProblem = extern struct {
    ulComponent: u32,
    ulAttribute: u32,
    ulPropTag: u32,
    scode: i32,
};

pub const STnefProblemArray = extern struct {
    cProblem: u32,
    aProblem: [1]STnefProblem,
};

pub const ITnef = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITnef,
                ulFlags: u32,
                ulElemID: u32,
                lpvData: ?*anyopaque,
                lpPropList: ?*SPropTagArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITnef,
                ulFlags: u32,
                ulElemID: u32,
                lpvData: ?*anyopaque,
                lpPropList: ?*SPropTagArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExtractProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITnef,
                ulFlags: u32,
                lpPropList: ?*SPropTagArray,
                lpProblems: ?*?*STnefProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITnef,
                ulFlags: u32,
                lpPropList: ?*SPropTagArray,
                lpProblems: ?*?*STnefProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITnef,
                ulFlags: u32,
                lpKey: ?*u16,
                lpProblems: ?*?*STnefProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITnef,
                ulFlags: u32,
                lpKey: ?*u16,
                lpProblems: ?*?*STnefProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenTaggedBody: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITnef,
                lpMessage: ?*IMessage,
                ulFlags: u32,
                lppStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITnef,
                lpMessage: ?*IMessage,
                ulFlags: u32,
                lppStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITnef,
                ulFlags: u32,
                ulElemID: u32,
                cValues: u32,
                lpProps: ?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITnef,
                ulFlags: u32,
                ulElemID: u32,
                cValues: u32,
                lpProps: ?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EncodeRecips: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITnef,
                ulFlags: u32,
                lpRecipientTable: ?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITnef,
                ulFlags: u32,
                lpRecipientTable: ?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinishComponent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITnef,
                ulFlags: u32,
                ulComponentID: u32,
                lpCustomPropList: ?*SPropTagArray,
                lpCustomProps: ?*SPropValue,
                lpPropList: ?*SPropTagArray,
                lpProblems: ?*?*STnefProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITnef,
                ulFlags: u32,
                ulComponentID: u32,
                lpCustomPropList: ?*SPropTagArray,
                lpCustomProps: ?*SPropValue,
                lpPropList: ?*SPropTagArray,
                lpProblems: ?*?*STnefProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITnef_AddProps(self: *const T, ulFlags: u32, ulElemID: u32, lpvData: ?*anyopaque, lpPropList: ?*SPropTagArray) HRESULT {
                return @as(*const ITnef.VTable, @ptrCast(self.vtable)).AddProps(@as(*const ITnef, @ptrCast(self)), ulFlags, ulElemID, lpvData, lpPropList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITnef_ExtractProps(self: *const T, ulFlags: u32, lpPropList: ?*SPropTagArray, lpProblems: ?*?*STnefProblemArray) HRESULT {
                return @as(*const ITnef.VTable, @ptrCast(self.vtable)).ExtractProps(@as(*const ITnef, @ptrCast(self)), ulFlags, lpPropList, lpProblems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITnef_Finish(self: *const T, ulFlags: u32, lpKey: ?*u16, lpProblems: ?*?*STnefProblemArray) HRESULT {
                return @as(*const ITnef.VTable, @ptrCast(self.vtable)).Finish(@as(*const ITnef, @ptrCast(self)), ulFlags, lpKey, lpProblems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITnef_OpenTaggedBody(self: *const T, lpMessage: ?*IMessage, ulFlags: u32, lppStream: ?*?*IStream) HRESULT {
                return @as(*const ITnef.VTable, @ptrCast(self.vtable)).OpenTaggedBody(@as(*const ITnef, @ptrCast(self)), lpMessage, ulFlags, lppStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITnef_SetProps(self: *const T, ulFlags: u32, ulElemID: u32, cValues: u32, lpProps: ?*SPropValue) HRESULT {
                return @as(*const ITnef.VTable, @ptrCast(self.vtable)).SetProps(@as(*const ITnef, @ptrCast(self)), ulFlags, ulElemID, cValues, lpProps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITnef_EncodeRecips(self: *const T, ulFlags: u32, lpRecipientTable: ?*IMAPITable) HRESULT {
                return @as(*const ITnef.VTable, @ptrCast(self.vtable)).EncodeRecips(@as(*const ITnef, @ptrCast(self)), ulFlags, lpRecipientTable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITnef_FinishComponent(self: *const T, ulFlags: u32, ulComponentID: u32, lpCustomPropList: ?*SPropTagArray, lpCustomProps: ?*SPropValue, lpPropList: ?*SPropTagArray, lpProblems: ?*?*STnefProblemArray) HRESULT {
                return @as(*const ITnef.VTable, @ptrCast(self.vtable)).FinishComponent(@as(*const ITnef, @ptrCast(self)), ulFlags, ulComponentID, lpCustomPropList, lpCustomProps, lpPropList, lpProblems);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LPOPENTNEFSTREAM = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpvSupport: ?*anyopaque,
        lpStream: ?*IStream,
        lpszStreamName: ?*i8,
        ulFlags: u32,
        lpMessage: ?*IMessage,
        wKeyVal: u16,
        lppTNEF: ?*?*ITnef,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpvSupport: ?*anyopaque,
        lpStream: ?*IStream,
        lpszStreamName: ?*i8,
        ulFlags: u32,
        lpMessage: ?*IMessage,
        wKeyVal: u16,
        lppTNEF: ?*?*ITnef,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const LPOPENTNEFSTREAMEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpvSupport: ?*anyopaque,
        lpStream: ?*IStream,
        lpszStreamName: ?*i8,
        ulFlags: u32,
        lpMessage: ?*IMessage,
        wKeyVal: u16,
        lpAdressBook: ?*IAddrBook,
        lppTNEF: ?*?*ITnef,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpvSupport: ?*anyopaque,
        lpStream: ?*IStream,
        lpszStreamName: ?*i8,
        ulFlags: u32,
        lpMessage: ?*IMessage,
        wKeyVal: u16,
        lpAdressBook: ?*IAddrBook,
        lppTNEF: ?*?*ITnef,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const LPGETTNEFSTREAMCODEPAGE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpStream: ?*IStream,
        lpulCodepage: ?*u32,
        lpulSubCodepage: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpStream: ?*IStream,
        lpulCodepage: ?*u32,
        lpulSubCodepage: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const _renddata = extern struct {
    atyp: u16 align(1),
    ulPosition: u32 align(1),
    dxWidth: u16 align(1),
    dyHeight: u16 align(1),
    dwFlags: u32 align(1),
};

pub const _dtr = extern struct {
    wYear: u16 align(1),
    wMonth: u16 align(1),
    wDay: u16 align(1),
    wHour: u16 align(1),
    wMinute: u16 align(1),
    wSecond: u16 align(1),
    wDayOfWeek: u16 align(1),
};

pub const _trp = extern struct {
    trpid: u16,
    cbgrtrp: u16,
    cch: u16,
    cbRgb: u16,
};

pub const _ADDR_ALIAS = extern struct {
    rgchName: [41]CHAR,
    rgchEName: [11]CHAR,
    rgchSrvr: [12]CHAR,
    dibDetail: u32,
    type: u16,
};

pub const NSID = extern struct {
    dwSize: u32,
    uchType: [16]u8,
    xtype: u32,
    lTime: i32,
    address: extern union {
        alias: _ADDR_ALIAS,
        rgchInterNet: [1]CHAR,
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (252)
//--------------------------------------------------------------------------------
pub extern "tapi32" fn lineAccept(
    hCall: u32,
    lpsUserUserInfo: ?[*:0]const u8,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineAddProvider(
    lpszProviderFilename: ?[*:0]const u8,
    hwndOwner: ?HWND,
    lpdwPermanentProviderID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineAddProviderA(
    lpszProviderFilename: ?[*:0]const u8,
    hwndOwner: ?HWND,
    lpdwPermanentProviderID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineAddProviderW(
    lpszProviderFilename: ?[*:0]const u16,
    hwndOwner: ?HWND,
    lpdwPermanentProviderID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineAddToConference(
    hConfCall: u32,
    hConsultCall: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineAgentSpecific(
    hLine: u32,
    dwAddressID: u32,
    dwAgentExtensionIDIndex: u32,
    lpParams: ?*anyopaque,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineAnswer(
    hCall: u32,
    lpsUserUserInfo: ?[*:0]const u8,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineBlindTransfer(
    hCall: u32,
    lpszDestAddress: ?[*:0]const u8,
    dwCountryCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineBlindTransferA(
    hCall: u32,
    lpszDestAddress: ?[*:0]const u8,
    dwCountryCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineBlindTransferW(
    hCall: u32,
    lpszDestAddressW: ?[*:0]const u16,
    dwCountryCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineClose(
    hLine: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineCompleteCall(
    hCall: u32,
    lpdwCompletionID: ?*u32,
    dwCompletionMode: u32,
    dwMessageID: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineCompleteTransfer(
    hCall: u32,
    hConsultCall: u32,
    lphConfCall: ?*u32,
    dwTransferMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineConfigDialog(
    dwDeviceID: u32,
    hwndOwner: ?HWND,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineConfigDialogA(
    dwDeviceID: u32,
    hwndOwner: ?HWND,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineConfigDialogW(
    dwDeviceID: u32,
    hwndOwner: ?HWND,
    lpszDeviceClass: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineConfigDialogEdit(
    dwDeviceID: u32,
    hwndOwner: ?HWND,
    lpszDeviceClass: ?[*:0]const u8,
    lpDeviceConfigIn: ?*const anyopaque,
    dwSize: u32,
    lpDeviceConfigOut: ?*VARSTRING,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineConfigDialogEditA(
    dwDeviceID: u32,
    hwndOwner: ?HWND,
    lpszDeviceClass: ?[*:0]const u8,
    lpDeviceConfigIn: ?*const anyopaque,
    dwSize: u32,
    lpDeviceConfigOut: ?*VARSTRING,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineConfigDialogEditW(
    dwDeviceID: u32,
    hwndOwner: ?HWND,
    lpszDeviceClass: ?[*:0]const u16,
    lpDeviceConfigIn: ?*const anyopaque,
    dwSize: u32,
    lpDeviceConfigOut: ?*VARSTRING,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineConfigProvider(
    hwndOwner: ?HWND,
    dwPermanentProviderID: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineCreateAgentW(
    hLine: u32,
    lpszAgentID: ?[*:0]const u16,
    lpszAgentPIN: ?[*:0]const u16,
    lphAgent: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineCreateAgentA(
    hLine: u32,
    lpszAgentID: ?[*:0]const u8,
    lpszAgentPIN: ?[*:0]const u8,
    lphAgent: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineCreateAgentSessionW(
    hLine: u32,
    hAgent: u32,
    lpszAgentPIN: ?[*:0]const u16,
    dwWorkingAddressID: u32,
    lpGroupID: ?*Guid,
    lphAgentSession: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineCreateAgentSessionA(
    hLine: u32,
    hAgent: u32,
    lpszAgentPIN: ?[*:0]const u8,
    dwWorkingAddressID: u32,
    lpGroupID: ?*Guid,
    lphAgentSession: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineDeallocateCall(
    hCall: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineDevSpecific(
    hLine: u32,
    dwAddressID: u32,
    hCall: u32,
    lpParams: ?*anyopaque,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineDevSpecificFeature(
    hLine: u32,
    dwFeature: u32,
    lpParams: ?*anyopaque,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineDial(
    hCall: u32,
    lpszDestAddress: ?[*:0]const u8,
    dwCountryCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineDialA(
    hCall: u32,
    lpszDestAddress: ?[*:0]const u8,
    dwCountryCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineDialW(
    hCall: u32,
    lpszDestAddress: ?[*:0]const u16,
    dwCountryCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineDrop(
    hCall: u32,
    lpsUserUserInfo: ?[*:0]const u8,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineForward(
    hLine: u32,
    bAllAddresses: u32,
    dwAddressID: u32,
    lpForwardList: ?*const LINEFORWARDLIST,
    dwNumRingsNoAnswer: u32,
    lphConsultCall: ?*u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineForwardA(
    hLine: u32,
    bAllAddresses: u32,
    dwAddressID: u32,
    lpForwardList: ?*const LINEFORWARDLIST,
    dwNumRingsNoAnswer: u32,
    lphConsultCall: ?*u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineForwardW(
    hLine: u32,
    bAllAddresses: u32,
    dwAddressID: u32,
    lpForwardList: ?*const LINEFORWARDLIST,
    dwNumRingsNoAnswer: u32,
    lphConsultCall: ?*u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGatherDigits(
    hCall: u32,
    dwDigitModes: u32,
    lpsDigits: ?[*:0]u8,
    dwNumDigits: u32,
    lpszTerminationDigits: ?[*:0]const u8,
    dwFirstDigitTimeout: u32,
    dwInterDigitTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGatherDigitsA(
    hCall: u32,
    dwDigitModes: u32,
    lpsDigits: ?[*:0]u8,
    dwNumDigits: u32,
    lpszTerminationDigits: ?[*:0]const u8,
    dwFirstDigitTimeout: u32,
    dwInterDigitTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGatherDigitsW(
    hCall: u32,
    dwDigitModes: u32,
    lpsDigits: ?[*:0]u16,
    dwNumDigits: u32,
    lpszTerminationDigits: ?[*:0]const u16,
    dwFirstDigitTimeout: u32,
    dwInterDigitTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGenerateDigits(
    hCall: u32,
    dwDigitMode: u32,
    lpszDigits: ?[*:0]const u8,
    dwDuration: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGenerateDigitsA(
    hCall: u32,
    dwDigitMode: u32,
    lpszDigits: ?[*:0]const u8,
    dwDuration: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGenerateDigitsW(
    hCall: u32,
    dwDigitMode: u32,
    lpszDigits: ?[*:0]const u16,
    dwDuration: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGenerateTone(
    hCall: u32,
    dwToneMode: u32,
    dwDuration: u32,
    dwNumTones: u32,
    lpTones: ?*const LINEGENERATETONE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAddressCaps(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAddressID: u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    lpAddressCaps: ?*LINEADDRESSCAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAddressCapsA(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAddressID: u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    lpAddressCaps: ?*LINEADDRESSCAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAddressCapsW(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAddressID: u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    lpAddressCaps: ?*LINEADDRESSCAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAddressID(
    hLine: u32,
    lpdwAddressID: ?*u32,
    dwAddressMode: u32,
    lpsAddress: ?[*:0]const u8,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAddressIDA(
    hLine: u32,
    lpdwAddressID: ?*u32,
    dwAddressMode: u32,
    lpsAddress: ?[*:0]const u8,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAddressIDW(
    hLine: u32,
    lpdwAddressID: ?*u32,
    dwAddressMode: u32,
    lpsAddress: ?[*:0]const u16,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAddressStatus(
    hLine: u32,
    dwAddressID: u32,
    lpAddressStatus: ?*LINEADDRESSSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAddressStatusA(
    hLine: u32,
    dwAddressID: u32,
    lpAddressStatus: ?*LINEADDRESSSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAddressStatusW(
    hLine: u32,
    dwAddressID: u32,
    lpAddressStatus: ?*LINEADDRESSSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentActivityListA(
    hLine: u32,
    dwAddressID: u32,
    lpAgentActivityList: ?*LINEAGENTACTIVITYLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentActivityListW(
    hLine: u32,
    dwAddressID: u32,
    lpAgentActivityList: ?*LINEAGENTACTIVITYLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentCapsA(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAddressID: u32,
    dwAppAPIVersion: u32,
    lpAgentCaps: ?*LINEAGENTCAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentCapsW(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAddressID: u32,
    dwAppAPIVersion: u32,
    lpAgentCaps: ?*LINEAGENTCAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentGroupListA(
    hLine: u32,
    dwAddressID: u32,
    lpAgentGroupList: ?*LINEAGENTGROUPLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentGroupListW(
    hLine: u32,
    dwAddressID: u32,
    lpAgentGroupList: ?*LINEAGENTGROUPLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentInfo(
    hLine: u32,
    hAgent: u32,
    lpAgentInfo: ?*LINEAGENTINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentSessionInfo(
    hLine: u32,
    hAgentSession: u32,
    lpAgentSessionInfo: ?*LINEAGENTSESSIONINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentSessionList(
    hLine: u32,
    hAgent: u32,
    lpAgentSessionList: ?*LINEAGENTSESSIONLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentStatusA(
    hLine: u32,
    dwAddressID: u32,
    lpAgentStatus: ?*LINEAGENTSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAgentStatusW(
    hLine: u32,
    dwAddressID: u32,
    lpAgentStatus: ?*LINEAGENTSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAppPriority(
    lpszAppFilename: ?[*:0]const u8,
    dwMediaMode: u32,
    lpExtensionID: ?*LINEEXTENSIONID,
    dwRequestMode: u32,
    lpExtensionName: ?*VARSTRING,
    lpdwPriority: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAppPriorityA(
    lpszAppFilename: ?[*:0]const u8,
    dwMediaMode: u32,
    lpExtensionID: ?*LINEEXTENSIONID,
    dwRequestMode: u32,
    lpExtensionName: ?*VARSTRING,
    lpdwPriority: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetAppPriorityW(
    lpszAppFilename: ?[*:0]const u16,
    dwMediaMode: u32,
    lpExtensionID: ?*LINEEXTENSIONID,
    dwRequestMode: u32,
    lpExtensionName: ?*VARSTRING,
    lpdwPriority: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetCallInfo(
    hCall: u32,
    lpCallInfo: ?*LINECALLINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetCallInfoA(
    hCall: u32,
    lpCallInfo: ?*LINECALLINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetCallInfoW(
    hCall: u32,
    lpCallInfo: ?*LINECALLINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetCallStatus(
    hCall: u32,
    lpCallStatus: ?*LINECALLSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetConfRelatedCalls(
    hCall: u32,
    lpCallList: ?*LINECALLLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetCountry(
    dwCountryID: u32,
    dwAPIVersion: u32,
    lpLineCountryList: ?*LINECOUNTRYLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetCountryA(
    dwCountryID: u32,
    dwAPIVersion: u32,
    lpLineCountryList: ?*LINECOUNTRYLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetCountryW(
    dwCountryID: u32,
    dwAPIVersion: u32,
    lpLineCountryList: ?*LINECOUNTRYLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetDevCaps(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    lpLineDevCaps: ?*LINEDEVCAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetDevCapsA(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    lpLineDevCaps: ?*LINEDEVCAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetDevCapsW(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    lpLineDevCaps: ?*LINEDEVCAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetDevConfig(
    dwDeviceID: u32,
    lpDeviceConfig: ?*VARSTRING,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetDevConfigA(
    dwDeviceID: u32,
    lpDeviceConfig: ?*VARSTRING,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetDevConfigW(
    dwDeviceID: u32,
    lpDeviceConfig: ?*VARSTRING,
    lpszDeviceClass: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetGroupListA(
    hLine: u32,
    lpGroupList: ?*LINEAGENTGROUPLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetGroupListW(
    hLine: u32,
    lpGroupList: ?*LINEAGENTGROUPLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetIcon(
    dwDeviceID: u32,
    lpszDeviceClass: ?[*:0]const u8,
    lphIcon: ?*isize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetIconA(
    dwDeviceID: u32,
    lpszDeviceClass: ?[*:0]const u8,
    lphIcon: ?*isize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetIconW(
    dwDeviceID: u32,
    lpszDeviceClass: ?[*:0]const u16,
    lphIcon: ?*isize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetID(
    hLine: u32,
    dwAddressID: u32,
    hCall: u32,
    dwSelect: u32,
    lpDeviceID: ?*VARSTRING,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetIDA(
    hLine: u32,
    dwAddressID: u32,
    hCall: u32,
    dwSelect: u32,
    lpDeviceID: ?*VARSTRING,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetIDW(
    hLine: u32,
    dwAddressID: u32,
    hCall: u32,
    dwSelect: u32,
    lpDeviceID: ?*VARSTRING,
    lpszDeviceClass: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetLineDevStatus(
    hLine: u32,
    lpLineDevStatus: ?*LINEDEVSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetLineDevStatusA(
    hLine: u32,
    lpLineDevStatus: ?*LINEDEVSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetLineDevStatusW(
    hLine: u32,
    lpLineDevStatus: ?*LINEDEVSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetMessage(
    hLineApp: u32,
    lpMessage: ?*LINEMESSAGE,
    dwTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetNewCalls(
    hLine: u32,
    dwAddressID: u32,
    dwSelect: u32,
    lpCallList: ?*LINECALLLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetNumRings(
    hLine: u32,
    dwAddressID: u32,
    lpdwNumRings: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetProviderList(
    dwAPIVersion: u32,
    lpProviderList: ?*LINEPROVIDERLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetProviderListA(
    dwAPIVersion: u32,
    lpProviderList: ?*LINEPROVIDERLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetProviderListW(
    dwAPIVersion: u32,
    lpProviderList: ?*LINEPROVIDERLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetProxyStatus(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAppAPIVersion: u32,
    lpLineProxyReqestList: ?*LINEPROXYREQUESTLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetQueueInfo(
    hLine: u32,
    dwQueueID: u32,
    lpLineQueueInfo: ?*LINEQUEUEINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetQueueListA(
    hLine: u32,
    lpGroupID: ?*Guid,
    lpQueueList: ?*LINEQUEUELIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetQueueListW(
    hLine: u32,
    lpGroupID: ?*Guid,
    lpQueueList: ?*LINEQUEUELIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetRequest(
    hLineApp: u32,
    dwRequestMode: u32,
    lpRequestBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetRequestA(
    hLineApp: u32,
    dwRequestMode: u32,
    lpRequestBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetRequestW(
    hLineApp: u32,
    dwRequestMode: u32,
    lpRequestBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetStatusMessages(
    hLine: u32,
    lpdwLineStates: ?*u32,
    lpdwAddressStates: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetTranslateCaps(
    hLineApp: u32,
    dwAPIVersion: u32,
    lpTranslateCaps: ?*LINETRANSLATECAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetTranslateCapsA(
    hLineApp: u32,
    dwAPIVersion: u32,
    lpTranslateCaps: ?*LINETRANSLATECAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineGetTranslateCapsW(
    hLineApp: u32,
    dwAPIVersion: u32,
    lpTranslateCaps: ?*LINETRANSLATECAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineHandoff(
    hCall: u32,
    lpszFileName: ?[*:0]const u8,
    dwMediaMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineHandoffA(
    hCall: u32,
    lpszFileName: ?[*:0]const u8,
    dwMediaMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineHandoffW(
    hCall: u32,
    lpszFileName: ?[*:0]const u16,
    dwMediaMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineHold(
    hCall: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineInitialize(
    lphLineApp: ?*u32,
    hInstance: ?HINSTANCE,
    lpfnCallback: ?LINECALLBACK,
    lpszAppName: ?[*:0]const u8,
    lpdwNumDevs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineInitializeExA(
    lphLineApp: ?*u32,
    hInstance: ?HINSTANCE,
    lpfnCallback: ?LINECALLBACK,
    lpszFriendlyAppName: ?[*:0]const u8,
    lpdwNumDevs: ?*u32,
    lpdwAPIVersion: ?*u32,
    lpLineInitializeExParams: ?*LINEINITIALIZEEXPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineInitializeExW(
    lphLineApp: ?*u32,
    hInstance: ?HINSTANCE,
    lpfnCallback: ?LINECALLBACK,
    lpszFriendlyAppName: ?[*:0]const u16,
    lpdwNumDevs: ?*u32,
    lpdwAPIVersion: ?*u32,
    lpLineInitializeExParams: ?*LINEINITIALIZEEXPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineMakeCall(
    hLine: u32,
    lphCall: ?*u32,
    lpszDestAddress: ?[*:0]const u8,
    dwCountryCode: u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineMakeCallA(
    hLine: u32,
    lphCall: ?*u32,
    lpszDestAddress: ?[*:0]const u8,
    dwCountryCode: u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineMakeCallW(
    hLine: u32,
    lphCall: ?*u32,
    lpszDestAddress: ?[*:0]const u16,
    dwCountryCode: u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineMonitorDigits(
    hCall: u32,
    dwDigitModes: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineMonitorMedia(
    hCall: u32,
    dwMediaModes: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineMonitorTones(
    hCall: u32,
    lpToneList: ?*const LINEMONITORTONE,
    dwNumEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineNegotiateAPIVersion(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPILowVersion: u32,
    dwAPIHighVersion: u32,
    lpdwAPIVersion: ?*u32,
    lpExtensionID: ?*LINEEXTENSIONID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineNegotiateExtVersion(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    dwExtLowVersion: u32,
    dwExtHighVersion: u32,
    lpdwExtVersion: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineOpen(
    hLineApp: u32,
    dwDeviceID: u32,
    lphLine: ?*u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    dwCallbackInstance: usize,
    dwPrivileges: u32,
    dwMediaModes: u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineOpenA(
    hLineApp: u32,
    dwDeviceID: u32,
    lphLine: ?*u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    dwCallbackInstance: usize,
    dwPrivileges: u32,
    dwMediaModes: u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineOpenW(
    hLineApp: u32,
    dwDeviceID: u32,
    lphLine: ?*u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    dwCallbackInstance: usize,
    dwPrivileges: u32,
    dwMediaModes: u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn linePark(
    hCall: u32,
    dwParkMode: u32,
    lpszDirAddress: ?[*:0]const u8,
    lpNonDirAddress: ?*VARSTRING,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineParkA(
    hCall: u32,
    dwParkMode: u32,
    lpszDirAddress: ?[*:0]const u8,
    lpNonDirAddress: ?*VARSTRING,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineParkW(
    hCall: u32,
    dwParkMode: u32,
    lpszDirAddress: ?[*:0]const u16,
    lpNonDirAddress: ?*VARSTRING,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn linePickup(
    hLine: u32,
    dwAddressID: u32,
    lphCall: ?*u32,
    lpszDestAddress: ?[*:0]const u8,
    lpszGroupID: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn linePickupA(
    hLine: u32,
    dwAddressID: u32,
    lphCall: ?*u32,
    lpszDestAddress: ?[*:0]const u8,
    lpszGroupID: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn linePickupW(
    hLine: u32,
    dwAddressID: u32,
    lphCall: ?*u32,
    lpszDestAddress: ?[*:0]const u16,
    lpszGroupID: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn linePrepareAddToConference(
    hConfCall: u32,
    lphConsultCall: ?*u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn linePrepareAddToConferenceA(
    hConfCall: u32,
    lphConsultCall: ?*u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn linePrepareAddToConferenceW(
    hConfCall: u32,
    lphConsultCall: ?*u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineProxyMessage(
    hLine: u32,
    hCall: u32,
    dwMsg: u32,
    dwParam1: u32,
    dwParam2: u32,
    dwParam3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineProxyResponse(
    hLine: u32,
    lpProxyRequest: ?*LINEPROXYREQUEST,
    dwResult: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineRedirect(
    hCall: u32,
    lpszDestAddress: ?[*:0]const u8,
    dwCountryCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineRedirectA(
    hCall: u32,
    lpszDestAddress: ?[*:0]const u8,
    dwCountryCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineRedirectW(
    hCall: u32,
    lpszDestAddress: ?[*:0]const u16,
    dwCountryCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineRegisterRequestRecipient(
    hLineApp: u32,
    dwRegistrationInstance: u32,
    dwRequestMode: u32,
    bEnable: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineReleaseUserUserInfo(
    hCall: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineRemoveFromConference(
    hCall: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineRemoveProvider(
    dwPermanentProviderID: u32,
    hwndOwner: ?HWND,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSecureCall(
    hCall: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSendUserUserInfo(
    hCall: u32,
    lpsUserUserInfo: ?[*:0]const u8,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAgentActivity(
    hLine: u32,
    dwAddressID: u32,
    dwActivityID: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAgentGroup(
    hLine: u32,
    dwAddressID: u32,
    lpAgentGroupList: ?*LINEAGENTGROUPLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAgentMeasurementPeriod(
    hLine: u32,
    hAgent: u32,
    dwMeasurementPeriod: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAgentSessionState(
    hLine: u32,
    hAgentSession: u32,
    dwAgentSessionState: u32,
    dwNextAgentSessionState: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAgentStateEx(
    hLine: u32,
    hAgent: u32,
    dwAgentState: u32,
    dwNextAgentState: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAgentState(
    hLine: u32,
    dwAddressID: u32,
    dwAgentState: u32,
    dwNextAgentState: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAppPriority(
    lpszAppFilename: ?[*:0]const u8,
    dwMediaMode: u32,
    lpExtensionID: ?*LINEEXTENSIONID,
    dwRequestMode: u32,
    lpszExtensionName: ?[*:0]const u8,
    dwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAppPriorityA(
    lpszAppFilename: ?[*:0]const u8,
    dwMediaMode: u32,
    lpExtensionID: ?*LINEEXTENSIONID,
    dwRequestMode: u32,
    lpszExtensionName: ?[*:0]const u8,
    dwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAppPriorityW(
    lpszAppFilename: ?[*:0]const u16,
    dwMediaMode: u32,
    lpExtensionID: ?*LINEEXTENSIONID,
    dwRequestMode: u32,
    lpszExtensionName: ?[*:0]const u16,
    dwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetAppSpecific(
    hCall: u32,
    dwAppSpecific: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetCallData(
    hCall: u32,
    lpCallData: ?*anyopaque,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetCallParams(
    hCall: u32,
    dwBearerMode: u32,
    dwMinRate: u32,
    dwMaxRate: u32,
    lpDialParams: ?*const LINEDIALPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetCallPrivilege(
    hCall: u32,
    dwCallPrivilege: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetCallQualityOfService(
    hCall: u32,
    lpSendingFlowspec: ?*anyopaque,
    dwSendingFlowspecSize: u32,
    lpReceivingFlowspec: ?*anyopaque,
    dwReceivingFlowspecSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetCallTreatment(
    hCall: u32,
    dwTreatment: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetCurrentLocation(
    hLineApp: u32,
    dwLocation: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetDevConfig(
    dwDeviceID: u32,
    lpDeviceConfig: ?*const anyopaque,
    dwSize: u32,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetDevConfigA(
    dwDeviceID: u32,
    lpDeviceConfig: ?*const anyopaque,
    dwSize: u32,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetDevConfigW(
    dwDeviceID: u32,
    lpDeviceConfig: ?*const anyopaque,
    dwSize: u32,
    lpszDeviceClass: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetLineDevStatus(
    hLine: u32,
    dwStatusToChange: u32,
    fStatus: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetMediaControl(
    hLine: u32,
    dwAddressID: u32,
    hCall: u32,
    dwSelect: u32,
    lpDigitList: ?*const LINEMEDIACONTROLDIGIT,
    dwDigitNumEntries: u32,
    lpMediaList: ?*const LINEMEDIACONTROLMEDIA,
    dwMediaNumEntries: u32,
    lpToneList: ?*const LINEMEDIACONTROLTONE,
    dwToneNumEntries: u32,
    lpCallStateList: ?*const LINEMEDIACONTROLCALLSTATE,
    dwCallStateNumEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetMediaMode(
    hCall: u32,
    dwMediaModes: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetQueueMeasurementPeriod(
    hLine: u32,
    dwQueueID: u32,
    dwMeasurementPeriod: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetNumRings(
    hLine: u32,
    dwAddressID: u32,
    dwNumRings: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetStatusMessages(
    hLine: u32,
    dwLineStates: u32,
    dwAddressStates: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetTerminal(
    hLine: u32,
    dwAddressID: u32,
    hCall: u32,
    dwSelect: u32,
    dwTerminalModes: u32,
    dwTerminalID: u32,
    bEnable: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetTollList(
    hLineApp: u32,
    dwDeviceID: u32,
    lpszAddressIn: ?[*:0]const u8,
    dwTollListOption: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetTollListA(
    hLineApp: u32,
    dwDeviceID: u32,
    lpszAddressIn: ?[*:0]const u8,
    dwTollListOption: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetTollListW(
    hLineApp: u32,
    dwDeviceID: u32,
    lpszAddressInW: ?[*:0]const u16,
    dwTollListOption: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetupConference(
    hCall: u32,
    hLine: u32,
    lphConfCall: ?*u32,
    lphConsultCall: ?*u32,
    dwNumParties: u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetupConferenceA(
    hCall: u32,
    hLine: u32,
    lphConfCall: ?*u32,
    lphConsultCall: ?*u32,
    dwNumParties: u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetupConferenceW(
    hCall: u32,
    hLine: u32,
    lphConfCall: ?*u32,
    lphConsultCall: ?*u32,
    dwNumParties: u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetupTransfer(
    hCall: u32,
    lphConsultCall: ?*u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetupTransferA(
    hCall: u32,
    lphConsultCall: ?*u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSetupTransferW(
    hCall: u32,
    lphConsultCall: ?*u32,
    lpCallParams: ?*const LINECALLPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineShutdown(
    hLineApp: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineSwapHold(
    hActiveCall: u32,
    hHeldCall: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineTranslateAddress(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    lpszAddressIn: ?[*:0]const u8,
    dwCard: u32,
    dwTranslateOptions: u32,
    lpTranslateOutput: ?*LINETRANSLATEOUTPUT,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineTranslateAddressA(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    lpszAddressIn: ?[*:0]const u8,
    dwCard: u32,
    dwTranslateOptions: u32,
    lpTranslateOutput: ?*LINETRANSLATEOUTPUT,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineTranslateAddressW(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    lpszAddressIn: ?[*:0]const u16,
    dwCard: u32,
    dwTranslateOptions: u32,
    lpTranslateOutput: ?*LINETRANSLATEOUTPUT,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineTranslateDialog(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    hwndOwner: ?HWND,
    lpszAddressIn: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineTranslateDialogA(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    hwndOwner: ?HWND,
    lpszAddressIn: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineTranslateDialogW(
    hLineApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    hwndOwner: ?HWND,
    lpszAddressIn: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineUncompleteCall(
    hLine: u32,
    dwCompletionID: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineUnhold(
    hCall: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineUnpark(
    hLine: u32,
    dwAddressID: u32,
    lphCall: ?*u32,
    lpszDestAddress: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineUnparkA(
    hLine: u32,
    dwAddressID: u32,
    lphCall: ?*u32,
    lpszDestAddress: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn lineUnparkW(
    hLine: u32,
    dwAddressID: u32,
    lphCall: ?*u32,
    lpszDestAddress: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneClose(
    hPhone: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneConfigDialog(
    dwDeviceID: u32,
    hwndOwner: ?HWND,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneConfigDialogA(
    dwDeviceID: u32,
    hwndOwner: ?HWND,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneConfigDialogW(
    dwDeviceID: u32,
    hwndOwner: ?HWND,
    lpszDeviceClass: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneDevSpecific(
    hPhone: u32,
    lpParams: ?*anyopaque,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetButtonInfo(
    hPhone: u32,
    dwButtonLampID: u32,
    lpButtonInfo: ?*PHONEBUTTONINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetButtonInfoA(
    hPhone: u32,
    dwButtonLampID: u32,
    lpButtonInfo: ?*PHONEBUTTONINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetButtonInfoW(
    hPhone: u32,
    dwButtonLampID: u32,
    lpButtonInfo: ?*PHONEBUTTONINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetData(
    hPhone: u32,
    dwDataID: u32,
    lpData: ?*anyopaque,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetDevCaps(
    hPhoneApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    lpPhoneCaps: ?*PHONECAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetDevCapsA(
    hPhoneApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    lpPhoneCaps: ?*PHONECAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetDevCapsW(
    hPhoneApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    lpPhoneCaps: ?*PHONECAPS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetDisplay(
    hPhone: u32,
    lpDisplay: ?*VARSTRING,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetGain(
    hPhone: u32,
    dwHookSwitchDev: u32,
    lpdwGain: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetHookSwitch(
    hPhone: u32,
    lpdwHookSwitchDevs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetIcon(
    dwDeviceID: u32,
    lpszDeviceClass: ?[*:0]const u8,
    lphIcon: ?*isize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetIconA(
    dwDeviceID: u32,
    lpszDeviceClass: ?[*:0]const u8,
    lphIcon: ?*isize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetIconW(
    dwDeviceID: u32,
    lpszDeviceClass: ?[*:0]const u16,
    lphIcon: ?*isize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetID(
    hPhone: u32,
    lpDeviceID: ?*VARSTRING,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetIDA(
    hPhone: u32,
    lpDeviceID: ?*VARSTRING,
    lpszDeviceClass: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetIDW(
    hPhone: u32,
    lpDeviceID: ?*VARSTRING,
    lpszDeviceClass: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetLamp(
    hPhone: u32,
    dwButtonLampID: u32,
    lpdwLampMode: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetMessage(
    hPhoneApp: u32,
    lpMessage: ?*PHONEMESSAGE,
    dwTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetRing(
    hPhone: u32,
    lpdwRingMode: ?*u32,
    lpdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetStatus(
    hPhone: u32,
    lpPhoneStatus: ?*PHONESTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetStatusA(
    hPhone: u32,
    lpPhoneStatus: ?*PHONESTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetStatusW(
    hPhone: u32,
    lpPhoneStatus: ?*PHONESTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetStatusMessages(
    hPhone: u32,
    lpdwPhoneStates: ?*u32,
    lpdwButtonModes: ?*u32,
    lpdwButtonStates: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneGetVolume(
    hPhone: u32,
    dwHookSwitchDev: u32,
    lpdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneInitialize(
    lphPhoneApp: ?*u32,
    hInstance: ?HINSTANCE,
    lpfnCallback: ?PHONECALLBACK,
    lpszAppName: ?[*:0]const u8,
    lpdwNumDevs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneInitializeExA(
    lphPhoneApp: ?*u32,
    hInstance: ?HINSTANCE,
    lpfnCallback: ?PHONECALLBACK,
    lpszFriendlyAppName: ?[*:0]const u8,
    lpdwNumDevs: ?*u32,
    lpdwAPIVersion: ?*u32,
    lpPhoneInitializeExParams: ?*PHONEINITIALIZEEXPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneInitializeExW(
    lphPhoneApp: ?*u32,
    hInstance: ?HINSTANCE,
    lpfnCallback: ?PHONECALLBACK,
    lpszFriendlyAppName: ?[*:0]const u16,
    lpdwNumDevs: ?*u32,
    lpdwAPIVersion: ?*u32,
    lpPhoneInitializeExParams: ?*PHONEINITIALIZEEXPARAMS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneNegotiateAPIVersion(
    hPhoneApp: u32,
    dwDeviceID: u32,
    dwAPILowVersion: u32,
    dwAPIHighVersion: u32,
    lpdwAPIVersion: ?*u32,
    lpExtensionID: ?*PHONEEXTENSIONID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneNegotiateExtVersion(
    hPhoneApp: u32,
    dwDeviceID: u32,
    dwAPIVersion: u32,
    dwExtLowVersion: u32,
    dwExtHighVersion: u32,
    lpdwExtVersion: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneOpen(
    hPhoneApp: u32,
    dwDeviceID: u32,
    lphPhone: ?*u32,
    dwAPIVersion: u32,
    dwExtVersion: u32,
    dwCallbackInstance: usize,
    dwPrivilege: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetButtonInfo(
    hPhone: u32,
    dwButtonLampID: u32,
    lpButtonInfo: ?*const PHONEBUTTONINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetButtonInfoA(
    hPhone: u32,
    dwButtonLampID: u32,
    lpButtonInfo: ?*const PHONEBUTTONINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetButtonInfoW(
    hPhone: u32,
    dwButtonLampID: u32,
    lpButtonInfo: ?*const PHONEBUTTONINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetData(
    hPhone: u32,
    dwDataID: u32,
    lpData: ?*const anyopaque,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetDisplay(
    hPhone: u32,
    dwRow: u32,
    dwColumn: u32,
    lpsDisplay: ?[*:0]const u8,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetGain(
    hPhone: u32,
    dwHookSwitchDev: u32,
    dwGain: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetHookSwitch(
    hPhone: u32,
    dwHookSwitchDevs: u32,
    dwHookSwitchMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetLamp(
    hPhone: u32,
    dwButtonLampID: u32,
    dwLampMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetRing(
    hPhone: u32,
    dwRingMode: u32,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetStatusMessages(
    hPhone: u32,
    dwPhoneStates: u32,
    dwButtonModes: u32,
    dwButtonStates: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneSetVolume(
    hPhone: u32,
    dwHookSwitchDev: u32,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn phoneShutdown(
    hPhoneApp: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiGetLocationInfo(
    lpszCountryCode: *[8]u8,
    lpszCityCode: *[8]u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiGetLocationInfoA(
    lpszCountryCode: *[8]u8,
    lpszCityCode: *[8]u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiGetLocationInfoW(
    lpszCountryCodeW: *[8]u16,
    lpszCityCodeW: *[8]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiRequestDrop(
    hwnd: ?HWND,
    wRequestID: WPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiRequestMakeCall(
    lpszDestAddress: ?[*:0]const u8,
    lpszAppName: ?[*:0]const u8,
    lpszCalledParty: ?[*:0]const u8,
    lpszComment: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiRequestMakeCallA(
    lpszDestAddress: ?[*:0]const u8,
    lpszAppName: ?[*:0]const u8,
    lpszCalledParty: ?[*:0]const u8,
    lpszComment: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiRequestMakeCallW(
    lpszDestAddress: ?[*:0]const u16,
    lpszAppName: ?[*:0]const u16,
    lpszCalledParty: ?[*:0]const u16,
    lpszComment: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiRequestMediaCall(
    hwnd: ?HWND,
    wRequestID: WPARAM,
    lpszDeviceClass: ?[*:0]const u8,
    lpDeviceID: ?[*:0]const u8,
    dwSize: u32,
    dwSecure: u32,
    lpszDestAddress: ?[*:0]const u8,
    lpszAppName: ?[*:0]const u8,
    lpszCalledParty: ?[*:0]const u8,
    lpszComment: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiRequestMediaCallA(
    hwnd: ?HWND,
    wRequestID: WPARAM,
    lpszDeviceClass: ?[*:0]const u8,
    lpDeviceID: ?[*:0]const u8,
    dwSize: u32,
    dwSecure: u32,
    lpszDestAddress: ?[*:0]const u8,
    lpszAppName: ?[*:0]const u8,
    lpszCalledParty: ?[*:0]const u8,
    lpszComment: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "tapi32" fn tapiRequestMediaCallW(
    hwnd: ?HWND,
    wRequestID: WPARAM,
    lpszDeviceClass: ?[*:0]const u16,
    lpDeviceID: ?[*:0]const u16,
    dwSize: u32,
    dwSecure: u32,
    lpszDestAddress: ?[*:0]const u16,
    lpszAppName: ?[*:0]const u16,
    lpszCalledParty: ?[*:0]const u16,
    lpszComment: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn OpenTnefStream(
    lpvSupport: ?*anyopaque,
    lpStream: ?*IStream,
    lpszStreamName: ?*i8,
    ulFlags: u32,
    lpMessage: ?*IMessage,
    wKeyVal: u16,
    lppTNEF: ?*?*ITnef,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn OpenTnefStreamEx(
    lpvSupport: ?*anyopaque,
    lpStream: ?*IStream,
    lpszStreamName: ?*i8,
    ulFlags: u32,
    lpMessage: ?*IMessage,
    wKeyVal: u16,
    lpAdressBook: ?*IAddrBook,
    lppTNEF: ?*?*ITnef,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn GetTnefStreamCodepage(
    lpStream: ?*IStream,
    lpulCodepage: ?*u32,
    lpulSubCodepage: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (10)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const lineCreateAgent = thismodule.lineCreateAgentA;
        pub const lineCreateAgentSession = thismodule.lineCreateAgentSessionA;
        pub const lineGetAgentActivityList = thismodule.lineGetAgentActivityListA;
        pub const lineGetAgentCaps = thismodule.lineGetAgentCapsA;
        pub const lineGetAgentGroupList = thismodule.lineGetAgentGroupListA;
        pub const lineGetAgentStatus = thismodule.lineGetAgentStatusA;
        pub const lineGetGroupList = thismodule.lineGetGroupListA;
        pub const lineGetQueueList = thismodule.lineGetQueueListA;
        pub const lineInitializeEx = thismodule.lineInitializeExA;
        pub const phoneInitializeEx = thismodule.phoneInitializeExA;
    },
    .wide => struct {
        pub const lineCreateAgent = thismodule.lineCreateAgentW;
        pub const lineCreateAgentSession = thismodule.lineCreateAgentSessionW;
        pub const lineGetAgentActivityList = thismodule.lineGetAgentActivityListW;
        pub const lineGetAgentCaps = thismodule.lineGetAgentCapsW;
        pub const lineGetAgentGroupList = thismodule.lineGetAgentGroupListW;
        pub const lineGetAgentStatus = thismodule.lineGetAgentStatusW;
        pub const lineGetGroupList = thismodule.lineGetGroupListW;
        pub const lineGetQueueList = thismodule.lineGetQueueListW;
        pub const lineInitializeEx = thismodule.lineInitializeExW;
        pub const phoneInitializeEx = thismodule.phoneInitializeExW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const lineCreateAgent = *opaque {};
        pub const lineCreateAgentSession = *opaque {};
        pub const lineGetAgentActivityList = *opaque {};
        pub const lineGetAgentCaps = *opaque {};
        pub const lineGetAgentGroupList = *opaque {};
        pub const lineGetAgentStatus = *opaque {};
        pub const lineGetGroupList = *opaque {};
        pub const lineGetQueueList = *opaque {};
        pub const lineInitializeEx = *opaque {};
        pub const phoneInitializeEx = *opaque {};
    } else struct {
        pub const lineCreateAgent = @compileError("'lineCreateAgent' requires that UNICODE be set to true or false in the root module");
        pub const lineCreateAgentSession = @compileError("'lineCreateAgentSession' requires that UNICODE be set to true or false in the root module");
        pub const lineGetAgentActivityList = @compileError("'lineGetAgentActivityList' requires that UNICODE be set to true or false in the root module");
        pub const lineGetAgentCaps = @compileError("'lineGetAgentCaps' requires that UNICODE be set to true or false in the root module");
        pub const lineGetAgentGroupList = @compileError("'lineGetAgentGroupList' requires that UNICODE be set to true or false in the root module");
        pub const lineGetAgentStatus = @compileError("'lineGetAgentStatus' requires that UNICODE be set to true or false in the root module");
        pub const lineGetGroupList = @compileError("'lineGetGroupList' requires that UNICODE be set to true or false in the root module");
        pub const lineGetQueueList = @compileError("'lineGetQueueList' requires that UNICODE be set to true or false in the root module");
        pub const lineInitializeEx = @compileError("'lineInitializeEx' requires that UNICODE be set to true or false in the root module");
        pub const phoneInitializeEx = @compileError("'phoneInitializeEx' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (25)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const ALLOCATOR_PROPERTIES = @import("../media/direct_show.zig").ALLOCATOR_PROPERTIES;
const AM_MEDIA_TYPE = @import("../media/direct_show.zig").AM_MEDIA_TYPE;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const CY = @import("../system/com.zig").CY;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IAddrBook = @import("../system/address_book.zig").IAddrBook;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IMAPITable = @import("../system/address_book.zig").IMAPITable;
const IMessage = @import("../system/address_book.zig").IMessage;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SPropTagArray = @import("../system/address_book.zig").SPropTagArray;
const SPropValue = @import("../system/address_book.zig").SPropValue;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const VARIANT = @import("../system/com.zig").VARIANT;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LINECALLBACK")) {
        _ = LINECALLBACK;
    }
    if (@hasDecl(@This(), "PHONECALLBACK")) {
        _ = PHONECALLBACK;
    }
    if (@hasDecl(@This(), "ASYNC_COMPLETION")) {
        _ = ASYNC_COMPLETION;
    }
    if (@hasDecl(@This(), "LINEEVENT")) {
        _ = LINEEVENT;
    }
    if (@hasDecl(@This(), "PHONEEVENT")) {
        _ = PHONEEVENT;
    }
    if (@hasDecl(@This(), "TUISPIDLLCALLBACK")) {
        _ = TUISPIDLLCALLBACK;
    }
    if (@hasDecl(@This(), "LPOPENTNEFSTREAM")) {
        _ = LPOPENTNEFSTREAM;
    }
    if (@hasDecl(@This(), "LPOPENTNEFSTREAMEX")) {
        _ = LPOPENTNEFSTREAMEX;
    }
    if (@hasDecl(@This(), "LPGETTNEFSTREAMCODEPAGE")) {
        _ = LPGETTNEFSTREAMCODEPAGE;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
