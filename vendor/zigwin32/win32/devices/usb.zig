//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (547)
//--------------------------------------------------------------------------------
pub const SHORT_PACKET_TERMINATE = @as(u32, 1);
pub const AUTO_CLEAR_STALL = @as(u32, 2);
pub const PIPE_TRANSFER_TIMEOUT = @as(u32, 3);
pub const IGNORE_SHORT_PACKETS = @as(u32, 4);
pub const ALLOW_PARTIAL_READS = @as(u32, 5);
pub const AUTO_FLUSH = @as(u32, 6);
pub const RAW_IO = @as(u32, 7);
pub const MAXIMUM_TRANSFER_SIZE = @as(u32, 8);
pub const RESET_PIPE_ON_RESUME = @as(u32, 9);
pub const AUTO_SUSPEND = @as(u32, 129);
pub const SUSPEND_DELAY = @as(u32, 131);
pub const DEVICE_SPEED = @as(u32, 1);
pub const LowSpeed = @as(u32, 1);
pub const FullSpeed = @as(u32, 2);
pub const HighSpeed = @as(u32, 3);
pub const IOCTL_GENERICUSBFN_TRANSFER_IN = @as(u32, 2277389);
pub const IOCTL_GENERICUSBFN_TRANSFER_IN_APPEND_ZERO_PKT = @as(u32, 2277393);
pub const IOCTL_GENERICUSBFN_TRANSFER_OUT = @as(u32, 2277398);
pub const IOCTL_GENERICUSBFN_CONTROL_STATUS_HANDSHAKE_IN = @as(u32, 2277400);
pub const IOCTL_GENERICUSBFN_CONTROL_STATUS_HANDSHAKE_OUT = @as(u32, 2277404);
pub const IOCTL_GENERICUSBFN_GET_CLASS_INFO = @as(u32, 2277410);
pub const IOCTL_GENERICUSBFN_GET_PIPE_STATE = @as(u32, 2277414);
pub const IOCTL_GENERICUSBFN_SET_PIPE_STATE = @as(u32, 2277417);
pub const IOCTL_GENERICUSBFN_ACTIVATE_USB_BUS = @as(u32, 2277420);
pub const IOCTL_GENERICUSBFN_DEACTIVATE_USB_BUS = @as(u32, 2277424);
pub const IOCTL_GENERICUSBFN_BUS_EVENT_NOTIFICATION = @as(u32, 2277430);
pub const IOCTL_GENERICUSBFN_GET_CLASS_INFO_EX = @as(u32, 2277434);
pub const IOCTL_GENERICUSBFN_GET_INTERFACE_DESCRIPTOR_SET = @as(u32, 2277438);
pub const IOCTL_GENERICUSBFN_REGISTER_USB_STRING = @as(u32, 2277441);
pub const USBUSER_VERSION = @as(u32, 4);
pub const USBUSER_GET_CONTROLLER_INFO_0 = @as(u32, 1);
pub const USBUSER_GET_CONTROLLER_DRIVER_KEY = @as(u32, 2);
pub const USBUSER_PASS_THRU = @as(u32, 3);
pub const USBUSER_GET_POWER_STATE_MAP = @as(u32, 4);
pub const USBUSER_GET_BANDWIDTH_INFORMATION = @as(u32, 5);
pub const USBUSER_GET_BUS_STATISTICS_0 = @as(u32, 6);
pub const USBUSER_GET_ROOTHUB_SYMBOLIC_NAME = @as(u32, 7);
pub const USBUSER_GET_USB_DRIVER_VERSION = @as(u32, 8);
pub const USBUSER_GET_USB2_HW_VERSION = @as(u32, 9);
pub const USBUSER_USB_REFRESH_HCT_REG = @as(u32, 10);
pub const USBUSER_OP_SEND_ONE_PACKET = @as(u32, 268435457);
pub const USBUSER_OP_RAW_RESET_PORT = @as(u32, 536870913);
pub const USBUSER_OP_OPEN_RAW_DEVICE = @as(u32, 536870914);
pub const USBUSER_OP_CLOSE_RAW_DEVICE = @as(u32, 536870915);
pub const USBUSER_OP_SEND_RAW_COMMAND = @as(u32, 536870916);
pub const USBUSER_SET_ROOTPORT_FEATURE = @as(u32, 536870917);
pub const USBUSER_CLEAR_ROOTPORT_FEATURE = @as(u32, 536870918);
pub const USBUSER_GET_ROOTPORT_STATUS = @as(u32, 536870919);
pub const USBUSER_INVALID_REQUEST = @as(u32, 4294967280);
pub const USBUSER_OP_MASK_DEVONLY_API = @as(u32, 268435456);
pub const USBUSER_OP_MASK_HCTEST_API = @as(u32, 536870912);
pub const USB_PACKETFLAG_LOW_SPEED = @as(u32, 1);
pub const USB_PACKETFLAG_FULL_SPEED = @as(u32, 2);
pub const USB_PACKETFLAG_HIGH_SPEED = @as(u32, 4);
pub const USB_PACKETFLAG_ASYNC_IN = @as(u32, 8);
pub const USB_PACKETFLAG_ASYNC_OUT = @as(u32, 16);
pub const USB_PACKETFLAG_ISO_IN = @as(u32, 32);
pub const USB_PACKETFLAG_ISO_OUT = @as(u32, 64);
pub const USB_PACKETFLAG_SETUP = @as(u32, 128);
pub const USB_PACKETFLAG_TOGGLE0 = @as(u32, 256);
pub const USB_PACKETFLAG_TOGGLE1 = @as(u32, 512);
pub const USB_HC_FEATURE_FLAG_PORT_POWER_SWITCHING = @as(u32, 1);
pub const USB_HC_FEATURE_FLAG_SEL_SUSPEND = @as(u32, 2);
pub const USB_HC_FEATURE_LEGACY_BIOS = @as(u32, 4);
pub const USB_HC_FEATURE_TIME_SYNC_API = @as(u32, 8);
pub const USB_SUBMIT_URB = @as(u32, 0);
pub const USB_RESET_PORT = @as(u32, 1);
pub const USB_GET_ROOTHUB_PDO = @as(u32, 3);
pub const USB_GET_PORT_STATUS = @as(u32, 4);
pub const USB_ENABLE_PORT = @as(u32, 5);
pub const USB_GET_HUB_COUNT = @as(u32, 6);
pub const USB_CYCLE_PORT = @as(u32, 7);
pub const USB_GET_HUB_NAME = @as(u32, 8);
pub const USB_IDLE_NOTIFICATION = @as(u32, 9);
pub const USB_RECORD_FAILURE = @as(u32, 10);
pub const USB_GET_BUS_INFO = @as(u32, 264);
pub const USB_GET_CONTROLLER_NAME = @as(u32, 265);
pub const USB_GET_BUSGUID_INFO = @as(u32, 266);
pub const USB_GET_PARENT_HUB_INFO = @as(u32, 267);
pub const USB_GET_DEVICE_HANDLE = @as(u32, 268);
pub const USB_GET_DEVICE_HANDLE_EX = @as(u32, 269);
pub const USB_GET_TT_DEVICE_HANDLE = @as(u32, 270);
pub const USB_GET_TOPOLOGY_ADDRESS = @as(u32, 271);
pub const USB_IDLE_NOTIFICATION_EX = @as(u32, 272);
pub const USB_REQ_GLOBAL_SUSPEND = @as(u32, 273);
pub const USB_REQ_GLOBAL_RESUME = @as(u32, 274);
pub const USB_GET_HUB_CONFIG_INFO = @as(u32, 275);
pub const USB_FAIL_GET_STATUS = @as(u32, 280);
pub const USB_REGISTER_COMPOSITE_DEVICE = @as(u32, 0);
pub const USB_UNREGISTER_COMPOSITE_DEVICE = @as(u32, 1);
pub const USB_REQUEST_REMOTE_WAKE_NOTIFICATION = @as(u32, 2);
pub const HCD_GET_STATS_1 = @as(u32, 255);
pub const HCD_DIAGNOSTIC_MODE_ON = @as(u32, 256);
pub const HCD_DIAGNOSTIC_MODE_OFF = @as(u32, 257);
pub const HCD_GET_ROOT_HUB_NAME = @as(u32, 258);
pub const HCD_GET_DRIVERKEY_NAME = @as(u32, 265);
pub const HCD_GET_STATS_2 = @as(u32, 266);
pub const HCD_DISABLE_PORT = @as(u32, 268);
pub const HCD_ENABLE_PORT = @as(u32, 269);
pub const HCD_USER_REQUEST = @as(u32, 270);
pub const HCD_TRACE_READ_REQUEST = @as(u32, 275);
pub const USB_GET_NODE_INFORMATION = @as(u32, 258);
pub const USB_GET_NODE_CONNECTION_INFORMATION = @as(u32, 259);
pub const USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION = @as(u32, 260);
pub const USB_GET_NODE_CONNECTION_NAME = @as(u32, 261);
pub const USB_DIAG_IGNORE_HUBS_ON = @as(u32, 262);
pub const USB_DIAG_IGNORE_HUBS_OFF = @as(u32, 263);
pub const USB_GET_NODE_CONNECTION_DRIVERKEY_NAME = @as(u32, 264);
pub const USB_GET_HUB_CAPABILITIES = @as(u32, 271);
pub const USB_GET_NODE_CONNECTION_ATTRIBUTES = @as(u32, 272);
pub const USB_HUB_CYCLE_PORT = @as(u32, 273);
pub const USB_GET_NODE_CONNECTION_INFORMATION_EX = @as(u32, 274);
pub const USB_RESET_HUB = @as(u32, 275);
pub const USB_GET_HUB_CAPABILITIES_EX = @as(u32, 276);
pub const USB_GET_HUB_INFORMATION_EX = @as(u32, 277);
pub const USB_GET_PORT_CONNECTOR_PROPERTIES = @as(u32, 278);
pub const USB_GET_NODE_CONNECTION_INFORMATION_EX_V2 = @as(u32, 279);
pub const USB_GET_TRANSPORT_CHARACTERISTICS = @as(u32, 281);
pub const USB_REGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = @as(u32, 282);
pub const USB_NOTIFY_ON_TRANSPORT_CHARACTERISTICS_CHANGE = @as(u32, 283);
pub const USB_UNREGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = @as(u32, 284);
pub const USB_START_TRACKING_FOR_TIME_SYNC = @as(u32, 285);
pub const USB_GET_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC = @as(u32, 286);
pub const USB_STOP_TRACKING_FOR_TIME_SYNC = @as(u32, 287);
pub const USB_GET_DEVICE_CHARACTERISTICS = @as(u32, 288);
pub const GUID_DEVINTERFACE_USB_HUB = Guid.initString("f18a0e88-c30c-11d0-8815-00a0c906bed8");
pub const GUID_DEVINTERFACE_USB_BILLBOARD = Guid.initString("5e9adaef-f879-473f-b807-4e5ea77d1b1c");
pub const GUID_DEVINTERFACE_USB_DEVICE = Guid.initString("a5dcbf10-6530-11d2-901f-00c04fb951ed");
pub const GUID_DEVINTERFACE_USB_HOST_CONTROLLER = Guid.initString("3abf6f2d-71c4-462a-8a92-1e6861e6af27");
pub const GUID_USB_WMI_STD_DATA = Guid.initString("4e623b20-cb14-11d1-b331-00a0c959bbd2");
pub const GUID_USB_WMI_STD_NOTIFICATION = Guid.initString("4e623b20-cb14-11d1-b331-00a0c959bbd2");
pub const GUID_USB_WMI_DEVICE_PERF_INFO = Guid.initString("66c1aa3c-499f-49a0-a9a5-61e2359f6407");
pub const GUID_USB_WMI_NODE_INFO = Guid.initString("9c179357-dc7a-4f41-b66b-323b9ddcb5b1");
pub const GUID_USB_WMI_TRACING = Guid.initString("3a61881b-b4e6-4bf9-ae0f-3cd8f394e52f");
pub const GUID_USB_TRANSFER_TRACING = Guid.initString("681eb8aa-403d-452c-9f8a-f0616fac9540");
pub const GUID_USB_PERFORMANCE_TRACING = Guid.initString("d5de77a6-6ae9-425c-b1e2-f5615fd348a9");
pub const GUID_USB_WMI_SURPRISE_REMOVAL_NOTIFICATION = Guid.initString("9bbbf831-a2f2-43b4-96d1-86944b5914b3");
pub const FILE_DEVICE_USB = @as(u32, 34);
pub const BMREQUEST_HOST_TO_DEVICE = @as(u32, 0);
pub const BMREQUEST_DEVICE_TO_HOST = @as(u32, 1);
pub const BMREQUEST_STANDARD = @as(u32, 0);
pub const BMREQUEST_CLASS = @as(u32, 1);
pub const BMREQUEST_VENDOR = @as(u32, 2);
pub const BMREQUEST_TO_DEVICE = @as(u32, 0);
pub const BMREQUEST_TO_INTERFACE = @as(u32, 1);
pub const BMREQUEST_TO_ENDPOINT = @as(u32, 2);
pub const BMREQUEST_TO_OTHER = @as(u32, 3);
pub const USB_REQUEST_GET_STATUS = @as(u32, 0);
pub const USB_REQUEST_CLEAR_FEATURE = @as(u32, 1);
pub const USB_REQUEST_SET_FEATURE = @as(u32, 3);
pub const USB_REQUEST_SET_ADDRESS = @as(u32, 5);
pub const USB_REQUEST_GET_DESCRIPTOR = @as(u32, 6);
pub const USB_REQUEST_SET_DESCRIPTOR = @as(u32, 7);
pub const USB_REQUEST_GET_CONFIGURATION = @as(u32, 8);
pub const USB_REQUEST_SET_CONFIGURATION = @as(u32, 9);
pub const USB_REQUEST_GET_INTERFACE = @as(u32, 10);
pub const USB_REQUEST_SET_INTERFACE = @as(u32, 11);
pub const USB_REQUEST_SYNC_FRAME = @as(u32, 12);
pub const USB_REQUEST_GET_FIRMWARE_STATUS = @as(u32, 26);
pub const USB_REQUEST_SET_FIRMWARE_STATUS = @as(u32, 27);
pub const USB_GET_FIRMWARE_ALLOWED_OR_DISALLOWED_STATE = @as(u32, 0);
pub const USB_GET_FIRMWARE_HASH = @as(u32, 1);
pub const USB_DEVICE_FIRMWARE_HASH_LENGTH = @as(u32, 32);
pub const USB_DISALLOW_FIRMWARE_UPDATE = @as(u32, 0);
pub const USB_ALLOW_FIRMWARE_UPDATE = @as(u32, 1);
pub const USB_REQUEST_SET_SEL = @as(u32, 48);
pub const USB_REQUEST_ISOCH_DELAY = @as(u32, 49);
pub const USB_DEVICE_DESCRIPTOR_TYPE = @as(u32, 1);
pub const USB_CONFIGURATION_DESCRIPTOR_TYPE = @as(u32, 2);
pub const USB_STRING_DESCRIPTOR_TYPE = @as(u32, 3);
pub const USB_INTERFACE_DESCRIPTOR_TYPE = @as(u32, 4);
pub const USB_ENDPOINT_DESCRIPTOR_TYPE = @as(u32, 5);
pub const USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE = @as(u32, 6);
pub const USB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR_TYPE = @as(u32, 7);
pub const USB_INTERFACE_POWER_DESCRIPTOR_TYPE = @as(u32, 8);
pub const USB_OTG_DESCRIPTOR_TYPE = @as(u32, 9);
pub const USB_DEBUG_DESCRIPTOR_TYPE = @as(u32, 10);
pub const USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE = @as(u32, 11);
pub const USB_BOS_DESCRIPTOR_TYPE = @as(u32, 15);
pub const USB_DEVICE_CAPABILITY_DESCRIPTOR_TYPE = @as(u32, 16);
pub const USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR_TYPE = @as(u32, 48);
pub const USB_SUPERSPEEDPLUS_ISOCH_ENDPOINT_COMPANION_DESCRIPTOR_TYPE = @as(u32, 49);
pub const USB_RESERVED_DESCRIPTOR_TYPE = @as(u32, 6);
pub const USB_CONFIG_POWER_DESCRIPTOR_TYPE = @as(u32, 7);
pub const USB_FEATURE_ENDPOINT_STALL = @as(u32, 0);
pub const USB_FEATURE_REMOTE_WAKEUP = @as(u32, 1);
pub const USB_FEATURE_TEST_MODE = @as(u32, 2);
pub const USB_FEATURE_FUNCTION_SUSPEND = @as(u32, 0);
pub const USB_FEATURE_U1_ENABLE = @as(u32, 48);
pub const USB_FEATURE_U2_ENABLE = @as(u32, 49);
pub const USB_FEATURE_LTM_ENABLE = @as(u32, 50);
pub const USB_FEATURE_LDM_ENABLE = @as(u32, 53);
pub const USB_FEATURE_BATTERY_WAKE_MASK = @as(u32, 40);
pub const USB_FEATURE_OS_IS_PD_AWARE = @as(u32, 41);
pub const USB_FEATURE_POLICY_MODE = @as(u32, 42);
pub const USB_FEATURE_CHARGING_POLICY = @as(u32, 54);
pub const USB_CHARGING_POLICY_DEFAULT = @as(u32, 0);
pub const USB_CHARGING_POLICY_ICCHPF = @as(u32, 1);
pub const USB_CHARGING_POLICY_ICCLPF = @as(u32, 2);
pub const USB_CHARGING_POLICY_NO_POWER = @as(u32, 3);
pub const USB_STATUS_PORT_STATUS = @as(u32, 0);
pub const USB_STATUS_PD_STATUS = @as(u32, 1);
pub const USB_STATUS_EXT_PORT_STATUS = @as(u32, 2);
pub const USB_GETSTATUS_SELF_POWERED = @as(u32, 1);
pub const USB_GETSTATUS_REMOTE_WAKEUP_ENABLED = @as(u32, 2);
pub const USB_GETSTATUS_U1_ENABLE = @as(u32, 4);
pub const USB_GETSTATUS_U2_ENABLE = @as(u32, 8);
pub const USB_GETSTATUS_LTM_ENABLE = @as(u32, 16);
pub const USB_DEVICE_CLASS_RESERVED = @as(u32, 0);
pub const USB_DEVICE_CLASS_AUDIO = @as(u32, 1);
pub const USB_DEVICE_CLASS_COMMUNICATIONS = @as(u32, 2);
pub const USB_DEVICE_CLASS_HUMAN_INTERFACE = @as(u32, 3);
pub const USB_DEVICE_CLASS_MONITOR = @as(u32, 4);
pub const USB_DEVICE_CLASS_PHYSICAL_INTERFACE = @as(u32, 5);
pub const USB_DEVICE_CLASS_POWER = @as(u32, 6);
pub const USB_DEVICE_CLASS_IMAGE = @as(u32, 6);
pub const USB_DEVICE_CLASS_PRINTER = @as(u32, 7);
pub const USB_DEVICE_CLASS_STORAGE = @as(u32, 8);
pub const USB_DEVICE_CLASS_HUB = @as(u32, 9);
pub const USB_DEVICE_CLASS_CDC_DATA = @as(u32, 10);
pub const USB_DEVICE_CLASS_SMART_CARD = @as(u32, 11);
pub const USB_DEVICE_CLASS_CONTENT_SECURITY = @as(u32, 13);
pub const USB_DEVICE_CLASS_VIDEO = @as(u32, 14);
pub const USB_DEVICE_CLASS_PERSONAL_HEALTHCARE = @as(u32, 15);
pub const USB_DEVICE_CLASS_AUDIO_VIDEO = @as(u32, 16);
pub const USB_DEVICE_CLASS_BILLBOARD = @as(u32, 17);
pub const USB_DEVICE_CLASS_DIAGNOSTIC_DEVICE = @as(u32, 220);
pub const USB_DEVICE_CLASS_WIRELESS_CONTROLLER = @as(u32, 224);
pub const USB_DEVICE_CLASS_MISCELLANEOUS = @as(u32, 239);
pub const USB_DEVICE_CLASS_APPLICATION_SPECIFIC = @as(u32, 254);
pub const USB_DEVICE_CLASS_VENDOR_SPECIFIC = @as(u32, 255);
pub const USB_DEVICE_CAPABILITY_WIRELESS_USB = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_USB20_EXTENSION = @as(u32, 2);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_USB = @as(u32, 3);
pub const USB_DEVICE_CAPABILITY_CONTAINER_ID = @as(u32, 4);
pub const USB_DEVICE_CAPABILITY_PLATFORM = @as(u32, 5);
pub const USB_DEVICE_CAPABILITY_POWER_DELIVERY = @as(u32, 6);
pub const USB_DEVICE_CAPABILITY_BATTERY_INFO = @as(u32, 7);
pub const USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT = @as(u32, 8);
pub const USB_DEVICE_CAPABILITY_PD_PROVIDER_PORT = @as(u32, 9);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_USB = @as(u32, 10);
pub const USB_DEVICE_CAPABILITY_PRECISION_TIME_MEASUREMENT = @as(u32, 11);
pub const USB_DEVICE_CAPABILITY_BILLBOARD = @as(u32, 13);
pub const USB_DEVICE_CAPABILITY_FIRMWARE_STATUS = @as(u32, 17);
pub const USB_DEVICE_CAPABILITY_USB20_EXTENSION_BMATTRIBUTES_RESERVED_MASK = @as(u32, 4294901985);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_BMATTRIBUTES_RESERVED_MASK = @as(u32, 253);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_BMATTRIBUTES_LTM_CAPABLE = @as(u32, 2);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_RESERVED_MASK = @as(u32, 65520);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_LOW = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_FULL = @as(u32, 2);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_HIGH = @as(u32, 4);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_SUPER = @as(u32, 8);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_U1_DEVICE_EXIT_MAX_VALUE = @as(u32, 10);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_U2_DEVICE_EXIT_MAX_VALUE = @as(u32, 2047);
pub const USB_DEVICE_CAPABILITY_MAX_U1_LATENCY = @as(u32, 10);
pub const USB_DEVICE_CAPABILITY_MAX_U2_LATENCY = @as(u32, 2047);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_BPS = @as(u32, 0);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_KBPS = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_MBPS = @as(u32, 2);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_GBPS = @as(u32, 3);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_MODE_SYMMETRIC = @as(u32, 0);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_MODE_ASYMMETRIC = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_DIR_RX = @as(u32, 0);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_DIR_TX = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_PROTOCOL_SS = @as(u32, 0);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_PROTOCOL_SSP = @as(u32, 1);
pub const GUID_USB_MSOS20_PLATFORM_CAPABILITY_ID = Guid.initString("d8dd60df-4589-4cc7-9cd2-659d9e648a9f");
pub const USB_CONFIG_POWERED_MASK = @as(u32, 192);
pub const USB_CONFIG_BUS_POWERED = @as(u32, 128);
pub const USB_CONFIG_SELF_POWERED = @as(u32, 64);
pub const USB_CONFIG_REMOTE_WAKEUP = @as(u32, 32);
pub const USB_CONFIG_RESERVED = @as(u32, 31);
pub const USB_ENDPOINT_DIRECTION_MASK = @as(u32, 128);
pub const USB_ENDPOINT_ADDRESS_MASK = @as(u32, 15);
pub const USB_ENDPOINT_TYPE_MASK = @as(u32, 3);
pub const USB_ENDPOINT_TYPE_CONTROL = @as(u32, 0);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS = @as(u32, 1);
pub const USB_ENDPOINT_TYPE_BULK = @as(u32, 2);
pub const USB_ENDPOINT_TYPE_INTERRUPT = @as(u32, 3);
pub const USB_ENDPOINT_TYPE_BULK_RESERVED_MASK = @as(u32, 252);
pub const USB_ENDPOINT_TYPE_CONTROL_RESERVED_MASK = @as(u32, 252);
pub const USB_20_ENDPOINT_TYPE_INTERRUPT_RESERVED_MASK = @as(u32, 252);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_RESERVED_MASK = @as(u32, 204);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_RESERVED_MASK = @as(u32, 192);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_MASK = @as(u32, 48);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_PERIODIC = @as(u32, 0);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_NOTIFICATION = @as(u32, 16);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_RESERVED10 = @as(u32, 32);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_RESERVED11 = @as(u32, 48);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_MASK = @as(u32, 12);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_NO_SYNCHRONIZATION = @as(u32, 0);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_ASYNCHRONOUS = @as(u32, 4);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_ADAPTIVE = @as(u32, 8);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_SYNCHRONOUS = @as(u32, 12);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_MASK = @as(u32, 48);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_DATA_ENDOINT = @as(u32, 0);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_FEEDBACK_ENDPOINT = @as(u32, 16);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_IMPLICIT_FEEDBACK_DATA_ENDPOINT = @as(u32, 32);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_RESERVED = @as(u32, 48);
pub const USB_ENDPOINT_SUPERSPEED_BULK_MAX_PACKET_SIZE = @as(u32, 1024);
pub const USB_ENDPOINT_SUPERSPEED_CONTROL_MAX_PACKET_SIZE = @as(u32, 512);
pub const USB_ENDPOINT_SUPERSPEED_ISO_MAX_PACKET_SIZE = @as(u32, 1024);
pub const USB_ENDPOINT_SUPERSPEED_INTERRUPT_MAX_PACKET_SIZE = @as(u32, 1024);
pub const MAXIMUM_USB_STRING_LENGTH = @as(u32, 255);
pub const USB_SUPERSPEED_ISOCHRONOUS_MAX_MULTIPLIER = @as(u32, 2);
pub const USB_SUPERSPEEDPLUS_ISOCHRONOUS_MIN_BYTESPERINTERVAL = @as(u32, 49153);
pub const USB_SUPERSPEEDPLUS_ISOCHRONOUS_MAX_BYTESPERINTERVAL = @as(u32, 16777215);
pub const USB_20_HUB_DESCRIPTOR_TYPE = @as(u32, 41);
pub const USB_30_HUB_DESCRIPTOR_TYPE = @as(u32, 42);
pub const USB_REQUEST_GET_STATE = @as(u32, 2);
pub const USB_REQUEST_CLEAR_TT_BUFFER = @as(u32, 8);
pub const USB_REQUEST_RESET_TT = @as(u32, 9);
pub const USB_REQUEST_GET_TT_STATE = @as(u32, 10);
pub const USB_REQUEST_STOP_TT = @as(u32, 11);
pub const USB_REQUEST_SET_HUB_DEPTH = @as(u32, 12);
pub const USB_REQUEST_GET_PORT_ERR_COUNT = @as(u32, 13);
pub const USB_PORT_STATUS_CONNECT = @as(u32, 1);
pub const USB_PORT_STATUS_ENABLE = @as(u32, 2);
pub const USB_PORT_STATUS_SUSPEND = @as(u32, 4);
pub const USB_PORT_STATUS_OVER_CURRENT = @as(u32, 8);
pub const USB_PORT_STATUS_RESET = @as(u32, 16);
pub const USB_PORT_STATUS_POWER = @as(u32, 256);
pub const USB_PORT_STATUS_LOW_SPEED = @as(u32, 512);
pub const USB_PORT_STATUS_HIGH_SPEED = @as(u32, 1024);
pub const PORT_LINK_STATE_U0 = @as(u32, 0);
pub const PORT_LINK_STATE_U1 = @as(u32, 1);
pub const PORT_LINK_STATE_U2 = @as(u32, 2);
pub const PORT_LINK_STATE_U3 = @as(u32, 3);
pub const PORT_LINK_STATE_DISABLED = @as(u32, 4);
pub const PORT_LINK_STATE_RX_DETECT = @as(u32, 5);
pub const PORT_LINK_STATE_INACTIVE = @as(u32, 6);
pub const PORT_LINK_STATE_POLLING = @as(u32, 7);
pub const PORT_LINK_STATE_RECOVERY = @as(u32, 8);
pub const PORT_LINK_STATE_HOT_RESET = @as(u32, 9);
pub const PORT_LINK_STATE_COMPLIANCE_MODE = @as(u32, 10);
pub const PORT_LINK_STATE_LOOPBACK = @as(u32, 11);
pub const PORT_LINK_STATE_TEST_MODE = @as(u32, 11);
pub const USB_FEATURE_INTERFACE_POWER_D0 = @as(u32, 2);
pub const USB_FEATURE_INTERFACE_POWER_D1 = @as(u32, 3);
pub const USB_FEATURE_INTERFACE_POWER_D2 = @as(u32, 4);
pub const USB_FEATURE_INTERFACE_POWER_D3 = @as(u32, 5);
pub const USB_SUPPORT_D0_COMMAND = @as(u32, 1);
pub const USB_SUPPORT_D1_COMMAND = @as(u32, 2);
pub const USB_SUPPORT_D2_COMMAND = @as(u32, 4);
pub const USB_SUPPORT_D3_COMMAND = @as(u32, 8);
pub const USB_SUPPORT_D1_WAKEUP = @as(u32, 16);
pub const USB_SUPPORT_D2_WAKEUP = @as(u32, 32);
pub const USBDI_VERSION = @as(u32, 1536);
pub const USB_PORTATTR_NO_CONNECTOR = @as(u32, 1);
pub const USB_PORTATTR_SHARED_USB2 = @as(u32, 2);
pub const USB_PORTATTR_MINI_CONNECTOR = @as(u32, 4);
pub const USB_PORTATTR_OEM_CONNECTOR = @as(u32, 8);
pub const USB_PORTATTR_OWNED_BY_CC = @as(u32, 16777216);
pub const USB_PORTATTR_NO_OVERCURRENT_UI = @as(u32, 33554432);
pub const USB_DEFAULT_DEVICE_ADDRESS = @as(u32, 0);
pub const USB_DEFAULT_ENDPOINT_ADDRESS = @as(u32, 0);
pub const USB_DEFAULT_MAX_PACKET = @as(u32, 64);
pub const URB_FUNCTION_SELECT_CONFIGURATION = @as(u32, 0);
pub const URB_FUNCTION_SELECT_INTERFACE = @as(u32, 1);
pub const URB_FUNCTION_ABORT_PIPE = @as(u32, 2);
pub const URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL = @as(u32, 3);
pub const URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL = @as(u32, 4);
pub const URB_FUNCTION_GET_FRAME_LENGTH = @as(u32, 5);
pub const URB_FUNCTION_SET_FRAME_LENGTH = @as(u32, 6);
pub const URB_FUNCTION_GET_CURRENT_FRAME_NUMBER = @as(u32, 7);
pub const URB_FUNCTION_CONTROL_TRANSFER = @as(u32, 8);
pub const URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER = @as(u32, 9);
pub const URB_FUNCTION_ISOCH_TRANSFER = @as(u32, 10);
pub const URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE = @as(u32, 11);
pub const URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE = @as(u32, 12);
pub const URB_FUNCTION_SET_FEATURE_TO_DEVICE = @as(u32, 13);
pub const URB_FUNCTION_SET_FEATURE_TO_INTERFACE = @as(u32, 14);
pub const URB_FUNCTION_SET_FEATURE_TO_ENDPOINT = @as(u32, 15);
pub const URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE = @as(u32, 16);
pub const URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE = @as(u32, 17);
pub const URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT = @as(u32, 18);
pub const URB_FUNCTION_GET_STATUS_FROM_DEVICE = @as(u32, 19);
pub const URB_FUNCTION_GET_STATUS_FROM_INTERFACE = @as(u32, 20);
pub const URB_FUNCTION_GET_STATUS_FROM_ENDPOINT = @as(u32, 21);
pub const URB_FUNCTION_RESERVED_0X0016 = @as(u32, 22);
pub const URB_FUNCTION_VENDOR_DEVICE = @as(u32, 23);
pub const URB_FUNCTION_VENDOR_INTERFACE = @as(u32, 24);
pub const URB_FUNCTION_VENDOR_ENDPOINT = @as(u32, 25);
pub const URB_FUNCTION_CLASS_DEVICE = @as(u32, 26);
pub const URB_FUNCTION_CLASS_INTERFACE = @as(u32, 27);
pub const URB_FUNCTION_CLASS_ENDPOINT = @as(u32, 28);
pub const URB_FUNCTION_RESERVE_0X001D = @as(u32, 29);
pub const URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL = @as(u32, 30);
pub const URB_FUNCTION_CLASS_OTHER = @as(u32, 31);
pub const URB_FUNCTION_VENDOR_OTHER = @as(u32, 32);
pub const URB_FUNCTION_GET_STATUS_FROM_OTHER = @as(u32, 33);
pub const URB_FUNCTION_CLEAR_FEATURE_TO_OTHER = @as(u32, 34);
pub const URB_FUNCTION_SET_FEATURE_TO_OTHER = @as(u32, 35);
pub const URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT = @as(u32, 36);
pub const URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT = @as(u32, 37);
pub const URB_FUNCTION_GET_CONFIGURATION = @as(u32, 38);
pub const URB_FUNCTION_GET_INTERFACE = @as(u32, 39);
pub const URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE = @as(u32, 40);
pub const URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE = @as(u32, 41);
pub const URB_FUNCTION_RESERVE_0X002B = @as(u32, 43);
pub const URB_FUNCTION_RESERVE_0X002C = @as(u32, 44);
pub const URB_FUNCTION_RESERVE_0X002D = @as(u32, 45);
pub const URB_FUNCTION_RESERVE_0X002E = @as(u32, 46);
pub const URB_FUNCTION_RESERVE_0X002F = @as(u32, 47);
pub const URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR = @as(u32, 42);
pub const URB_FUNCTION_SYNC_RESET_PIPE = @as(u32, 48);
pub const URB_FUNCTION_SYNC_CLEAR_STALL = @as(u32, 49);
pub const URB_FUNCTION_CONTROL_TRANSFER_EX = @as(u32, 50);
pub const URB_FUNCTION_RESERVE_0X0033 = @as(u32, 51);
pub const URB_FUNCTION_RESERVE_0X0034 = @as(u32, 52);
pub const URB_FUNCTION_OPEN_STATIC_STREAMS = @as(u32, 53);
pub const URB_FUNCTION_CLOSE_STATIC_STREAMS = @as(u32, 54);
pub const URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL = @as(u32, 55);
pub const URB_FUNCTION_ISOCH_TRANSFER_USING_CHAINED_MDL = @as(u32, 56);
pub const URB_FUNCTION_GET_ISOCH_PIPE_TRANSFER_PATH_DELAYS = @as(u32, 61);
pub const URB_FUNCTION_RESET_PIPE = @as(u32, 30);
pub const USBD_SHORT_TRANSFER_OK = @as(u32, 2);
pub const USBD_START_ISO_TRANSFER_ASAP = @as(u32, 4);
pub const USBD_DEFAULT_PIPE_TRANSFER = @as(u32, 8);
pub const USBD_TRANSFER_DIRECTION_OUT = @as(u32, 0);
pub const USBD_TRANSFER_DIRECTION_IN = @as(u32, 1);
pub const USBD_TRANSFER_DIRECTION = @as(u32, 1);
pub const USBD_ISO_START_FRAME_RANGE = @as(u32, 1024);
pub const USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE = @as(u32, 4294967295);
pub const USBD_PF_CHANGE_MAX_PACKET = @as(u32, 1);
pub const USBD_PF_SHORT_PACKET_OPT = @as(u32, 2);
pub const USBD_PF_ENABLE_RT_THREAD_ACCESS = @as(u32, 4);
pub const USBD_PF_MAP_ADD_TRANSFERS = @as(u32, 8);
pub const USBD_PF_VIDEO_PRIORITY = @as(u32, 16);
pub const USBD_PF_VOICE_PRIORITY = @as(u32, 32);
pub const USBD_PF_INTERACTIVE_PRIORITY = @as(u32, 48);
pub const USBD_PF_PRIORITY_MASK = @as(u32, 240);
pub const USBD_PF_HANDLES_SSP_HIGH_BANDWIDTH_ISOCH = @as(u32, 256);
pub const USBD_PF_SSP_HIGH_BANDWIDTH_ISOCH = @as(u32, 65536);
pub const OS_STRING_DESCRIPTOR_INDEX = @as(u32, 238);
pub const MS_GENRE_DESCRIPTOR_INDEX = @as(u32, 1);
pub const MS_POWER_DESCRIPTOR_INDEX = @as(u32, 2);
pub const MS_OS_STRING_SIGNATURE = "MSFT100";
pub const MS_OS_FLAGS_CONTAINERID = @as(u32, 2);
pub const URB_OPEN_STATIC_STREAMS_VERSION_100 = @as(u32, 256);
pub const KREGUSBFNENUMPATH = "\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\USBFN\\";
pub const UREGUSBFNENUMPATH = "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\USBFN\\";
pub const KREGMANUSBFNENUMPATH = "\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\ManufacturingMode\\Current\\USBFN\\";
pub const UREGMANUSBFNENUMPATH = "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\ManufacturingMode\\Current\\USBFN\\";
pub const MAX_NUM_USBFN_ENDPOINTS = @as(u32, 15);
pub const MAX_CONFIGURATION_NAME_LENGTH = @as(u32, 40);
pub const MAX_USB_STRING_LENGTH = @as(u32, 255);
pub const MAX_SUPPORTED_CONFIGURATIONS = @as(u32, 12);
pub const USBFN_INTERRUPT_ENDPOINT_SIZE_NOT_UPDATEABLE_MASK = @as(u32, 128);
pub const USB_TEST_MODE_TEST_J = @as(u32, 1);
pub const USB_TEST_MODE_TEST_K = @as(u32, 2);
pub const USB_TEST_MODE_TEST_SE0_NAK = @as(u32, 3);
pub const USB_TEST_MODE_TEST_PACKET = @as(u32, 4);
pub const USB_TEST_MODE_TEST_FORCE_ENABLE = @as(u32, 5);
pub const MAX_INTERFACE_NAME_LENGTH = @as(u32, 40);
pub const MAX_ALTERNATE_NAME_LENGTH = @as(u32, 40);
pub const MAX_ASSOCIATION_NAME_LENGTH = @as(u32, 40);
pub const IOCTL_INTERNAL_USB_SUBMIT_URB = @as(u32, 2228227);
pub const IOCTL_INTERNAL_USB_RESET_PORT = @as(u32, 2228231);
pub const IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO = @as(u32, 2228239);
pub const USBD_PORT_ENABLED = @as(u32, 1);
pub const USBD_PORT_CONNECTED = @as(u32, 2);
pub const IOCTL_INTERNAL_USB_GET_PORT_STATUS = @as(u32, 2228243);
pub const IOCTL_INTERNAL_USB_ENABLE_PORT = @as(u32, 2228247);
pub const IOCTL_INTERNAL_USB_GET_HUB_COUNT = @as(u32, 2228251);
pub const IOCTL_INTERNAL_USB_CYCLE_PORT = @as(u32, 2228255);
pub const IOCTL_INTERNAL_USB_GET_HUB_NAME = @as(u32, 2228256);
pub const IOCTL_INTERNAL_USB_GET_BUS_INFO = @as(u32, 2229280);
pub const IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME = @as(u32, 2229284);
pub const IOCTL_INTERNAL_USB_GET_BUSGUID_INFO = @as(u32, 2229288);
pub const IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO = @as(u32, 2229292);
pub const IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION = @as(u32, 2228263);
pub const IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE = @as(u32, 2229299);
pub const IOCTL_INTERNAL_USB_NOTIFY_IDLE_READY = @as(u32, 2229315);
pub const IOCTL_INTERNAL_USB_REQ_GLOBAL_SUSPEND = @as(u32, 2229319);
pub const IOCTL_INTERNAL_USB_REQ_GLOBAL_RESUME = @as(u32, 2229323);
pub const IOCTL_INTERNAL_USB_RECORD_FAILURE = @as(u32, 2228267);
pub const IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE_EX = @as(u32, 2229303);
pub const IOCTL_INTERNAL_USB_GET_TT_DEVICE_HANDLE = @as(u32, 2229307);
pub const IOCTL_INTERNAL_USB_GET_TOPOLOGY_ADDRESS = @as(u32, 2229311);
pub const IOCTL_INTERNAL_USB_GET_DEVICE_CONFIG_INFO = @as(u32, 2229327);
pub const IOCTL_INTERNAL_USB_REGISTER_COMPOSITE_DEVICE = @as(u32, 4784131);
pub const IOCTL_INTERNAL_USB_UNREGISTER_COMPOSITE_DEVICE = @as(u32, 4784135);
pub const IOCTL_INTERNAL_USB_REQUEST_REMOTE_WAKE_NOTIFICATION = @as(u32, 4784139);
pub const IOCTL_INTERNAL_USB_FAIL_GET_STATUS_FROM_DEVICE = @as(u32, 2229347);
pub const IOCTL_USB_HCD_GET_STATS_1 = @as(u32, 2229244);
pub const IOCTL_USB_HCD_GET_STATS_2 = @as(u32, 2229288);
pub const IOCTL_USB_HCD_DISABLE_PORT = @as(u32, 2229296);
pub const IOCTL_USB_HCD_ENABLE_PORT = @as(u32, 2229300);
pub const IOCTL_USB_DIAGNOSTIC_MODE_ON = @as(u32, 2229248);
pub const IOCTL_USB_DIAGNOSTIC_MODE_OFF = @as(u32, 2229252);
pub const IOCTL_USB_GET_ROOT_HUB_NAME = @as(u32, 2229256);
pub const IOCTL_GET_HCD_DRIVERKEY_NAME = @as(u32, 2229284);
pub const IOCTL_USB_GET_NODE_INFORMATION = @as(u32, 2229256);
pub const IOCTL_USB_GET_NODE_CONNECTION_INFORMATION = @as(u32, 2229260);
pub const IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION = @as(u32, 2229264);
pub const IOCTL_USB_GET_NODE_CONNECTION_NAME = @as(u32, 2229268);
pub const IOCTL_USB_DIAG_IGNORE_HUBS_ON = @as(u32, 2229272);
pub const IOCTL_USB_DIAG_IGNORE_HUBS_OFF = @as(u32, 2229276);
pub const IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME = @as(u32, 2229280);
pub const IOCTL_USB_GET_HUB_CAPABILITIES = @as(u32, 2229308);
pub const IOCTL_USB_HUB_CYCLE_PORT = @as(u32, 2229316);
pub const IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES = @as(u32, 2229312);
pub const IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX = @as(u32, 2229320);
pub const IOCTL_USB_RESET_HUB = @as(u32, 2229324);
pub const IOCTL_USB_GET_HUB_CAPABILITIES_EX = @as(u32, 2229328);
pub const IOCTL_USB_GET_HUB_INFORMATION_EX = @as(u32, 2229332);
pub const IOCTL_USB_GET_PORT_CONNECTOR_PROPERTIES = @as(u32, 2229336);
pub const IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX_V2 = @as(u32, 2229340);
pub const IOCTL_USB_GET_TRANSPORT_CHARACTERISTICS = @as(u32, 2229348);
pub const IOCTL_USB_REGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = @as(u32, 2229352);
pub const IOCTL_USB_NOTIFY_ON_TRANSPORT_CHARACTERISTICS_CHANGE = @as(u32, 2229356);
pub const IOCTL_USB_UNREGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = @as(u32, 2229360);
pub const IOCTL_USB_START_TRACKING_FOR_TIME_SYNC = @as(u32, 2229364);
pub const IOCTL_USB_GET_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC = @as(u32, 2229368);
pub const IOCTL_USB_STOP_TRACKING_FOR_TIME_SYNC = @as(u32, 2229372);
pub const IOCTL_USB_GET_DEVICE_CHARACTERISTICS = @as(u32, 2229376);
pub const WMI_USB_DRIVER_INFORMATION = @as(u32, 0);
pub const WMI_USB_DRIVER_NOTIFICATION = @as(u32, 1);
pub const WMI_USB_POWER_DEVICE_ENABLE = @as(u32, 2);
pub const WMI_USB_HUB_NODE_INFORMATION = @as(u32, 4);
pub const WMI_USB_PERFORMANCE_INFORMATION = @as(u32, 1);
pub const WMI_USB_DEVICE_NODE_INFORMATION = @as(u32, 2);
pub const USB_TRANSPORT_CHARACTERISTICS_VERSION_1 = @as(u32, 1);
pub const USB_TRANSPORT_CHARACTERISTICS_LATENCY_AVAILABLE = @as(u32, 1);
pub const USB_TRANSPORT_CHARACTERISTICS_BANDWIDTH_AVAILABLE = @as(u32, 2);
pub const USB_REGISTER_FOR_TRANSPORT_LATENCY_CHANGE = @as(u32, 1);
pub const USB_REGISTER_FOR_TRANSPORT_BANDWIDTH_CHANGE = @as(u32, 2);
pub const USB_DEVICE_CHARACTERISTICS_VERSION_1 = @as(u32, 1);
pub const USB_DEVICE_CHARACTERISTICS_MAXIMUM_PATH_DELAYS_AVAILABLE = @as(u32, 1);
pub const MAX_NUM_PIPES = @as(u32, 8);
pub const BULKIN_FLAG = @as(u32, 128);
pub const FILE_DEVICE_USB_SCAN = @as(u32, 32768);
pub const IOCTL_INDEX = @as(u32, 2048);
pub const IOCTL_GET_VERSION = @as(u32, 2147491840);
pub const IOCTL_CANCEL_IO = @as(u32, 2147491844);
pub const IOCTL_WAIT_ON_DEVICE_EVENT = @as(u32, 2147491848);
pub const IOCTL_READ_REGISTERS = @as(u32, 2147491852);
pub const IOCTL_WRITE_REGISTERS = @as(u32, 2147491856);
pub const IOCTL_GET_CHANNEL_ALIGN_RQST = @as(u32, 2147491860);
pub const IOCTL_GET_DEVICE_DESCRIPTOR = @as(u32, 2147491864);
pub const IOCTL_RESET_PIPE = @as(u32, 2147491868);
pub const IOCTL_GET_USB_DESCRIPTOR = @as(u32, 2147491872);
pub const IOCTL_SEND_USB_REQUEST = @as(u32, 2147491876);
pub const IOCTL_GET_PIPE_CONFIGURATION = @as(u32, 2147491880);
pub const IOCTL_SET_TIMEOUT = @as(u32, 2147491884);
pub const IOCTL_ABORT_PIPE = @as(u32, 2147491844);

//--------------------------------------------------------------------------------
// Section: Types (150)
//--------------------------------------------------------------------------------
pub const USB_DEVICE_SPEED = enum(i32) {
    LowSpeed = 0,
    FullSpeed = 1,
    HighSpeed = 2,
    SuperSpeed = 3,
};
pub const UsbLowSpeed = USB_DEVICE_SPEED.LowSpeed;
pub const UsbFullSpeed = USB_DEVICE_SPEED.FullSpeed;
pub const UsbHighSpeed = USB_DEVICE_SPEED.HighSpeed;
pub const UsbSuperSpeed = USB_DEVICE_SPEED.SuperSpeed;

pub const USB_DEVICE_TYPE = enum(i32) {
    @"11Device" = 0,
    @"20Device" = 1,
};
pub const Usb11Device = USB_DEVICE_TYPE.@"11Device";
pub const Usb20Device = USB_DEVICE_TYPE.@"20Device";

pub const BM_REQUEST_TYPE = extern union {
    pub const _BM = extern struct {
        _bitfield: u8,
    };
    s: _BM,
    B: u8,
};

pub const USB_DEFAULT_PIPE_SETUP_PACKET = extern struct {
    pub const _wIndex = extern union {
        Anonymous: extern struct {
            LowByte: u8,
            HiByte: u8,
        } align(1),
        W: u16 align(1),
    };
    pub const _wValue = extern union {
        Anonymous: extern struct {
            LowByte: u8,
            HiByte: u8,
        } align(1),
        W: u16 align(1),
    };
    bmRequestType: BM_REQUEST_TYPE align(1),
    bRequest: u8 align(1),
    wValue: _wValue align(1),
    wIndex: _wIndex align(1),
    wLength: u16 align(1),
};

pub const USB_DEVICE_STATUS = extern union {
    AsUshort16: u16 align(1),
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
};

pub const USB_INTERFACE_STATUS = extern union {
    AsUshort16: u16 align(1),
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
};

pub const USB_ENDPOINT_STATUS = extern union {
    AsUshort16: u16 align(1),
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
};

pub const USB_COMMON_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
};

pub const USB_DEVICE_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bcdUSB: u16 align(1),
    bDeviceClass: u8 align(1),
    bDeviceSubClass: u8 align(1),
    bDeviceProtocol: u8 align(1),
    bMaxPacketSize0: u8 align(1),
    idVendor: u16 align(1),
    idProduct: u16 align(1),
    bcdDevice: u16 align(1),
    iManufacturer: u8 align(1),
    iProduct: u8 align(1),
    iSerialNumber: u8 align(1),
    bNumConfigurations: u8 align(1),
};

pub const USB_DEVICE_QUALIFIER_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bcdUSB: u16 align(1),
    bDeviceClass: u8 align(1),
    bDeviceSubClass: u8 align(1),
    bDeviceProtocol: u8 align(1),
    bMaxPacketSize0: u8 align(1),
    bNumConfigurations: u8 align(1),
    bReserved: u8 align(1),
};

pub const USB_BOS_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    wTotalLength: u16 align(1),
    bNumDeviceCaps: u8 align(1),
};

pub const USB_DEVICE_CAPABILITY_USB20_EXTENSION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bmAttributes: extern union {
        AsUlong: u32 align(1),
        Anonymous: extern struct {
            _bitfield: u32 align(1),
        } align(1),
    },
};

pub const USB_DEVICE_CAPABILITY_POWER_DELIVERY_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bDevCapabilityType: u8 align(1),
    bReserved: u8 align(1),
    bmAttributes: extern union {
        AsUlong: u32 align(1),
        Anonymous: extern struct {
            _bitfield: u32 align(1),
        } align(1),
    } align(1),
    bmProviderPorts: u16 align(1),
    bmConsumerPorts: u16 align(1),
    bcdBCVersion: u16 align(1),
    bcdPDVersion: u16 align(1),
    bcdUSBTypeCVersion: u16 align(1),
};

pub const USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bDevCapabilityType: u8 align(1),
    bReserved: u8 align(1),
    bmCapabilities: extern union {
        AsUshort: u16 align(1),
        Anonymous: extern struct {
            _bitfield: u16 align(1),
        } align(1),
    } align(1),
    wMinVoltage: u16 align(1),
    wMaxVoltage: u16 align(1),
    wReserved: u16 align(1),
    dwMaxOperatingPower: u32 align(1),
    dwMaxPeakPower: u32 align(1),
    dwMaxPeakPowerTime: u32 align(1),
};

pub const USB_DEVICE_CAPABILITY_SUPERSPEED_USB_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bDevCapabilityType: u8 align(1),
    bmAttributes: u8 align(1),
    wSpeedsSupported: u16 align(1),
    bFunctionalitySupport: u8 align(1),
    bU1DevExitLat: u8 align(1),
    wU2DevExitLat: u16 align(1),
};

pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED = extern union {
    AsUlong32: u32 align(1),
    Anonymous: extern struct {
        _bitfield: u32 align(1),
    } align(1),
};

pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_USB_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bDevCapabilityType: u8 align(1),
    bReserved: u8 align(1),
    bmAttributes: extern union {
        AsUlong: u32 align(1),
        Anonymous: extern struct {
            _bitfield: u32 align(1),
        } align(1),
    } align(1),
    wFunctionalitySupport: extern union {
        AsUshort: u16 align(1),
        Anonymous: extern struct {
            _bitfield: u16 align(1),
        } align(1),
    } align(1),
    wReserved: u16 align(1),
    bmSublinkSpeedAttr: [1]USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED align(1),
};

pub const USB_DEVICE_CAPABILITY_CONTAINER_ID_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    ContainerID: [16]u8,
};

pub const USB_DEVICE_CAPABILITY_PLATFORM_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bDevCapabilityType: u8 align(1),
    bReserved: u8 align(1),
    PlatformCapabilityUuid: Guid align(1),
    CapabililityData: [1]u8 align(1),
};

pub const USB_DEVICE_CAPABILITY_BILLBOARD_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bDevCapabilityType: u8 align(1),
    iAddtionalInfoURL: u8 align(1),
    bNumberOfAlternateModes: u8 align(1),
    bPreferredAlternateMode: u8 align(1),
    VconnPower: extern union {
        AsUshort: u16 align(1),
        Anonymous: extern struct {
            _bitfield: u16 align(1),
        } align(1),
    } align(1),
    bmConfigured: [32]u8 align(1),
    bReserved: u32 align(1),
    AlternateMode: [1]extern struct {
        wSVID: u16 align(1),
        bAlternateMode: u8 align(1),
        iAlternateModeSetting: u8 align(1),
    } align(1),
};

pub const USB_DEVICE_CAPABILITY_FIRMWARE_STATUS_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bcdDescriptorVersion: u8,
    bmAttributes: extern union {
        AsUlong: u32 align(1),
        Anonymous: extern struct {
            _bitfield: u32 align(1),
        } align(1),
    },
};

pub const USB_DEVICE_CAPABILITY_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
};

pub const USB_CONFIGURATION_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    wTotalLength: u16 align(1),
    bNumInterfaces: u8 align(1),
    bConfigurationValue: u8 align(1),
    iConfiguration: u8 align(1),
    bmAttributes: u8 align(1),
    MaxPower: u8 align(1),
};

pub const USB_INTERFACE_ASSOCIATION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bFirstInterface: u8,
    bInterfaceCount: u8,
    bFunctionClass: u8,
    bFunctionSubClass: u8,
    bFunctionProtocol: u8,
    iFunction: u8,
};

pub const USB_INTERFACE_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bInterfaceNumber: u8,
    bAlternateSetting: u8,
    bNumEndpoints: u8,
    bInterfaceClass: u8,
    bInterfaceSubClass: u8,
    bInterfaceProtocol: u8,
    iInterface: u8,
};

pub const USB_ENDPOINT_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bEndpointAddress: u8 align(1),
    bmAttributes: u8 align(1),
    wMaxPacketSize: u16 align(1),
    bInterval: u8 align(1),
};

pub const USB_HIGH_SPEED_MAXPACKET = extern union {
    pub const _MP = extern struct {
        _bitfield: u16 align(1),
    };
    us: u16 align(1),
};

pub const USB_STRING_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bString: [1]u16 align(1),
};

pub const USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bMaxBurst: u8 align(1),
    bmAttributes: extern union {
        AsUchar: u8,
        Bulk: extern struct {
            _bitfield: u8,
        },
        Isochronous: extern struct {
            _bitfield: u8,
        },
    } align(1),
    wBytesPerInterval: u16 align(1),
};

pub const USB_SUPERSPEEDPLUS_ISOCH_ENDPOINT_COMPANION_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    wReserved: u16 align(1),
    dwBytesPerInterval: u32 align(1),
};

pub const USB_HUB_DESCRIPTOR = extern struct {
    bDescriptorLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bNumberOfPorts: u8 align(1),
    wHubCharacteristics: u16 align(1),
    bPowerOnToPowerGood: u8 align(1),
    bHubControlCurrent: u8 align(1),
    bRemoveAndPowerMask: [64]u8 align(1),
};

pub const USB_30_HUB_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bNumberOfPorts: u8 align(1),
    wHubCharacteristics: u16 align(1),
    bPowerOnToPowerGood: u8 align(1),
    bHubControlCurrent: u8 align(1),
    bHubHdrDecLat: u8 align(1),
    wHubDelay: u16 align(1),
    DeviceRemovable: u16 align(1),
};

pub const USB_HUB_STATUS = extern union {
    AsUshort16: u16 align(1),
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
};

pub const USB_HUB_CHANGE = extern union {
    AsUshort16: u16 align(1),
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
};

pub const USB_HUB_STATUS_AND_CHANGE = extern union {
    AsUlong32: u32 align(1),
    Anonymous: extern struct {
        HubStatus: USB_HUB_STATUS,
        HubChange: USB_HUB_CHANGE,
    } align(1),
};

pub const USB_20_PORT_STATUS = extern union {
    AsUshort16: u16 align(1),
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
};

pub const USB_20_PORT_CHANGE = extern union {
    AsUshort16: u16 align(1),
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
};

pub const USB_30_PORT_STATUS = extern union {
    AsUshort16: u16 align(1),
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
};

pub const USB_30_PORT_CHANGE = extern union {
    AsUshort16: u16 align(1),
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
};

pub const USB_PORT_STATUS = extern union {
    AsUshort16: u16 align(1),
    Usb20PortStatus: USB_20_PORT_STATUS align(1),
    Usb30PortStatus: USB_30_PORT_STATUS align(1),
};

pub const USB_PORT_CHANGE = extern union {
    AsUshort16: u16 align(1),
    Usb20PortChange: USB_20_PORT_CHANGE align(1),
    Usb30PortChange: USB_30_PORT_CHANGE align(1),
};

pub const USB_PORT_EXT_STATUS = extern union {
    AsUlong32: u32 align(1),
    Anonymous: extern struct {
        _bitfield: u32 align(1),
    } align(1),
};

pub const USB_PORT_STATUS_AND_CHANGE = extern union {
    AsUlong32: u32 align(1),
    Anonymous: extern struct {
        PortStatus: USB_PORT_STATUS,
        PortChange: USB_PORT_CHANGE,
    } align(1),
};

pub const USB_PORT_EXT_STATUS_AND_CHANGE = extern union {
    AsUlong64: u64 align(1),
    Anonymous: extern struct {
        PortStatusChange: USB_PORT_STATUS_AND_CHANGE,
        PortExtStatus: USB_PORT_EXT_STATUS,
    } align(1),
};

pub const USB_HUB_30_PORT_REMOTE_WAKE_MASK = extern union {
    AsUchar8: u8,
    Anonymous: extern struct {
        _bitfield: u8,
    },
};

pub const USB_FUNCTION_SUSPEND_OPTIONS = extern union {
    AsUchar: u8,
    Anonymous: extern struct {
        _bitfield: u8,
    },
};

pub const USB_CONFIGURATION_POWER_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    SelfPowerConsumedD0: [3]u8 align(1),
    bPowerSummaryId: u8 align(1),
    bBusPowerSavingD1: u8 align(1),
    bSelfPowerSavingD1: u8 align(1),
    bBusPowerSavingD2: u8 align(1),
    bSelfPowerSavingD2: u8 align(1),
    bBusPowerSavingD3: u8 align(1),
    bSelfPowerSavingD3: u8 align(1),
    TransitionTimeFromD1: u16 align(1),
    TransitionTimeFromD2: u16 align(1),
    TransitionTimeFromD3: u16 align(1),
};

pub const USB_INTERFACE_POWER_DESCRIPTOR = extern struct {
    bLength: u8 align(1),
    bDescriptorType: u8 align(1),
    bmCapabilitiesFlags: u8 align(1),
    bBusPowerSavingD1: u8 align(1),
    bSelfPowerSavingD1: u8 align(1),
    bBusPowerSavingD2: u8 align(1),
    bSelfPowerSavingD2: u8 align(1),
    bBusPowerSavingD3: u8 align(1),
    bSelfPowerSavingD3: u8 align(1),
    TransitionTimeFromD1: u16 align(1),
    TransitionTimeFromD2: u16 align(1),
    TransitionTimeFromD3: u16 align(1),
};

pub const USB_CONTROLLER_FLAVOR = enum(i32) {
    USB_HcGeneric = 0,
    OHCI_Generic = 100,
    OHCI_Hydra = 101,
    OHCI_NEC = 102,
    UHCI_Generic = 200,
    UHCI_Piix4 = 201,
    UHCI_Piix3 = 202,
    UHCI_Ich2 = 203,
    UHCI_Reserved204 = 204,
    UHCI_Ich1 = 205,
    UHCI_Ich3m = 206,
    UHCI_Ich4 = 207,
    UHCI_Ich5 = 208,
    UHCI_Ich6 = 209,
    UHCI_Intel = 249,
    UHCI_VIA = 250,
    UHCI_VIA_x01 = 251,
    UHCI_VIA_x02 = 252,
    UHCI_VIA_x03 = 253,
    UHCI_VIA_x04 = 254,
    UHCI_VIA_x0E_FIFO = 264,
    EHCI_Generic = 1000,
    EHCI_NEC = 2000,
    EHCI_Lucent = 3000,
    EHCI_NVIDIA_Tegra2 = 4000,
    EHCI_NVIDIA_Tegra3 = 4001,
    EHCI_Intel_Medfield = 5001,
};
pub const USB_HcGeneric = USB_CONTROLLER_FLAVOR.USB_HcGeneric;
pub const OHCI_Generic = USB_CONTROLLER_FLAVOR.OHCI_Generic;
pub const OHCI_Hydra = USB_CONTROLLER_FLAVOR.OHCI_Hydra;
pub const OHCI_NEC = USB_CONTROLLER_FLAVOR.OHCI_NEC;
pub const UHCI_Generic = USB_CONTROLLER_FLAVOR.UHCI_Generic;
pub const UHCI_Piix4 = USB_CONTROLLER_FLAVOR.UHCI_Piix4;
pub const UHCI_Piix3 = USB_CONTROLLER_FLAVOR.UHCI_Piix3;
pub const UHCI_Ich2 = USB_CONTROLLER_FLAVOR.UHCI_Ich2;
pub const UHCI_Reserved204 = USB_CONTROLLER_FLAVOR.UHCI_Reserved204;
pub const UHCI_Ich1 = USB_CONTROLLER_FLAVOR.UHCI_Ich1;
pub const UHCI_Ich3m = USB_CONTROLLER_FLAVOR.UHCI_Ich3m;
pub const UHCI_Ich4 = USB_CONTROLLER_FLAVOR.UHCI_Ich4;
pub const UHCI_Ich5 = USB_CONTROLLER_FLAVOR.UHCI_Ich5;
pub const UHCI_Ich6 = USB_CONTROLLER_FLAVOR.UHCI_Ich6;
pub const UHCI_Intel = USB_CONTROLLER_FLAVOR.UHCI_Intel;
pub const UHCI_VIA = USB_CONTROLLER_FLAVOR.UHCI_VIA;
pub const UHCI_VIA_x01 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x01;
pub const UHCI_VIA_x02 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x02;
pub const UHCI_VIA_x03 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x03;
pub const UHCI_VIA_x04 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x04;
pub const UHCI_VIA_x0E_FIFO = USB_CONTROLLER_FLAVOR.UHCI_VIA_x0E_FIFO;
pub const EHCI_Generic = USB_CONTROLLER_FLAVOR.EHCI_Generic;
pub const EHCI_NEC = USB_CONTROLLER_FLAVOR.EHCI_NEC;
pub const EHCI_Lucent = USB_CONTROLLER_FLAVOR.EHCI_Lucent;
pub const EHCI_NVIDIA_Tegra2 = USB_CONTROLLER_FLAVOR.EHCI_NVIDIA_Tegra2;
pub const EHCI_NVIDIA_Tegra3 = USB_CONTROLLER_FLAVOR.EHCI_NVIDIA_Tegra3;
pub const EHCI_Intel_Medfield = USB_CONTROLLER_FLAVOR.EHCI_Intel_Medfield;

pub const USBD_VERSION_INFORMATION = extern struct {
    USBDI_Version: u32,
    Supported_USB_Version: u32,
};

pub const USBD_PIPE_TYPE = enum(i32) {
    Control = 0,
    Isochronous = 1,
    Bulk = 2,
    Interrupt = 3,
};
pub const UsbdPipeTypeControl = USBD_PIPE_TYPE.Control;
pub const UsbdPipeTypeIsochronous = USBD_PIPE_TYPE.Isochronous;
pub const UsbdPipeTypeBulk = USBD_PIPE_TYPE.Bulk;
pub const UsbdPipeTypeInterrupt = USBD_PIPE_TYPE.Interrupt;

pub const USBD_DEVICE_INFORMATION = extern struct {
    OffsetNext: u32,
    UsbdDeviceHandle: ?*anyopaque,
    DeviceDescriptor: USB_DEVICE_DESCRIPTOR,
};

pub const USBD_PIPE_INFORMATION = extern struct {
    MaximumPacketSize: u16,
    EndpointAddress: u8,
    Interval: u8,
    PipeType: USBD_PIPE_TYPE,
    PipeHandle: ?*anyopaque,
    MaximumTransferSize: u32,
    PipeFlags: u32,
};

pub const USBD_ENDPOINT_OFFLOAD_MODE = enum(i32) {
    ModeNotSupported = 0,
    SoftwareAssisted = 1,
    HardwareAssisted = 2,
};
pub const UsbdEndpointOffloadModeNotSupported = USBD_ENDPOINT_OFFLOAD_MODE.ModeNotSupported;
pub const UsbdEndpointOffloadSoftwareAssisted = USBD_ENDPOINT_OFFLOAD_MODE.SoftwareAssisted;
pub const UsbdEndpointOffloadHardwareAssisted = USBD_ENDPOINT_OFFLOAD_MODE.HardwareAssisted;

pub const USBD_ENDPOINT_OFFLOAD_INFORMATION = extern struct {
    Size: u32 align(1),
    EndpointAddress: u16 align(1),
    ResourceId: u32 align(1),
    Mode: USBD_ENDPOINT_OFFLOAD_MODE align(1),
    _bitfield1: u32 align(1),
    _bitfield2: u32 align(1),
    TransferSegmentLA: LARGE_INTEGER align(1),
    TransferSegmentVA: ?*anyopaque align(1),
    TransferRingSize: usize align(1),
    TransferRingInitialCycleBit: u32 align(1),
    MessageNumber: u32 align(1),
    EventRingSegmentLA: LARGE_INTEGER align(1),
    EventRingSegmentVA: ?*anyopaque align(1),
    EventRingSize: usize align(1),
    EventRingInitialCycleBit: u32 align(1),
};

pub const USBD_INTERFACE_INFORMATION = extern struct {
    Length: u16,
    InterfaceNumber: u8,
    AlternateSetting: u8,
    Class: u8,
    SubClass: u8,
    Protocol: u8,
    Reserved: u8,
    InterfaceHandle: ?*anyopaque,
    NumberOfPipes: u32,
    Pipes: [1]USBD_PIPE_INFORMATION,
};

pub const _URB_HCD_AREA = extern struct {
    Reserved8: [8]?*anyopaque,
};

pub const _URB_HEADER = extern struct {
    Length: u16,
    Function: u16,
    Status: i32,
    UsbdDeviceHandle: ?*anyopaque,
    UsbdFlags: u32,
};

pub const _URB_SELECT_INTERFACE = extern struct {
    Hdr: _URB_HEADER,
    ConfigurationHandle: ?*anyopaque,
    Interface: USBD_INTERFACE_INFORMATION,
};

pub const _URB_SELECT_CONFIGURATION = extern struct {
    Hdr: _URB_HEADER,
    ConfigurationDescriptor: ?*USB_CONFIGURATION_DESCRIPTOR,
    ConfigurationHandle: ?*anyopaque,
    Interface: USBD_INTERFACE_INFORMATION,
};

pub const _URB_PIPE_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: ?*anyopaque,
    Reserved: u32,
};

pub const _URB_FRAME_LENGTH_CONTROL = extern struct {
    Hdr: _URB_HEADER,
};

pub const _URB_GET_FRAME_LENGTH = extern struct {
    Hdr: _URB_HEADER,
    FrameLength: u32,
    FrameNumber: u32,
};

pub const _URB_SET_FRAME_LENGTH = extern struct {
    Hdr: _URB_HEADER,
    FrameLengthDelta: i32,
};

pub const _URB_GET_CURRENT_FRAME_NUMBER = extern struct {
    Hdr: _URB_HEADER,
    FrameNumber: u32,
};

pub const _URB_CONTROL_DESCRIPTOR_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: ?*anyopaque,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
    Reserved1: u16,
    Index: u8,
    DescriptorType: u8,
    LanguageId: u16,
    Reserved2: u16,
};

pub const _URB_CONTROL_GET_STATUS_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: ?*anyopaque,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
    Reserved1: [4]u8,
    Index: u16,
    Reserved2: u16,
};

pub const _URB_CONTROL_FEATURE_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: ?*anyopaque,
    Reserved2: u32,
    Reserved3: u32,
    Reserved4: ?*anyopaque,
    Reserved5: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
    Reserved0: u16,
    FeatureSelector: u16,
    Index: u16,
    Reserved1: u16,
};

pub const _URB_CONTROL_VENDOR_OR_CLASS_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: ?*anyopaque,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
    RequestTypeReservedBits: u8,
    Request: u8,
    Value: u16,
    Index: u16,
    Reserved1: u16,
};

pub const _URB_CONTROL_GET_INTERFACE_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: ?*anyopaque,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
    Reserved1: [4]u8,
    Interface: u16,
    Reserved2: u16,
};

pub const _URB_CONTROL_GET_CONFIGURATION_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: ?*anyopaque,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
    Reserved1: [8]u8,
};

pub const OS_STRING = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    MicrosoftString: [7]u16,
    bVendorCode: u8,
    Anonymous: extern union {
        bPad: u8,
        bFlags: u8,
    },
};

pub const _URB_OS_FEATURE_DESCRIPTOR_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: ?*anyopaque,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
    _bitfield: u8,
    Reserved2: u8,
    InterfaceNumber: u8,
    MS_PageIndex: u8,
    MS_FeatureDescriptorIndex: u16,
    Reserved3: u16,
};

pub const _URB_CONTROL_TRANSFER = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: ?*anyopaque,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
    SetupPacket: [8]u8,
};

pub const _URB_CONTROL_TRANSFER_EX = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: ?*anyopaque,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    Timeout: u32,
    hca: _URB_HCD_AREA,
    SetupPacket: [8]u8,
};

pub const _URB_BULK_OR_INTERRUPT_TRANSFER = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: ?*anyopaque,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
};

pub const USBD_ISO_PACKET_DESCRIPTOR = extern struct {
    Offset: u32,
    Length: u32,
    Status: i32,
};

pub const _URB_ISOCH_TRANSFER = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: ?*anyopaque,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: ?*anyopaque,
    TransferBufferMDL: ?*anyopaque,
    UrbLink: ?*URB,
    hca: _URB_HCD_AREA,
    StartFrame: u32,
    NumberOfPackets: u32,
    ErrorCount: u32,
    IsoPacket: [1]USBD_ISO_PACKET_DESCRIPTOR,
};

pub const USBD_STREAM_INFORMATION = extern struct {
    PipeHandle: ?*anyopaque,
    StreamID: u32,
    MaximumTransferSize: u32,
    PipeFlags: u32,
};

pub const _URB_OPEN_STATIC_STREAMS = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: ?*anyopaque,
    NumberOfStreams: u32,
    StreamInfoVersion: u16,
    StreamInfoSize: u16,
    Streams: ?*USBD_STREAM_INFORMATION,
};

pub const _URB_GET_ISOCH_PIPE_TRANSFER_PATH_DELAYS = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: ?*anyopaque,
    MaximumSendPathDelayInMilliSeconds: u32,
    MaximumCompletionPathDelayInMilliSeconds: u32,
};

pub const URB = extern struct {
    Anonymous: extern union {
        UrbHeader: _URB_HEADER,
        UrbSelectInterface: _URB_SELECT_INTERFACE,
        UrbSelectConfiguration: _URB_SELECT_CONFIGURATION,
        UrbPipeRequest: _URB_PIPE_REQUEST,
        UrbFrameLengthControl: _URB_FRAME_LENGTH_CONTROL,
        UrbGetFrameLength: _URB_GET_FRAME_LENGTH,
        UrbSetFrameLength: _URB_SET_FRAME_LENGTH,
        UrbGetCurrentFrameNumber: _URB_GET_CURRENT_FRAME_NUMBER,
        UrbControlTransfer: _URB_CONTROL_TRANSFER,
        UrbControlTransferEx: _URB_CONTROL_TRANSFER_EX,
        UrbBulkOrInterruptTransfer: _URB_BULK_OR_INTERRUPT_TRANSFER,
        UrbIsochronousTransfer: _URB_ISOCH_TRANSFER,
        UrbControlDescriptorRequest: _URB_CONTROL_DESCRIPTOR_REQUEST,
        UrbControlGetStatusRequest: _URB_CONTROL_GET_STATUS_REQUEST,
        UrbControlFeatureRequest: _URB_CONTROL_FEATURE_REQUEST,
        UrbControlVendorClassRequest: _URB_CONTROL_VENDOR_OR_CLASS_REQUEST,
        UrbControlGetInterfaceRequest: _URB_CONTROL_GET_INTERFACE_REQUEST,
        UrbControlGetConfigurationRequest: _URB_CONTROL_GET_CONFIGURATION_REQUEST,
        UrbOSFeatureDescriptorRequest: _URB_OS_FEATURE_DESCRIPTOR_REQUEST,
        UrbOpenStaticStreams: _URB_OPEN_STATIC_STREAMS,
        UrbGetIsochPipeTransferPathDelays: _URB_GET_ISOCH_PIPE_TRANSFER_PATH_DELAYS,
    },
};

pub const USB_IDLE_CALLBACK = *const fn(
    Context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const USB_IDLE_CALLBACK_INFO = extern struct {
    IdleCallback: ?USB_IDLE_CALLBACK,
    IdleContext: ?*anyopaque,
};

pub const USB_USER_ERROR_CODE = enum(i32) {
    Success = 0,
    NotSupported = 1,
    InvalidRequestCode = 2,
    FeatureDisabled = 3,
    InvalidHeaderParameter = 4,
    InvalidParameter = 5,
    MiniportError = 6,
    BufferTooSmall = 7,
    ErrorNotMapped = 8,
    DeviceNotStarted = 9,
    NoDeviceConnected = 10,
};
pub const UsbUserSuccess = USB_USER_ERROR_CODE.Success;
pub const UsbUserNotSupported = USB_USER_ERROR_CODE.NotSupported;
pub const UsbUserInvalidRequestCode = USB_USER_ERROR_CODE.InvalidRequestCode;
pub const UsbUserFeatureDisabled = USB_USER_ERROR_CODE.FeatureDisabled;
pub const UsbUserInvalidHeaderParameter = USB_USER_ERROR_CODE.InvalidHeaderParameter;
pub const UsbUserInvalidParameter = USB_USER_ERROR_CODE.InvalidParameter;
pub const UsbUserMiniportError = USB_USER_ERROR_CODE.MiniportError;
pub const UsbUserBufferTooSmall = USB_USER_ERROR_CODE.BufferTooSmall;
pub const UsbUserErrorNotMapped = USB_USER_ERROR_CODE.ErrorNotMapped;
pub const UsbUserDeviceNotStarted = USB_USER_ERROR_CODE.DeviceNotStarted;
pub const UsbUserNoDeviceConnected = USB_USER_ERROR_CODE.NoDeviceConnected;

pub const USBUSER_REQUEST_HEADER = extern struct {
    UsbUserRequest: u32 align(1),
    UsbUserStatusCode: USB_USER_ERROR_CODE align(1),
    RequestBufferLength: u32 align(1),
    ActualBufferLength: u32 align(1),
};

pub const PACKET_PARAMETERS = extern struct {
    DeviceAddress: u8 align(1),
    EndpointAddress: u8 align(1),
    MaximumPacketSize: u16 align(1),
    Timeout: u32 align(1),
    Flags: u32 align(1),
    DataLength: u32 align(1),
    HubDeviceAddress: u16 align(1),
    PortTTNumber: u16 align(1),
    ErrorCount: u8 align(1),
    Pad: [3]u8 align(1),
    UsbdStatusCode: i32 align(1),
    Data: [4]u8 align(1),
};

pub const USBUSER_SEND_ONE_PACKET = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    PacketParameters: PACKET_PARAMETERS,
};

pub const RAW_RESET_PORT_PARAMETERS = extern struct {
    PortNumber: u16 align(1),
    PortStatus: u16 align(1),
};

pub const USBUSER_RAW_RESET_ROOT_PORT = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: RAW_RESET_PORT_PARAMETERS,
};

pub const RAW_ROOTPORT_FEATURE = extern struct {
    PortNumber: u16 align(1),
    PortFeature: u16 align(1),
    PortStatus: u16 align(1),
};

pub const USBUSER_ROOTPORT_FEATURE_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: RAW_ROOTPORT_FEATURE,
};

pub const RAW_ROOTPORT_PARAMETERS = extern struct {
    PortNumber: u16 align(1),
    PortStatus: u16 align(1),
};

pub const USBUSER_ROOTPORT_PARAMETERS = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: RAW_ROOTPORT_PARAMETERS,
};

pub const USB_CONTROLLER_INFO_0 = extern struct {
    PciVendorId: u32 align(1),
    PciDeviceId: u32 align(1),
    PciRevision: u32 align(1),
    NumberOfRootPorts: u32 align(1),
    ControllerFlavor: USB_CONTROLLER_FLAVOR align(1),
    HcFeatureFlags: u32 align(1),
};

pub const USBUSER_CONTROLLER_INFO_0 = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Info0: USB_CONTROLLER_INFO_0,
};

pub const USB_UNICODE_NAME = extern struct {
    Length: u32 align(1),
    String: [1]u16 align(1),
};

pub const USBUSER_CONTROLLER_UNICODE_NAME = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    UnicodeName: USB_UNICODE_NAME,
};

pub const USB_PASS_THRU_PARAMETERS = extern struct {
    FunctionGUID: Guid align(1),
    ParameterLength: u32 align(1),
    Parameters: [4]u8 align(1),
};

pub const USBUSER_PASS_THRU_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    PassThru: USB_PASS_THRU_PARAMETERS,
};

pub const WDMUSB_POWER_STATE = enum(i32) {
    NotMapped = 0,
    SystemUnspecified = 100,
    SystemWorking = 101,
    SystemSleeping1 = 102,
    SystemSleeping2 = 103,
    SystemSleeping3 = 104,
    SystemHibernate = 105,
    SystemShutdown = 106,
    DeviceUnspecified = 200,
    DeviceD0 = 201,
    DeviceD1 = 202,
    DeviceD2 = 203,
    DeviceD3 = 204,
};
pub const WdmUsbPowerNotMapped = WDMUSB_POWER_STATE.NotMapped;
pub const WdmUsbPowerSystemUnspecified = WDMUSB_POWER_STATE.SystemUnspecified;
pub const WdmUsbPowerSystemWorking = WDMUSB_POWER_STATE.SystemWorking;
pub const WdmUsbPowerSystemSleeping1 = WDMUSB_POWER_STATE.SystemSleeping1;
pub const WdmUsbPowerSystemSleeping2 = WDMUSB_POWER_STATE.SystemSleeping2;
pub const WdmUsbPowerSystemSleeping3 = WDMUSB_POWER_STATE.SystemSleeping3;
pub const WdmUsbPowerSystemHibernate = WDMUSB_POWER_STATE.SystemHibernate;
pub const WdmUsbPowerSystemShutdown = WDMUSB_POWER_STATE.SystemShutdown;
pub const WdmUsbPowerDeviceUnspecified = WDMUSB_POWER_STATE.DeviceUnspecified;
pub const WdmUsbPowerDeviceD0 = WDMUSB_POWER_STATE.DeviceD0;
pub const WdmUsbPowerDeviceD1 = WDMUSB_POWER_STATE.DeviceD1;
pub const WdmUsbPowerDeviceD2 = WDMUSB_POWER_STATE.DeviceD2;
pub const WdmUsbPowerDeviceD3 = WDMUSB_POWER_STATE.DeviceD3;

pub const USB_POWER_INFO = extern struct {
    SystemState: WDMUSB_POWER_STATE align(1),
    HcDevicePowerState: WDMUSB_POWER_STATE align(1),
    HcDeviceWake: WDMUSB_POWER_STATE align(1),
    HcSystemWake: WDMUSB_POWER_STATE align(1),
    RhDevicePowerState: WDMUSB_POWER_STATE align(1),
    RhDeviceWake: WDMUSB_POWER_STATE align(1),
    RhSystemWake: WDMUSB_POWER_STATE align(1),
    LastSystemSleepState: WDMUSB_POWER_STATE align(1),
    CanWakeup: BOOLEAN align(1),
    IsPowered: BOOLEAN align(1),
};

pub const USBUSER_POWER_INFO_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    PowerInformation: USB_POWER_INFO,
};

pub const USB_OPEN_RAW_DEVICE_PARAMETERS = extern struct {
    PortStatus: u16 align(1),
    MaxPacketEp0: u16 align(1),
};

pub const USBUSER_OPEN_RAW_DEVICE = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_OPEN_RAW_DEVICE_PARAMETERS,
};

pub const USB_CLOSE_RAW_DEVICE_PARAMETERS = extern struct {
    xxx: u32 align(1),
};

pub const USBUSER_CLOSE_RAW_DEVICE = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_CLOSE_RAW_DEVICE_PARAMETERS,
};

pub const USB_SEND_RAW_COMMAND_PARAMETERS = extern struct {
    Usb_bmRequest: u8 align(1),
    Usb_bRequest: u8 align(1),
    Usb_wVlaue: u16 align(1),
    Usb_wIndex: u16 align(1),
    Usb_wLength: u16 align(1),
    DeviceAddress: u16 align(1),
    MaximumPacketSize: u16 align(1),
    Timeout: u32 align(1),
    DataLength: u32 align(1),
    UsbdStatusCode: i32 align(1),
    Data: [4]u8 align(1),
};

pub const USBUSER_SEND_RAW_COMMAND = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_SEND_RAW_COMMAND_PARAMETERS,
};

pub const USB_BANDWIDTH_INFO = extern struct {
    DeviceCount: u32 align(1),
    TotalBusBandwidth: u32 align(1),
    Total32secBandwidth: u32 align(1),
    AllocedBulkAndControl: u32 align(1),
    AllocedIso: u32 align(1),
    AllocedInterrupt_1ms: u32 align(1),
    AllocedInterrupt_2ms: u32 align(1),
    AllocedInterrupt_4ms: u32 align(1),
    AllocedInterrupt_8ms: u32 align(1),
    AllocedInterrupt_16ms: u32 align(1),
    AllocedInterrupt_32ms: u32 align(1),
};

pub const USBUSER_BANDWIDTH_INFO_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    BandwidthInformation: USB_BANDWIDTH_INFO,
};

pub const USB_BUS_STATISTICS_0 = extern struct {
    DeviceCount: u32 align(1),
    CurrentSystemTime: LARGE_INTEGER align(1),
    CurrentUsbFrame: u32 align(1),
    BulkBytes: u32 align(1),
    IsoBytes: u32 align(1),
    InterruptBytes: u32 align(1),
    ControlDataBytes: u32 align(1),
    PciInterruptCount: u32 align(1),
    HardResetCount: u32 align(1),
    WorkerSignalCount: u32 align(1),
    CommonBufferBytes: u32 align(1),
    WorkerIdleTimeMs: u32 align(1),
    RootHubEnabled: BOOLEAN align(1),
    RootHubDevicePowerState: u8 align(1),
    Unused: u8 align(1),
    NameIndex: u8 align(1),
};

pub const USBUSER_BUS_STATISTICS_0_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    BusStatistics0: USB_BUS_STATISTICS_0,
};

pub const USB_DRIVER_VERSION_PARAMETERS = extern struct {
    DriverTrackingCode: u32 align(1),
    USBDI_Version: u32 align(1),
    USBUSER_Version: u32 align(1),
    CheckedPortDriver: BOOLEAN align(1),
    CheckedMiniportDriver: BOOLEAN align(1),
    USB_Version: u16 align(1),
};

pub const USBUSER_GET_DRIVER_VERSION = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_DRIVER_VERSION_PARAMETERS,
};

pub const USB_USB2HW_VERSION_PARAMETERS = extern struct {
    Usb2HwRevision: u8,
};

pub const USBUSER_GET_USB2HW_VERSION = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_USB2HW_VERSION_PARAMETERS,
};

pub const USBUSER_REFRESH_HCT_REG = extern struct {
    Header: USBUSER_REQUEST_HEADER align(1),
    Flags: u32 align(1),
};

pub const WINUSB_PIPE_INFORMATION = extern struct {
    PipeType: USBD_PIPE_TYPE,
    PipeId: u8,
    MaximumPacketSize: u16,
    Interval: u8,
};

pub const WINUSB_PIPE_INFORMATION_EX = extern struct {
    PipeType: USBD_PIPE_TYPE,
    PipeId: u8,
    MaximumPacketSize: u16,
    Interval: u8,
    MaximumBytesPerInterval: u32,
};

pub const WINUSB_SETUP_PACKET = extern struct {
    RequestType: u8 align(1),
    Request: u8 align(1),
    Value: u16 align(1),
    Index: u16 align(1),
    Length: u16 align(1),
};

pub const USB_START_TRACKING_FOR_TIME_SYNC_INFORMATION = extern struct {
    TimeTrackingHandle: ?HANDLE align(1),
    IsStartupDelayTolerable: BOOLEAN align(1),
};

pub const USB_STOP_TRACKING_FOR_TIME_SYNC_INFORMATION = extern struct {
    TimeTrackingHandle: ?HANDLE align(1),
};

pub const USB_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC_INFORMATION = extern struct {
    TimeTrackingHandle: ?HANDLE align(1),
    InputFrameNumber: u32 align(1),
    InputMicroFrameNumber: u32 align(1),
    QueryPerformanceCounterAtInputFrameOrMicroFrame: LARGE_INTEGER align(1),
    QueryPerformanceCounterFrequency: LARGE_INTEGER align(1),
    PredictedAccuracyInMicroSeconds: u32 align(1),
    CurrentGenerationID: u32 align(1),
    CurrentQueryPerformanceCounter: LARGE_INTEGER align(1),
    CurrentHardwareFrameNumber: u32 align(1),
    CurrentHardwareMicroFrameNumber: u32 align(1),
    CurrentUSBFrameNumber: u32 align(1),
};

pub const USBFN_EVENT = enum(i32) {
    Minimum = 0,
    Attach = 1,
    Reset = 2,
    Detach = 3,
    Suspend = 4,
    Resume = 5,
    SetupPacket = 6,
    Configured = 7,
    UnConfigured = 8,
    PortType = 9,
    BusTearDown = 10,
    SetInterface = 11,
    Maximum = 12,
};
pub const UsbfnEventMinimum = USBFN_EVENT.Minimum;
pub const UsbfnEventAttach = USBFN_EVENT.Attach;
pub const UsbfnEventReset = USBFN_EVENT.Reset;
pub const UsbfnEventDetach = USBFN_EVENT.Detach;
pub const UsbfnEventSuspend = USBFN_EVENT.Suspend;
pub const UsbfnEventResume = USBFN_EVENT.Resume;
pub const UsbfnEventSetupPacket = USBFN_EVENT.SetupPacket;
pub const UsbfnEventConfigured = USBFN_EVENT.Configured;
pub const UsbfnEventUnConfigured = USBFN_EVENT.UnConfigured;
pub const UsbfnEventPortType = USBFN_EVENT.PortType;
pub const UsbfnEventBusTearDown = USBFN_EVENT.BusTearDown;
pub const UsbfnEventSetInterface = USBFN_EVENT.SetInterface;
pub const UsbfnEventMaximum = USBFN_EVENT.Maximum;

pub const USBFN_PORT_TYPE = enum(i32) {
    UnknownPort = 0,
    StandardDownstreamPort = 1,
    ChargingDownstreamPort = 2,
    DedicatedChargingPort = 3,
    InvalidDedicatedChargingPort = 4,
    ProprietaryDedicatedChargingPort = 5,
    PortTypeMaximum = 6,
};
pub const UsbfnUnknownPort = USBFN_PORT_TYPE.UnknownPort;
pub const UsbfnStandardDownstreamPort = USBFN_PORT_TYPE.StandardDownstreamPort;
pub const UsbfnChargingDownstreamPort = USBFN_PORT_TYPE.ChargingDownstreamPort;
pub const UsbfnDedicatedChargingPort = USBFN_PORT_TYPE.DedicatedChargingPort;
pub const UsbfnInvalidDedicatedChargingPort = USBFN_PORT_TYPE.InvalidDedicatedChargingPort;
pub const UsbfnProprietaryDedicatedChargingPort = USBFN_PORT_TYPE.ProprietaryDedicatedChargingPort;
pub const UsbfnPortTypeMaximum = USBFN_PORT_TYPE.PortTypeMaximum;

pub const USBFN_BUS_SPEED = enum(i32) {
    Low = 0,
    Full = 1,
    High = 2,
    Super = 3,
    Maximum = 4,
};
pub const UsbfnBusSpeedLow = USBFN_BUS_SPEED.Low;
pub const UsbfnBusSpeedFull = USBFN_BUS_SPEED.Full;
pub const UsbfnBusSpeedHigh = USBFN_BUS_SPEED.High;
pub const UsbfnBusSpeedSuper = USBFN_BUS_SPEED.Super;
pub const UsbfnBusSpeedMaximum = USBFN_BUS_SPEED.Maximum;

pub const USBFN_DIRECTION = enum(i32) {
    Minimum = 0,
    In = 1,
    Out = 2,
    Maximum = 3,
    pub const Tx = .In;
    pub const Rx = .Out;
};
pub const UsbfnDirectionMinimum = USBFN_DIRECTION.Minimum;
pub const UsbfnDirectionIn = USBFN_DIRECTION.In;
pub const UsbfnDirectionOut = USBFN_DIRECTION.Out;
pub const UsbfnDirectionTx = USBFN_DIRECTION.In;
pub const UsbfnDirectionRx = USBFN_DIRECTION.Out;
pub const UsbfnDirectionMaximum = USBFN_DIRECTION.Maximum;

pub const USBFN_DEVICE_STATE = enum(i32) {
    Minimum = 0,
    Attached = 1,
    Default = 2,
    Detached = 3,
    Addressed = 4,
    Configured = 5,
    Suspended = 6,
    StateMaximum = 7,
};
pub const UsbfnDeviceStateMinimum = USBFN_DEVICE_STATE.Minimum;
pub const UsbfnDeviceStateAttached = USBFN_DEVICE_STATE.Attached;
pub const UsbfnDeviceStateDefault = USBFN_DEVICE_STATE.Default;
pub const UsbfnDeviceStateDetached = USBFN_DEVICE_STATE.Detached;
pub const UsbfnDeviceStateAddressed = USBFN_DEVICE_STATE.Addressed;
pub const UsbfnDeviceStateConfigured = USBFN_DEVICE_STATE.Configured;
pub const UsbfnDeviceStateSuspended = USBFN_DEVICE_STATE.Suspended;
pub const UsbfnDeviceStateStateMaximum = USBFN_DEVICE_STATE.StateMaximum;

pub const ALTERNATE_INTERFACE = extern struct {
    InterfaceNumber: u16,
    AlternateInterfaceNumber: u16,
};

pub const USBFN_NOTIFICATION = extern struct {
    Event: USBFN_EVENT,
    u: extern union {
        BusSpeed: USBFN_BUS_SPEED,
        SetupPacket: USB_DEFAULT_PIPE_SETUP_PACKET,
        ConfigurationValue: u16,
        PortType: USBFN_PORT_TYPE,
        AlternateInterface: ALTERNATE_INTERFACE,
    },
};

pub const USBFN_PIPE_INFORMATION = extern struct {
    EpDesc: USB_ENDPOINT_DESCRIPTOR,
    PipeId: u32,
};

pub const USBFN_CLASS_INTERFACE = extern struct {
    InterfaceNumber: u8,
    PipeCount: u8,
    PipeArr: [16]USBFN_PIPE_INFORMATION,
};

pub const USBFN_CLASS_INFORMATION_PACKET = extern struct {
    FullSpeedClassInterface: USBFN_CLASS_INTERFACE,
    HighSpeedClassInterface: USBFN_CLASS_INTERFACE,
    InterfaceName: [40]u16,
    InterfaceGuid: [39]u16,
    HasInterfaceGuid: BOOLEAN,
    SuperSpeedClassInterface: USBFN_CLASS_INTERFACE,
};

pub const USBFN_CLASS_INTERFACE_EX = extern struct {
    BaseInterfaceNumber: u8,
    InterfaceCount: u8,
    PipeCount: u8,
    PipeArr: [16]USBFN_PIPE_INFORMATION,
};

pub const USBFN_CLASS_INFORMATION_PACKET_EX = extern struct {
    FullSpeedClassInterfaceEx: USBFN_CLASS_INTERFACE_EX,
    HighSpeedClassInterfaceEx: USBFN_CLASS_INTERFACE_EX,
    SuperSpeedClassInterfaceEx: USBFN_CLASS_INTERFACE_EX,
    InterfaceName: [40]u16,
    InterfaceGuid: [39]u16,
    HasInterfaceGuid: BOOLEAN,
};

pub const USBFN_INTERFACE_INFO = extern struct {
    InterfaceNumber: u8,
    Speed: USBFN_BUS_SPEED,
    Size: u16,
    InterfaceDescriptorSet: [1]u8,
};

pub const USBFN_USB_STRING = extern struct {
    StringIndex: u8,
    UsbString: [255]u16,
};

pub const USBFN_BUS_CONFIGURATION_INFO = extern struct {
    ConfigurationName: [40]u16,
    IsCurrent: BOOLEAN,
    IsActive: BOOLEAN,
};

pub const DRV_VERSION = extern struct {
    major: u32,
    minor: u32,
    internal: u32,
};

pub const IO_BLOCK = extern struct {
    uOffset: u32,
    uLength: u32,
    pbyData: ?*u8,
    uIndex: u32,
};

pub const IO_BLOCK_EX = extern struct {
    uOffset: u32,
    uLength: u32,
    pbyData: ?*u8,
    uIndex: u32,
    bRequest: u8,
    bmRequestType: u8,
    fTransferDirectionIn: u8,
};

pub const CHANNEL_INFO = extern struct {
    EventChannelSize: u32,
    uReadDataAlignment: u32,
    uWriteDataAlignment: u32,
};

pub const PIPE_TYPE = enum(i32) {
    EVENT_PIPE = 0,
    READ_DATA_PIPE = 1,
    WRITE_DATA_PIPE = 2,
    ALL_PIPE = 3,
};
pub const EVENT_PIPE = PIPE_TYPE.EVENT_PIPE;
pub const READ_DATA_PIPE = PIPE_TYPE.READ_DATA_PIPE;
pub const WRITE_DATA_PIPE = PIPE_TYPE.WRITE_DATA_PIPE;
pub const ALL_PIPE = PIPE_TYPE.ALL_PIPE;

pub const USBSCAN_GET_DESCRIPTOR = extern struct {
    DescriptorType: u8,
    Index: u8,
    LanguageId: u16,
};

pub const DEVICE_DESCRIPTOR = extern struct {
    usVendorId: u16,
    usProductId: u16,
    usBcdDevice: u16,
    usLanguageId: u16,
};

pub const RAW_PIPE_TYPE = enum(i32) {
    CONTROL = 0,
    ISOCHRONOUS = 1,
    BULK = 2,
    INTERRUPT = 3,
};
pub const USBSCAN_PIPE_CONTROL = RAW_PIPE_TYPE.CONTROL;
pub const USBSCAN_PIPE_ISOCHRONOUS = RAW_PIPE_TYPE.ISOCHRONOUS;
pub const USBSCAN_PIPE_BULK = RAW_PIPE_TYPE.BULK;
pub const USBSCAN_PIPE_INTERRUPT = RAW_PIPE_TYPE.INTERRUPT;

pub const USBSCAN_PIPE_INFORMATION = extern struct {
    MaximumPacketSize: u16,
    EndpointAddress: u8,
    Interval: u8,
    PipeType: RAW_PIPE_TYPE,
};

pub const USBSCAN_PIPE_CONFIGURATION = extern struct {
    NumberOfPipes: u32,
    PipeInfo: [8]USBSCAN_PIPE_INFORMATION,
};

pub const USBSCAN_TIMEOUT = extern struct {
    TimeoutRead: u32,
    TimeoutWrite: u32,
    TimeoutEvent: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (34)
//--------------------------------------------------------------------------------
pub extern "winusb" fn WinUsb_Initialize(
    DeviceHandle: ?HANDLE,
    InterfaceHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_Free(
    InterfaceHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_GetAssociatedInterface(
    InterfaceHandle: ?*anyopaque,
    AssociatedInterfaceIndex: u8,
    AssociatedInterfaceHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_GetDescriptor(
    InterfaceHandle: ?*anyopaque,
    DescriptorType: u8,
    Index: u8,
    LanguageID: u16,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: ?*u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_QueryInterfaceSettings(
    InterfaceHandle: ?*anyopaque,
    AlternateInterfaceNumber: u8,
    UsbAltInterfaceDescriptor: ?*USB_INTERFACE_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_QueryDeviceInformation(
    InterfaceHandle: ?*anyopaque,
    InformationType: u32,
    BufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_SetCurrentAlternateSetting(
    InterfaceHandle: ?*anyopaque,
    SettingNumber: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_GetCurrentAlternateSetting(
    InterfaceHandle: ?*anyopaque,
    SettingNumber: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_QueryPipe(
    InterfaceHandle: ?*anyopaque,
    AlternateInterfaceNumber: u8,
    PipeIndex: u8,
    PipeInformation: ?*WINUSB_PIPE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_QueryPipeEx(
    InterfaceHandle: ?*anyopaque,
    AlternateSettingNumber: u8,
    PipeIndex: u8,
    PipeInformationEx: ?*WINUSB_PIPE_INFORMATION_EX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_SetPipePolicy(
    InterfaceHandle: ?*anyopaque,
    PipeID: u8,
    PolicyType: u32,
    ValueLength: u32,
    // TODO: what to do with BytesParamIndex 3?
    Value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_GetPipePolicy(
    InterfaceHandle: ?*anyopaque,
    PipeID: u8,
    PolicyType: u32,
    ValueLength: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    Value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_ReadPipe(
    InterfaceHandle: ?*anyopaque,
    PipeID: u8,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_WritePipe(
    InterfaceHandle: ?*anyopaque,
    PipeID: u8,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_ControlTransfer(
    InterfaceHandle: ?*anyopaque,
    SetupPacket: WINUSB_SETUP_PACKET,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_ResetPipe(
    InterfaceHandle: ?*anyopaque,
    PipeID: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_AbortPipe(
    InterfaceHandle: ?*anyopaque,
    PipeID: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_FlushPipe(
    InterfaceHandle: ?*anyopaque,
    PipeID: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_SetPowerPolicy(
    InterfaceHandle: ?*anyopaque,
    PolicyType: u32,
    ValueLength: u32,
    // TODO: what to do with BytesParamIndex 2?
    Value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_GetPowerPolicy(
    InterfaceHandle: ?*anyopaque,
    PolicyType: u32,
    ValueLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    Value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_GetOverlappedResult(
    InterfaceHandle: ?*anyopaque,
    lpOverlapped: ?*OVERLAPPED,
    lpNumberOfBytesTransferred: ?*u32,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winusb" fn WinUsb_ParseConfigurationDescriptor(
    ConfigurationDescriptor: ?*USB_CONFIGURATION_DESCRIPTOR,
    StartPosition: ?*anyopaque,
    InterfaceNumber: i32,
    AlternateSetting: i32,
    InterfaceClass: i32,
    InterfaceSubClass: i32,
    InterfaceProtocol: i32,
) callconv(@import("std").os.windows.WINAPI) ?*USB_INTERFACE_DESCRIPTOR;

pub extern "winusb" fn WinUsb_ParseDescriptors(
    // TODO: what to do with BytesParamIndex 1?
    DescriptorBuffer: ?*anyopaque,
    TotalLength: u32,
    StartPosition: ?*anyopaque,
    DescriptorType: i32,
) callconv(@import("std").os.windows.WINAPI) ?*USB_COMMON_DESCRIPTOR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "winusb" fn WinUsb_GetCurrentFrameNumber(
    InterfaceHandle: ?*anyopaque,
    CurrentFrameNumber: ?*u32,
    TimeStamp: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "winusb" fn WinUsb_GetAdjustedFrameNumber(
    CurrentFrameNumber: ?*u32,
    TimeStamp: LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "winusb" fn WinUsb_RegisterIsochBuffer(
    InterfaceHandle: ?*anyopaque,
    PipeID: u8,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*u8,
    BufferLength: u32,
    IsochBufferHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "winusb" fn WinUsb_UnregisterIsochBuffer(
    IsochBufferHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "winusb" fn WinUsb_WriteIsochPipe(
    BufferHandle: ?*anyopaque,
    Offset: u32,
    Length: u32,
    FrameNumber: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "winusb" fn WinUsb_ReadIsochPipe(
    BufferHandle: ?*anyopaque,
    Offset: u32,
    Length: u32,
    FrameNumber: ?*u32,
    NumberOfPackets: u32,
    IsoPacketDescriptors: [*]USBD_ISO_PACKET_DESCRIPTOR,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "winusb" fn WinUsb_WriteIsochPipeAsap(
    BufferHandle: ?*anyopaque,
    Offset: u32,
    Length: u32,
    ContinueStream: BOOL,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "winusb" fn WinUsb_ReadIsochPipeAsap(
    BufferHandle: ?*anyopaque,
    Offset: u32,
    Length: u32,
    ContinueStream: BOOL,
    NumberOfPackets: u32,
    IsoPacketDescriptors: [*]USBD_ISO_PACKET_DESCRIPTOR,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "winusb" fn WinUsb_StartTrackingForTimeSync(
    InterfaceHandle: ?*anyopaque,
    StartTrackingInfo: ?*USB_START_TRACKING_FOR_TIME_SYNC_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "winusb" fn WinUsb_GetCurrentFrameNumberAndQpc(
    InterfaceHandle: ?*anyopaque,
    FrameQpcInfo: ?*USB_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "winusb" fn WinUsb_StopTrackingForTimeSync(
    InterfaceHandle: ?*anyopaque,
    StopTrackingInfo: ?*USB_STOP_TRACKING_FOR_TIME_SYNC_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
// Section: Imports (6)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const HANDLE = @import("../foundation.zig").HANDLE;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const OVERLAPPED = @import("../system/io.zig").OVERLAPPED;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "USB_IDLE_CALLBACK")) { _ = USB_IDLE_CALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
